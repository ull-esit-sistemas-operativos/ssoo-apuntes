<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.20">
<meta name="author" content="Jesús Torres">
<title>Sistemas Operativos</title>
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */

@import url("//fonts.googleapis.com/css?family=Noto+Sans:300,600italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700");
@import url(https://cdn.jsdelivr.net/gh/asciidoctor/asciidoctor@2.0/data/stylesheets/asciidoctor-default.css); /* Default asciidoc style framework - important */

/* CUSTOMISATIONS */
/* Change the values in root for quick customisation. If you want even more fine grain... venture further. */

:root{
--maincolor:#FFFFFF;
--primarycolor:#2c3e50;
--secondarycolor:#ba3925;
--tertiarycolor: #186d7a;
--sidebarbackground:#CCC;
--linkcolor:#b71c1c;
--linkcoloralternate:#f44336;
--white:#FFFFFF;
--black:#000000;
}

/* Text styles */
h1{color:var(--primarycolor) !important;}
h2,h3,h4,h5,h6{color:var(--secondarycolor) !important;}
.title{color:var(--tertiarycolor) !important; font-family:"Noto Sans",sans-serif !important;font-style: normal !important; font-weight: normal !important;}
p{font-family: "Noto Sans",sans-serif !important}

/* Table styles */
th{font-family: "Noto Sans",sans-serif !important}

/* Responsiveness fixes */
video {
  max-width: 100%;
}

@media all and (max-width: 600px) {
table {
  width: 55vw!important;
  font-size: 3vw;
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="icon" href="media/extras/favicon.ico" sizes="any">
<link rel="icon" href="media/extras/ssoo-icon.svg" type="image/svg+xml">
<link rel="icon" type="image/png" sizes="192x192" href="media/extras/ssoo-icon-192.png">
<link rel="icon" type="image/png" sizes="512x512" href="media/extras/ssoo-icon-512.png">
<link rel="apple-touch-icon" href="media/extras/ssoo-apple-touch-icon.png"><!-- 180×180 -->
<link rel="stylesheet" href="media/extras/inlineDisqussions.css">
<style>
    body {
        display: flex;
        flex-direction: column;
        min-height: 100vh;
    }
    content {
        flex: 1;
    }
    #preamble {
        margin-top: 0.5em;
    }
    #header, #content, #footnotes {
        margin: 0 auto 0 5em
    }
    #content h1>a.anchor, h2>a.anchor, h3>a.anchor,
    #toctitle>a.anchor, .sidebarblock>.content>.title>a.anchor,
    h4>a.anchor, h5>a.anchor, h6>a.anchor {
        color: #ba3925;
    }
    .imageblock {
        text-align: center;
    }
    .imageblock > .content {
        margin-bottom: 1rem;
    }
    .imageblock > .title {
        text-align: inherit;
    }
    .tableblock > .lightcell {
        color: gray;
    }
    table tfoot td p {
        font-weight: bold;
    }
    #footer-text {
        margin: 0 auto;
        max-width: 62.5em;
        padding-left: .9375em;
        padding-right: .9375em;
    }
    #footer-text a {
        color: hsla(0,0%,100%,.8);
        text-decoration: none;
        font-weight: bold;
    }
    #footer-text a:hover {
        color: hsla(0,0%,100%,.8);
    }
</style>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script src="media/extras/inlineDisqussions.js"></script>
<script type="text/javascript">
    window.onload = function(){
        if ('{comments_enabled}' === 'true') {
            setTimeout(function() {
                disqus_shortname = 'ull-esit-sistemas-operativos';
                jQuery("img, p, .colist td, .stemblock").not('#toc p').inlineDisqussions();
                query_params = (new URL(document.location)).searchParams;
                if (query_params.has('disqussion')) {
                    let identifier = window.location.pathname + 'disqussion-' + query_params.get('disqussion');
                    let selection = jQuery('[data-disqus-identifier="' +  identifier + '"]').not('.disqussion-link');
                    if (selection.length) {
                        selection[0].scrollIntoView(true);
                    }
                }
            }, 500);
        }
    }
</script>
<style>.toc-current{font-weight: bold;} .toc-root{font-family: "Open Sans","DejaVu Sans",sans-serif;
                       font-size: 0.9em;} #content{display: flex; flex-direction: column; flex: 1 1 auto;}
             .nav-footer{text-align: center; margin-top: auto;}
             .nav-footer > p > a {white-space: nowrap;}</style>
<style>
.admonitionblock td.icon .icon-time:before {content:"\f017";color:#f28500;}
</style>
</head>
<body id="tipos_de_sistemas_operativos" class="book toc2 toc-left">
<div id="header">
<h1>Sistemas Operativos</h1>
<div class="details">
<span id="author" class="author">Jesús Torres</span><br>
<span id="email" class="email"><a href="mailto:jmtorres@ull.es">jmtorres@ull.es</a></span><br>
<span id="revdate">Curso 2024-2025</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Tabla de Contenido</div>
<p><span class="toc-root"><a href="main.html">Sistemas Operativos</a></span></p><ul class="sectlevel1">
<li><a href="ediciones_y_licencia.html">Ediciones y licencia</a>
</li>
<li><a href="código_de_los_ejemplos.html">Código de los ejemplos</a>
</li>
<li><a href="introducción.html">Parte I: Introducción</a>
<ul class="sectlevel1">
<li><a href="qué_es_un_sistema_operativo.html">1. ¿Qué es un sistema operativo?</a>
</li>
<li><a href="tipos_de_sistemas_operativos.html"><span class="toc-current">2. Tipos de sistemas operativos</span></a>
<ul class="sectlevel2">
<li><a href="tipos_de_sistemas_operativos.html#_mainframe">2.1. Mainframe</a>
</li>
<li><a href="tipos_de_sistemas_operativos.html#_sistemas_de_escritorio">2.2. Sistemas de escritorio</a>
</li>
<li><a href="tipos_de_sistemas_operativos.html#_sistemas_de_mano">2.3. Sistemas de mano</a>
</li>
<li><a href="tipos_de_sistemas_operativos.html#_sistemas_multiprocesador">2.4. Sistemas multiprocesador</a>
</li>
<li><a href="tipos_de_sistemas_operativos.html#_sistemas_distribuidos">2.5. Sistemas distribuidos</a>
</li>
<li><a href="tipos_de_sistemas_operativos.html#_sistemas_en_clúster">2.6. Sistemas en clúster</a>
</li>
<li><a href="tipos_de_sistemas_operativos.html#_sistemas_de_tiempo_real">2.7. Sistemas de tiempo real</a>
</li>
</ul>
</li>
<li><a href="historia_de_los_sistemas_operativos.html">3. Historia de los sistemas operativos</a>
</li>
</ul>
</li>
<li><a href="organización_de_los_sistemas_operativos.html">Parte II: Organización de los sistemas operativos</a>
</li>
<li><a href="gestión_de_procesos.html">Parte III: Gestión de procesos</a>
</li>
<li><a href="gestión_de_la_memoria.html">Parte IV: Gestión de la memoria</a>
</li>
<li><a href="gestión_del_almacenamiento.html">Parte V: Gestión del almacenamiento</a>
</li>
<li><a href="bibliografía.html">Bibliografía</a>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="tipos_de_sistemas_operativos"><a class="anchor" href="#tipos_de_sistemas_operativos"></a>2. Tipos de sistemas operativos</h2>
<div class="sectionbody">
<div class="admonitionblock time">
<table>
<tr>
<td class="icon">
<i class="fa icon-time" title=""></i>
</td>
<td class="content">
<div class="paragraph">
<p><strong>Tiempo de lectura:</strong> 23 minutos</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Ahora que sabemos que todos los sistemas operativos hacen lo mismo, pero que el «cómo» lo hacen difiere de un tipo de sistema informático a otro, vamos a ver los tipos de sistemas informáticos, las características de los sistemas operativos que los gestionan y cómo han evolucionado a lo largo de la historia.</p>
</div>
<div class="sect2">
<h3 id="_mainframe"><a class="anchor" href="#_mainframe"></a>2.1. Mainframe</h3>
<div class="paragraph">
<p>Los <strong>ordenadores centrales</strong> o <em><strong>mainframes</strong></em> fueron los primeros computadores utilizados en muchas aplicaciones comerciales y científicas.
Se caracterizan no tanto por la potencia de su CPU como por su: gran capacidad de memoria, gran capacidad de almacenamiento secundario, gran cantidad de dispositivos de E/S y rapidez de estos y alta fiabilidad.</p>
</div>
<div class="paragraph">
<p>Los <em>mainframes</em> pueden funcionar durante años sin problemas ni interrupciones y las reparaciones se realizan sin detener su funcionamiento.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>La mayor diferencia entre los superordenadores y los <em>mainframes</em><a href="bibliografía.html#Wikipedia-Mainframe">[32]</a> está en que los primeros se centran en resolver problemas limitados por la velocidad de cálculo —lo cual requiere miles de CPU de alto rendimiento— mientras que los segundos se centran en la fiabilidad y en problemas limitados por la E/S —por lo que los <em>mainframes</em> suelen tener «solo» entre una y varias docenas de CPU—.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Los <em>mainframes</em> aparecieron a finales de la década de los 50 del siglo pasado y han seguido evolucionando hasta la actualidad, por lo que dentro de este tipo de sistemas nos encontramos con varias categorías.</p>
</div>
<div class="sect3">
<h4 id="_sistemas_de_procesamiento_por_lotes"><a class="anchor" href="#_sistemas_de_procesamiento_por_lotes"></a>2.1.1. Sistemas de procesamiento por lotes</h4>
<div class="paragraph">
<p>

Los primeros <em>mainframes</em> eran enormes máquinas operadas desde una consola y conectados a lectores de tarjetas perforadas, dispositivos de cinta e impresoras.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Para imágenes y más información sobre las tarjetas perforadas, véase <a href="https://en.wikipedia.org/wiki/Computer_programming_in_the_punched_card_era">«Computer programming in the punched card era&#8201;&#8212;&#8201;Wikipedia»</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>El trabajo era preparado por cada programador —normalmente en tarjetas perforadas— y entregado al operador del sistema, que era quién tenía acceso al sistema y la responsabilidad de ejecutar los programas y devolver los resultados al programador correspondiente.</p>
</div>
<div class="paragraph">
<p>No había sistema operativo y el operador debía cargar y ejecutar cada programa de uno en uno.</p>
</div>
<div id="fig-consola-ibm-705" class="imageblock">
<div class="content">
<img src="media/C02-tipos_de_sistemas/consola_ibm_705.jpg" alt="consola ibm 705">
</div>
<div class="title">Figura 2.1. Operadora en la consola de un mainframe IBM 705&#8201;&#8212;&#8201;Fuente: <a href="https://www.ibm.com/history/700">IBM</a></div>
</div>
<div class="paragraph">
<p>Estos sistemas se convirtieron en <strong>sistemas de procesamiento por lotes</strong> o <strong>sistemas en <em>batch</em></strong> cuando se comenzó a utilizar un pequeño programa —llamado <strong>monitor del sistema</strong>— cuya función era cargar y ejecutar sin interrupción un conjunto —o lote— de programas.</p>
</div>
<div class="paragraph">
<p>Para preparar los lotes, por lo general, el operador cargaba previamente en cinta magnética el conjunto de programas a partir de las tarjetas perforadas proporcionadas por los programadores.
Como se ilustra en la <a href="tipos_de_sistemas_operativos.html#fig-sistemas-procesamiento-lotes">Figura 2.2</a>, para ello se utilizaba un ordenador autónomo —independiente del <em>mainframe</em>— con lector de tarjetas y unidad de cinta.
Posteriomente, el operador movía la cinta con el conjunto de programas a la unidad de cinta de entrada del <em>mainframe</em> y lanzaba la ejecución del <strong>monitor del sistema</strong>, para que este se encargara de ir leyendo y ejecutando cada uno de los programas.
Para obtener mayor rendimiento, los resultados de los programas se escribían en una unidad de cinta diferente.
Cuando terminaba la ejecución de todo el conjunto, el operador llevaba la cinta a otro ordenador autónomo para leer los resultados e imprimrlos, con el objeto de entregárselos a los programadaores.</p>
</div>
<div id="fig-sistemas-procesamiento-lotes" class="imageblock">
<div class="content">
<img src="media/C02-tipos_de_sistemas/sistemas_procesamiento_lotes.svg" alt="sistemas procesamiento lotes">
</div>
<div class="title">Figura 2.2. Gestión de trabajos en sistemas de procesamiento por lotes.</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>El <strong>monitor del sistema</strong> es un predecesor de los sistemas operativos y tenía las siguientes características:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Permanecía cargado durante todo el tiempo en la memoria del sistema (véase la <a href="tipos_de_sistemas_operativos.html#fig-sistemas-procesamiento-lotes">Figura 2.2</a>).</p>
</li>
<li>
<p>Su única tarea era cargar y transferir automáticamente la ejecución de un programa al siguiente cuando el anterior terminaba.</p>
</li>
<li>
<p>El mayor inconveniente de este tipo de sistemas era que la CPU permanecía mucho tiempo desocupada porque era —y sigue siendo— varios órdenes de magnitud más rápida que los dispositivos de E/S.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Cualquier programa necesita realizar operaciones de E/S para obtener los datos requeridos para sus cálculos —guardados en tarjetas perforadas y unidades de cinta o, si hablamos de hoy en día, en discos duros y memorias USB—.
También necesita hacer operaciones de E/S para guardar o imprimir los resultados de esos cálculos.</p>
</div>
<div class="paragraph">
<p>Si solo se puede ejecutar un programa la vez, cuando el programa solicita una operación de E/S, la CPU queda a la espera de que esta termine para continuar con la ejecución del programa, por lo que se pierde tiempo de CPU en no hacer nada.
Este desaprovechamiento de la CPU es peor cuanto más rápida es la CPU respecto a los dispositivos de E/S.</p>
</div>
</div>
<div class="sect3">
<h4 id="_sistemas_multiprogramados"><a class="anchor" href="#_sistemas_multiprogramados"></a>2.1.2. Sistemas multiprogramados</h4>
<div class="paragraph">
<p>
La solución al inconveniente de los sistemas de procesamiento por lotes con la E/S fue que los programas no accedieran directamente al dispositivo de E/S, sino que, en su lugar, solicitaran la operación al <strong>monitor del sistema</strong> para que este la solicitara al hardware.
Así el sistema operativo —como podemos comenzar a llamarlo— tiene la oportunidad de sustituir el programa en la CPU por otro, mientras la operación de E/S se completa.</p>
</div>
<div class="paragraph">
<p>Además, con la aparición de la tecnología de los discos magnéticos en la década de los 60 del siglo pasado, los trabajos de los programadores comenzaron a ser almacenados en discos, desde donde eran escogidos por el sistema operativo para su ejecución.</p>
</div>
<div class="paragraph">
<p>A estos sistemas se los llamó <strong>multiprogramados</strong>, porque permitían tener varios programas en memoria al mismo tiempo e intercalar su ejecución en la CPU.
A la cantidad de programas cargados en memoria en un instante dado se la denominaba <strong>grado de multiprogramación</strong>.</p>
</div>
<div id="fig-sistemas-multiprogramados" class="imageblock">
<div class="content">
<img src="media/C02-tipos_de_sistemas/sistemas_multiprogramados.svg" alt="sistemas multiprogramados">
</div>
<div class="title">Figura 2.3. Gestión de trabajos en sistemas multiprogramados.</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>En los <strong>sistemas multiprogramados</strong> la ejecución de los trabajos funcionaba de la siguiente manera (véase la <a href="tipos_de_sistemas_operativos.html#fig-sistemas-multiprogramados">Figura 2.3</a>):</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>En el disco magnético se almacenaba una cola donde se iban colocando todos los trabajos que tenían que ser ejecutados.</p>
</li>
<li>
<p>El sistema operativo cargaba varios trabajos en memoria del conjunto de trabajos en la cola en el disco magnético.</p>
</li>
<li>
<p>El sistema operativo cede la CPU a uno de los trabajos en memoria.</p>
</li>
<li>
<p>Cuando el trabajo en la CPU requería usar la E/S se lo pedía al sistema operativo.
En lugar de mantener a la CPU ocupada inútilmente, el sistema operativo programaba la operación de E/S, pero escogía otro trabajo de entre los que estaban en memoria y lo ejecutaba en la CPU.</p>
<div class="paragraph">
<p>Cuando la operación de E/S del anterior trabajo terminaba, el programa que ocupaba la CPU no era interrumpido, sino que debía esperar a una nueva oportunidad de ser escogido para ejecutarse en la CPU.</p>
</div>
</li>
<li>
<p>Cuando un programa en la CPU terminaba, sus recursos se liberaban, dejando memoria libre.
Por lo tanto, el sistema operativo escogía un nuevo trabajo de la cola de trabajos en el disco magnético y lo cargaba en la memoria.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Todo este proceso se repetía mientras hubiera trabajos que ejecutar en la cola de trabajos en el disco.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Para operar de la forma descrita es necesario que el sistema operativo realice tres tareas esenciales:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La <strong>planificación de trabajos</strong>, cuya responsabilidad es seleccionar el siguiente trabajo que será cargado en la memoria principal para mantenerla llena.</p>
</li>
<li>
<p>La <strong>planificación de la CPU</strong>, cuya responsabilidad es elegir el siguiente trabajo que será ejecutado en la CPU, de entre los disponibles en la memoria principal.</p>
</li>
<li>
<p>La <strong>gestión de la memoria</strong>, cuya responsabilidad es repartir la memoria principal entre los trabajos alojados en la misma.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Un ejemplo de este tipo de sistemas operativos es el IBM OS/360, que fue lanzado en 1966 para utilizarlo en los <em>mainframes</em> IBM System/360 (véase el <a href="historia_de_los_sistemas_operativos.html#sect-historia-segunda-generación">Apartado 3.2</a>).</p>
</div>
</div>
<div class="sect3">
<h4 id="_sistemas_de_tiempo_compartido"><a class="anchor" href="#_sistemas_de_tiempo_compartido"></a>2.1.3. Sistemas de tiempo compartido</h4>
<div class="paragraph">
<p>
Los sistemas multiprogramados ofrecían un uso más eficiente de la CPU, pero no eran capaces de proporcionar interacción directa con los usuarios.
Los programadores seguían teniendo que entregar los trabajos al operador y espera a que este les devolviera los resultados.</p>
</div>
<div class="paragraph">
<p>Los <strong>sistemas de tiempo compartido</strong> se desarrollaron tras observar que al dar acceso a un grupo de usuarios se podía conseguir un uso más eficiente del sistema, en comparación a cuando solo podía ser utilizado por un usuario a la vez.
Esto es debido a que, generalmente, un usuario introduce información de forma continua para luego detenerse durante largos periodos de tiempo, mientras que en un grupo de usuarios, las pausas de uno de ellos se pueden llenar con la actividad de los otros.</p>
</div>
<div id="fig-sistemas-tiempo-compartido" class="imageblock">
<div class="content">
<img src="media/C02-tipos_de_sistemas/sistemas_de_tiempo_compartido.svg" alt="sistemas de tiempo compartido">
</div>
<div class="title">Figura 2.4. Gestión de trabajos en sistemas de tiempo compartido.</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Los <strong>sistemas de tiempo compartido</strong> se caracterizaban por:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Tener <strong>terminales</strong>, es decir, hardware especializado en hacer de interfaz directa entre los usuarios y el sistema.
A través de estas terminales los usuarios podían enviar comandos al sistema e interactuar con sus trabajos.
Podía haber múltiples usuarios al mismo tiempo, pero cada uno solo podía tener un trabajo en ejecución a la vez.</p>
</li>
<li>
<p>Usar la <strong>multiprogramación</strong> para tener varios trabajos en la memoria principal al mismo tiempo e intercambiar el trabajo en la CPU cuando este solicitaba una operación de E/S, como ya se venía haciendo en los <strong>sistemas multiprogramados</strong> para hacer un uso más eficiente de la CPU.</p>
</li>
<li>
<p>Repartir el tiempo de CPU entre usuarios.
El sistema operativo asignaba un tiempo de CPU a cada usuario —denominado <strong>ventana de tiempo</strong> o <strong>cuanto</strong> de CPU—.
Cuando este tiempo se agotaba, el sistema intercambiaba el trabajo en la CPU por el de otro usuario en el sistema.
La ventana de tiempo era extremadamente pequeña, dando a cada usuario la impresión de que su trabajo nunca se detenía, como si dispusiera de la CPU en exclusiva.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Los sistemas que, como los de tiempo compartido, pueden ser utilizados por varios usuarios simultáneamente se denominan sistemas <strong>multiusuario</strong> .</p>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En los primeros sistemas se usaban <strong>terminales</strong> electromecánicos con un teclado y una impresora, como el <a href="https://en.wikipedia.org/wiki/Teletype_Model_33">Teletype Model 3</a> (1963).
Posteriormente llegaron los terminales electrónicos, que usaban un monitor en lugar de una impresora, como el <a href="https://es.wikipedia.org/wiki/IBM_3270">IBM 3270</a>.
En cualquier caso solo disponían del hardware necesario para realizar la tarea de conectar a los usuarios con el ordenador central.</p>
</div>
<div class="paragraph">
<p>Estos terminales no deben confundirse con las terminales por software que traen algunos sistemas operativos modernos.
Las terminales por software o <em>terminales virtuales</em> se programan para emular las especificaciones de alguna versión de esas terminales físicas antiguas que hemos comentado.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Los sistemas de tiempo compartido significaron un salto importante en complejidad por diversas razones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Como varios trabajos están en la memoria principal al mismo tiempo, el sistema operativo requiere mecanismos de <strong>gestión de la memoria</strong> y <strong>protección</strong>.</p>
</li>
<li>
<p>Para tener un tiempo de respuesta razonable, los trabajos deben estar cargados en la memoria principal.
Para que quepan más trabajos de los usuarios en la memoria, el sistema operativo debe utilizar técnicas de <strong>memoria virtual</strong> para ejecutar trabajos que no están completamente cargados en la memoria principal.</p>
</li>
<li>
<p>Como la CPU debe ser compartida entre todos los trabajos, el sistema operativo necesita mecanismos de <strong>planificación de la CPU</strong>.</p>
</li>
<li>
<p>Como varios trabajos pueden tener la necesidad de cooperar y que su ejecución siga cierto orden, el sistema operativo debe proporcionar mecanismos de <strong>sincronización</strong> y <strong>comunicación</strong>.</p>
</li>
<li>
<p>Como el sistema debe disponer de un <strong>sistema de archivos</strong> para repartir el espacio en disco y facilitar a los usuarios el acceso y gestión de sus datos, el sistema operativo necesita un componente de <strong>gestión de discos</strong>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Las primeras versiones de UNIX —lanzado por primera vez en 1970— el sistema operativo VMS —desarrollado en 1978— para los VAX de Digital Equipment Corportation y el IBM OS/400 —introducido en 1988— utilizado en los minicomputadoras AS/400, son algunos ejemplos de sistemas operativos de tiempo compartido (véase el <a href="historia_de_los_sistemas_operativos.html#sect-historia-tercera-generación">Apartado 3.3</a>).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Estrictamente hablando, el término <strong>sistemas de tiempo compartido</strong> hace referencia a estos <em>mainframes</em> desarrollados a partir de principios de la década de 1970.
Así que no es común utilizarlo con <em>mainframes</em> modernos.</p>
</div>
<div class="paragraph">
<p>Los <em>mainframes</em> modernos permiten a un mismo usuario ejecutar varios trabajos al mismo tiempo, repartiendo el tiempo de CPU entre todos los trabajo en el sistema y no solo entre los usuarios.
Y lo mismo ocurre en la mayor parte de los sistemas operativos de propósito general actuales —utilizados en ordenadores de escritorio, servidores, portátiles y dispositivos móviles— que con el tiempo han copiado muchas características de los <strong>sistemas de tiempo compartido</strong>.
Por eso el término actual es <strong>sistema multitarea</strong>, que es mucho más general.</p>
</div>
<div class="paragraph">
<p>La <strong>multitarea</strong>  es un método para tener varios procesos en memoria y ejecutarlos «al mismo tiempo».
Generalmente requiere de técnicas de multiprogramación, como las empleadas por los antiguos <strong>sistemas multiprogramados</strong>, y de reparto del tiempo de CPU, como ocurre en los antiguos <strong>sistemas de tiempo compartido</strong>.
Por eso se puede decir que ambos tipos de sistemas <em>mainframe</em> eran <strong>sistemas multitarea</strong>.
Al igual que lo son los <em>mainframes</em> modernos y muchos sistemas operativos actuales de escritorio y de dispositivos móviles.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_de_escritorio"><a class="anchor" href="#_sistemas_de_escritorio"></a>2.2. Sistemas de escritorio</h3>
<div class="paragraph">
<p>
En la década de los 70 del siglo pasado también aparecieron las primeras CPU en microprocesadores y con estas llegaron las <strong>microcomputadoras</strong> o <strong>microordenadores</strong>.
Las primeras <strong>microcomputadoras</strong> no incluían teclado ni monitor y se programaban usando interruptores y ledes ubicados en el frontal de la unidad.
Pero en torno a 1977 apareció la segunda generación de <strong>microcomputadoras</strong>, que sí incluían estos periféricos de E/S, por lo que eran más fáciles de usar que sus predecesoras.
Entonces comenzaron a recibir el nombre de <em>ordenadores domésticos</em> y de su mano llegaron los primeros <strong>sistemas operativos de escritorio</strong>.</p>
</div>
<div id="fig-ordenadores-domésticos-1977" class="imageblock">
<div class="content">
<img src="media/C02-tipos_de_sistemas/ordenadores_domésticos_1977.jpg" alt="ordenadores domésticos 1977">
</div>
<div class="title">Figura 2.5. Los tres ordenadores que la revista Byte denominó como la "Trinidad de 1977" de la computación doméstica: el <a href="https://es.wikipedia.org/wiki/Commodore_PET">Commodore PET 2001</a>, el <a href="https://es.wikipedia.org/wiki/Apple_II">Apple II</a> y el <a href="https://es.wikipedia.org/wiki/TRS-80">TRS-80 Model I</a>&#8201;&#8212;&#8201;Fuente: <a href="https://commons.wikimedia.org/wiki/File:Trinity77.jpg">Wikipedia</a></div>
</div>
<div class="paragraph">
<p>Los <em>mainframes</em> y las minicomputadoras de la época siguieron siendo los ordenadores corporativos por excelencia, ya que eran mucho más grandes y potentes, y también costosos.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>El término en desuso <strong>minicomputadora</strong> o <strong>miniordenador</strong> hace referencia a máquinas multiusuario de rango medio, entre los <em>mainframes</em> y los ordenadores domésticos.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Los primeros <strong>sistemas operativos de escritorio</strong> eran muy básicos.
Por ejemplo, en un sistema diseñado para ser utilizado por un único usuario no tiene sentido implementar un sistema de archivos con permisos.
Así que, los primeros sistemas operativos de escritorio carecían de esta característica que, sin embargo, ya existía en los sistemas de tiempo compartido de la época.
De la misma manera, carecían de otros mecanismos de protección y no eran ni multiusuario ni multitarea.</p>
</div>
<div class="paragraph">
<p>Pese a estas diferencias, los <strong>sistemas operativos de escritorio</strong> se han beneficiado del desarrollo de los sistemas operativos para <em>mainframes</em>.
Los sistemas de escritorio actuales son <strong>multiusuario</strong> y <strong>multitarea</strong>; incluyen sistemas de archivos con permisos, autenticación y mecanismos de protección de la memoria —como medidas para proteger los datos de los usuarios— y han incorporado muchas otras características de los sistemas operativos para <em>mainframe</em>.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Aunque con el tiempo los sistemas de escritorio han ido adquiriendo características desarrolladas en los <em>mainframes</em>, no debemos olvidar que ambos tipos de sistemas se siguen diseñando con objetivos diferentes.
Mientras que en los <em>mainframes</em> se persigue maximizar la fiabilidad y utilización eficiente de los recursos, en los sistemas de escritorio se maximiza la facilidad de uso y el tiempo de respuesta al usuario, poniendo algo de atención al rendimiento.</p>
</div>
<div class="paragraph">
<p>Los <strong>sistemas operativos de escritorio</strong> modernos ya nos son «solo de escritorio» ni se ejecutan únicamente en ordenadores domésticos.
Se utilizan en un altísimo porcentaje en servidores, superordenadores y hasta en dispositivos móviles.
Por eso, en la actualidad, el término <strong>sistema operativo de propósito general</strong>  es mucho más adecuado.</p>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>El <strong>tiempo de respuesta</strong> al usuario se puede considerar como el intervalo de tiempo entre un comando de un usuario —por ejemplo un clic— y la respuesta del sistema a dicho comando.
En ocasiones este tiempo se minimiza a costa de un uso menos eficiente de los recursos del sistema, por lo que no es un objetivo deseable para diseñar un <em>mainframe</em>.
Para más información, véase el <a href="planificación_de_la_cpu.html#_criterios_de_planificación">Apartado 14.3</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Son muchos los ejemplos de sistemas operativos en esta categoría. Van desde CP/M —lanzado en 1977— hasta los actuales GNU/Linux, Microsoft Windows y Apple macOS, pasando por MS-DOS, IBM OS/2 y todas las versiones anteriores de Microsoft Windows (véase el <a href="historia_de_los_sistemas_operativos.html#sect-historia-cuarta-generación">Apartado 3.4</a>).</p>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_de_mano"><a class="anchor" href="#_sistemas_de_mano"></a>2.3. Sistemas de mano</h3>
<div class="paragraph">
<p>

Con el nombre genérico de <strong>sistemas de mano</strong> —del inglés <em>handheld</em>— hacemos referencia a las <em>tablets</em>, <em>smartphones</em>, lectores de libros electrónicos y otro sistemas móviles y portátiles.
Los desarrolladores de aplicaciones y sistemas de mano deben enfrentarse a diversos desafíos, originados por el tamaño limitado de los dispositivos y la alimentación mediante el uso de baterías.
Debido a esas limitaciones, muchos sistemas de mano tienen poca cantidad de memoria, procesadores lentos —en comparación con sus equivalentes de escritorio— y pantallas más pequeñas.</p>
</div>
<div class="paragraph">
<p>En el diseño del sistema operativo suele primar la facilidad de uso y buscar un buen equilibrio entre rendimiento y tiempo de vida de la batería.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_multiprocesador"><a class="anchor" href="#_sistemas_multiprocesador"></a>2.4. Sistemas multiprocesador</h3>
<div class="paragraph">
<p>
Un <strong>sistema multiprocesador</strong> es aquel ordenador hay procesadores interconectados que comparten el bus del sistema, el reloj y, en ocasiones la memoria, y los periféricos.</p>
</div>
<div class="paragraph">
<p>Hace años esto solo se daba en sistemas con varias CPU, lo que era relativamente común en servidores y sistemas de alto rendimiento para trabajos técnicos o científicos.
Sin embargo, en la actualidad cualquier dispositivo digital u ordenador doméstico puede tener una CPU con múltiples núcleos, lo que los convierte en sistemas multiprocesador.</p>
</div>
<div class="paragraph">
<p>Las principales ventajas de estos sistemas son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Aumentan la cantidad de trabajo realizado</strong>. A mayor número de procesadores, mayor cantidad de trabajo puede realizar el sistema.
Sin embargo debemos de tener en cuenta que un sistema con <em>N</em> CPU no es un sistema <em>N</em> veces más rápido.
Cuando varios procesadores cooperan para realizar una tarea, existe cierta pérdida de rendimiento debida a los mecanismos de sincronización requeridos para controlar el acceso a los recursos compartidos por los procesadores.</p>
</li>
<li>
<p><strong>Economía de escala</strong>. Un sistema multiprocesador puede costar menos que múltiples sistemas monoprocesadores conectados para hacer un trabajo equivalente, porque comparten periféricos, almacenamiento, alimentación, etc.</p>
</li>
<li>
<p><strong>Alta disponibilidad</strong>. Con el hardware adecuado el sistema puede ser tolerante al fallo de uno de los procesadores.
En caso de fallo el sistema no se detendría, pero sí trabajaría más despacio.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>En la actualidad existen dos tipos de sistemas multiprocesador:</p>
</div>
<div id="fig-smp" class="imageblock">
<div class="content">
<img src="media/C02-tipos_de_sistemas/multiprocesamiento_simétrico.svg" alt="multiprocesamiento simétrico">
</div>
<div class="title">Figura 2.6. Arquitectura de un sistema de multiprocesamiento simétrico.</div>
</div>
<div class="ulist">
<ul>
<li>
<p>En los <strong>sistemas de multiprocesamiento simétrico</strong> o <strong>SMP</strong> (<em>Symmetric Multiprocessing</em>) todos los procesadores son iguales.
Todos comparten los mismos recursos, pueden acceder a los mismos dispositivos (véase la <a href="tipos_de_sistemas_operativos.html#fig-smp">Figura 2.6</a>) y cada uno ejecuta una copia del núcleo del sistema operativo.
El sistema operativo debe haber sido diseñado para saber repartir el trabajo entre los procesadores y compartir adecuadamente entre tareas y procesadores el resto de recursos del sistema.
Casi todos los sistemas multiprocesador modernos son de este tipo.</p>
</li>
<li>
<p>En los <strong>sistemas de multiprocesamiento asimétrico</strong> o <strong>AMP</strong> (<em>Asymmetric Multiprocessing</em>) hay un procesador principal y varios secundarios a quienes el principal planifica y entrega las tareas que deben ejecutar.
En ocasiones los procesadores secundarios se distinguen del principal por haber sido diseñados para realizar algún tipo concreto de tareas de forma muy eficiente o por estar conectadas a hardware especial.
Ejemplos de esto son las <a href="https://es.wikipedia.org/wiki/Unidad_de_procesamiento_gr%C3%A1fico">GPU</a>, que no son sino procesadores diseñados específicamente para el procesamiento de gráficos, o las CPU de E/S conectadas a discos duros para gestionarlos de forma más eficiente.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Un ejemplo bastante ilustrativo es el de <a href="https://es.wikipedia.org/wiki/Cell_(microprocesador)">Cell</a>, la CPU de PlayStation 3.
Tenía un núcleo principal de propósito general y 8 núcleos optimizados para ejecutar, de forma muy eficiente, operaciones vectoriales.
Con la ayuda del sistema operativo, los programas debían envíar tareas matemáticamente intensivas a los procesadores secundarios, si querían extraer el máximo provecho de la arquitectura.</p>
</div>
<div class="paragraph">
<p>Desarrollar para un sistema así es más complejo.
Por lo que, aunque sobre el papel esta arquitectura ofrecía gran rendimiento, aprovecharlo era un verdadero reto para los desarrolladores.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_distribuidos"><a class="anchor" href="#_sistemas_distribuidos"></a>2.5. Sistemas distribuidos</h3>
<div class="paragraph">
<p>
En la actualidad es común el uso de redes para interconectar ordenadores individuales —por ejemplo Internet o la red de área local de una oficina— cada uno equipado con su procesador, su memoria, sus dispositivos de almacenamiento, su fuente de alimentación, etc.
En las redes de ordenadores los procesadores de dichos ordenadores se comunican con otros procesadores a través de líneas de comunicación, como: redes Ethernet, líneas telefónicas o wifi.
Estos sistemas son comúnmente denominados <strong>sistemas distribuidos</strong>.</p>
</div>
<div class="paragraph">
<p>Sin entrar en detalles, los sistemas distribuidos pueden ser clasificados en <strong>sistemas cliente-servidor</strong> y <strong>sistemas de redes entre iguales</strong>.</p>
</div>
<div class="sect3">
<h4 id="_sistemas_cliente_servidor"><a class="anchor" href="#_sistemas_cliente_servidor"></a>2.5.1. Sistemas cliente-servidor</h4>
<div class="paragraph">
<p>En los <strong>sistemas cliente-servidor</strong>  existen ordenadores que actúan como <strong>servidores</strong> encargados de satisfacer las peticiones generadas por otros ordenadores que actúan como <strong>clientes</strong>.</p>
</div>
<div class="paragraph">
<p>Este tipo de sistemas han sustituido, en un gran número de casos, a los terminales conectados a <em>mainframes</em>, debido a que los sistemas de escritorio son cada vez más potentes y baratos.
Concretamente:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Los terminales han sido sustituidos por sistemas de escritorio que, al disponer de más recursos, son capaces de realizar muchas de las funcionalidades que anteriormente eran manejadas directamente por los <em>mainframes</em>.</p>
</li>
<li>
<p>Al mismo tiempo estos <em>mainframes</em> se han reemplazado por servidores, no muy diferentes a los sistemas de escritorios, pero preparados para atender las peticiones de sus clientes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ejemplos de este tipo de sistemas son los servidores de base de datos, que responden a las consultas SQL de los clientes, o los servidores de archivos, que proporcionan una interfaz de sistema de archivos con la que los clientes pueden crear, leer, escribir y borrar archivos en el servidor; de forma similar a como si estuvieran almacenados localmente en el propio cliente.</p>
</div>
</div>
<div class="sect3">
<h4 id="_sistemas_de_redes_entre_iguales"><a class="anchor" href="#_sistemas_de_redes_entre_iguales"></a>2.5.2. Sistemas de redes entre iguales</h4>
<div class="paragraph">
<p>En los <strong>sistemas de redes entre iguales</strong>   o <strong>P2P</strong> (<em>peer-to-peer</em>) clientes y servidores no se distinguen los unos de los otros.
Todos los nodos del sistema son iguales y cada uno puede actuar como cliente o servidor, dependiendo de cuándo piden o proporcionan un servicio.</p>
</div>
<div class="paragraph">
<p>La ventaja fundamental de este tipo de sistemas es que en los sistemas cliente-servidor el servidor puede ser el cuello de botella del rendimiento, pero en los sistemas de redes entre iguales la carga se distribuye entre todos los nodos de la red.
Ejemplos de este tipo de sistemas son las redes <a href="https://es.wikipedia.org/wiki/BitTorrent">BitTorrent</a> y <a href="https://es.wikipedia.org/wiki/Bitcoin">Bitcoin</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Un servidor puede ser el cuello de botella no solo por su potencia sino también por el ancho de banda de su conexión a la red.
La potencia del servidor es lo de menos cuando se intenta distribuir en Internet archivos de gran tamaño —por ejemplo imágenes de CD o DVD— pues el problema es que varias descargas simultáneas pueden consumir todo el ancho de banda del servidor durante largos periodos de tiempo.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_sistemas_operativos_para_sistemas_distribuidos"><a class="anchor" href="#_sistemas_operativos_para_sistemas_distribuidos"></a>2.5.3. Sistemas operativos para sistemas distribuidos</h4>
<div class="paragraph">
<p>Desde el punto de vista de los sistemas operativos para sistemas distribuidos es posible hacer la siguiente distinción:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Los <strong>sistemas operativos de red</strong>  ofrecen a las aplicaciones que corren sobre ellos servicios de acceso a redes de ordenadores.
Por ejemplo, implementan algún mecanismo que permita a diferentes procesos en diferentes ordenadores enviar y recibir mensajes.
Además suelen incorporar la opción de proporcionar algunos servicios de red, como la compartición de archivos y dispositivos con otros equipos de la misma red.</p>
<div class="paragraph">
<p>Los ordenadores con sistemas operativos de red son autónomos.
Simplemente es que gracias al sistema operativo de red, conocen la existencia de la red y saben usarla para comunicarse con otros ordenadores de la misma.</p>
</div>
<div class="paragraph">
<p>Este tipo de sistemas operativos son los más utilizados en los tipos de sistemas distribuidos comentados anteriormente.
En la actualidad, la inmensa mayoría de sistemas de escritorio y dispositivos de mano utilizan sistemas operativos de red.</p>
</div>
</li>
<li>
<p>Los <strong>sistemas operativos distribuidos</strong>  crean en el usuario la ilusión de que está en un único ordenador, aunque en realidad el sistema operativo controla todos los ordenadores de la red, dando al usuario acceso transparente a los recursos en todos los equipos de la misma.</p>
<div class="paragraph">
<p>Con este tipo de sistemas operativos el usuario no sabe en qué ordenador se ejecutan sus procesos, donde se almacenan sus archivos, ni qué equipo tiene conectado los distintos periféricos a los que tiene acceso.</p>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Un ejemplo de sistema operativo distribuido es <a href="https://en.wikipedia.org/wiki/Amoeba_(operating_system)">Amoeba</a>, un sistema operativo distribuido de investigación escrito por Andrew S. Tanenbaum en Vrije Universiteit.
Para más información, véase el <a href="http://www.cs.vu.nl/pub/amoeba/">sitio web de Amoeba</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_en_clúster"><a class="anchor" href="#_sistemas_en_clúster"></a>2.6. Sistemas en clúster</h3>
<div class="paragraph">
<p>
Como los sistemas distribuidos, los <strong>sistemas en clúster</strong> interconectar ordenadores individuales.
Sin embargo, generalmente se acepta que los <strong>sistemas en clúster</strong> comparten el almacenamiento y estén conectados por medio de una red local, condiciones que no tienen por qué darse en los sistemas distribuidos.</p>
</div>
<div class="paragraph">
<p>Los <strong>sistemas en clúster</strong> se utilizan para:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Obtener servicios con alta disponibilidad</strong>.
Para ello un nodo del clúster puede estar ejecutando un servicio mientras otro nodo lo monitoriza.
En caso de fallo en el nodo que da el servicio, el que lo monitoriza lo sustituye.</p>
<div class="paragraph">
<p>Si es necesario proporcionar varios servicios, el mecanismo anterior se puede extender repartiendo los servicios entre dos o más nodos y haciendo que se monitoricen entre ellos.</p>
</div>
</li>
<li>
<p><strong>Computación de alto rendimiento</strong> o <strong>HPC</strong>.
En este caso todos los nodos se utilizan para dar un mismo servicio.
Un nodo especial, denominado balanceador de carga, tiene la responsabilidad de repartir el trabajo entre los nodos.</p>
<div class="paragraph">
<p>Este tipo de <strong>sistemas en clúster</strong> se utiliza para realizar trabajos de cálculo muy pesados, como simulaciones —por ejemplo simulación meteorológica, nuclear o de gestión hospitalaria— o romper sistemas de cifrado.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>También es muy utilizado en servidores de Internet —como servidores web, correo electrónico o de mensajería instantánea— o servidores de base de datos que deben dar servicio a una gran cantidad de clientes simultáneamente.
En estos casos el balanceador de carga realiza su trabajo repartiendo las conexiones de los usuarios entre los servidores del clúster.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_de_tiempo_real"><a class="anchor" href="#_sistemas_de_tiempo_real"></a>2.7. Sistemas de tiempo real</h3>
<div class="paragraph">
<p>
Los <strong>sistemas de tiempo real</strong> se utilizan cuando existen requerimientos estrictos de tiempo en la ejecución de ciertas tareas o en el procesamiento de flujos de datos.</p>
</div>
<div class="paragraph">
<p>En general se usan frecuentemente en dispositivos de control donde, dentro de unos márgenes estrictos de tiempo, se deben tomar datos de uno o varios sensores, para analizarlos posteriormente y realizar, en consecuencia, alguna acción con algún mecanismo de control.
Por ejemplo, se suelen utilizar en sistemas de control industrial, domótica, armamento, automoción —en la inyección electrónica de combustible, sistemas de frenado y de control de tracción— o en dispositivos médicos.</p>
</div>
<div class="paragraph">
<p>Los <strong>sistemas de tiempo real</strong> están muy relacionados con los <strong>sistemas empotrados</strong>.
Estos últimos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se diseñan para realizar tareas muy específicas. No son sistemas de propósito general sino de propósito específico.</p>
</li>
<li>
<p>Sus sistemas operativos tienen características muy limitadas y no tienen que tener necesariamente una interfaz de usuario.</p>
</li>
<li>
<p>Estos sistemas están tanto en el motor de los automóviles y los robots que los fabrican, como en reproductores de DVD, microondas o dispositivos de red.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Los <strong>sistemas de tiempo real</strong> pueden ser clasificados en <strong>sistemas de tiempo real estricto</strong> y <strong>sistemas de tiempo real flexible</strong>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Los <strong>sistemas de tiempo real estricto</strong>  o <strong>hard real-time</strong> garantizan que las tareas serán realizadas dentro de unos márgenes estrictos de tiempo.</p>
<div class="paragraph">
<p>Para ello, todas las situaciones imprevistas que puedan ocasionar retrasos en el funcionamiento del sistema operativo deben estar perfectamente delimitadas en tiempo.
Por lo tanto, suelen carecer de memoria virtual y de otras abstracciones que aíslen al desarrollador del funcionamiento real del hardware, ya que introducen impredecibilidad.</p>
</div>
<div class="paragraph">
<p>Los sistemas de tiempo real estricto no son compatibles con los sistemas de tiempo compartido.</p>
</div>
</li>
<li>
<p>Los <strong>sistemas de tiempo real flexible</strong>   o <strong>soft real-time</strong> son útiles cuando en un sistema operativo convencional hay tareas que tienen mayor importancia que el resto, por lo que deben ser realizadas con mayor prioridad.</p>
<div class="paragraph">
<p>El tiempo real flexible no sirve cuando se tienen tareas con limitaciones precisas de tiempo, porque no hay manera de garantizar que dichas restricciones se van a cumplir.
Sin embargo sí es útil para tareas relacionadas con la multimedia, la realidad virtual, los videojuegos, etc. y es compatible con la memoria virtual y otras características presentes en los sistemas de escritorio.
Por eso la mayor parte de los sistemas de escritorio actuales soportan tareas de tiempo real flexible.</p>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph nav-footer">
<p>← Anterior: <a href="qué_es_un_sistema_operativo.html">¿Qué es un sistema operativo?</a> | ↑ Subir: <a href="introducción.html">Introducción</a> | ⌂ Inicio: <a href="main.html">Sistemas Operativos</a> | Siguiente: <a href="historia_de_los_sistemas_operativos.html">Historia de los sistemas operativos</a> →</p>
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "AMS" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
<div id="footer">
    <div id="footer-text">
        Esta obra está sujeta a la licencia
        <a href="http://creativecommons.org/licenses/by/4.0/deed.es">Creative Commons Atribución 4.0 Internacional</a>,
        excepto donde se indique lo contrario.
    </div>
</div>
</body>
</html>