<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="author" content="Jesús Torres">
<title>Sistemas Operativos</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<meta name='robots' content='noindex,nofollow'>
<style>
    .imageblock {
        text-align: center;
    }
    .imageblock > .content {
        margin-bottom: 1rem;
    }
    .imageblock > .title {
        text-align: inherit;
    }
    .tableblock > .lightcell {
        color: gray;
    }
    table tfoot td p {
        font-weight: bold;
    }
</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Sistemas Operativos</h1>
<div class="details">
<span id="author" class="author">Jesús Torres</span><br>
<span id="email" class="email"><a href="mailto:jmtorres@ull.es">jmtorres@ull.es</a></span><br>
<span id="revdate">Curso 2020-2021</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Tabla de Contenido</div>
<ul class="sectlevel1">
<li><a href="#_ejemplos_de_código">Ejemplos de código</a></li>
<li><a href="#_introducción">Parte I: Introducción</a>
<ul class="sectlevel1">
<li><a href="#_qué_es_un_sistema_operativo">1. ¿Qué es un sistema operativo?</a>
<ul class="sectlevel2">
<li><a href="#_definición_de_sistema_operativo">1.1. Definición de sistema operativo</a></li>
<li><a href="#_funciones_del_sistema_operativo">1.2. Funciones del sistema operativo</a></li>
</ul>
</li>
<li><a href="#_tipos_de_sistemas_operativos">2. Tipos de sistemas operativos</a>
<ul class="sectlevel2">
<li><a href="#_mainframe">2.1. Mainframe</a></li>
<li><a href="#_sistemas_de_escritorio">2.2. Sistemas de escritorio</a></li>
<li><a href="#_sistemas_de_mano">2.3. Sistemas de mano</a></li>
<li><a href="#_sistemas_multiprocesador">2.4. Sistemas multiprocesador</a></li>
<li><a href="#_sistemas_distribuidos">2.5. Sistemas distribuidos</a></li>
<li><a href="#_sistemas_en_cluster">2.6. Sistemas en cluster</a></li>
<li><a href="#_sistemas_de_tiempo_real">2.7. Sistemas de tiempo real</a></li>
</ul>
</li>
<li><a href="#_historia_de_los_sistemas_operativos">3. Historia de los sistemas operativos</a>
<ul class="sectlevel2">
<li><a href="#_historia_primera_generación">3.1. 1ª Generación (1945-55)</a></li>
<li><a href="#_historia_segunda_generación">3.2. 2ª Generación (1955-64)</a></li>
<li><a href="#_historia_tercera_generación">3.3. 3ª Generación (1965-1968)</a></li>
<li><a href="#_historia_cuarta_generación">3.4. 4ª Generación (1965-1980)</a></li>
<li><a href="#_5º_generación_desde_1980">3.5. 5º Generación (desde 1980):</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_organización_de_los_sistemas_operativos">Parte II: Organización de los sistemas operativos</a>
<ul class="sectlevel1">
<li><a href="#_componentes_del_sistema">4. Componentes del sistema</a>
<ul class="sectlevel2">
<li><a href="#componente_gestión_de_procesos">4.1. Gestión de procesos</a></li>
<li><a href="#_gestión_de_la_memoria_principal">4.2. Gestión de la memoria principal</a></li>
<li><a href="#_gestión_del_sistema_de_es">4.3. Gestión del sistema de E/S</a></li>
<li><a href="#_gestión_del_almacenamiento_secundario">4.4. Gestión del almacenamiento secundario</a></li>
<li><a href="#_gestión_del_sistema_de_archivos">4.5. Gestión del sistema de archivos</a></li>
<li><a href="#_gestión_de_red">4.6. Gestión de red</a></li>
<li><a href="#_protección_y_seguridad">4.7. Protección y seguridad</a></li>
</ul>
</li>
<li><a href="#_servicios_del_sistema">5. Servicios del sistema</a>
<ul class="sectlevel2">
<li><a href="#_servicios_que_garantizan_el_funcionamiento_eficiente_del_sistema">5.1. Servicios que garantizan el funcionamiento eficiente del sistema</a></li>
<li><a href="#_servicios_útiles_para_el_usuario">5.2. Servicios útiles para el usuario</a></li>
<li><a href="#_interfaz_de_usuario">5.3. Interfaz de usuario</a></li>
</ul>
</li>
<li><a href="#_interfaz_de_programación_de_aplicaciones">6. Interfaz de programación de aplicaciones</a>
<ul class="sectlevel2">
<li><a href="#_interfaces_de_programación_de_aplicaciones">6.1. Interfaces de programación de aplicaciones</a></li>
<li><a href="#_llamadas_al_sistema">6.2. Llamadas al sistema</a></li>
<li><a href="#_librería_del_sistema">6.3. Librería del sistema</a></li>
<li><a href="#_librería_estándar">6.4. Librería estándar</a></li>
<li><a href="#_con_todas_las_piezas_juntas">6.5. Con todas las piezas juntas</a></li>
</ul>
</li>
<li><a href="#_operación_del_sistema_operativo">7. Operación del sistema operativo</a>
<ul class="sectlevel2">
<li><a href="#_software_controlado_mediante_interrupciones">7.1. Software controlado mediante interrupciones</a></li>
<li><a href="#_operación_en_modo_dual">7.2. Operación en modo dual</a></li>
<li><a href="#_protección_de_la_memoria">7.3. Protección de la memoria</a></li>
<li><a href="#_el_temporizador">7.4. El temporizador</a></li>
<li><a href="#_maquinas_virtuales">7.5. Maquinas virtuales</a></li>
<li><a href="#_arranque_del_sistema">7.6. Arranque del sistema</a></li>
</ul>
</li>
<li><a href="#_sistemas_operativos_por_su_estructura">8. Sistemas operativos por su estructura</a>
<ul class="sectlevel2">
<li><a href="#_estructura_sencilla">8.1. Estructura sencilla</a></li>
<li><a href="#_estructura_en_capas">8.2. Estructura en capas</a></li>
<li><a href="#_microkernel">8.3. Microkernel</a></li>
<li><a href="#_estructura_modular">8.4. Estructura modular</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_gestión_de_procesos">Parte III: Gestión de procesos</a>
<ul class="sectlevel1">
<li><a href="#_procesos">9. Procesos</a>
<ul class="sectlevel2">
<li><a href="#_el_proceso">9.1. El proceso</a></li>
<li><a href="#_estados_de_los_procesos">9.2. Estados de los procesos</a></li>
<li><a href="#_bloque_de_control_de_proceso">9.3. Bloque de control de proceso</a></li>
<li><a href="#_colas_de_planificación">9.4. Colas de planificación</a></li>
<li><a href="#_planificación_de_procesos">9.5. Planificación de procesos</a></li>
<li><a href="#_cambio_de_contexto">9.6. Cambio de contexto</a></li>
<li><a href="#_operaciones_sobre_los_procesos">9.7. Operaciones sobre los procesos</a></li>
<li><a href="#_procesos_cooperativos">9.8. Procesos cooperativos</a></li>
</ul>
</li>
<li><a href="#_comunicación_mediante_de_paso_de_mensajes">10. Comunicación mediante de paso de mensajes</a>
<ul class="sectlevel2">
<li><a href="#_tamaño_del_mensaje">10.1. Tamaño del mensaje</a></li>
<li><a href="#_referenciación">10.2. Referenciación</a></li>
<li><a href="#_buffering_2">10.3. Buffering</a></li>
<li><a href="#_operaciones_síncronas_y_asíncronas">10.4. Operaciones síncronas y asíncronas</a></li>
<li><a href="#_ejemplos_de_sistemas_de_paso_de_mensajes">10.5. Ejemplos de sistemas de paso de mensajes</a></li>
</ul>
</li>
<li><a href="#_memoria_compartida">11. Memoria compartida</a>
<ul class="sectlevel2">
<li><a href="#_memoria_compartida_anónima">11.1. Memoria compartida anónima</a></li>
<li><a href="#_memoria_compartida_con_nombre">11.2. Memoria compartida con nombre</a></li>
</ul>
</li>
<li><a href="#_hilos">12. Hilos</a>
<ul class="sectlevel2">
<li><a href="#_introducción_2">12.1. Introducción</a></li>
<li><a href="#_beneficios">12.2. Beneficios</a></li>
<li><a href="#_soporte_multihilo">12.3. Soporte multihilo</a></li>
<li><a href="#_modelos_multihilo">12.4. Modelos multihilo</a></li>
<li><a href="#_operaciones_sobre_los_hilos">12.5. Operaciones sobre los hilos</a></li>
<li><a href="#_otras_consideraciones_sobre_los_hilos">12.6. Otras consideraciones sobre los hilos</a></li>
</ul>
</li>
<li><a href="#_sincronización">13. Sincronización</a>
<ul class="sectlevel2">
<li><a href="#_el_problema_de_las_secciones_críticas">13.1. El problema de las secciones críticas</a></li>
<li><a href="#_sincronización_por_hardware">13.2. Sincronización por hardware</a></li>
<li><a href="#_semáforos">13.3. Semáforos</a></li>
<li><a href="#_mutex">13.4. Mutex</a></li>
<li><a href="#_variables_de_condición">13.5. Variables de condición</a></li>
<li><a href="#_esperas">13.6. Esperas</a></li>
<li><a href="#_funciones_reentrantes_y_seguras_en_hilos">13.7. Funciones reentrantes y seguras en hilos</a></li>
</ul>
</li>
<li><a href="#_planificación_de_la_cpu">14. Planificación de la CPU</a>
<ul class="sectlevel2">
<li><a href="#_planificación_expropiativa">14.1. Planificación expropiativa</a></li>
<li><a href="#_el_asignador">14.2. El asignador</a></li>
<li><a href="#_criterios_de_planificación">14.3. Criterios de planificación</a></li>
<li><a href="#_ciclo_de_ráfagas_de_cpu_y_de_es">14.4. Ciclo de ráfagas de CPU y de E/S</a></li>
<li><a href="#_algoritmos_de_planificación_de_la_cpu">14.5. Algoritmos de planificación de la CPU</a></li>
<li><a href="#_planificación_de_tiempo_real">14.6. Planificación de tiempo real</a></li>
<li><a href="#_planificación_en_sistemas_multiprocesador">14.7. Planificación en sistemas multiprocesador</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_gestión_de_la_memoria">Parte IV: Gestión de la memoria</a>
<ul class="sectlevel1">
<li><a href="#_memoria_principal">15. Memoria principal</a>
<ul class="sectlevel2">
<li><a href="#_etapas_de_un_programa_de_usuario">15.1. Etapas de un programa de usuario</a></li>
<li><a href="#_reubicación_de_las_direcciones">15.2. Reubicación de las direcciones</a></li>
<li><a href="#_espacio_de_direcciones_virtual_frente_a_físico">15.3. Espacio de direcciones virtual frente a físico</a></li>
<li><a href="#_enlazado_dinámico_y_librerías_compartidas">15.4. Enlazado dinámico y librerías compartidas</a></li>
<li><a href="#_asignación_contigua_de_memoria">15.5. Asignación contigua de memoria</a></li>
<li><a href="#_fragmentación">15.6. Fragmentación</a></li>
<li><a href="#_intercambio">15.7. Intercambio</a></li>
</ul>
</li>
<li><a href="#_paginación">16. Paginación</a>
<ul class="sectlevel2">
<li><a href="#_método_básico">16.1. Método básico</a></li>
<li><a href="#_soporte_hardware_de_la_tabla_de_páginas">16.2. Soporte hardware de la tabla de páginas</a></li>
<li><a href="#_protección_de_la_memoria_2">16.3. Protección de la memoria</a></li>
<li><a href="#_páginas_compartidas">16.4. Páginas compartidas</a></li>
<li><a href="#_paginación_jerárquica">16.5. Paginación jerárquica</a></li>
</ul>
</li>
<li><a href="#_memoria_virtual">17. Memoria virtual</a>
<ul class="sectlevel2">
<li><a href="#_paginación_bajo_demanda">17.1. Paginación bajo demanda</a></li>
<li><a href="#_copy_on_write">17.2. Copy-on-write</a></li>
<li><a href="#_archivos_mapeados_en_memoria">17.3. Archivos mapeados en memoria</a></li>
<li><a href="#_reemplazo_de_página">17.4. Reemplazo de página</a></li>
<li><a href="#_asignación_de_marcos_de_página">17.5. Asignación de marcos de página</a></li>
<li><a href="#_hiperpaginación">17.6. Hiperpaginación</a></li>
<li><a href="#_otras_consideraciones">17.7. Otras consideraciones</a></li>
<li><a href="#_interfaz_de_gestión_de_la_memoria">17.8. Interfaz de gestión de la memoria</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_gestión_del_almacenamiento">Parte V: Gestión del almacenamiento</a>
<ul class="sectlevel1">
<li><a href="#_almacenamiento_secundario">18. Almacenamiento secundario</a>
<ul class="sectlevel2">
<li><a href="#_dispositivos_de_almacenamiento">18.1. Dispositivos de almacenamiento</a></li>
<li><a href="#_archivos_y_sistemas_de_archivos">18.2. Archivos y sistemas de archivos</a></li>
<li><a href="#_volúmenes_de_datos">18.3. Volúmenes de datos</a></li>
</ul>
</li>
<li><a href="#_sistemas_de_archivos">19. Sistemas de archivos</a>
<ul class="sectlevel2">
<li><a href="#_estructura_de_un_sistema_de_archivos">19.1. Estructura de un sistema de archivos</a></li>
<li><a href="#_estructuras_de_metadatos_en_disco">19.2. Estructuras de metadatos en disco</a></li>
<li><a href="#_estructuras_de_metadatos_en_memoria">19.3. Estructuras de metadatos en memoria</a></li>
<li><a href="#_montaje_de_sistemas_de_archivos">19.4. Montaje de sistemas de archivos</a></li>
<li><a href="#_archivos">19.5. Archivos</a></li>
<li><a href="#_estructura_de_directorios_2">19.6. Estructura de directorios</a></li>
<li><a href="#_compartición_de_archivos">19.7. Compartición de archivos</a></li>
<li><a href="#_coherencia">19.8. Coherencia</a></li>
</ul>
</li>
<li><a href="#_implementación_de_sistemas_de_archivos">20. Implementación de sistemas de archivos</a>
<ul class="sectlevel2">
<li><a href="#_implementación_de_directorios">20.1. Implementación de directorios</a></li>
<li><a href="#_métodos_de_asignación">20.2. Métodos de asignación</a></li>
<li><a href="#_gestión_del_espacio_libre">20.3. Gestión del espacio libre</a></li>
<li><a href="#_sistemas_de_archivos_virtuales">20.4. Sistemas de archivos virtuales</a></li>
<li><a href="#_planificación_de_disco">20.5. Planificación de disco</a></li>
</ul>
</li>
<li><a href="#_bibliografía">Bibliografía</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_ejemplos_de_código">Ejemplos de código</h2>
<div class="sectionbody">
<div class="paragraph">
<p>En algunos capítulos se enlazan ejemplos de código para ilustrar en mayor detalle los conceptos tratados.
Todos los ejemplos están disponibles en el repositorio <span class="icon"><i class="fa fa-github"></i></span> <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/tree/so2021">ull-esit-sistemas-operativos/ssoo-ejemplos</a>, de donde se pueden descargar.</p>
</div>
<div class="paragraph">
<p>Para compilar los ejemplos, es necesario disponer de herramientas de desarrollo para C y C&#43;&#43;.
Por ejemplo, en la distribución Debian de GNU/Linux y derivadas —como Ubuntu o Linux Mint— basta con tener instalados los paquetes <strong>build-essential</strong> y <strong>cmake</strong>.
Mientras que en Microsoft Windows hacen falta las <a href="https://go.microsoft.com/fwlink/?linkid=840931"><strong>Visual Studio Build Tools</strong></a>.</p>
</div>
<div class="paragraph">
<p>Para compilar es necesario hacer lo siguiente desde la línea de comandos:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Ir al directorio raíz del repositorio descargado y descomprimido.</p>
</li>
<li>
<p>Ejecutar <code>cmake -B build</code> para configurar el proyecto.</p>
</li>
<li>
<p>Ejecutar <code>cmake --build build</code> para compilar los ejemplos.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>En Microsoft Windows estos comandos deben ejecutarse desde la consola de <strong>Developer Command Prompt</strong>.</p>
</div>
<div class="paragraph">
<p>En cada sistema solo se compilarán los ejemplos compatibles, que se guardarán en el directorio <code>build/bin/</code>, desde dónde se pueden ejecutar para probarlos.</p>
</div>
<div class="paragraph">
<p>El código fuente de los ejemplos está en el directorio <code>src/</code>, dentro del subdirectorio numerado con el capítulo correspondiente.</p>
</div>
</div>
</div>
<h1 id="_introducción" class="sect0">Parte I: Introducción</h1>
<div class="sect1">
<h2 id="_qué_es_un_sistema_operativo">1. ¿Qué es un sistema operativo?</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>7 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>¿Qué es un sistema operativo? ¿cuáles son sus responsabilidades en el contexto de un sistema informático? ¿cómo cumple con ellas?
Éstas son algunas de las cuestiones que responderemos en este capítulo.
Aunque, cómo veremos, no son preguntas sencillas de responder.</p>
</div>
<div class="sect2">
<h3 id="_definición_de_sistema_operativo">1.1. Definición de sistema operativo</h3>
<div class="paragraph">
<p>En general no existe una definición universal de lo qué es un <strong>sistema operativo</strong>, aunque si muchas propuestas de diferentes autores:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Hay quién considera que simplemente es una cuestión del mercado: «lo que nos venden cuando llegamos a una tienda y pedimos un sistema operativo».</p>
<div class="paragraph">
<p>En realidad esta definición no es muy precisa, puesto que las características incluidas pueden variar enormemente de un sistema a otro.
Por ejemplo, algunos sistemas operativos apenas alcanzan el megabyte de espacio, careciendo incluso de las aplicaciones más básicas, mientras que otros ocupan gigabytes de espacio, incluyen una interfaz gráfica basada en ventanas y las aplicaciones más comunes que cualquier usuario puede necesitar.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Aunque pueda parecer lo contrario, la cuestión de qué componentes son parte o no de un sistema operativo no es trivial. Por ejemplo, Microsoft y el Departamento de Justicia de los Estados Unidos se enfrentaron en 1998 por la inclusión del navegador Internet Explorer como parte del sistema operativo Microsoft Windows.</p>
</div>
<div class="paragraph">
<p>Microsoft afirmaba que ambos productos eran realmente uno solo y que su unión fue el resultado de un proceso de innovación.
Mientras tanto, la otra parte alegaba que el navegador era un producto distinto y separado, que no formaba parte del sistema operativo y que todo el asunto restringía la libre competencia en el mercado de los navegadores.</p>
</div>
<div class="paragraph">
<p>Seguramente en 1998 los argumentos del Departamento de Justicia de los Estados Unidos tenían mucho sentido, ¿pero qué ocurriría si se planteara este mismo asunto en la actualidad?.
¿Concibes que tu móvil o tu ordenador no trajeran de serie un navegador?</p>
</div>
<div class="paragraph">
<p>Para más información, véase <a href="https://es.wikipedia.org/wiki/Caso_Estados_Unidos_contra_Microsoft">«Caso Estados Unidos contra Microsoft&#8201;&#8212;&#8201;Wikipedia»</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Una definición mucho más común es que el sistema operativo es «aquel programa que se ejecuta continuamente en el ordenador» —lo que denominamos comúnmente como <em><strong>kernel</strong></em> o <strong>núcleo</strong> del sistema— siendo todo lo demás programas del sistema y aplicaciones.</p>
<div class="paragraph">
<p>Sin embargo, en algunos casos ésta definición excluye como parte del sistema operativo algunos servicios que intuitivamente solemos considerar dentro del mismo.
Por ejemplo, si aplicamos esta definición a los sistemas operativos de estructura microkernel, no podríamos decir que servicios básicos como la comunicación en red, los sistemas de archivos y la gestión de la memoria son parte del sistema operativo.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Como veremos en el <a href="#_microkernel">Apartado 8.3</a>, en los sistemas operativos <em>microkernel</em> la funcionalidad implementada en el núcleo del sistema es la mínima necesaria.
Por lo tanto, según la definición anterior, muchos de los componentes y servicios básicos que damos por supuestos a un sistema operativo no formarían parte del mismo en ese tipo de sistemas.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_funciones_del_sistema_operativo">1.2. Funciones del sistema operativo</h3>
<div class="paragraph">
<p>Por lo que hemos visto hasta ahora, parece evidente que no es sencillo definir lo que «es» un sistema operativo.
Sin embargo, es posible que tengamos más suerte definiéndolo a través de lo que «hace».
Es decir, describiendo sus funciones dentro de un sistema informático cualquiera.</p>
</div>
<div id="componentes_sistema_informático" class="imageblock">
<div class="content">
<img src="C01-definición/media/componentes_sistema_informático.svg" alt="componentes sistema informático">
</div>
<div class="title">Figura 1. Vista abstracta de los componentes de un sistema informático.</div>
</div>
<div class="paragraph">
<p>Un <strong>sistema informático</strong> puede ser dividido, <em>grosso modo</em>, en cuatro componentes: el hardware, los usuarios, los programas de aplicación y el sistema operativo (véase la <a href="#componentes_sistema_informático">Figura 1</a>):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Programas de aplicación</strong>. El objetivo fundamental de cualquier sistema informático es ejecutar programas para resolver los problemas informáticos de los usuarios.
Con ese objetivo se construye su hardware y se desarrollan los programas de aplicación —procesadores de textos, hojas de cálculo, compiladores, navegadores de Internet, etc.— que usan los usuarios para resolver sus problemas.</p>
</li>
<li>
<p><strong>Hardware</strong>. El hardware —la CPU, la memoria, los dispositivos de entrada salida, etc.— proporcionan los recursos computacionales del sistema informático.
Los programas de aplicación necesitan usar estos recursos computacionales para resolver los problemas informáticos de los usuarios.</p>
</li>
<li>
<p><strong>Sistema operativo</strong>. En un sistema informático las aplicaciones necesitan realizar operaciones comunes, como acceder a los dispositivos de E/S o reservar porciones de la memoria.
En lugar de que cada aplicación intente hacerlo por su cuenta, es mucho más sencillo que estas operaciones comunes estén centralizadas en el sistema operativo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Por lo tanto, el sistema operativo controla, coordina el acceso y asigna los recursos computacionales del hardware a los distintos programas de aplicación.</p>
</div>
<div class="paragraph">
<p>En realidad ésta es solo una de las dos perspectivas desde las que se pueden analizar las funciones del sistema operativo.
Es la denominada como: <strong>perspectiva del sistema informático</strong>, mientras que la otra es la <strong>perspectiva del usuario</strong>.</p>
</div>
<div class="sect3">
<h4 id="_perspectiva_del_sistema_informático">1.2.1. Perspectiva del sistema informático</h4>
<div class="paragraph">
<p>Un sistema informático tiene múltiples recursos hardware, como son: tiempo de CPU, espacio de memoria, espacio de almacenamiento de archivos, dispositivos de E/S, etc.
También tiene recursos software ofrecidos por algunos programas que se ejecutan en el sistema, como son: servicios de red, servicios de impresión, seguridad, etc.—.
Estos recursos los necesitan los programas de aplicación para resolver los problemas informáticos de los usuarios.</p>
</div>
<div class="paragraph">
<p>Dentro del sistema informático, el sistema operativo es el programa más íntimamente relacionado con el hardware y su función es gestionar los recursos hardware y software disponibles, asignarlos a los diferentes programas, resolver los conflictos en las peticiones y hacer que el sistema opere eficientemente para resolver los problemas de los usuarios.</p>
</div>
<div class="paragraph">
<p>Además, el sistema operativo es el programa encargado del control de la ejecución de los programas de los usuarios, por lo que tiene la tarea de prevenir errores y el uso inadecuado del ordenador.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>En resumen, desde la perspectiva del sistema informático, las funciones del <strong>sistema operativo</strong> son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Gestionar los recursos computacionales del sistema informático.</p>
</li>
<li>
<p>Controlar la ejecución de los programas de usuario y el acceso a los dispositivos de E/S.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Un <strong>sistema operativo</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>No hace trabajo directamente útil para los usuarios.</p>
</li>
<li>
<p>Pero proporciona un entorno adecuado para que los programas de aplicación lo hagan.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Los sistemas operativos existen porque es más sencillo crear sistemas informáticos útiles para los usuarios con ellos que sin ellos.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_perspectiva_del_usuario">1.2.2. Perspectiva del usuario</h4>
<div class="paragraph">
<p>Si intentamos definir las funciones del sistema operativo desde nuestra experiencia como usuarios, seguramente haríamos referencia a la interfaz que nos proporciona para utilizar el sistema informático.
Sin embargo, debemos tener en cuenta que la interfaz varía con el tipo de sistema, por lo que definir las funciones del sistema operativo desde la perspectiva del usuario es mucho más difícil.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, los usuarios que se sientan frente a un sistema de escritorio disponen de: monitor, teclado, ratón y una unidad central.
Estos sistemas se diseñan buscando la máxima productividad en equipos donde un usuario monopoliza todos los recursos; por lo que el sistema operativo se diseña considerando fundamentalmente la facilidad de uso, poniendo algo de atención en el rendimiento y nada en el aprovechamiento de los recursos.</p>
</div>
<div class="paragraph">
<p>Esto difiere mucho de otro tipo de sistema informático dónde múltiples usuarios se sientan frente a terminales conectadas a un gran ordenador central.
Así todos los usuarios comparten los recursos del sistema informático y pueden intercambiar información entre sí.
En este tipo de sistemas el sistema operativo maximiza el aprovechamiento de los recursos con el objeto de garantizar que toda la CPU, memoria y E/S son empleadas de forma eficiente y que ningún usuario utiliza más de lo que le corresponde.
Obviamente, en este tipo de sistemas la facilidad de uso está en un segundo plano.</p>
</div>
<div class="paragraph">
<p>Otros sistemas operativos se diseñan para sistemas informáticos que tienen poca o ninguna interacción con los usuarios.
Es, por ejemplo, el caso de los sistema empotrados de los electrodomésticos.</p>
</div>
<div class="paragraph">
<p>Todos estos tipos de sistemas tienen interfaces muy diferentes, lo que dificulta obtener una definición única de sistema operativo desde la perspectiva del usuario.</p>
</div>
<div class="paragraph">
<p>En los tres casos los objetivos con los que se diseña el sistema operativo son opuestos, por lo que seguramente sea diferente «lo que tiene que hacer» cada sistema operativo para alcanzarlos.
Sin embargo, en los tres casos el sistema operativo es el responsable de la gestión de los recursos computacionales y del control de los programas, funciones que definimos anteriormente desde la perspectiva del sistema informático y que no cambian de un tipo de sistema a otro.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tipos_de_sistemas_operativos">2. Tipos de sistemas operativos</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>23 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Ahora que sabemos que todos los sistemas operativos hacen lo mismo pero que el «cómo» lo hacen difiere de un tipo de sistema informático a otro, vamos a ver los tipos de sistemas informáticos, las características de los sistemas operativos que los gestionan y cómo han evolucionado a lo largo de la historia.</p>
</div>
<div class="sect2">
<h3 id="_mainframe">2.1. Mainframe</h3>
<div class="paragraph">
<p>Los <strong>ordenadores centrales</strong> o <em><strong>mainframes</strong></em> fueron los primeros computadores utilizados en muchas aplicaciones comerciales y científicas.
Se caracterizan no tanto por la potencia de su CPU como por su: gran capacidad de memoria, gran capacidad de almacenamiento secundario, gran cantidad de dispositivos de E/S y rapidez de éstos y alta fiabilidad.</p>
</div>
<div class="paragraph">
<p>Los <em>mainframes</em> pueden funcionar durante años sin problemas ni interrupciones y las reparaciones se realizan sin detener su funcionamiento.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>La mayor diferencia entre los superordenadores y los <em>mainframes</em> está en que los primeros se centran en resolver problemas limitados por la velocidad de cálculo —lo cual requiere miles de CPU de alto rendimiento— mientras que los segundos se centran en la fiabilidad y en problemas limitados por la E/S —por lo que los <em>mainframes</em> suelen tener «solo» entre una y varias docenas de CPU—.</p>
</div>
<div class="paragraph">
<p>Para más información sobre los <em>mainframes</em>, véase <a href="http://es.wikipedia.org/wiki/Ordenador_central">«Ordenador central&#8201;&#8212;&#8201;Wikipedia»</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Los <em>mainframes</em> aparecieron a finales de la década de los 50 del siglo pasado y han seguido evolucionando hasta la actualidad, por lo que dentro de este tipo de sistemas nos encontramos con varios categorías.</p>
</div>
<div class="sect3">
<h4 id="_sistemas_de_procesamiento_por_lotes">2.1.1. Sistemas de procesamiento por lotes</h4>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>Los primeros <em>mainframe</em> eran enormes máquinas operadas desde una consola y conectados a lectores de tarjetas perforadas, dispositivos de cinta e impresoras.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Para imágenes y más información sobre las tarjetas perforadas, véase <a href="https://en.wikipedia.org/wiki/Computer_programming_in_the_punched_card_era">«Computer programming in the punched card era&#8201;&#8212;&#8201;Wikipedia»</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>El trabajo era preparado por cada programador —normalmente en tarjetas perforadas— y entregado al operador del sistema, que era quién tenía acceso al sistema y la responsabilidad de ejecutar los programas y devolver los resultados al programador correspondiente.</p>
</div>
<div class="paragraph">
<p>No había sistema operativo y el operador debía cargar y ejecutar cada programa de uno en uno.</p>
</div>
<div id="consola_ibm_705" class="imageblock">
<div class="content">
<img src="C02-tipos_de_sistemas/media/consola_ibm_705.jpg" alt="consola ibm 705">
</div>
<div class="title">Figura 2. Operadora en la consola de un mainframe IBM 705&#8201;&#8212;&#8201;Fuente: <a href="https://www.ibm.com/ibm/history/ibm100/images/icp/Y444110I58591Z46/us__en_us__ibm100__700_series__705__620x350.jpg">IBM</a></div>
</div>
<div class="paragraph">
<p>Estos sistemas se convirtieron en <strong>sistemas de procesamiento por lotes</strong> o <strong>sistemas en <em>batch</em></strong> cuando se comenzó a utilizar un pequeño programa —llamado <strong>monitor del sistema</strong>— cuya función era cargar y ejecutar sin interrupción un conjunto —o lote— de programas.</p>
</div>
<div class="paragraph">
<p>Para preparar los lotes, por lo general, el operador cargaba previamente en cinta magnética el conjunto de programas a partir de las tarjetas perforadas proporcionadas por los programadores.
Para ello se utilizaba un lector de tarjetas autónomo, independiente del <em>mainframe</em>.</p>
</div>
<div id="sistemas_procesamiento_lotes" class="imageblock">
<div class="content">
<img src="C02-tipos_de_sistemas/media/sistemas_procesamiento_lotes.svg" alt="sistemas procesamiento lotes">
</div>
<div class="title">Figura 3. Organización de la memoria en sistemas de procesamiento por lotes.</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>El <strong>monitor del sistema</strong> es un predecesor de los sistemas operativos y tenía las siguientes características:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Permanecía cargado durante todo el tiempo en la memoria del sistema (véase la <a href="#sistemas_procesamiento_lotes">Figura 3</a>).</p>
</li>
<li>
<p>Su única tarea era cargar y transferir automáticamente la ejecución de un programa al siguiente cuando el anterior terminaba.</p>
</li>
<li>
<p>El mayor inconveniente de este tipo de sistemas era que la CPU permanecía mucho tiempo desocupada porque era —y sigue siendo— varios ordenes de magnitud más rápida que los dispositivos de E/S.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Cualquier programa necesita realizar operaciones de E/S para obtener los datos requeridos para sus cálculos —guardados en tarjetas perforadas y unidades de cinta o, si hablamos de hoy en día, en discos duros y memorias USB—.
También necesita hacer operaciones de E/S para guardar o imprimir los resultados de esos cálculos.</p>
</div>
<div class="paragraph">
<p>Si solo se puede ejecutar un programa la vez, cuando el programa solicita una operación de E/S, la CPU queda a la espera de que esta termine para continuar con la ejecución del programa, por lo que se pierde tiempo de CPU en no hacer nada.
Este desaprovechamiento de la CPU es peor cuanto más rápida es la CPU respecto a los dispositivos de E/S.</p>
</div>
</div>
<div class="sect3">
<h4 id="_sistemas_multiprogramados">2.1.2. Sistemas multiprogramados</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>La solución al inconveniente de los sistemas de procesamiento por lotes con la E/S fue que los programas no accedieran directamente al dispositivo de E/S, sino que, en su lugar, solicitaran la operación al <strong>monitor del sistema</strong> para que éste la solicitara al hardware.
Así el sistema operativo —como podemos comenzar a llamarlo— tiene la oportunidad de sustituir el programa en la CPU por otro, mientras la operación de E/S se completa.</p>
</div>
<div class="paragraph">
<p>Además, con la aparición de la tecnología de los discos magnéticos en la década de los 60 del siglo pasado, los trabajos de los programadores comenzaron a ser almacenados en discos, desde donde eran escogidos por el sistema operativo para su ejecución.</p>
</div>
<div class="paragraph">
<p>A estos sistemas se los llamó <strong>multiprogramados</strong>.</p>
</div>
<div id="sistemas_multiprogramados" class="imageblock">
<div class="content">
<img src="C02-tipos_de_sistemas/media/sistemas_multiprogramados.svg" alt="sistemas multiprogramados">
</div>
<div class="title">Figura 4. Organización de la memoria en sistemas multiprogramados.</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>En los <strong>sistemas multiprogramados</strong> la ejecución de los trabajos funcionaba de la siguiente manera:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>En el disco magnético se almacenaba una cola donde se iban colocando todos los trabajos que tenían que ser ejecutados.</p>
</li>
<li>
<p>El sistema operativo cargaba varios trabajos en memoria del conjunto de trabajos en la cola en el disco magnético (véase la <a href="#sistemas_multiprogramados">Figura 4</a>).</p>
</li>
<li>
<p>El sistema operativo cede la CPU a uno de los trabajos en memoria.</p>
</li>
<li>
<p>Cuando el trabajo en la CPU requería usar la E/S se lo pedía al sistema operativo.
En lugar de mantener a la CPU ocupada inútilmente, el sistema operativo programaba la operación de E/S pero escogía otro trabajo de entre los que estaban en memoria y lo ejecutaba en la CPU.</p>
<div class="paragraph">
<p>Cuando la operación de E/S del anterior trabajo terminaba, el programa que ocupaba la CPU no era interrumpido, sino que debía esperar a una nueva oportunidad de ser escogido para ejecutarse en la CPU.</p>
</div>
</li>
<li>
<p>Cuando un programa en la CPU terminaba, sus recursos se liberaban, dejando memoria libre.
Por lo tanto, el sistema operativo escogía un nuevo trabajo de la cola de trabajos en el disco magnético y lo cargaba en la memoria.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Todo este proceso se repetía mientras hubiera trabajos que ejecutar en la cola de trabajos en el disco.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Para operar de la forma descrita es necesario que el sistema operativo realice tres tareas esenciales:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La <strong>planificación de trabajos</strong>, cuya responsabilidad es seleccionar el siguiente trabajo que será cargado en la memoria principal para mantenerla llena.</p>
</li>
<li>
<p>La <strong>planificación de la CPU</strong>, cuya responsabilidad es elegir el siguiente trabajo que será ejecutado en la CPU, de entre los disponibles en la memoria principal.</p>
</li>
<li>
<p>La <strong>gestión de la memoria</strong>, cuya responsabilidad es repartir la memoria principal entre los trabajos alojados en la misma.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Un ejemplo de este tipo de sistemas operativos es el IBM OS/360, que fue lanzado en 1966 para utilizarlo en los <em>mainframes</em> IBM System/360 (véase el <a href="#_historia_segunda_generación">Apartado 3.2</a>).</p>
</div>
</div>
<div class="sect3">
<h4 id="_sistemas_de_tiempo_compartido">2.1.3. Sistemas de tiempo compartido</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Los sistemas multiprogramados ofrecían un uso más eficiente de la CPU pero no eran capaces de proporcionar interacción directa con los usuarios.
Los programadores seguían teniendo que entregar los trabajos al operador y esperar a que éste les devolviera los resultados.</p>
</div>
<div class="paragraph">
<p>Los <strong>sistemas de tiempo compartido</strong> se desarrollaron tras observar que al dar acceso a un grupo de usuarios se podía conseguir un uso más eficiente del sistema, en comparación a cuando solo podía ser utilizado por un usuario a la vez.
Esto es debido a que, generalmente, un usuario introduce información de forma continua para luego detenerse durante largos periodos de tiempo, mientras que en un grupo de usuarios, las pausas de uno de ellos se pueden llenar con la actividad de los otros.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Los <strong>sistemas de tiempo compartido</strong> se caracterizaban por:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Tener <strong>terminales</strong>, es decir, hardware especializado en hacer de interfaz directa entre los usuarios y el sistema.
A través de estas terminales los usuarios podían dar órdenes al sistema e interactuar con sus trabajos.
Podían haber múltiples usuarios al mismo tiempo pero cada uno solo podía tener un trabajo en ejecución a la vez.</p>
</li>
<li>
<p>Usar la <strong>multiprogramación</strong> para tener varios trabajos en la memoria principal al mismo tiempo e intercambiar el trabajo en la CPU cuando éste solicitaba una operación de E/S, como ya se venía haciendo en los <strong>sistemas multiprogramados</strong> para hacer un uso más eficiente de la CPU.</p>
</li>
<li>
<p>Repartir el tiempo de CPU entre usuarios.
El sistema operativo asignaba un tiempo de CPU a cada usuario —denominado <strong>ventana de tiempo</strong> o <strong>cuanto</strong> de CPU—.
Cuando este tiempo se agotaba, el sistema intercambiaba el trabajo en la CPU por el de otro usuario en el sistema.
La ventana de tiempo era extremadamente pequeña, dando a cada usuario la impresión de que su trabajo nunca se detenía, como si dispusiera de la CPU en exclusiva.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Los sistemas que, como los de tiempo compartido, pueden ser utilizados por varios usuarios simultáneamente se denominan sistemas <strong>multiusuario</strong> .</p>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En los primeros sistemas se usaban <strong>terminales</strong> electro-mecánicos con un teclado y una impresora, como el <a href="https://en.wikipedia.org/wiki/Teletype_Model_33">Teletype Model 3</a> (1963).
Posteriormente llegaron los terminales electrónicos, que usaban un monitor en lugar de una impresora, como el <a href="https://es.wikipedia.org/wiki/IBM_3270">IBM 3270</a>.
En cualquier caso solo disponían del hardware necesario para realizar la tarea de conectar a los usuarios con el ordenador central.</p>
</div>
<div class="paragraph">
<p>Estos terminales no deben confundirse con las terminales por software que traen algunos sistemas operativos modernos.
Las terminales por software o <em>terminales virtuales</em> se programan para emular las especificaciones de alguna versión de esas terminales físicas antiguas que hemos comentado.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Los sistemas de tiempo compartido significaron un salto importante en complejidad por diversas razones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Como varios trabajos están en la memoria principal al mismo tiempo, el sistema operativo requiere mecanismos de <strong>gestión de la memoria</strong> y <strong>protección</strong>.</p>
</li>
<li>
<p>Para tener un tiempo de respuesta razonable, los trabajos deben estar cargados en la memoria principal.
Para que quepan más trabajos de los usuarios en la memoria, el sistema operativo debe utilizar técnicas de <strong>memoria virtual</strong> para ejecutar trabajos que no están completamente cargados en la memoria principal.</p>
</li>
<li>
<p>Como la CPU debe ser compartida entre todos los trabajos, el sistema operativo necesita mecanismos de <strong>planificación de la CPU</strong>.</p>
</li>
<li>
<p>Como varios trabajos pueden tener la necesidad de cooperar y que su ejecución siga cierto orden, el sistema operativo debe proporcionar mecanismos de <strong>sincronización</strong> y <strong>comunicación</strong>.</p>
</li>
<li>
<p>Como el sistema debe disponer de un <strong>sistema de archivos</strong> para repartir el espacio en disco y facilitar a los usuarios el acceso y gestión de sus datos, el sistema operativo necesita un componente de <strong>gestión de discos</strong>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Las primeras versiones de UNIX —lanzado por primera vez en 1970— el sistema operativo VMS —desarrollado en 1978— para los VAX de Digital Equipment Corportation y el IBM OS/400 —introducido en 1988— utilizado en los minicomputadoras AS/400, son algunos ejemplos de sistemas operativos de tiempo compartido (véase el <a href="#_historia_tercera_generación">Apartado 3.3</a>).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Estrictamente hablando, el término <strong>sistemas de tiempo compartido</strong> hace referencia a estos <em>mainframes</em> desarrollados a partir de principios de la década de 1970.
Así que no es común utilizarlo con <em>mainframe</em> modernos.</p>
</div>
<div class="paragraph">
<p>Los <em>mainframe</em> modernos permiten a un mismo usuario ejecutar varios trabajos al mismo tiempo, repartiendo el tiempo de CPU entre todos los trabajo en el sistema y no solo entre los usuarios.
Y lo mismo ocurre en la mayor parte de los sistemas operativos de propósito general actuales —utilizados en ordenadores de escritorio, servidores, portátiles y dispositivos móviles— que con el tiempo han copiado muchas características de los <strong>sistemas de tiempo compartido</strong>.
Por eso el termino actuales <strong>sistema multitarea</strong>, que es mucho más general.</p>
</div>
<div class="paragraph">
<p>La <strong>multitarea</strong>  es un método para tener varios procesos en memoria y ejecutarlos «al mismo tiempo».
Generalmente requiere de técnicas de multiprogramación, como las empleadas por los antiguos <strong>sistemas multiprogramados</strong>, y de reparto del tiempo de CPU, como ocurre en los antiguos <strong>sistemas de tiempo compartido</strong>.
Por eso se puede decir que esos dos tipos de sistemas <em>mainframe</em> eran <strong>sistemas multitarea</strong>.
Al igual que lo son los <em>mainframe</em> modernos y muchos sistemas operativos actuales de escritorio y de dispositivos móviles.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_de_escritorio">2.2. Sistemas de escritorio</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>En la década de los 70 del siglo pasado también aparecieron las primeras CPU en microprocesadores y con éstas llegaron las <strong>microcomputadoras</strong> o <strong>microordenadores</strong>.
Las primeras <strong>microcomputadoras</strong> no incluían teclado ni monitor y se programaban usando interruptores y ledes ubicados en el frontal de la unidad.
Pero en torno a 1977 apareció la segunda generación de <strong>microcomputadoras</strong>, que si incluían estos periféricos de E/S, por lo que eran más fáciles de usar que sus predecesoras.
Entonces comenzaron a recibir el nombre de <em>ordenadores domésticos</em> y de su mano llegaron los primeros <strong>sistemas operativos de escritorio</strong>.</p>
</div>
<div id="ordenadores_domésticos_1977" class="imageblock">
<div class="content">
<img src="C02-tipos_de_sistemas/media/ordenadores_domésticos_1977.jpg" alt="ordenadores domésticos 1977">
</div>
<div class="title">Figura 5. Los tres ordenadores que la revista Byte denominó como la "Trinidad de 1977" de la computación doméstica: el <a href="https://es.wikipedia.org/wiki/Commodore_PET">Commodore PET 2001</a>, el <a href="https://es.wikipedia.org/wiki/Apple_II">Apple II</a> y el <a href="https://es.wikipedia.org/wiki/TRS-80">TRS-80 Model I</a>&#8201;&#8212;&#8201;Fuente: <a href="https://commons.wikimedia.org/wiki/File:Trinity77.jpg">Wikipedia</a></div>
</div>
<div class="paragraph">
<p>Los <em>mainframes</em> y las minicomputadoras de la época siguieron siendo los ordenadores corporativos por excelencia, ya que eran mucho más grandes y potentes, y también costosos.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>El término en desuso <strong>minicomputadora</strong> o <strong>miniordenador</strong> hace referencia a máquinas multiusuario de rango medio, entre los <em>mainframes</em> y los ordenadores domésticos.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Los primeros <strong>sistemas operativos de escritorio</strong> eran muy básicos.
Por ejemplo, en un sistema diseñado para ser utilizado por un único usuario no tiene sentido implementar un sistema de archivos con permisos.
Así que, los primeros sistemas operativos de escritorio carecían de esta característica que, sin embargo, ya existía en los sistemas de tiempo compartido de la época.
De la misma manera, carecían de otros mecanismos de protección y no eran ni multiusuario ni multitarea.</p>
</div>
<div class="paragraph">
<p>Pese a estas diferencias, los <strong>sistemas operativos de escritorio</strong> se han beneficiado del desarrollo de los sistemas operativos para <em>mainframes</em>.
Los sistemas de escritorio actuales son <strong>multiusuario</strong> y <strong>multitarea</strong>; incluyen sistemas de archivos con permisos, autenticación y mecanismos de protección de la memoria —como medidas para proteger los datos de los usuarios— y han incorporado muchas otras características de los sistemas operativos para <em>mainframe</em>.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Aunque con el tiempo los sistemas de escritorio han ido adquiriendo características desarrolladas en los <em>mainframe</em>, no debemos olvidar que ambos tipos de sistemas se siguen diseñando con objetivos diferentes.
Mientras que en los <em>mainframe</em> se persigue maximizar la fiabilidad y utilización eficiente de los recursos, en los sistemas de escritorio se maximiza la facilidad de uso y el tiempo de respuesta al usuario, poniendo algo de atención al rendimiento.</p>
</div>
<div class="paragraph">
<p>Los <strong>sistemas operativos de escritorio</strong> modernos ya nos son «solo de escritorio» ni se ejecutan únicamente en ordenadores domésticos.
Se utilizan en un altísimo porcentaje en servidores, superordenadores y hasta en dispositivos móviles.
Por eso, en la actualidad, el término <strong>sistema operativo de propósito general</strong>  es mucho más adecuado.</p>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>El <strong>tiempo de respuesta</strong> al usuario se puede considerar como el intervalo de tiempo entre un comando de un usuario —por ejemplo un clic— y la respuesta del sistema a dicho comando.
En ocasiones este tiempo se minimiza a costa de un uso menos eficiente de los recursos del sistema, por lo que no es un objetivo deseable para diseñar un <em>mainframe</em>.
Para más información, véase el <a href="#_criterios_de_planificación">Apartado 14.3</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Son muchos los ejemplos de sistemas operativos en esta categoría. Van desde CP/M —lanzado en 1977— hasta los actuales GNU/Linux, Microsoft Windows y Apple macOS, pasando por MS-DOS, IBM OS/2 y todas las versiones anteriores de Microsoft Windows (véase el <a href="#_historia_cuarta_generación">Apartado 3.4</a>).</p>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_de_mano">2.3. Sistemas de mano</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Con el nombre genérico de <strong>sistemas de mano</strong> hacemos referencia a las <em>tablets</em>, lectores de libros electrónicos y teléfonos móviles.
Los desarrolladores de aplicaciones y sistemas de mano deben enfrentarse a diversos desafíos, originados por el tamaño limitado de los dispositivos y la alimentación mediante el uso de baterías.
Debido a esas limitaciones muchos sistemas de mano tienen poca cantidad de memoria, procesadores lentos —en comparación con sus equivalentes de escritorio— y pantallas más pequeñas.</p>
</div>
<div class="paragraph">
<p>En el diseño del sistema operativo suele primar la facilidad de uso y buscar un buen equilibrio entre rendimiento y tiempo de vida de la batería.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_multiprocesador">2.4. Sistemas multiprocesador</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Un <strong>sistema multiprocesador</strong> es aquel ordenador hay procesadores interconectados que comparten el bus del sistema, el reloj y, en ocasiones la memoria, y los periféricos.</p>
</div>
<div class="paragraph">
<p>Hace años esto solo se daban en sistemas con varias CPU, lo que era relativamente común en servidores y sistemas de alto rendimiento para trabajos técnicos o científicos.
Sin embargo, en la actualidad cualquier dispositivo digital u ordenador doméstico puede tener una CPU con múltiples núcleos, lo que los convierte en sistemas multiprocesador.</p>
</div>
<div class="paragraph">
<p>Las principales de ventajas de estos sistemas son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Aumentan la cantidad de trabajo realizado</strong>. A mayor número de procesadores, mayor cantidad
de trabajo puede realizar el sistema.
Sin embargo debemos de tener en cuenta que un sistema con \$N\$ CPU no es un sistema \$N\$ veces más
rápido.
Cuando varios procesadores cooperan para realizar una tarea, existe cierta pérdida de
rendimiento debida a los mecanismos de sincronización requeridos para controlar el acceso a los recursos compartidos por los procesadores.</p>
</li>
<li>
<p><strong>Economía de escala</strong>. Un sistema multiprocesador puede costar menos que múltiples sistemas monoprocesadores conectados para hacer un trabajo equivalente, porque comparten periféricos, almacenamiento, alimentación, etc.</p>
</li>
<li>
<p><strong>Alta disponibilidad</strong>. Con el hardware adecuado el sistema puede ser tolerante al fallo de uno de los procesadores.
En caso de fallo el sistema no se detendría pero si trabajaría más despacio.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>En la actualidad existen dos tipos de sistemas multiprocesador:</p>
</div>
<div id="smp" class="imageblock">
<div class="content">
<img src="C02-tipos_de_sistemas/media/multiprocesamiento_simétrico.svg" alt="multiprocesamiento simétrico">
</div>
<div class="title">Figura 6. Arquitectura de un sistema de multiprocesamiento simétrico.</div>
</div>
<div class="ulist">
<ul>
<li>
<p>En los <strong>sistemas de multiprocesamiento simétrico</strong> o <strong>SMP</strong> (<em>Symmetric Multiprocessing</em>) todos los procesadores son iguales.
Todos comparten los mismos recursos, pueden acceder a los
mismos dispositivos (véase la <a href="#smp">Figura 6</a>) y cada uno ejecuta una copia del núcleo del sistema operativo.
El sistema operativo debe haber sido diseñado para saber repartir el trabajo entre los procesadores y compartir adecuadamente entre tareas y procesadores el resto de recursos del sistema.
Casi todos los sistemas multiprocesador modernos son de este tipo.</p>
</li>
<li>
<p>En los <strong>sistemas de multiprocesamiento asimétrico</strong> o <strong>AMP</strong> (<em>Asymmetric Multiprocessing</em>) hay un procesador principal y varios secundarios a quienes el principal planifica y entrega las tareas que deben ejecutar.
En ocasiones los procesadores secundarios se distinguen del principal por haber sido diseñados para realizar algún tipo concreto de tareas de forma muy eficiente o por estar conectadas a hardware especial.
Ejemplos de esto son las <a href="https://es.wikipedia.org/wiki/Unidad_de_procesamiento_gr%C3%A1fico">GPU</a>, que no son sino procesadores diseñados específicamente para el procesamiento de gráficos, o las CPU de E/S conectadas a
discos duros para gestionarlos de forma más eficiente.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Un ejemplo bastante ilustrativo es el de <a href="https://es.wikipedia.org/wiki/Cell_(microprocesador)">Cell</a>, la CPU de PlayStation 3.
Tenía un núcleo principal de propósito general y 8 núcleos optimizados para ejecutar de forma muy eficiente operaciones vectoriales.
Con la ayuda del sistema operativo, los programas debían envían tareas matemáticamente intensivas a los procesadores secundarios, si querían extraer el máximo provecho de la arquitectura.</p>
</div>
<div class="paragraph">
<p>Desarrollar para un sistema así es más complejo.
Por lo que, aunque sobre el papel esta arquitectura ofrecía gran rendimiento, aprovecharlo era un verdadero reto para los desarrolladores.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_distribuidos">2.5. Sistemas distribuidos</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>En la actualidad es común el uso de redes para interconectar ordenadores individuales —por ejemplo Internet o la red de área local de una oficina— cada uno equipado con su procesador, su memoria, sus dispositivos de almacenamiento, su fuente de alimentación, etc.
En las redes de ordenadores los procesadores de dichos ordenadores se comunican con otros procesadores a través de líneas de comunicación, como: redes Ethernet, líneas telefónicas o wifi.
Estos sistemas son comúnmente denominados <strong>sistemas distribuidos</strong>.</p>
</div>
<div class="paragraph">
<p>Sin entrar en detalles, los sistemas distribuidos pueden ser clasificados en <strong>sistemas cliente-servidor</strong> y <strong>sistemas de redes entre iguales</strong>.</p>
</div>
<div class="sect3">
<h4 id="_sistemas_cliente_servidor">2.5.1. Sistemas cliente-servidor</h4>
<div class="paragraph">
<p>En los <strong>sistemas cliente-servidor</strong>  existen ordenadores que actúan como <strong>servidores</strong> encargados de satisfacer las peticiones generadas por otros ordenadores que actúan como <strong>clientes</strong>.</p>
</div>
<div class="paragraph">
<p>Este tipo de sistemas han sustituido, en un gran número de casos, a los terminales conectados a <em>mainframes</em>, debido a que los sistemas de escritorio son cada vez más potentes y baratos.
Concretamente:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Los terminales han sido sustituidos por sistemas de escritorio que, al disponer de más recursos, son capaces de realizar muchas de las funcionalidades que anteriormente eran manejadas directamente por los <em>mainframes</em>.</p>
</li>
<li>
<p>Al mismo tiempo estos <em>mainframes</em> se han reemplazado por servidores, no muy diferentes a los sistemas de escritorios, pero preparados para atender las peticiones de sus clientes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ejemplos de este este tipo de sistemas son los servidores de base de datos, que responden a las consultas SQL de los clientes, o los servidores de archivos, que proporcionan una interfaz de sistema de archivos con la que los clientes pueden crear, leer, escribir y borrar archivos en el servidor; de forma similar a como si estuvieran almacenados localmente en el propio cliente.</p>
</div>
</div>
<div class="sect3">
<h4 id="_sistemas_de_redes_entre_iguales">2.5.2. Sistemas de redes entre iguales</h4>
<div class="paragraph">
<p>En los <strong>sistemas de redes entre iguales</strong>   o <strong>P2P</strong> (<em>peer-to-peer</em>) clientes y servidores no se distinguen los unos de los otros.
Todos los nodos del sistema son iguales y cada uno puede actuar como cliente o servidor, dependiendo de cuándo piden o proporcionan un servicio.</p>
</div>
<div class="paragraph">
<p>La ventaja fundamental de este tipo de sistemas es que en los sistemas cliente-servidor el servidor puede ser el cuello de botella del rendimiento, pero en los sistemas de redes entre iguales la carga se distribuye entre todos los nodos de la red.
Ejemplos de este tipo de sistemas son las redes <a href="https://es.wikipedia.org/wiki/BitTorrent">BitTorrent</a> y <a href="https://es.wikipedia.org/wiki/Bitcoin">Bitcoin</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Un servidor puede ser el cuello de botella no solo por su potencia sino también por el ancho de banda de su conexión a la red.
La potencia del servidor es lo de menos cuando se intenta distribuir en Internet archivos de gran tamaño —por ejemplo imágenes de CD o DVD— pues el problema es que varias descargas simultáneas pueden consumir todo el ancho de banda del servidor durante largos periodos de tiempo.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_sistemas_operativos_para_sistemas_distribuidos">2.5.3. Sistemas operativos para sistemas distribuidos</h4>
<div class="paragraph">
<p>Desde el punto de vista de los sistemas operativos para sistemas distribuidos es posible hacer la siguiente distinción:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Los <strong>sistemas operativos de red</strong>  ofrecen a las aplicaciones que corren sobre ellos servicios de acceso a redes de ordenadores.
Por ejemplo, implementan algún mecanismo que permita a diferentes procesos en diferentes ordenadores enviar y recibir mensajes.
Además suelen incorporar la opción de proporcionar algunos servicios de red, como la compartición de archivos y dispositivos con otros equipos de la misma red.</p>
<div class="paragraph">
<p>Los ordenadores con sistemas operativos de red son autónomos.
Simplemente es que gracias al sistema operativo de red, conocen la existencia de la red y saben usarla para comunicarse con otros ordenadores de la misma.</p>
</div>
<div class="paragraph">
<p>Este tipo de sistemas operativos son los más utilizados en los tipos de sistemas distribuidos comentados anteriormente.
En la actualidad, la inmensa mayoría de sistemas de escritorio y dispositivos de mano utilizan sistemas operativos de red.</p>
</div>
</li>
<li>
<p>Los <strong>sistemas operativos distribuidos</strong>  crean en el usuario la ilusión de que está en un único ordenador, aunque en realidad el sistema operativo controla todos los ordenadores de la red, dando al usuario acceso transparente a los recursos en todos los equipos de la misma.</p>
<div class="paragraph">
<p>Con este tipo de sistemas operativos el usuario no sabe en qué ordenador se ejecutan sus procesos, dónde se almacenan sus archivos, ni qué equipo tiene conectado los distintos periféricos a los que tiene acceso.</p>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Un ejemplo de sistema operativo distribuido es <a href="https://en.wikipedia.org/wiki/Amoeba_(operating_system)">Amoeba</a>, un sistema operativo distribuido de investigación escrito por Andrew S. Tanenbaum en Vrije Universiteit.
Para más información, véase el <a href="http://www.cs.vu.nl/pub/amoeba/">sitio web de Amoeba</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_en_cluster">2.6. Sistemas en cluster</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Como los sistemas distribuidos, los <strong>sistemas en <em>cluster</em></strong> interconectar ordenadores individuales.
Sin embargo generalmente se acepta que los <strong>sistemas en <em>cluster</em></strong> comparten el almacenamiento y estén conectados por medio de una red local, condiciones que no tienen por qué darse en los sistemas distribuidos.</p>
</div>
<div class="paragraph">
<p>Los <strong>sistemas en <em>cluster</em></strong> se utilizan para:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Obtener servicios con alta disponibilidad</strong>.
Para ello un nodo del <em>cluster</em> puede estar ejecutando un servicio mientras otro nodo lo monitoriza.
En caso de fallo en el nodo que da el servicio, el que lo monitoriza lo sustituye.</p>
<div class="paragraph">
<p>Si es necesario proporcionar varios servicios, el mecanismo anterior se puede extender repartiendo los servicios entre dos o más nodos y haciendo que se monitoricen entre ellos.</p>
</div>
</li>
<li>
<p><strong>Computación de alto rendimiento</strong> o <strong>HPC</strong>.
En este caso todos los nodos se utilizan para dar un mismo servicio.
Un nodo especial, denominado balanceador de carga, tiene la responsabilidad de repartir el trabajo entre los nodos.</p>
<div class="paragraph">
<p>Este tipo de <strong>sistemas en <em>cluster</em></strong> se utiliza para realizar trabajos de cálculo muy pesados, como simulaciones —por ejemplo simulación meteorológica, nuclear o de gestión hospitalaria— o romper sistemas de cifrado.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>También es muy utilizado en servidores de Internet —como servidores web, correo electrónico o de mensajería instantánea— o servidores de base de datos que deban dar
servicio a una gran cantidad de clientes simultáneamente.
En estos casos el balanceador de carga realiza su trabajo repartiendo las conexiones de los usuarios entre los servidores del <em>cluster</em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_de_tiempo_real">2.7. Sistemas de tiempo real</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Los <strong>sistemas de tiempo real</strong> se utilizan cuando existen requerimientos estrictos de tiempo en la ejecución de ciertas tareas o en el procesamiento de flujos de datos.</p>
</div>
<div class="paragraph">
<p>En general se usan frecuentemente en dispositivos de control donde, dentro de unos márgenes estrictos de tiempo, se deben tomar datos de uno o varios sensores, para analizarlos posteriormente y realizar, en consecuencia, alguna acción con algún mecanismo de control.
Por ejemplo, se suelen utilizar en sistemas de control industrial, domótica, armamento, automoción —en la inyección electrónica de combustible, sistemas de frenado y de control de tracción— o en dispositivos médicos.</p>
</div>
<div class="paragraph">
<p>Los <strong>sistema de tiempo real</strong> están muy relacionados con los <strong>sistemas empotrados</strong>.
Estos últimos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se diseñan para realizar tareas muy específicas. No son sistemas de propósito general sino de propósito específico.</p>
</li>
<li>
<p>Sus sistemas operativos tienen características muy limitadas y no tienen que tener necesariamente una interfaz de usuario.</p>
</li>
<li>
<p>Estos sistemas están tanto en el motor de los automóviles y los robots que los fabrican, como en reproductores de DVD, microondas o dispositivos de red.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Los <strong>sistemas de tiempo real</strong> pueden ser clasificados en <strong>sistemas de tiempo real estricto</strong> y <strong>sistemas de tiempo real flexible</strong>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Los <strong>sistemas de tiempo real estricto</strong>  o <strong>hard real-time</strong> garantizan que las tareas serán realizadas dentro de unos márgenes estrictos de tiempo.</p>
<div class="paragraph">
<p>Para ello, todas las situaciones imprevistas que puedan ocasionar retardos en el funcionamiento del sistema operativo deben estar perfectamente limitadas en tiempo.
Por lo tanto, suelen carecer de memoria virtual y de otras abstracciones que aíslen al desarrollador del funcionamiento real del hardware ya que introducen impredecibilidad.</p>
</div>
<div class="paragraph">
<p>Los sistemas de tiempo real estricto no son compatibles con los sistemas de tiempo compartido.</p>
</div>
</li>
<li>
<p>Los <strong>sistemas de tiempo real flexible</strong>   o <strong>soft real-time</strong> son útiles cuando en un sistema operativo convencional hay tareas que tienen mayor importancia que el resto, por lo que deben ser realizadas con mayor prioridad.</p>
<div class="paragraph">
<p>El tiempo real flexible no sirve cuando se tienen tareas con limitaciones precisas de tiempo, porque no hay manera de garantizar que dichas restricciones se van a cumplir.
Sin embargo si es útil para tareas relacionadas con la multimedia, la realidad virtual, los videojuegos, etc. y es compatible con la memoria virtual y otras características presentes en los sistemas de escritorio.
Por eso la mayor parte de los sistemas de escritorio actuales soportan tareas de tiempo real flexible.</p>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_historia_de_los_sistemas_operativos">3. Historia de los sistemas operativos</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>19 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>La historia de los sistemas operativos se puede dividir en cinco grandes etapas o generaciones, obviamente conectadas con las generaciones de los ordenadores donde funcionaban.</p>
</div>
<div class="sect2">
<h3 id="_historia_primera_generación">3.1. 1ª Generación (1945-55)</h3>
<div class="paragraph">
<p>En la primera generación de ordenadores no se utilizaban sistemas operativos.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Sus principales características son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Computadoras construidas con electrónica de <a href="https://es.wikipedia.org/wiki/V%C3%A1lvula_termoi%C3%B3nica">válvulas de vacío</a>.</p>
</li>
<li>
<p>Sin sistema operativo.</p>
</li>
<li>
<p>Sin lenguajes de programación.
Se programaban directamente en lenguaje máquina.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Algunos ejemplos de ordenadores destacables fueron:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="https://es.wikipedia.org/wiki/ENIAC">ENIAC</a> (1945)</dt>
<dd>
<p>Se le considera el primer ordenador electrónico digital de propósito general, aunque existe cierta polémica sobre este punto.
Lo cierto es que se construyeron otros ordenadores antes que éste pero o no eran de propósito general —como las famosas computadoras <a href="https://es.wikipedia.org/wiki/Colossus">Colossus</a> (1944), que fueron diseñadas para ayudar en <a href="https://es.wikipedia.org/wiki/Criptoan%C3%A1lisis">criptoanálisis</a>— o no eran electrónicos sino electro-mecánicos —como la computadora <a href="https://es.wikipedia.org/wiki/Z3">Z3</a> (1941), que usaba <a href="https://es.wikipedia.org/wiki/Rel%C3%A9">relés</a>—.</p>
<div class="paragraph">
<p>No era un producto comercial sino un proyecto experimental de defensa que principalmente se diseño y utilizó para calcular tablas de tiro de artillería destinadas al Laboratorio de Investigación Balística del Ejército de los Estados Unidos.</p>
</div>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/Z4">Z4</a> (1945) fue el primer ordenador digital comercial, pero era electro-mecánico.</p>
</div>
</dd>
<dt class="hdlist1"><a href="https://es.wikipedia.org/wiki/IBM_701">IBM 701</a> (1953)</dt>
<dd>
<p>Fue el primer <em>mainframe</em> de la serie IBM 700, que a la larga se convertiría en un éxito de ventas.
Utilizaba tubos de vacío y tarjetas perforadas.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>El IBM 7090 —versión transistorizada del 709, que utilizaba válvulas de vacío, como todos los de la serie 700— y el posterior 7094, fueron usados por la NASA para los cálculos de control de las misiones de los programas espaciales Mercury y Gemini y durante la primera etapa del programa Apolo.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_historia_segunda_generación">3.2. 2ª Generación (1955-64)</h3>
<div class="paragraph">
<p>En la segunda generación de ordenadores los transistores reemplazan a las válvulas de vacío.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>En lo que respecta a los sistemas operativos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Aparecen los monitores del sistema, que se pueden considerar un predecesor de los sistemas operativos.</p>
</li>
<li>
<p>Sistema de procesamiento por lotes.</p>
</li>
<li>
<p>Se comienzan a utilizar lenguajes de programación, como: ensamblador, FORTRAN y COBOL.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/GM-NAA_I/O">GM-NAA I/O</a> (<em>General Motors and North American Aviation Input/Output system</em>) fue el primer sistema operativo.
Fue desarrollado por General Motors Research Laboratory en 1956 para el <em>mainframe</em> <a href="https://en.wikipedia.org/wiki/IBM_704">IBM 704</a> con el fin de automatizar la carga y ejecución de un nuevo trabajo una vez había terminado el anterior.
Para su desarrollo se basaron en un monitor del sistema creado en 1955 por programadores de General Motors para el IBM 701.</p>
</div>
<div id="instalación_ibm_702" class="imageblock">
<div class="content">
<img src="C03-historia/media/instalación_ibm_702.jpg" alt="instalación ibm 702">
</div>
<div class="title">Figura 7. Instalación de un mainframe IBM 702&#8201;&#8212;&#8201;Fuente: <a href="https://commons.wikimedia.org/wiki/File:BRL61-IBM_702.jpg">Wikipedia</a></div>
</div>
</div>
<div class="sect2">
<h3 id="_historia_tercera_generación">3.3. 3ª Generación (1965-1968)</h3>
<div class="paragraph">
<p>En la tercera generación se comenzaron a utilizar los circuitos integrados, que fue una invención de finales de la década de 1950.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>En lo que respecta a los sistemas operativos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Aparecen los sistemas operativos multiprogramados.</p>
</li>
<li>
<p>Aparecen más lenguajes de programación.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>El ejemplo más destacado de esta época es el <a href="https://en.wikipedia.org/wiki/OS/360_and_successors">IBM OS/360</a>
Fue un sistema operativo desarrollado por IBM para su <em>mainframe</em> <a href="https://en.wikipedia.org/wiki/IBM_System/360">IBM System/360</a> (S/360) (véase la <a href="#instalación_ibm_system_360">Figura 8</a>).
Su versión DOS/360 (<em>Disk Operating System/360</em>) fue el primer sistema operativo en hacer los discos magnéticos un requisito para poder operar.</p>
</div>
<div id="instalación_ibm_system_360" class="imageblock">
<div class="content">
<img src="C03-historia/media/instalación_ibm_system_360.jpg" alt="instalación ibm system 360">
</div>
<div class="title">Figura 8. Instalación de un mainframe IBM System/360&#8201;&#8212;&#8201;Fuente: <a href="http://www-03.ibm.com/ibm/history/ibm100/us/en/icons/system360/impacts/">IBM</a></div>
</div>
<div class="paragraph">
<p>Se anunció en 1964 pero fue lanzado en 1966, con un año de retraso respecto a la fecha prevista originalmente.
Los motivos fundamentales fueron ciertos problemas de organización interna de la compañía y la falta de experiencia en proyectos de esa envergadura.
Las previsiones iniciales eran de 1 millón de líneas de código y miles de componentes de software.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Algunos autores fechan los inicios de la ingeniería del software en la publicación del libro «The Mythical Man-Month: Essays on Software Engineering», escrito por Frederick Brooks y publicado en 1975.
Frederick Brooks se basó en la experiencia adquirida mientras administraba el desarrollo del IBM OS/360, donde era jefe de proyecto.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_historia_cuarta_generación">3.4. 4ª Generación (1965-1980)</h3>
<div class="paragraph">
<p>La cuarta generación abarca desde mediados de los años 60 hasta finales de la década de los 70.
Respecto a los ordenadores, es el resultado del desarrollo de los microprocesadores.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>En lo que respecta a los sistemas operativos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Aparecen los sistemas operativos de tiempo compartido.</p>
</li>
<li>
<p>Aparecen los terminales, los programas interactivos y las máquinas virtuales.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>A continuación veremos los ejemplos más representativos de esta época.</p>
</div>
<div class="sect3">
<h4 id="_multics">3.4.1. MULTICS</h4>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/Multics">MULTICS</a> fue anunciado en 1964, fruto de la colaboración entre el MIT, General Electrics y Bell Labs, como el primer sistema operativo de propósito general.</p>
</div>
<div id="multics_mainframe" class="imageblock">
<div class="content">
<img src="C03-historia/media/multics_mainframe.jpg" alt="multics mainframe">
</div>
<div class="title">Figura 9. Mainframe GE-6180 con sistema MULTICS, entorno a 1976 en el MIT&#8201;&#8212;&#8201;Fuente: <a href="http://www.multicians.org/multics-stories.html">Multicians</a></div>
</div>
<div class="paragraph">
<p>Fue el primer sistema operativo en proporcionar un sistema de archivos jerárquico, intérprete de comandos implementado como programa de usuario, listas de control de acceso individuales para cada archivo y enlazado dinámico, entre otras características novedosas.</p>
</div>
<div class="paragraph">
<p>Además experimentó con eliminar la separación entre el espacio de direcciones de los procesos y los archivos.
Es decir, como si todos los archivos estuvieran mapeados en memoria, permitiendo a los procesos acceder al contenido de los archivos directamente (véase el <a href="#_archivos_mapeados_en_memoria">Apartado 17.3</a>).</p>
</div>
</div>
<div class="sect3">
<h4 id="_vmcms">3.4.2. VM/CMS</h4>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/VM_(sistema_operativo)">VM/CMS</a> es un sistema de IBM utilizado en los <em>mainframe</em> <a href="https://en.wikipedia.org/wiki/IBM_System/360">IBM System/360</a>, System/370, System/390 y zSeries.
VM es un <a href="https://es.wikipedia.org/wiki/Hipervisor">hipervisor</a> que se encarga de virtualizar el hardware para crear múltiples máquinas virtuales, dando la sensación de que cada una es un <em>mainframe</em> independiente.</p>
</div>
<div class="paragraph">
<p>Como sistema operativo de las maquinas virtuales, una opción común es CMS, un sistema interactivo y monousuario muy ligero, diseñado para operar fundamentalmente en una máquina virtual de VM.
Gracias a VM/CMS, cada usuario tiene la sensación de trabajar en un sistema completamente independiente y seguro.</p>
</div>
<div class="paragraph">
<p>El desarrollo de VM/CMS comenzó en 1965 y la primera versión estuvo disponible a primeros de 1966.
Las versiones actuales se denominan IBM z/VM.</p>
</div>
</div>
<div class="sect3">
<h4 id="_unix">3.4.3. UNIX</h4>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/Unix">UNIX</a> fue desarrollado originalmente por Bell Labs en 1970 para los sistemas <a href="https://es.wikipedia.org/wiki/PDP-11">PDP-11/20</a> (véase la <a href="#dec_pdp11">Figura 10</a>).
La autoría del mismo se le atribuye a un grupo de programadores, liderados por Ken Thompson, que decidieron rehacer el trabajo de MULTICS pero a menor escala; después de que Bell Labs abandonara el proyecto MULTICS en 1969.
Inicialmente se llamó UNICS y fue desarrollado para los sistemas PDP-7.</p>
</div>
<div id="dec_pdp11" class="imageblock">
<div class="content">
<img src="C03-historia/media/dec_pdp11_ken_den.jpg" alt="dec pdp11 ken den">
</div>
<div class="title">Figura 10. Dennis Ritchie (de pie) y Ken Thompson (sentado) frente a un PDP-11 y sus dos terminales <a href="https://en.wikipedia.org/wiki/Teletype_Model_33">Teletype 33</a>&#8201;&#8212;&#8201;Fuente: <a href="https://www.bell-labs.com/usr/dmr/www/">Dennis Ritchie</a></div>
</div>
<div class="paragraph">
<p>La primer versión de UNIX fue implementada en ensamblador, como era común en la época.
Posteriormente, Dennis Ritchie y Brian Kernighan diseñaron un nuevo lenguaje de programación llamado «C», especialmente pensado para que UNIX fuera escrito con él.
Eso facilitó que UNIX pudiera ser portado a ordenadores diferentes.
Además, gracias al lenguaje C, el código era más conciso y compacto, lo que se tradujo en que se pudieron desarrollar nuevas funcionalidades más rápidamente.</p>
</div>
<div class="paragraph">
<p>AT&amp;T, la compañía matriz de Bell Labs, no podía competir en la industria de los ordenadores, por lo que puso el código fuente de UNIX a disposición de universidades, compañías privadas y del gobierno de los Estados Unidos.
Eso aumento su difusión y dio resultados inesperados.
Por ejemplo, una de las variantes más importantes de UNIX fue <a href="https://es.wikipedia.org/wiki/Berkeley_Software_Distribution">BSD</a>, desarrollada por la Universidad de California en Berkeley.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>La versión 4.2BSD (<em>Berkeley Software Distribution</em>) de esta variante de UNIX fue la primera que incluyó la interfaz de <em>sockets</em> para facilitar la comunicación entre procesos a través de Internet y otras redes.
Esta interfaz se ha convertido en estándar en prácticamente cualquier sistemas operativo.</p>
</div>
<div class="paragraph">
<p>También implementó y ayudó a difundir el estándar de comunicaciones TCP/IP, base de la actual Internet.
Muchos sistemas operativos actuales, tanto libres como privativos, utilizan código de UNIX BSD en su implementaciones de los protocolos TCP/IP y de diversas utilidades de red.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>En la actualidad se considera que hay dos grandes familias de UNIX y las distintas variantes pertenecen a una u otra en función del UNIX del que derivaron originalmente:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La familia derivada de <strong>AT&amp;T UNIX System V</strong>, en la que se incluyen sistemas operativos no libres, tales como: <a href="https://es.wikipedia.org/wiki/SCO_OpenServer">SCO OpenServer</a>, <a href="https://es.wikipedia.org/wiki/Solaris_(sistema_operativo)">Oracle/Sun Microsystems Solaris Operating Environment</a> y <a href="https://es.wikipedia.org/wiki/UnixWare">SCO UnixWare</a>.</p>
</li>
<li>
<p>La familia derivada de <strong>UNIX BSD</strong>, en la que se incluyen sistemas libres como: <a href="https://es.wikipedia.org/wiki/FreeBSD">FreeBSD</a>, <a href="https://es.wikipedia.org/wiki/NetBSD">NetBSD</a>, <a href="https://es.wikipedia.org/wiki/OpenBSD">OpenBSD</a>, <a href="https://en.wikipedia.org/wiki/Darwin_(operating_system)">Darwin</a> y <a href="https://es.wikipedia.org/wiki/DragonFly_BSD">DragonFly BSD</a>, entre muchos otros.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/FreeBSD">FreeBSD</a> es el sistema base de algunos sistemas no libres.
Por ejemplo, <a href="https://en.wikipedia.org/wiki/Darwin_(operating_system)">Darwin</a> es el sistema operativo en el que se basan los sistemas operativos de Apple: macOS, IOS, watchOS, tvOS e iPadOS.
A su vez Darwin utiliza múltiples elementos de FreeBSD (véase el <a href="#_mach">Apartado 3.5.8</a>).</p>
</div>
<div class="paragraph">
<p>Otro ejemplo destacable es <a href="https://en.wikipedia.org/wiki/PlayStation_4_system_software">Orbis OS</a> —el sistema operativo de PlayStation 4— que también está basado en FreeBSD.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_vms">3.4.4. VMS</h4>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/OpenVMS">VMS</a> es un sistema operativo de 32 bits diseñado originalmente por Digital Equipment Corporation (DEC) —ahora propiedad de HP— en 1978 para usarlo en minicomputadoras <a href="https://es.wikipedia.org/wiki/VAX">VAX</a>.
Posteriormente fue portado a sistemas DEC Alpha e Intel Itanium.</p>
</div>
<div id="dec_vax11" class="imageblock">
<div class="content">
<img src="C03-historia/media/dec_vax11.jpg" alt="dec vax11">
</div>
<div class="title">Figura 11. Instalación de VAX 11/780 en 1980&#8201;&#8212;&#8201;Fuente: <a href="http://www.chilton-computing.org.uk/">Science and Technology Facilities Council</a></div>
</div>
<div class="paragraph">
<p>Las siglas VMS vienen de <em>Virtual Memory System</em>, ya que una de sus principales características era explotar el concepto de <strong>memoria virtual</strong>.
Este concepto también es muy utilizando en los sistemas operativos modernos.
Permite que los procesos se ejecuten aislados, unos de otros, en la memoria principal y sin tener que ser cargados completamente, lo que permite que cada uno consuma memos memoria.</p>
</div>
<div class="paragraph">
<p>VMS era un sistema multiusuario y multiprocesador que podía distribuir el trabajo entre varias máquinas, lo que le permitía ser tolerante a fallos.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>VMS es en cierta medida un ancestro de Microsoft Windows NT (véase el <a href="#_windows_nt">Apartado 3.5.6</a>).
Para desarrollar Windows NT, Microsoft contrató a un grupo de desarrolladores de Digital Equipment Corporation.
Muchos aspectos del diseño de Windows NT reflejan la experiencia de DEC en VMS.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_ibm_os400">3.4.5. IBM OS/400</h4>
<div class="paragraph">
<p>El <a href="https://es.wikipedia.org/wiki/OS/400">IBM OS/400</a> es un sistema utilizado en la familia de minicomputadoras <a href="https://es.wikipedia.org/wiki/AS/400">IBM AS/400</a> —llamada iSeries desde 2006—.
Fueron introducidos en el mercado en 1988, pero aún es posible verlos en algunas organizaciones.
En 2008 el sistema operativo IBM OS/400 pasó a llamarse IBM i y siguen publicándose nuevas versiones en la actualidad.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_5º_generación_desde_1980">3.5. 5º Generación (desde 1980):</h3>
<div class="paragraph">
<p>Esta última generación abarca desde la década de 1980 hasta la actualidad.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Respecto a los sistemas operativos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Incluye a los sistemas operativos de escritorio y ordenadores personales (PC).</p>
</li>
<li>
<p>Aparecen múltiples conceptos nuevos: monousuario, multitarea, distribuidos, paralelos, tiempo real, etc.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Se puede observar una muestra de la interfaz gráfica de usuario de algunos estos sistemas en el artículo <a href="https://www.webdesignerdepot.com/2009/03/operating-system-interface-design-between-1981-2009/">«Operating System Interface Design Between 1981-2009»</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_cpm">3.5.1. CP/M</h4>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/CP/M">CP/M</a> (1974) fue el sistema operativo estándar en la primera generación de microcomputadoras. Fue creado por Digital Research, Inc. —fundada por Gary Kildall— para ser el sistema operativo de los microordenadores basados en <a href="https://es.wikipedia.org/wiki/Intel_8080">Intel 8080/85</a> y <a href="https://es.wikipedia.org/wiki/Zilog_Z80">Zilog Z80</a>.</p>
</div>
<div class="paragraph">
<p>Con la elección de MS-DOS por parte de IBM para su <a href="https://es.wikipedia.org/wiki/IBM_PC">IBM PC</a>, CP/M fue perdiendo mercado paulatinamente hasta desaparecer.
Sin embargo, la influencia de CP/M en MS-DOS es indudable, en tanto en cuanto 86-DOS, el predecesor de MS-DOS, estaba basado en las ideas de CP/M.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ms_dos">3.5.2. MS-DOS</h4>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/MS-DOS">MS-DOS</a> fue el sistema operativo estándar en la segunda generación de microcomputadoras.
No era ni multitarea ni multiusuario.
Fue el primer sistema operativo del <a href="https://es.wikipedia.org/wiki/IBM_PC">IBM PC</a> —lanzado en 1981— y durante mucho tiempo fue ampliamente utilizado en toda la plataforma «PC compatible».</p>
</div>
<div class="paragraph">
<p>MS-DOS fue creado por Seattle Computer Products (SCP) con el nombre de <a href="https://es.wikipedia.org/wiki/QDOS">86-DOS</a> en 1979.
Se basaron en ideas de CP/M, pues pretendían ofrecer una versión de CP/M para procesadores <a href="https://es.wikipedia.org/wiki/Intel_8086_y_8088">Intel 8086</a>.
Inicialmente era conocido como QDOS (<em>Quick and Dirty Operating System</em>) pero SCP le cambió el nombre en 1980, cuando comenzaron al licenciarlo.
Posteriormente Microsoft adquirió el sistema y lo vendió a IBM en 1981 con el nombre de MS-DOS.</p>
</div>
<div class="paragraph">
<p>Tanto IBM como Microsoft lanzaron versiones de DOS, aunque originalmente IBM solamente validaba y empaquetaba el software de Microsoft.
Microsoft lanzaba sus versiones bajo el nombre de MS-DOS, mientras IBM las lanzaba bajo el nombre de <a href="https://es.wikipedia.org/wiki/IBM_PC_DOS">IBM PC-DOS</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En <a href="https://www.pcjs.org/">PCjs</a> se pueden probar de forma sencilla sistemas operativos y aplicaciones antiguas del IBM PC.
Solo hace falta acceder con el navegador y elegir la experiencia que más nos llame la atención.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_os2">3.5.3. OS/2</h4>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/OS/2">OS/2</a> fue un sistema operativo creado por Microsoft e IBM para aprovechar las nuevas características de la segunda generación de ordenadores personales de IBM, equipados con procesador <a href="https://es.wikipedia.org/wiki/Intel_80286">Intel 80286</a>.
Pero al final terminó siendo desarrollado en exclusiva por IBM.</p>
</div>
<div class="paragraph">
<p>OS/2 fue pensado como un sucesor con <strong>operación en modo dual</strong> de MS-DOS y de Microsoft Windows 2.0.
Fue anunciado en abril y lanzado en diciembre de 1987 como un sistema operativo en modo texto.
En la versión 1.1, lanzada en noviembre de 1988, se le añadió interfaz gráfica.</p>
</div>
<div id="os_2_1" class="imageblock">
<div class="content">
<img src="C03-historia/media/os_2_1.png" alt="os 2 1">
</div>
<div class="title">Figura 12. Panel de control de Microsoft-IBM OS/2 1.1&#8201;&#8212;&#8201;Fuente: Michal Necasek</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En los sistemas con <strong>operación en modo dual</strong> se distingue entre dos modos de ejecución, de tal forma que solo en el modo en el que se ejecuta el código del sistema operativo se pueden realizar operaciones peligrosas.
En el otro modo y con menos privilegios, se ejecutan las aplicaciones de usuario.
Para más información, véase el <a href="#_operación_en_modo_dual">Apartado 7.2</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>La colaboración entre IBM y Microsoft terminó en 1990, entre el lanzamiento de Windows 3.0 y la de OS/2 1.3.
El aumento de popularidad de Windows llevo a Microsoft a dejar de centrarse en el desarrollo de OS/2, lo que hizo que IBM se preocupara por los continuos retrasos en el desarrollo de OS/2 2.0.
Inicialmente ambas compañías acordaron que IBM tomaría el mantenimiento de OS/2 1.0 y el desarrollo de OS/2 2.0, mientras Microsoft continuaría desarrollando OS/2 3.0, que entonces era conocido como «NT OS/2».
Sin embargo Microsoft finalmente decidió renombrar NT OS/2 como Windows NT, dejando el futuro desarrollo de OS/2 en manos de IBM.</p>
</div>
<div class="paragraph">
<p>OS/2 Warp 3 fue un sistema completo de 32 bits lanzado en 1994.
Le seguiría OS/2 Warp 4, en 1996.
Poco después, IBM anunció que OS/2 desaparecería.</p>
</div>
</div>
<div class="sect3">
<h4 id="_windows_3_x">3.5.4. Windows 3.x</h4>
<div class="paragraph">
<p>La familia <a href="https://es.wikipedia.org/wiki/Windows_3.1x">Windows 3.x</a> de Microsoft Windows fue desarrollada desde 1990 hasta 1994.
Windows 3.0 fue la primera versión de éxito de Windows, permitiendo a Microsoft competir con el <a href="https://es.wikipedia.org/wiki/Macintosh">Macintosh</a> de Apple Computer y el <a href="https://es.wikipedia.org/wiki/Commodore_Amiga">Commodore Amiga</a>.</p>
</div>
<div id="windows_30" class="imageblock">
<div class="content">
<img src="C03-historia/media/windows_30.png" alt="windows 30">
</div>
<div class="title">Figura 13. Administrador de programas de Microsoft Windows 3.0&#8201;&#8212;&#8201;Fuente: <a href="https://guidebookgallery.org/screenshots/win30">Guidebook</a></div>
</div>
<div class="paragraph">
<p>En 1983, Microsoft anunció el desarrollo de Windows, una interfaz gráfica de usuario para su sistema MS-DOS, que se usaba en los IBM PC y compatibles desde 1981.
Windows requería una instalación previa de MS-DOS y era iniciado como un programa más, que podía ser terminado en cualquier momento, devolviendo al usuario a la línea de comandos de MS-DOS.</p>
</div>
<div class="paragraph">
<p>MS-DOS le proporcionaba a Windows controladores de dispositivo para ciertas tareas, como el acceso al CD-ROM o a la interfaz de red.
Sin embargo Windows ejecutaba aplicaciones especificas de Windows, almacenadas en un formato ejecutable mucho más complejo que el de los programas de MS-DOS.
Además, debido a que MS-DOS no aislaba a las aplicaciones del hardware y no se protegía así mismo de los errores en dichas aplicaciones, Windows disponía de controladores de dispositivo propios, así como sus propios sistemas de gestión de procesos y de memoria.
En realidad Windows no se ejecutaba sobre MS-DOS, sino que hacía uso de él.
Por ello puede ser considerado como un sistema operativo.</p>
</div>
</div>
<div class="sect3">
<h4 id="_windows_95_98_me">3.5.5. Windows 95, 98, Me</h4>
<div class="paragraph">
<p>La familia Windows 3.x fue sustituida por una serie de sistemas operativos gráficos híbridos de 16/32 bits.</p>
</div>
<div id="windows_95" class="imageblock">
<div class="content">
<img src="C03-historia/media/windows_95.png" alt="windows 95">
</div>
<div class="title">Figura 14. Escritorio de Microsoft Windows 95&#8201;&#8212;&#8201;Fuente: <a href="http://www.guidebookgallery.org/screenshots/win95">Guidebook</a></div>
</div>
<div class="paragraph">
<p>Windows 95 fue lanzado en 1995.
Fue el primer Windows unido a una versión de MS-DOS específica, aunque este hecho se intentaba mantener oculto.
Entre las características de Windows 95 destacan: mejoras significativas en la interfaz de usuario (véase la <a href="#windows_95">Figura 14</a>), nombres de archivo de hasta 256 caracteres con conservación de mayúsculas y minúsculas —en MS-DOS el límite era de 8 caracteres para el nombre más 3 de extensión— y multitarea expropiativa para las aplicaciones de 32 bits.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Como veremos en el <a href="#_planificación_expropiativa">Apartado 14.1</a>, la planificación expropiativa es una técnica que permite al sistema operativo expulsar de la CPU a los procesos en ciertas circunstancias; como, por ejemplo, que lleven demasiado tiempo utilizando la CPU de forma ininterrumpida.</p>
</div>
<div class="paragraph">
<p>En la familia Windows 3.x la planificación era cooperativa, es decir, los procesos abandonaban la CPU voluntariamente.
Esto ocasionaba problemas con programas que no devolvía la CPU al sistema con la suficiente frecuencia, ya que así el resto de procesos no tenía ocasión de ejecutarse para hacer su trabajo o responder al usuario.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Windows 98 fue lanzado el 25 de junio de 1998.
Le siguió Windows Me, el 14 de septiembre de 2000.
Windows Me fue la última versión de la familia de sistemas operativos híbridos de 16/32 bits que sucedió a la familia Windows 3.x.</p>
</div>
</div>
<div class="sect3">
<h4 id="_windows_nt">3.5.6. Windows NT, 2000, XP, Vista, 7, 8 y 10</h4>
<div class="paragraph">
<p>Windows NT fue un sistema operativo de 32 bits.
El primero de la familia de sistemas operativos Microsoft Windows actuales.</p>
</div>
<div class="paragraph">
<p>Su desarrollo empezó en 1988 con el nombre de OS/2 3.0.
Cuando Windows 3.0 fue lanzado en mayo de 1990, tuvo tanto éxito que Microsoft decidió cambiar la API del aún en desarrollo NT OS/2 —que era como Microsoft lo llamaba entonces— pasando de ser una versión extendida de la API de OS/2 a una versión extendida de la API de Windows 3.0.
Esta decisión causó tensión entre Microsoft e IBM y provocó que finalmente la colaboración terminara.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Una interfaz de programación de aplicaciones o API (del inglés <em>Application Programming Interface</em>) es el conjunto de funciones, procedimientos o métodos que ofrece el sistema operativo para ser utilizado por las aplicaciones.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Como hemos comentado anteriormente, Microsoft contrató a un grupo de desarrolladores de Digital Equipment Corporation para crear Windows NT.
Por lo que muchos de sus elementos reflejan la experiencia anterior de DEC en VMS.</p>
</div>
<div class="paragraph">
<p>Windows NT soportaba varias API de distintos sistemas operativos —por ejemplo Win32, POSIX y OS/2 2.1— que eran implementadas como subsistemas encima de un API nativo no documentado públicamente.
Esta estructura en subsistemas, fue lo que permitió la adopción tardía de la API de Windows 3.0 como API principal, tal y como hemos comentado.</p>
</div>
<div class="paragraph">
<p>La primera versión —Windows NT 3.1— lanzada el 13 de julio de 1993, era un sistema operativo <em>microkernel</em> (véase el <a href="#_mach">Apartado 3.5.8</a> un poco más adelante) multiplataforma que corría sobre procesadores <a href="https://es.wikipedia.org/wiki/IA-32">x86</a>, <a href="https://es.wikipedia.org/wiki/DEC_Alpha">DEC Alpha</a>, <a href="https://es.wikipedia.org/wiki/MIPS_(procesador)">MIPS</a> 4000 y <a href="https://es.wikipedia.org/wiki/PowerPC">PowerPC</a>.</p>
</div>
<div class="paragraph">
<p>Windows NT 4.0 —lanzado en 1996— fue la última versión en soportar plataformas distintas a Intel IA-32.
Aunque el desarrollo de Windows 2000 para procesador Alpha continuó un poco más, hasta 1999, cuando Compaq dejó de soportar Windows NT en esa arquitectura.
Además Windows NT 4.0 integró en el núcleo más funciones —por ejemplo, parte del subsistema gráfico— para obtener un rendimiento más próximo al de Windows 95 en ese apartado.</p>
</div>
<div class="paragraph">
<p>Windows 2000 —o Windows NT 5.0— fue lanzado en el 17 de febrero de 2000 y fue el primer sistema operativo de la familia NT al que se le eliminaron las siglas del nombre.
Fue por motivos de marketing, para favorecer la unificación de las dos familias de sistemas operativos Microsoft Windows de entonces —Windows 9x y Windows NT— alrededor de la tecnología NT.</p>
</div>
<div class="paragraph">
<p>Windows XP —o Windows NT 5.1— completó en 2001 el proceso de unificación de las dos familias de sistemas operativos Windows.
Con su aparición forzó la extinción de la familia Windows 9x, al sustituirla con una versión de Windows XP denominada Windows XP Home Edition, específica para la informática doméstica.</p>
</div>
</div>
<div class="sect3">
<h4 id="_gnulinux">3.5.7. GNU/Linux</h4>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/GNU/Linux">GNU/Linux</a> es un sistema operativo libre y, tal vez, el más famoso proyecto de <a href="https://es.wikipedia.org/wiki/Software_libre">software libre</a>.</p>
</div>
<div class="paragraph">
<p>El proyecto GNU se inició en 1983, con el fin de desarrollar un sistema operativo estilo UNIX enteramente libre.
El proyecto incluía la creación de herramientas de desarrollo de software y aplicaciones de usuario.</p>
</div>
<div class="paragraph">
<p>Mucho tiempo después, el estudiante universitario finés Linus Torvalds comenzó a desarrollar el núcleo Linux como hobby, mientras estudiaba en la Universidad de Helsinki.
Torvalds originalmente usaba <a href="https://es.wikipedia.org/wiki/MINIX">Minix</a>, un sistema operativo simplificado escrito por Andrew Tanenbaum para enseñar diseño de sistemas operativos.
Sin embargo, el hecho de que Tanenbaum no diera soporte a las mejoras del sistema operativo que eran propuestas por otros desarrolladores, llevó a Torvalds a escribir un sustituto de MINIX.</p>
</div>
<div class="paragraph">
<p>En 1991, cuando se liberó la primera versión del núcleo Linux, el proyecto GNU había desarrollado todos los componentes necesarios del sistema operativo excepto el núcleo.
Torvalds y otros desarrolladores rápidamente adaptaron Linux para que funcionara con los componentes de GNU, creando un sistema operativo completamente funcional que se denomina GNU/Linux.</p>
</div>
<div class="paragraph">
<p>El núcleo Linux fue licenciado bajo la GNU General Public License (GPL), como el resto del proyecto GNU.
Pero Linux no es parte de dicho proyecto.
El proyecto GNU tiene su propio núcleo, denominado <a href="https://es.wikipedia.org/wiki/GNU_Hurd">GNU/Hurd</a>, que lleva 30 años en desarrollo y parece que aun está muy lejos de estar listo.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>GNU no es el único sistema operativo que utiliza el núcleo Linux.
<a href="https://es.wikipedia.org/wiki/Android">Android</a>, por ejemplo, es un sistema operativo que usa el núcleo Linux pero no es GNU.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_mach">3.5.8. Mach</h4>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/Mach_(n%C3%BAcleo)">Mach</a> es un núcleo de sistema operativo desarrollado en la Universidad Carnegie-Mellon (CMU).
El proyecto en la CMU se desarrolló desde 1985 hasta 1994.</p>
</div>
<div class="paragraph">
<p>Mach explora el concepto que denominamos <strong><em>microkernel</em></strong>.
En los sistemas operativos <strong><em>microkernel</em></strong> solo se implementa en el núcleo del sistema un conjunto mínimo de servicios básicos.
El resto de los servicios proporcionados por el sistema operativo se implementan como procesos con menos privilegios.</p>
</div>
<div class="paragraph">
<p>Por sus ventajas en cuanto a seguridad y fiabilidad, en algún momento se pensó que los <em>microkernel</em> dominarían el universo de los sistema operativos.
Sin embargo, el mayor esfuerzo hasta la fecha para conseguirlo es <a href="https://es.wikipedia.org/wiki/GNU_Hurd">GNU/Hurd</a>, que lleva varias décadas de retraso.
Por fortuna, otros sistemas operativos <em>microkernel</em> han tenido algo más éxito, como es el caso de <a href="https://es.wikipedia.org/wiki/QNX">QNX</a> o <a href="https://en.wikipedia.org/wiki/MINIX_3">MINIX 3</a>.
Mientras que Google parece que lo va a intentar con <a href="https://es.wikipedia.org/wiki/Google_Fuchsia">Google Fuchsia</a>, el posible sustituto de Android.</p>
</div>
<div class="paragraph">
<p>A mediados de los 90, Apple Computers seleccionó <a href="https://es.wikipedia.org/wiki/NEXTSTEP">OpenStep</a> como base para el sucesor de su clásico <a href="https://es.wikipedia.org/wiki/Mac_OS_Classic">Mac OS</a>.
OpenStep es realmente una versión actualizada de NeXTSTEP que era un sistema basado en un núcleo Mach 2.5 con porciones del sistema UNIX BSD de la Universidad de Berkeley.
Por tanto, la mezcla de Mach con UNIX BSD de OpenStep es la base del sistema operativo <a href="https://es.wikipedia.org/wiki/MacOS">macOS</a> actual de Apple.</p>
</div>
<div id="openstep_42" class="imageblock">
<div class="content">
<img src="C03-historia/media/openstep_42.png" alt="openstep 42">
</div>
<div class="title">Figura 15. Entorno gráfico de OpenStep 4.2&#8201;&#8212;&#8201;Fuente: <a href="https://guidebookgallery.org/screenshots/openstep42">Guidebook</a></div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Para ser exactos, la base del sistema operativo macOS es un sistema operativo libre denominado <a href="https://en.wikipedia.org/wiki/Darwin_(operating_system)">Darwin</a> y desarrollado por Apple .
Se trata de un sistema <a href="https://es.wikipedia.org/wiki/FreeBSD">FreeBSD</a> adaptado para correr sobre el núcleo Mach.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<img src="C03-historia/media/historia_sistemas_operativos.svg" alt="historia sistemas operativos">
</div>
<div class="title">Figura 16. Línea de tiempo de la historia de los sistemas operativos.</div>
</div>
</div>
</div>
</div>
</div>
<h1 id="_organización_de_los_sistemas_operativos" class="sect0">Parte II: Organización de los sistemas operativos</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>El estudio de la organización interna de los sistemas operativos requiere del análisis de tres aspectos diferentes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Los componentes del sistema operativo y sus interrelaciones.</p>
</li>
<li>
<p>Los servicios que el sistema operativo proporciona a través del funcionamiento coordinado de dichos componentes.</p>
</li>
<li>
<p>La interfaz de programación que el sistema operativo ofrece a usuarios y programadores como forma de acceso a dichos servicios.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>También veremos como como se categorizan los sistemas operativos según la forma en la que se interconectan sus componentes.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_componentes_del_sistema">4. Componentes del sistema</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>11 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Crear un software tan complejo como un sistema operativo no es sencillo, por ello resulta más práctico dividirlo en piezas más pequeñas especializadas en aspectos concretos de la gestión del sistema.</p>
</div>
<div class="paragraph">
<p>Cada sistema operativo tiene diferentes componentes con distinto nombre.
Lo que veremos en este capítulo es un esquema de los más comunes a la mayoría de sistemas operativos actuales.</p>
</div>
<div class="sect2">
<h3 id="componente_gestión_de_procesos">4.1. Gestión de procesos</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>La gestión de los procesos es un elemento central de todo sistema operativo:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>El <strong>proceso</strong> es la unidad de trabajo en cualquier sistema operativo moderno.
Es quién realiza las tareas que interesan a los usuarios.
Por eso, es a cada proceso al que se le asigna el tiempo de CPU y el resto de recursos del sistema, como por ejemplo: memoria, archivos o dispositivos de E/S abiertos.</p>
</li>
<li>
<p>Un <strong>proceso</strong> es un programa en ejecución.
Un programa se convierte en proceso cuando las instrucciones del programa son cargadas en la memoria desde el archivo del ejecutable y se le asignan recursos para su ejecución.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Los procesos son entidades activas que necesita recursos —CPU, memoria, archivos, dispositivos E/S—.
Algunos de esos recursos se asignan durante su creación, mientras que otros son solicitados por el proceso durante su ejecución —por ejemplo la memoria, de la que todo proceso necesita cierta cantidad para comenzar pero que luego puede pedir más dinámicamente durante su ejecución—.
Cuando el proceso termina el sistema operativo reclama de estos recursos aquellos que sean reutilizables para otros procesos.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Un <strong>programa</strong> no es un proceso, es una entidad pasiva.
Es el contenido de un archivo en disco con las instrucciones que algún día una CPU ejecutará.
Un programa no puede hacer ningún tipo de trabajo a menos que sus instrucciones sean ejecutadas por una CPU, pero si eso ocurre, ya no sería un programa sino un proceso.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Aunque varios procesos estén asociados al mismo programa no pueden ser considerados el mismo proceso.
La CPU ejecuta las instrucciones de cada proceso una detrás de otra, de manera que para conocer la siguiente instrucción a ejecutar cada proceso tiene un contador de programa que se lo indica a la CPU, así como valores en los registros de la CPU que dependen de la historia pasada del proceso.
Aunque varios procesos ejecuten el mismo programa, la secuencia de instrucciones ejecutadas y el estado del proceso en cada momento seguramente sean diferentes.
Por lo tanto, no son el mismo proceso.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Por el momento estamos considerando que <strong>proceso</strong> y <strong>trabajo</strong> hacen referencia al mismo concepto porque en los sistemas más antiguos (véase el <a href="#_mainframe">Apartado 2.1</a>) la unidad de trabajo se llamaba <strong>trabajo</strong> mientras que en los sistemas modernos se llama <strong>proceso</strong>, de tal forma que podemos considerar al segundo una evolución del primero.</p>
</div>
<div class="paragraph">
<p>Sin embargo, mirándolo exclusivamente desde la perspectiva de los sistemas operativos modernos, son dos conceptos diferentes aunque relacionados.
En un sistema moderno un trabajo puede ser realizado por un solo proceso o mediante la colaboración de varios.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_responsabilidades_de_la_gestión_de_procesos">4.1.1. Responsabilidades de la gestión de procesos</h4>
<div class="paragraph">
<p>El componente de gestión de procesos es el responsable de la siguientes actividades:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Crear y terminar procesos.</p>
</li>
<li>
<p>Suspender y reanudar los procesos.</p>
</li>
<li>
<p>Proporcionar mecanismos para la sincronización de procesos.</p>
</li>
<li>
<p>Proporcionar mecanismos para la comunicación entre procesos.</p>
</li>
<li>
<p>Proporcionar mecanismos para el tratamiento de interbloqueos.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gestión_de_la_memoria_principal">4.2. Gestión de la memoria principal</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>La memoria principal es un recurso fundamental para las operaciones de cualquier sistema operativo moderno.
Esto es así porque generalmente es el único almacenamiento al que la CPU tiene acceso directo.
Para que un programa pueda ser ejecutado debe ser copiado a la memoria principal.
Y para que un proceso tenga acceso a datos almacenados en cualquier otro dispositivo de almacenamiento, primero deben ser copiados a la memoria principal.</p>
</div>
<div class="paragraph">
<p>Para mejorar el aprovechamiento de la CPU y la respuesta al usuario es necesario tener en la memoria varios programas al mismo tiempo.
Puesto que dichos programas deben compartir la memoria durante su ejecución, automáticamente existe la necesidad de que el sistema operativo disponga de un componente de gestión de la memoria principal.</p>
</div>
<div class="sect3">
<h4 id="_responsabilidad_de_la_gestión_de_la_memoria">4.2.1. Responsabilidad de la gestión de la memoria</h4>
<div class="paragraph">
<p>El componente de gestión de la memoria debe asumir las siguientes responsabilidades:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Controlar qué partes de la memoria están actualmente en uso y cuáles no.</p>
</li>
<li>
<p>Decidir que procesos —o partes de procesos— añadir o extraer de la memoria cuando hay o falta espacio en la misma.</p>
</li>
<li>
<p>Asignar y liberar espacio de la memoria principal según sea necesario.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gestión_del_sistema_de_es">4.3. Gestión del sistema de E/S</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El <strong>sistema de E/S</strong> hace de interfaz con el hardware, oculta las peculiaridades del hardware al resto del sistema.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>El sistema de E/S consta de:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Un componente de gestión de memoria especializado en E/S</strong>, con soporte para servicios de <em>buffering</em>, <em>caching</em> y <em>spooling</em>.
Estos servicios son utilizados por el resto del sistema de E/S.</p>
</li>
<li>
<p><strong>Una interfaz genérica de acceso a los controladores de dispositivo</strong>.
Cada dispositivo es diferente, pero los procesos y el resto de componentes del sistema no deben tener necesidad de conocer sus particularidades a la hora de acceder a ellos.
Es decir, para acceder a cualquier disco duro el sistema ofrece una misma interfaz, impedientemente de su marca y modelo.
Y lo mismo ocurre con las tarjetas de sonido o con los dispositivos de entrada, como teclados y ratones.
Así los programadores pueden acceder a cualquier dispositivo abstrayendo de las particularidades concretas del hardware instalado en cada ordenador.</p>
</li>
<li>
<p><strong>Controladores de dispositivo</strong>, que generalmente son desarrollados por los fabricantes de los dispositivos y son el componente que realmente conoce las peculiaridades específicas del dispositivo.
Por tanto, las peticiones que hacen los procesos a la interfaz de E/S genérica la traslada el sistema a los controladores de dispositivo para que éstos las conviertan en acciones concretas sobre el hardware del dispositivo.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Una característica de los sistemas UNIX es que todos los dispositivos de E/S se representa como un archivo en el sistema de archivos.
Esto se puede comprobar rápidamente visitando el directorio <code>/dev</code> en cualquier sistema GNU/Linux o UNIX BSD, ya que es allí donde suelen estar.</p>
</div>
<div class="paragraph">
<p>Así no hace falta diseñar y aprender una interfaz diferente para cada tipo de dispositivo.
Los procesos que quiere utilizar cualquier dispositivo de E/S solo tienen que usar las mismas funciones y llamadas al sistema que emplean para manipular los archivos normales.
Por ejemplo, <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a>, <a href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a>, <a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a> o <a href="https://man7.org/linux/man-pages/man2/close.2.html">close()</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_buffering">4.3.1. Buffering</h4>
<div class="paragraph">
<p>El <strong>buffering</strong> o uso de memoria intermedia es una estrategia en la que se almacenan los datos de manera temporal en una zona de la memoria, llamada búfer.</p>
</div>
<div class="paragraph">
<p>Consiste en que el controlador indica a un dispositivo que escriba los bloques de datos solicitados en un búfer.
Cuando la escritura del búfer se ha completado, se transfiere su contenido al proceso que hizo la solicitud para que procese los datos.
Mientras lo hace, el controlador indica al dispositivo que copie nuevos datos en el búfer.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, al grabar sonido del dispositivo de sonido del sistema no se entregan las muestras una a una al proceso.
En su lugar se graban varios miles de muestras que se escriben en un búfer.
Cuando el búfer está lleno, se transfieren todas las muestras al proceso de una sola vez y se siguen grabando muestras en el búfer.</p>
</div>
<div class="paragraph">
<p>Lo mismo ocurre al reproducir sonido.
El proceso no entrega las muestras de sonido de una en una al dispositivo, sino que empaqueta varias miles que se copian al búfer de una sola vez.
Entonces el controlador indica al dispositivo que lea las muestras desde ese búfer según lo vaya necesitando.</p>
</div>
</div>
<div class="sect3">
<h4 id="_caching">4.3.2. Caching</h4>
<div class="paragraph">
<p>En el <strong>caching</strong> el sistema mantiene en la memoria principal una copia de datos  leídos o escritos recientemente en los dispositivos de E/S del sistema —por ejemplo, en los discos duros o en las memorias USB—.
Esto mejora la eficiencia del sistema si accede con frecuencia a los mismos datos, puesto que el acceso a la memoria principal es más rápido que el acceso a los dispositivos de E/S.
La memoria principal es de tamaño limitado, por lo que sólo se mantiene copia de los datos utilizados con mayor frecuencia.</p>
</div>
</div>
<div class="sect3">
<h4 id="_spooling">4.3.3. Spooling</h4>
<div class="paragraph">
<p>El <strong>spooling</strong> se utiliza en dispositivos que no admiten el acceso simultáneo de varias aplicaciones a vez, como es el caso de impresoras y unidades de cinta.</p>
</div>
<div class="paragraph">
<p>Cuando varias aplicaciones intentan enviar un trabajo a una impresora, el sistema operativo lo intercepta para copiar los datos enviados a un archivo independiente.
Cuando una aplicación termina de enviar el trabajo, el archivo correspondiente se mete en una cola de donde son extraídos los trabajos para su impresión de uno en uno.
Así no hay acceso simultáneo al dispositivo por parte de varios procesos, mientras que éstos pueden entregar el trabajo y continuar con su trabajo sin esperar a que la impresora esté disponible.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gestión_del_almacenamiento_secundario">4.4. Gestión del almacenamiento secundario</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Dentro de los dispositivos de E/S, los dedicados al almacenamiento secundario —como discos duros, memorias USB o lectores de DVD-ROM— merecen un tratamiento especial.</p>
</div>
<div class="paragraph">
<p>Los programas que se desean ejecutar deben estar en la memoria principal —o almacenamiento primario— pero ésta es demasiado pequeña para alojar todos los datos y todos los programas del sistema.
Además, incluso aunque pudiera ser así, los datos almacenados en la memoria principal se perderían en caso de que ocurriera un fallo de alimentación.
Por eso los ordenadores disponen de un almacenamiento secundario para guardar datos de forma masiva y permanente.</p>
</div>
<div class="paragraph">
<p>El gestor del almacenamiento secundario utiliza el sistema de E/S para acceder a los dispositivos y ofrecer al sistema servicios más complejos.</p>
</div>
<div class="sect3">
<h4 id="_responsabilidades_de_la_gestión_del_almacenamiento_secundario">4.4.1. Responsabilidades de la gestión del almacenamiento secundario</h4>
<div class="paragraph">
<p>El gestor del almacenamiento secundario es el responsable de:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Gestionar el espacio libre en discos duros y resto de dispositivos de almacenamiento secundario.</p>
</li>
<li>
<p>Asignar el espacio de almacenamiento.</p>
</li>
<li>
<p>Planificar el acceso a los dispositivos, de tal forma que se ordenen las operaciones de forma eficiente.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gestión_del_sistema_de_archivos">4.5. Gestión del sistema de archivos</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Los ordenadores pueden almacenar información en diferentes tipos de medios físicos —por ejemplo en discos duros magnéticos, CD/DVD-ROM, memorias USB o SSD— cada uno de los cuales tiene características propias.
El acceso a cada tipo de medio es controlado por un dispositivo —por ejemplo el controlador de disco o la unidad de DVD-ROM— que también tiene características propias.
El sistema de E/S y la gestión del almacenamiento secundario simplifican el acceso a estos dispositivos, pero no lo suficiente como para que sea cómodo usarlos constantemente en cualquier programa.</p>
</div>
<div class="paragraph">
<p>Para simplificar aun más el acceso al almacenamiento, el sistema operativo proporciona una visión lógica uniforme de todos los sistemas de almacenamiento.
Es decir, abstrae las propiedades físicas de los dispositivos de almacenamiento para definir el <strong>archivo</strong>, una unidad de almacenamiento lógico con la que trabajan los procesos para guardar y recuperar datos.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Un <strong>archivo</strong> o <strong>fichero</strong> es una colección de datos relacionados, identificados por un nombre, que es tratada por el sistema operativo como una unidad de información en el almacenamiento secundario —por ejemplo un programa, una imagen o un documento—.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Los archivos normalmente se organizan en directorios para facilitar su uso y organización.</p>
</div>
<div class="sect3">
<h4 id="_responsabilidades_de_la_gestión_del_sistema_de_archivos">4.5.1. Responsabilidades de la gestión del sistema de archivos</h4>
<div class="paragraph">
<p>El sistema de archivos utiliza al gestor del almacenamiento secundario y al sistema de E/S y es responsable de las siguientes actividades:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Crear y borrar archivos.</p>
</li>
<li>
<p>Crear y borrar directorios para organizar los archivos.</p>
</li>
<li>
<p>Soportar operaciones básicas para la manipulación de archivos y directorios: lectura y escritura de datos, cambio de nombre, cambio de permisos, etc.</p>
</li>
<li>
<p>Mapear en memoria archivos del almacenamiento secundario.</p>
</li>
<li>
<p>Hacer copias de seguridad de los archivos en sistemas de almacenamiento estables y seguros.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gestión_de_red">4.6. Gestión de red</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El componente de red se responsabiliza de la comunicación con otros sistemas interconectados mediante una red de ordenadores —por ejemplo, en Internet o en la red de área local de una oficina—.</p>
</div>
</div>
<div class="sect2">
<h3 id="_protección_y_seguridad">4.7. Protección y seguridad</h3>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><strong>Protección</strong> es cualquier mecanismo para controlar el acceso de los procesos y usuarios a los recursos definidos por el sistema.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Son mecanismos necesarios cuando un sistema informático tiene múltiples usuarios y permite la ejecución concurrente de varios procesos, pues así sólo pueden utilizar los recursos aquellos procesos que hayan obtenido la autorización del sistema operativo.</p>
</li>
<li>
<p>Permite mejorar la fiabilidad, al permitir detectar los elementos del sistema que no operan correctamente.
Un recurso desprotegido no puede defenderse contra el uso —o mal uso— de un usuario no autorizado o incompetente.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Ejemplos típicos de mecanismos de protección son el hardware de direccionamiento de memoria, que se utiliza para que los procesos se ejecuten en su propio espacio de direcciones, y el temporizador, que garantiza que ningún proceso toma el control de la CPU por tiempo indefinido.
Además, los registros de los dispositivos de E/S suelen estar protegidos del acceso directo de los usuarios, lo que protege la integridad de los dispositivos.
Mientras que en algunos sistemas se pueden establecer permisos sobre los archivos para garantizar que sólo los procesos con la debida autorización tengan acceso.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Un sistema puede tener la protección adecuada pero estar expuesto a fallos y permitir accesos inapropiados.
Por eso es necesario disponer de mecanismos de <strong>seguridad</strong> que se encarguen de defender el sistema frente a ataques internos y externos.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Eso incluye a virus y gusanos, ataques de <a href="https://es.wikipedia.org/wiki/Ataque_de_denegaci%C3%B3n_de_servicio">denegación de servicio</a>, robo de identidad y uso no autorizado del sistema, entre muchos otros tipos de ataque.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_servicios_del_sistema">5. Servicios del sistema</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>5 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Un sistema operativo proporciona un entorno para la ejecución de programas.
Ese entorno debe proporcionar ciertos servicios a los programas y a los usuarios de esos programas.
Estos servicios son proporcionados gracias al funcionamiento coordinado de los diferentes componentes del sistema.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="C05-servicios/media/organización_sistema.svg" alt="organización sistema">
</div>
<div class="title">Figura 17. Diagrama general de organización de los sistemas operativos.</div>
</div>
<div class="paragraph">
<p>Aunque cada sistema operativo proporciona servicios diferentes, es posible identificar unas pocas clases comunes.</p>
</div>
<div class="sect2">
<h3 id="_servicios_que_garantizan_el_funcionamiento_eficiente_del_sistema">5.1. Servicios que garantizan el funcionamiento eficiente del sistema</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Asignación de recursos</strong>.
Cuando hay múltiples usuarios o múltiples trabajos ejecutándose los recursos deben ser asignados a cada uno de ellos.</p>
<div class="paragraph">
<p>Ejemplos de estos recursos son la CPU —asignada por el planificador de la CPU del gestor de procesos— la memoria principal —asignada por el gestor de memoria— y el almacenamiento de archivos —asignada por el sistema de archivos y el gestor del almacenamiento secundario—.
Esta asignación debe hacerse con el fin de garantizar la máxima eficacia del sistema.</p>
</div>
</li>
<li>
<p><strong>Monitorización</strong>.
Es normal querer hacer seguimiento de los recursos que los usuarios usan y en qué cantidad.
Esto puede ser útil para facturar a los usuarios por el uso de los recursos —por ejemplo, facturar por el tiempo de CPU— para configurar el sistema mejorando el rendimiento o para limitar cuánto de cada recurso puede usar cada usuario como máximo.</p>
</li>
<li>
<p><strong>Protección y seguridad</strong>.
Protección implica asegurar que el acceso a los recursos del sistema
está controlado.
Por ejemplo, que la información almacenada en un sistema multiusuario sólo puede ser accedida por su propietario o que un proceso no pueda interferir con otro o con el sistema operativo.
La seguridad del sistema respecto a los agentes exteriores también es
importante.
Empieza obligando a los usuarios a autenticarse en él para obtener acceso a los recursos del mismo, pero incluye defender de intentos de acceso inválidos a través de la red.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_servicios_útiles_para_el_usuario">5.2. Servicios útiles para el usuario</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Interfaz de usuario</strong>. Los sistemas operativos diseñados para que los usuarios interactúen con ellos deben proporcionar una interfaz de usuario adecuada, que puede ser diferente formas según le propósito del sistema.</p>
</li>
<li>
<p><strong>Operaciones de E/S</strong>. Un programa puede necesitar realizar operaciones de E/S que pueden
involucrar a archivos o a dispositivos de E/S.
Por eficiencia y protección un usuario, normalmente los procesos no puede tener acceso directo a los dispositivos; por lo que el sistema operativo debe proporcionar medios para solicitar estas operaciones a los componentes correspondientes del sistema operativo.</p>
</li>
<li>
<p><strong>Manipulación de sistemas de archivos</strong>. Los programas necesitan leer y escribir archivos y
directorios, crearlos y borrarlos por nombre, buscar un archivo dado y listar información
acerca del mismo.</p>
</li>
<li>
<p><strong>Comunicaciones</strong>. Los procesos necesitan poder intercambiar información entre ellos, tanto si
se ejecutan en el mismo ordenador, como en diferentes equipos unidos por una red.</p>
</li>
<li>
<p><strong>Detección de errores</strong>. El sistema operativo necesita tener conocimiento de los posibles errores y para cada tipo de error debe tomar la acción apropiada para asegurar una computación consiste y segura.
Por ejemplo, pueden haber errores del hardware —como fallos de energía o errores en la
memoria— en la E/S —como errores de paridad o falta de papel en la impresora— y en los
programas de usuario —como desbordamientos aritméticos o accesos ilegales a la memoria—.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_interfaz_de_usuario">5.3. Interfaz de usuario</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>La <strong>interfaz de usuario</strong> es un servicio fundamental para todos los sistemas diseñados para que los usuarios interactúen con ellos directamente, por lo que nos vamos a detener un poco más en él.</p>
</div>
<div class="paragraph">
<p>Las interfaces de usuario pueden ser de diferentes tipos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Interfaz de línea de comandos</strong> o <strong>intérprete de comandos</strong>, que permite que los usuarios introduzcan directamente los comandos que el sistema operativo debe ejecutar.
En algunos sistemas este tipo de interfaz se incluye dentro del núcleo, pero en la mayor parte —como MS-DOS y UNIX— se trata de un programa especial denominado <em>shell</em> que se ejecuta cuando un usuario inicia una sesión.</p>
</li>
<li>
<p><strong>Interfaz de proceso por lotes</strong>, en la que los comandos y directivas para controlar dichos comandos se listan en archivos que posteriormente pueden ser ejecutados.
Este tipo de interfaz es la utilizada en sistemas no interactivos, como los antiguos sistemas de procesamiento por lotes y los sistemas multiprogramados.</p>
<div class="paragraph">
<p>También suele estar disponible en los sistemas de tiempo compartido y en los sistemas de escritorio modernos, junto con algún otro tipo de interfaz de usuario.
Por ejemplo, la <em>shell</em> de los sistemas UNIX permite indicar comandos uno a uno —de forma interactiva— pero también permite usar <em>scripts</em> —un archivo con una lista de órdenes para que se ejecuten automáticamente de principio a fin—.</p>
</div>
</li>
<li>
<p><strong>Interfaz gráfica de usuario</strong> o <strong>GUI</strong> (<em>Graphical User Interface</em>) que permite a los usuarios utilizar un sistema de ventanas y menús controlable mediante el ratón.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Puesto que la interfaz de usuario puede variar de un sistema a otro, y de un usuario a otro dentro del mismo sistema, no se suele etiquetar como un componente básico del sistema operativo, sino como un servicio ofrecido por el sistema operativo.</p>
</div>
<div class="paragraph">
<p>A parte de la interfaz de usuario, cualquier sistema operativo moderno incluye una colección de <strong>programas del sistema</strong>.
El papel de estos programas del sistema es proporcionar un entorno conveniente para la ejecución y desarrollo de programas.
Entre los programas del sistema se suelen incluir aplicaciones para manipular archivos y directorios, programas para obtener información sobre el estado del sistema —como la fecha y hora o la memoria y el espacio en disco disponible— herramientas de desarrollo —como intérpretes, compiladores, enlazadores y depuradores— programas de comunicaciones —como clientes de correo electrónico y navegadores web— etc.</p>
</div>
<div class="paragraph">
<p>Además, muchos sistemas operativos disponen de programas que son útiles para resolver los problemas más comunes de los usuarios.
Entre estos programas se suelen incluir: editores de archivos de texto y procesadores de texto, hojas de cálculo, sistemas de base de datos, juegos, etc.
Ha esta colección de aplicaciones se la suele conocer con el término de <strong>utilidades del sistema</strong> o <strong>programas de aplicación</strong>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_interfaz_de_programación_de_aplicaciones">6. Interfaz de programación de aplicaciones</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>15 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Un sistema operativo proporciona un entorno controlado para la ejecución de programas.
Dicho entorno debe proporcionar ciertos servicios que pueden ser accedidos por los programas a través de una <strong>interfaz de programación de aplicaciones</strong> o <strong>API</strong> (<em>Application Programming Interface</em>).</p>
</div>
<div class="sect2">
<h3 id="_interfaces_de_programación_de_aplicaciones">6.1. Interfaces de programación de aplicaciones</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Algunas de las API disponibles para los desarrolladores de aplicaciones son Windows API y POSIX.</p>
</div>
<div class="sect3">
<h4 id="_windows_api">6.1.1. Windows API</h4>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/Win32_API">Windows API</a> es el nombre que recibe la <strong>interfaz de programación de aplicaciones</strong> de Microsoft Windows, con la que prácticamente tienen que interactuar todas las aplicaciones, de una forma u otra.</p>
</div>
<div class="paragraph">
<p>Antiguamente se denominaba Win32 API, pero Microsoft ha querido aglutinar bajo una misma denominación las distintas versiones de la API de Windows que han existido, como Win16 —usada en las versiones de 16 bits de Windows— o Win64 —que es la variante de Win32 adaptada a arquitecturas de 64 bits—.</p>
</div>
<div class="paragraph">
<p>Está compuesta por funciones en C almacenadas, principalmente, en las librerías de enlace dinámico (<a href="https://es.wikipedia.org/wiki/Biblioteca_de_enlace_din%C3%A1mico">DLL</a>): <code>kernel32.dll</code>, <code>user32.dll</code> y <code>gdi32.dll</code>.
Aunque según se ha ido ampliando la API, se han incorporado otras librerías adicionales.</p>
</div>
<div class="paragraph">
<p>Provee un conjunto muy amplio de servicios: E/S a archivos y dispositivos, gestión de procesos, hilos y memoria, manejo de errores, registro de Windows, interfaz a dispositivos gráficos —pantallas e impresoras— gestión de ventanas, comunicaciones en red, etc.</p>
</div>
</div>
<div class="sect3">
<h4 id="_posix">6.1.2. POSIX</h4>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/POSIX">POSIX</a> (<em>Portable Operating System Interface for Unix</em>) es el nombre de una familia de estándares que definen una <strong>interfaz de programación de aplicaciones</strong> para sistemas operativos.
Esto permite que un mismo programa pueda ser ejecutado en distintos sistemas operativos, siempre que sean compatibles con POSIX.</p>
</div>
<div class="paragraph">
<p>El lenguaje C fue diseñado originalmente para implementar sistemas UNIX y por eso la librería estándar de C tenía mucho parecido con la librería del sistema de UNIX.
Con el tiempo, al ir añadiendo más funcionalidades, la librería del sistema de los sistemas UNIX de los distintos fabricantes fue divergiendo, haciendo muy complicado desarrollar programas que usaran las características más avanzadas y que a la vez pudieran ejecutarse en varios de ellos.
Por eso el <a href="https://es.wikipedia.org/wiki/Institute_of_Electrical_and_Electronics_Engineers">IEEE</a> desarrollo el estándar POSIX, que define una API común para todos los UNIX y sistemas estilo UNIX modernos —como es el caso de GNU/Linux—.
Así que la práctica totalidad de estos sistemas son compatible POSIX.</p>
</div>
<div class="paragraph">
<p>Por su origen, la API POSIX es un superconjunto de la API de la librería estándar de C.
Por eso en los sistemas POSIX, la librería estándar de C es parte de la librería del sistema, en lugar de dos librerías separadas.</p>
</div>
<div class="paragraph">
<p>Las funciones POSIX están almacenadas, principalmente, en la librería <code>libc</code>.
Aunque algunas características pueden estar en otras librerías, como <code>libm</code> —la librería matemática— o <code>libpthread</code> —la librería de hilos—.</p>
</div>
<div class="paragraph">
<p>Los desarrolladores del sistema a veces añaden funciones no incluidas en el estándar POSIX, con el objeto de soportar algún tipo de funcionalidad avanzada del sistema.
Antes de usarlas debemos tener presente que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Un programa que solo utilice la API POSIX podrá ejecutarse en cualquier sistema operativo compatible POSIX.</p>
</li>
<li>
<p>Mientras que uno que utilice, por ejemplo, alguna funcionalidad adicional no POSIX de Linux o macOS, solo podrá compilarse y ejecutarse en Linux o en macOS, según el caso.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_llamadas_al_sistema">6.2. Llamadas al sistema</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Para un programa, acceder a los servicios del sistema operativo no es tan sencillo como invocar una función.
Para invocar una función, un programa necesita conocer la dirección en la memoria del punto de entrada de dicha función —es decir, la ubicación de su primera instrucción—.
Sin embargo, el código del núcleo del sistema puede estar en cualquier ubicación de la memoria principal.
Así que las direcciones de los puntos de entrada a las funciones del núcleo son desconocidas.
Además, generalmente, el código y los datos del núcleo están protegidos frente a accesos indebidos (véase el <a href="#_protección_de_la_memoria">Apartado 7.3</a>).
Eso significa que para que un proceso pueda invocar los servicios que necesita hace falta un procedimiento diferente, denominado <strong>llamada al sistema</strong>.</p>
</div>
<div class="sect3">
<h4 id="_invocar_llamadas_al_sistema">6.2.1. Invocar llamadas al sistema</h4>
<div class="paragraph">
<p>Generalmente una llamada al sistema se invoca mediante una instrucción específica en lenguaje ensamblador que genera una <strong>excepción</strong> —que no es más que una interrupción lanzada por la propia CPU al detectar instrucciones especiales o un error al ejecutar una instrucción, como una división por 0 o un acceso indebido a ciertas zonas de la memoria—.
Por ejemplo, en MIPS e Intel x86 se usa la instrucción <code>syscall</code>, que lanza un excepción, haciendo que la CPU salte a una rutina en el código del núcleo del sistema, deteniendo así la ejecución del proceso que la invocó.</p>
</div>
<div class="paragraph">
<p>Al realizar una llamada, es necesario que el sistema sepa qué operación le está pidiendo el proceso.
Esto se suele hacer poniendo un número identificativo de la llamada en un registro concreto de la CPU.
Por ejemplo, en Linux para x86 la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a> —que se utiliza para abrir archivos— se identifica con el número 2 o con el 5, según si es en 64 o en 32 bits, respectivamente.
Este número se debe guardar en el registro <code>v0</code> en MIPS o <code>eax</code> en x86, antes de la instrucción <code>syscall</code>.</p>
</div>
<div class="paragraph">
<p>Los números utilizados para identificar cada llamada al sistema dependen del sistema operativo.
Mientras que el registro donde se guarda, la instrucción utilizada y el resto de detalles sobre cómo realizar la llamada, dependen también de la arquitectura de la CPU.</p>
</div>
</div>
<div class="sect3">
<h4 id="_paso_de_argumentos">6.2.2. Paso de argumentos</h4>
<div class="paragraph">
<p>Obviamente una llamada al sistema suele requerir más información que la identidad de la llamada.
Si, por ejemplo, se quiere abrir un archivo, al menos es necesario indicar su nombre, así como si se abre para leer o para escribir.</p>
</div>
<div class="paragraph">
<p>En concreto hay tres métodos para pasar parámetros adicionales al identificador a una llamada al sistema:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Mediante registros de la CPU</strong>.
Consiste en cargar los parámetros de la llamada al sistema en los registros de la CPU antes de realizar la llamada al sistema.
Este método es el más eficiente, pero limita el número de parámetros al número de registros disponibles.</p>
<div class="paragraph">
<p>Es utilizado, por ejemplo, en Linux para MIPS (véase el <a href="#linux_mips_syscall">Ejemplo 1</a>) y en la mayoría de sistemas operativos para x86-64.</p>
</div>
</li>
<li>
<p><strong>Mediante tabla en memoria</strong>
Consiste en copiar los parámetros de la llamada al sistema en una tabla en la memoria principal y luego guardar la dirección de dicha tabla en un registro específico de la CPU, antes de la llamada al sistema.
Así no se limita el número de parámetros que pueden ser pasados en cada llamada al sistema.</p>
<div class="paragraph">
<p>Era utilizado por Microsoft Windows 2000 y anteriores.
También en Linux para x86 32 bits, cuando el número de parámetros es superior a 6.</p>
</div>
</li>
<li>
<p><strong>Mediante la pila del proceso</strong> se insertan los parámetros de la llamada al sistema en la pila del proceso —que también se suele usar para guardar variables locales y, en algunas arquitecturas, los argumentos pasados al llamar a funciones— y el sistema operativo los recupera de allí durante la llamada al sistema.
Al igual que en el caso anterior, tampoco limita el número de parámetros que pueden ser pasados en cada llamada al sistema.</p>
<div class="paragraph">
<p>Es utilizado, por ejemplo, en sistemas UNIX BSD y en Windows XP y posteriores para x86 de 32 bits.</p>
</div>
</li>
</ul>
</div>
<div id="linux_mips_syscall" class="exampleblock">
<div class="title">Ejemplo 1. Llamada al sistema en Linux MIPS.</div>
<div class="content">
<div class="paragraph">
<p>Veamos como invocar directamente la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a> en Linux para MIPS.</p>
</div>
<div class="paragraph">
<p>Esta llamada sirve para escribir datos en un archivo.
Así que necesita tres argumentos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>SIZE</strong>: El número de bytes a escribir.</p>
</li>
<li>
<p><strong>BUFFER</strong>: La dirección de la memoria de la que coger los bytes.</p>
</li>
<li>
<p><strong>FILEDES</strong>: El descriptor que identifica a un archivo abierto donde se van a escribir los datos.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Al terminar devuelve el número de bytes escritos en el archivo, que puede ser inferior a <code>SIZE</code>.</p>
</div>
<div class="paragraph">
<p>El identificador de la llamada al sistema es 4004, según el <a href="https://git.linux-mips.org/cgit/ralf/linux.git/tree/arch/mips/include/uapi/asm/unistd.h">listado de llamadas al sistema</a> para Linux en MIPS.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>  lw      $a0, FILEDES   <i class="conum" data-value="1"></i><b>(1)</b>
  la      $a1, BUFFER    <i class="conum" data-value="1"></i><b>(1)</b>
  lw      $a2, SIZE      <i class="conum" data-value="1"></i><b>(1)</b>
  li      $v0, 40004     <i class="conum" data-value="2"></i><b>(2)</b>
  syscall                <i class="conum" data-value="3"></i><b>(3)</b> <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Cargar cada uno de los 3 argumentos de la llamada al sistema en los registros <code>a0</code>, <code>a1</code> y <code>a2</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Cargar el identificador de la llamada <code>write()</code> en el registro <code>v0</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Invocar la llamada al sistema.
Aunque vemos que es una única instrucción, lo que realmente va a ocurrir es que el sistema operativo va a tomar el control de la CPU para realizar la tarea solicitada.
La siguiente instrucción no comenzará a ejecutarse hasta que el sistema operativo no lo decida, por lo que, desde el punto de vista del programa, va a ser como si <code>syscall</code> fuera una instrucción más lenta de lo normal.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Al ejecutar la siguiente instrucción del código del programa, el registro <code>v0</code> contendrá el número de bytes escritos.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap06/syscall.s">syscalls.s</a> se puede ver un ejemplo completo similar, pero para Linux x86 de 64 bits.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>En cualquier caso, sea cual sea el método utilizado, el sistema operativo es responsable de comprobar de manera estricta la validez de los parámetros enviados en la llamada al sistema antes de realizar cualquier operación, puesto que nunca debe confiar en que los procesos hagan su trabajo correctamente.
A fin de cuentas, una de las funciones del sistema operativo es el control de dichos procesos.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_librería_del_sistema">6.3. Librería del sistema</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Las <strong>llamadas al sistema</strong> proporcionan una interfaz con la que los procesos pueden invocar los servicios que el sistema operativo ofrece.
El problema es que como se hacen mediante instrucciones en lenguaje ensamblador (véase el <a href="#linux_mips_syscall">Ejemplo 1</a>) no son demasiado cómodas de utilizar.
Así que generalmente los programas no las invocan directamente.
En su lugar, lo que hacen es llamar a funciones de la <strong>librería del sistema</strong>, que a su vez son las encargadas de hacer las llamadas al sistema necesarias.</p>
</div>
<div class="paragraph">
<p>Cuando hablamos anteriormente de <a href="https://es.wikipedia.org/wiki/Win32_API">Windows API</a> y del estándar <a href="https://es.wikipedia.org/wiki/POSIX">POSIX</a>, hablábamos de la interfaz de la <strong>librería del sistema</strong> en esos sistemas operativos.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>La <strong>librería del sistema</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Es parte del sistema operativo, por lo que se distribuye con él.</p>
</li>
<li>
<p>Es una colección de clases o funciones que ofrecen los servicios del sistema operativo a los programas, apoyándose en las llamadas al sistema.</p>
<div class="paragraph">
<p>Algunas funciones de la librería del sistema son traducciones literales de llamadas al sistema —por ejemplo, <a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a> o <a href="https://man7.org/linux/man-pages/man2/close.2.html">close()</a>— mientras que otras pueden ser más complejas, hacer más trabajo o mostrar conceptos más abstractos que los usados por el sistema operativo al nivel de llamadas al sistema.</p>
</div>
</li>
<li>
<p>Constituye la verdadera <strong>interfaz de programación de aplicaciones</strong> del sistema operativo.
Es la forma recomendada de solicitar servicios al sistema operativo.
Invocar directamente las llamadas al sistema debe ser el último recurso.</p>
</li>
<li>
<p>Sus funciones se llaman como cualquier otra.
Al igual que el resto de librerías, se carga dentro de la región de memoria asignada al proceso.
Por lo tanto, la invocación de las funciones de la librería del sistema se realiza como si fueran cualquier otra función del programa.</p>
</li>
<li>
<p>Es muy común que esté implementada en C, lo que permite que tanto los programas en C como en C&#43;&#43; la puedan utilizar directamente.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_librería_estándar">6.4. Librería estándar</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Lenguajes distintos de C y C&#43;&#43; pueden tener difícil usar las funciones de la librería del sistema.
Pero de alguna forma deben poder hacerlo, porque sus programadores necesitan acceso a los servicios que ofrece el sistema operativo.</p>
</div>
<div class="paragraph">
<p>Incluso en C y en C&#43;&#43; puede ser interesante tener acceso a funcionalidades adicionales a las ofrecidas por la API del sistema operativo: estructuras de datos, algoritmos de ordenamiento o búsqueda, funciones para manipular cadenas, funciones matemáticas, etc.
También abstracciones de los servicios del sistema, que encajen mejor con las particularidades del lenguaje de programación en cuestión.
Por ejemplo, utilizando clases y objetos en lenguajes que soportan programación orientada a objetos.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Por eso, junto a cada intérprete o compilador de cada lenguaje de programación suele ir una <strong>librería estándar</strong> que ofrece clases o funciones con las que los programas pueden acceder a los servicios del sistema operativo y realizar las tareas más comunes de forma más sencilla.</p>
</div>
<div class="paragraph">
<p>Estas librerías generalmente no forman parte del sistema operativo, sino de las herramientas de desarrollo de cada lenguaje de programación, y constituyen la <strong>interfaz de programación de aplicaciones</strong> del lenguaje al que acompañan.</p>
</div>
<div class="paragraph">
<p>La <strong>librería estándar</strong> necesita acceder a los servicios del sistema operativo para, a su vez, dar servicio a los programas que la usan.
Es decir, cuando un programa invoca alguna función o método de la librería estándar que lo acompaña, es muy probable que ésta necesite invocar uno o más servicios del sistema operativo para atender la petición convenientemente.
Para ello la <strong>librería estándar</strong> utiliza la <strong>librería del sistema</strong> que acompaña al sistema operativo, que a su vez realiza las <strong>llamadas al sistema</strong> necesarias.</p>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">De archivos a flujos</div>
<div class="paragraph">
<p>Un ejemplo del papel de las <strong>librerías estándar</strong> lo podemos encontrar en el acceso a los archivos.</p>
</div>
<div class="paragraph">
<p>Las llamadas al sistema y la librería del sistema de los sistemas operativos ofrecen funciones básicas para manipular archivos.
Los archivos se abren indicando su ruta y, al hacerlo, el sistema operativo devuelve un identificador del archivo abierto (véase <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a>).
Este identificador se puede usar para leer o escribir en bytes el contenido del archivo.</p>
</div>
<div class="paragraph">
<p>Si embargo en C, C&#43;&#43; y otros lenguajes, todo lo que son flujos de datos se generalizan en el concepto de flujo o <em>stream</em> (véase <a href="https://en.cppreference.com/w/c/io">&lt;stdio.h&gt;</a> e <a href="https://en.cppreference.com/w/cpp/header/iostream">std::iostream</a>).
En él. se incluye la entrada de teclado y la salida por pantalla, la impresión de documentos, las conexiones de red —potencialmente— y, obviamente, el acceso a archivos y a dispositivos.</p>
</div>
<div class="paragraph">
<p>Los flujos pueden ser de texto o binarios, lo que implica algunas transformaciones en los datos.
Además van ligados al concepto del <em>buffering</em>, es decir, que los bytes o caracteres escritos en el flujo no se «envían» inmediatamente, sino que se acumulan en la memoria para ser enviados en bloque.</p>
</div>
<div class="paragraph">
<p>Todas estas características adicionales las implementa la <strong>librería estándar</strong>.
Pero por debajo, al final, los datos tiene que ser escritos en un archivo, una impresora o el monitor, recursos que gestiona el sistema operativo.
Por lo tanto, las <strong>librerías estándar</strong> necesitan hacer uso de la <strong>librería del sistema</strong> para comunicarse con el sistema operativo.</p>
</div>
<hr>
<div class="paragraph">
<p>Algo que suele ocurrir al crear mayores abstracciones es que se suele perder control y características específicas.
Por ejemplo, la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a> con la que se pueden crear archivos permite asignar permisos o crear archivos temporales.
Sin embargo, con las interfaces de <em>streams</em> de C y C&#43;&#43; no se puede hacer eso, ya que los permisos y la temporalidad son propiedades de los archivos que no son comunes a todas fuentes de flujos de datos.</p>
</div>
<div class="paragraph">
<p>Así que en ocasiones puede ser que nos resulte más útil llamar a las funciones de la <strong>librería del sistema</strong>, que usar las facilidades de la <strong>librería estándar</strong>.
Sin embargo, debemos valorar que así perdemos portabilidad, ya que ahora nuestro programa ya no podrá usarse allí donde haya un compilador o intérprete de nuestro lenguaje, sino solo en sistemas operativos con una <strong>librería del sistema</strong> compatible.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_con_todas_las_piezas_juntas">6.5. Con todas las piezas juntas</h3>
<div class="paragraph">
<p>En la <a href="#api_win32">Figura 18</a> se ilustra el papel de todos los elementos comentados, con el ejemplo de programas en C y Python, ejecutados en Microsoft Windows, que invocan los métodos <a href="https://en.cppreference.com/w/c/io/fopen">fopen()</a> y <code>file()</code> de la librería estándar de estos lenguajes, respectivamente.</p>
</div>
<div id="api_win32" class="imageblock">
<div class="content">
<img src="C06-api/media/interfaz_programación_aplicaciones_win32.svg" alt="interfaz programación aplicaciones win32">
</div>
<div class="title">Figura 18. Elementos de la interfaz de programación de aplicaciones en Microsoft Windows.</div>
</div>
<div class="paragraph">
<p>En ambos casos, la librería estándar llama a la función <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile()</a> de la librería del sistema de Windows, que finalmente realiza una llamada al sistema que hace que el sistema operativo tome el control, deteniendo la ejecución del proceso que la solicita.
Entonces se realiza la tarea solicitada mediante el funcionamiento coordinado de los diferentes componentes del sistema (véase el <a href="#_componentes_del_sistema">Capítulo 4</a>).</p>
</div>
<div class="paragraph">
<p>El programa en C, puede usar tanto la función <a href="https://en.cppreference.com/w/c/io/fopen">fopen()</a> de su librería estándar como llamar directamente a la función <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile()</a> de la librería del sistema —marcado en rojo en la <a href="#api_win32">Figura 18</a>—.
Sin embargo, en el programa en Python no tenemos esa facilidad —al menos directamente—.</p>
</div>
<div class="paragraph">
<p>Usar directamente las funciones de la librería del sistema desde programas en C o C&#43;&#43; tiene la ventaja de que permite utilizar todas las características del sistema operativo.
Por ejemplo, utilizar las opciones adicionales de <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile()</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">HANDLE</span> <span class="n">WINAPI</span> <span class="nf">CreateFile</span><span class="p">(</span>
  <span class="n">LPCTSTR</span> <span class="n">lpFileName</span><span class="p">,</span>                           <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="n">DWORD</span> <span class="n">dwDesiredAccess</span><span class="p">,</span>                        <i class="conum" data-value="2"></i><b>(2)</b>
  <span class="n">DWORD</span> <span class="n">dwShareMode</span><span class="p">,</span>                            <i class="conum" data-value="3"></i><b>(3)</b>
  <span class="n">LPSECURITY_ATTRIBUTES</span> <span class="n">lpSecurityAttributes</span><span class="p">,</span>   <i class="conum" data-value="4"></i><b>(4)</b>
  <span class="n">DWORD</span> <span class="n">dwCreationDisposition</span><span class="p">,</span>                  <i class="conum" data-value="5"></i><b>(5)</b>
  <span class="n">DWORD</span> <span class="n">dwFlagsAndAttributes</span><span class="p">,</span>                   <i class="conum" data-value="6"></i><b>(6)</b>
  <span class="n">HANDLE</span> <span class="n">hTemplateFile</span>                          <i class="conum" data-value="7"></i><b>(7)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Nombre del archivo.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Modo de acceso: lectura o escritura.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Modo en el que se compartirá el archivo con otros procesos que accedan al mismo tiempo.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Permisos del archivo, en caso de crearlo.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Acción en caso de que el archivo exista o no: siempre crear, solo abrir, truncar si existe, etc.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Atributos del archivo, en caso de crearlo.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Archivo abierto del que copiar los atributos para copiarlo en éste,
en caso de crearlo.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>que <a href="https://en.cppreference.com/w/c/io/fopen">fopen()</a> no posee:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">FILE</span><span class="o">*</span> <span class="nf">fopen</span><span class="p">(</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mode</span>  <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Nombre del archivo.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Modo de acceso: lectura o escritura.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Sin embargo, debemos tener en cuenta que se pierde portabilidad pues <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile()</a> solo está disponible en Microsoft Window, mientras que <a href="https://en.cppreference.com/w/c/io/fopen">fopen()</a> viene con la librería estándar de cualquier compilador de C.</p>
</div>
<div class="paragraph">
<p>En la <a href="#api_posix">Figura 19</a> se puede observar un ejemplo similar en <a href="https://es.wikipedia.org/wiki/GNU/Linux">GNU/Linux</a> —un sistema compatible <a href="https://es.wikipedia.org/wiki/POSIX">POSIX</a>— pero en esta ocasión con programas en C y C&#43;&#43;.
En este caso la llamada al sistema es <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a> y tanto <a href="https://en.cppreference.com/w/c/io/fopen">fopen()</a> en C como <a href="https://en.cppreference.com/w/cpp/io/basic_ofstream/open">std::ofstream::open()</a> en C&#43;&#43; la utilizan.
Además, ambos lenguajes pueden invocar directamente la librería del sistema —marcado en rojo en la <a href="#api_posix">Figura 19</a>— si necesitan alguna característica adicional de la función <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a>.</p>
</div>
<div id="api_posix" class="imageblock">
<div class="content">
<img src="C06-api/media/interfaz_programación_aplicaciones_posix.svg" alt="interfaz programación aplicaciones posix">
</div>
<div class="title">Figura 19. Elementos de la interfaz de programación de aplicaciones en GNU/Linux.</div>
</div>
<div class="paragraph">
<p>La única diferencia es que en <a href="#api_posix">Figura 19</a> las funciones <a href="https://en.cppreference.com/w/c/io/fopen">fopen()</a> y <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a> están realmente en la misma librería, porque en los sistemas POSIX la librería del sistema y la librería estándar de C pueden ser la misma, dado que el estándar POSIX se diseñó como un superconjunto de la librería estándar de C.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_operación_del_sistema_operativo">7. Operación del sistema operativo</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>17 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Dado que el sistema operativo y los procesos de usuarios comparten los recursos del sistema informático, necesitamos estar seguros de que un error en un programa sólo afecte al proceso que lo ejecuta —por ejemplo, que un proceso no puede modificar la memoria de otro proceso o la del núcleo del sistema—.
Por eso es necesario establecer mecanismos de protección frente a los errores en los programas que se ejecutan en el sistema.</p>
</div>
<div class="sect2">
<h3 id="_software_controlado_mediante_interrupciones">7.1. Software controlado mediante interrupciones</h3>
<div class="paragraph">
<p>Antes de entender como funcionan estos mecanismos de protección debemos entender que los sistemas operativos modernos pertenecen a un tipo de software que se dice que está controlado mediante interrupciones.</p>
</div>
<div class="paragraph">
<p>Los sucesos que requieren la atención del sistema casi siempre se indican mediante una interrupción:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cuando un proceso comete un error —como una división por cero o un acceso a memoria no válido— o un programa solicita un servicio al sistema operativo a través de una llamada al sistema lo que se genera es una excepción.
Esta excepción despierta al sistema operativo para que haga lo que sea más conveniente.</p>
</li>
<li>
<p>Cuando un proceso necesita un servicio lo que hace es lanzar una llamada al sistema, que no es más que ejecutar una instrucción que lanza una excepción.
Esta excepción despierta al sistema operativo para que atienda la petición.</p>
</li>
<li>
<p>Cuando los dispositivos de E/S requieren la atención del sistema operativo —por ejemplo, porque se ha completado una transferencia de datos— se genera una interrupción que despierta al sistema operativo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Esto funciona así porque el sistema operativo configura la CPU durante el arranque para que si ocurre cualquier interrupción o excepción la ejecución, salte a rutinas en el código del núcleo, con el objeto de darles el tratamiento adecuado.</p>
</div>
<div class="paragraph">
<p>Si ningún proceso realiza una acción ilegal o pide un servicio, ni ningún dispositivo de E/S pide la atención del sistema, el sistema operativo permanece inactivo esperado a que algo ocurra.</p>
</div>
<div class="paragraph">
<p>Teniendo todo esto en cuenta podremos entender mejor como funciona el modo dual.</p>
</div>
</div>
<div class="sect2">
<h3 id="_operación_en_modo_dual">7.2. Operación en modo dual</h3>
<div class="paragraph">
<p>Para proteger el sistema de programas con errores es necesario poder distinguir entre la ejecución de código del sistema operativo y del código de los programas de usuario, de tal forma que el código de los programas de usuario esté más limitado en lo que puede hacer que el del sistema operativo.</p>
</div>
<div class="paragraph">
<p>El método que utilizan la mayor parte de los sistemas operativos consiste en utilizar algún tipo de soporte en la CPU que permita diferenciar entre varios modos de ejecución y restringir la utilización de las instrucciones peligrosas —llamadas <strong>instrucciones privilegiadas</strong>— para que sólo puedan ser utilizadas en el modo en el que se ejecuta el código del sistema operativo.</p>
</div>
<div class="sect3">
<h4 id="_modos_de_operación">7.2.1. Modos de operación</h4>
<div class="paragraph">
<p>Así que como mínimo son necesarios dos modos de operación diferentes:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>En el <strong>modo usuario</strong>, en el que se ejecuta el código de los procesos de los usuarios.
Si se hace un intento de ejecutar una instrucción privilegiada en este modo, el hardware la trata como ilegal y genera una excepción que es interceptada por el sistema operativo, en lugar de ejecutar la instrucción.</p>
</li>
<li>
<p>En el <strong>modo privilegiado</strong> —también denominado <strong>modo supervisor</strong>, <strong>modo del sistema</strong> o <strong>modo kernel</strong>— se ejecuta el código de las tareas del sistema operativo.
La CPU es la encargada de garantizar que las instrucciones privilegiadas sólo pueden ser ejecutadas en este modo.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>El modo actual de operación puede venir indicado por un <strong>bit de modo</strong> en alguno de los registros de configuración de la CPU, de tal forma que, si por ejemplo, el bit está a 0, la CPU considera que el código en ejecución opera en modo privilegiado, mientras que si el bit está a 1, el código en ejecución opera en modo usuario.</p>
</div>
<div class="paragraph">
<p>Comúnmente en el grupo de las <strong>instrucciones privilegiadas</strong> se suelen incluir:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La instrucción para conmutar al modo usuario desde el modo privilegiado.</p>
</li>
<li>
<p>Las instrucciones para acceder a dispositivos de E/S.</p>
</li>
<li>
<p>Las instrucciones necesarias para la gestión de las interrupciones.
Por ejemplo, para desactivarlas —evitando que se lancen—, activarlas y configurarlas.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Niveles de privilegio en procesadores x86</div>
<div class="paragraph">
<p>Aunque para operar en modo dual solo se necesita que la CPU admita los dos modos descritos, existen procesadores que soportan más, con la idea de tener mayor control sobre el nivel de privilegio en el que se ejecuta cada componente del sistema.</p>
</div>
<div class="paragraph">
<p>Es el caso de la arquitectura Intel x86, que soporta 4 modos de operación.
El modo 0 es para el software más confiable y el que necesita más privilegios, que generalmente es el núcleo.
Mientras que el modo 3 se utiliza para el software menos confiable y que necesita más supervisión, que normalmente son los procesos de usuario.</p>
</div>
<div class="paragraph">
<p>La idea detrás de tener los modos 1 y 2 es usarlos para controladores de dispositivo o procesos que dan servicio al resto del sistema.
Así estos componentes pueden tener mayores privilegios que los procesos de usuario —por ejemplo, los controladores de dispositivo necesitan acceso directo al hardware— pero al mismo tiempo serían supervisados y no podrían afectar al núcleo, que se ejecuta en el modo 0.</p>
</div>
<div class="paragraph">
<p>Sin embargo, los sistemas operativos con mayor cuota de mercado —incluyendo Microsoft Windows, macOS, Linux y Android— solo utilizan los modos 0 y 3.
Los motivos son que los desarrolladores de sistemas no encuentran realmente ninguna ventaja en utilizar más modos y que complica portar el sistema operativo a procesadores donde solo se soporten dos.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
En procesadores x86 recientes, que vienen con instrucciones específicas para facilitar la ejecución de máquinas virtuales, se ha incorporado un modo -1, para que el núcleo del sistema operativo virtualizado se ejecute en el modo 0 mientras es supervisado desde el modo -1 por el núcleo del sistema operativo anfitrión.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Para más información, véase <a href="https://es.wikipedia.org/wiki/Anillo_(seguridad_inform%C3%A1tica)">«Anillo (seguridad informática)&#8201;&#8212;&#8201;Wikipedia»</a>.</p>
</div>
<hr>
<div class="paragraph">
<p>En los procesadores x86 es importante no confundir los <strong>modos real</strong> y <strong>protegido</strong> con el modo dual y los niveles de privilegio de los que estamos hablando.</p>
</div>
<div class="paragraph">
<p>Por compatibilidad hacia atrás, los procesadores x86 se inician en modo real, donde se comportan como una CPU <a href="https://es.wikipedia.org/wiki/Intel_8086_y_8088">Intel 8086</a>.
En este modo, por ejemplo, solo tienen acceso al primer mega de memoria RAM —ya que los procesadores <a href="https://es.wikipedia.org/wiki/Intel_8086_y_8088">Intel 8086</a> solo tenían 20 bits para direcciones de memoria—.</p>
</div>
<div class="paragraph">
<p>Cuando un sistema operativo moderno arranca, lo primero que hace es iniciar el modo protegido, en el que se activan todas las características de la CPU.
Entra otras, el direccionamiento de 32 o 64 bits —según el procesador que sea— y la posibilidad de usar los 4 niveles de privilegio, de los que hemos hablado, para que el núcleo pueda supervisar al resto de componentes.</p>
</div>
<div class="paragraph">
<p>Para más información, véase <a href="https://es.wikipedia.org/wiki/Modo_protegido">«Modo protegido&#8201;&#8212;&#8201;Wikipedia»</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ejecución_de_instrucciones">7.2.2. Ejecución de instrucciones</h4>
<div class="paragraph">
<p>A continuación podemos ver el ciclo de vida de la ejecución de instrucciones en un sistema con modo dual de operación:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Inicialmente, al arrancar el ordenador, la CPU se inicia en el modo privilegiado —es decir, en nuestro ejemplo, con el bit de modo a 0—.
En este modo se carga el núcleo del sistema operativo e inicia su ejecución.</p>
</li>
<li>
<p>El núcleo del sistema operativo debe cambiar al modo usuario —poniendo el bit de modo a 1— antes de ceder la CPU a un proceso de usuario.
Esto ocurre cuando es necesario que un proceso de usuario continúe o inicie su ejecución (véase el <a href="#_el_asignador">Apartado 14.2</a>).
Así se asegura que el código de los procesos de usuario siempre se ejecuten en modo usuario, con menos privilegios.</p>
</li>
<li>
<p>La CPU conmuta a modo privilegiado cuando ocurre una interrupción o una excepción —poniendo el bit de modo a 0— antes de comenzar el código del sistema operativo que se encargará de tratarlas.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>Esto último es muy importante.
Como ya hemos comentado, los sistemas operativos están controlados mediante interrupciones.
Al activarse el modo privilegiado cada vez que ocurre una interrupción, podemos estar seguros de que las tareas del sistema operativo se ejecutarán siempre en modo privilegiado.</p>
</div>
<div class="paragraph">
<p>Cuando se dispone de la protección del modo dual, el hardware se encarga de detectar los errores de ejecución y de notificarlo al sistema operativo mediante excepciones, siendo responsabilidad de este último realizar un tratamiento adecuado de los mismos.
Por lo general, si un programa falla de alguna forma —como por ejemplo, intentando utilizar una instrucción ilegal o de acceder a una zona de memoria inválida— el sistema operativo lo hace terminar.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_protección_de_la_memoria">7.3. Protección de la memoria</h3>
<div class="paragraph">
<p>La memoria principal debe acomodar tanto el sistema operativo como a los diferentes procesos de los usuarios.
Por eso la memoria normalmente se divide en dos partes o espacios:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>La primera parte es el <strong>espacio del núcleo</strong>.
Sirve para albergar el núcleo del sistema operativo.</p>
<div class="paragraph">
<p>El sistema operativo puede estar localizado tanto en la parte baja como en la parte alta de la memoria.
El factor determinante en la elección es la localización del vector de interrupciones, que es una tabla en la memoria que define las direcciones a las que saltará la CPU en caso de que ocurra una interrupción o una excepción.</p>
</div>
<div class="paragraph">
<p>Puesto que en la mayor parte de las arquitecturas éste reside en la parte baja de la memoria, normalmente el sistema operativo también se aloja en la parte baja.</p>
</div>
</li>
<li>
<p>La segunda parte es el <strong>espacio de usuario</strong> y alberga los procesos de usuario.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Sin embargo, en los sistemas operativos modernos, los procesos no tienen acceso libre a toda memoria física, con el objeto de proteger a los procesos en ejecución y al sistema operativo de posibles errores en cualquiera de ellos:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>El sistema operativo proporciona a cada proceso una «vista» privada de la memoria RAM; de tal forma que el <strong>espacio de usuario</strong> que ve cada proceso es similar al que vería cada uno de ellos si se estuviera ejecutando en solitario (véase la <a href="#protección_memoria">Figura 20</a>).</p>
</li>
<li>
<p>A esa «vista» que tiene cada proceso de la memoria es a lo que se denomina <strong>espacio de direcciones virtual</strong> del proceso.
Está formada por el conjunto de todas las direcciones que puede generar la CPU para un proceso dado.
Por ejemplo, en una CPU de 32 bits el espacio de direcciones virtual tiene 4 GiB, desde la dirección 0x00000000 a 0xFFFFFFFF.</p>
</li>
<li>
<p>En los accesos a la memoria principal durante la ejecución del proceso, estas <strong>direcciones virtuales</strong> son convertidas por la CPU en direcciones físicas, antes de ser enviadas a la memoria principal.
Por tanto las <strong>direcciones físicas</strong> son las direcciones reales que ve la memoria.
Mientras que el <strong>espacio de direcciones físico</strong> es el conjunto de direcciones físicas que corresponden a todas las direcciones virtuales de un espacio de direcciones virtual dado.</p>
</li>
</ul>
</div>
</div>
</div>
<div id="protección_memoria" class="imageblock">
<div class="content">
<img src="C07-modo_dual/media/protección_memoria.svg" alt="protección memoria">
</div>
<div class="title">Figura 20. Mapeo de la memoria física en el espacio de direcciones virtual de un proceso.</div>
</div>
<div class="paragraph">
<p>La conversión de una dirección virtual en una física, la realiza en tiempo de ejecución un componente de la CPU denominado MMU (<em>Memory-Management Unit</em>).</p>
</div>
<div class="paragraph">
<p>Las ventajas de usar esta técnica, desde el punto de vista de la protección de la memoria son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Permite el aislamiento de los procesos, creando para cada uno la ilusión de que toda la memoria es para él y evitando que un proceso pueda acceder a la memoria de otros procesos.</p>
</li>
<li>
<p>Permite marcar modos de acceso autorizados en las diferentes regiones de la memoria —como por ejemplo lectura, escritura y ejecución— evitando que el código ejecutado en modo usuario tenga acceso a zonas a las que no debería tenerlo.
El acceso a la memoria en un modo no autorizado se considera una instrucción privilegiada, por lo que ese tipo de acceso desde el modo usuario siempre genera una excepción.
Por ejemplo, si se intenta ejecutar instrucciones en una zona de memoria no marcada con el permiso de ejecución.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_el_temporizador">7.4. El temporizador</h3>
<div class="paragraph">
<p>El <strong>temporizador</strong> se configura por el sistema operativo durante el arranque del sistema para interrumpir a la CPU a intervalos regulares.
Así, cuando el temporizador interrumpe, el control se transfiere automáticamente al núcleo del sistema.
Entonces éste puede:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Conceder más tiempo al proceso en ejecución.</p>
</li>
<li>
<p>Detenerlo y darle más tiempo de CPU en el futuro</p>
</li>
<li>
<p>Tratar la interrupción como un error y terminar el programa.</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>El temporizador se utiliza para asegurar que ningún proceso acapara la CPU indefinidamente.
Por ejemplo, un programa mal desarrollado que entra en un bucle infinito, del que no sale jamás.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Obviamente, las instrucciones que pueden modificar el contenido del temporizador son instrucciones privilegiadas.</p>
</div>
</div>
<div class="sect2">
<h3 id="_maquinas_virtuales">7.5. Maquinas virtuales</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Utilizando las técnicas comentadas anteriormente, el sistema operativo crea a los procesos la ilusión de que se ejecutan en su propio procesador y memoria principal, aunque realmente los comparten.
Aun así, los procesos saben que hay un sistema operativo que los supervisa, porque le deben solicitar a él los distintos recursos a través de las llamadas al sistema.</p>
</div>
<div class="paragraph">
<p>Una máquina virtual también es un proceso en un sistema operativo una máquina real —también llamado sistema operativo anfitrión—.
Se utilizan la mismas técnicas para crear la ilusión de que se ejecuta en su propia máquina.
Sin embargo, en lugar de llamadas al sistema, el software que gestiona la máquina virtual ofrece una interfaz de hardware virtual.
Es decir:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>El sistema operativo de la máquina virtual intenta acceder al hardware, ya que presupone que se ejecuta en una máquina real.</p>
</li>
<li>
<p>El sistema operativo anfitrión intercepta estos intentos —ya que son instrucciones privilegiadas, prohibidas para los procesos en el modo usuario— y, en lugar de detener el proceso, comunica el suceso al software de gestión de la máquina virtual.</p>
</li>
<li>
<p>El software de gestión de la máquina virtual identifica a qué dispositivo y que intenta hacer el sistema operativo de la máquina virtual en él —para lo que generalmente se utilizan máquinas de estado que simulan el comportamiento del hardware real— y lo transforma en peticiones al sistema operativo anfitrión.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Por ejemplo, los intentos del sistema operativo virtual de acceder a los discos duros del hardware virtual, son convertidos en operaciones sobre un archivo, en un sistema de archivos real que contiene la imagen en disco de la máquina virtual.</p>
</div>
</div>
<div class="sect2">
<h3 id="_arranque_del_sistema">7.6. Arranque del sistema</h3>
<div class="paragraph">
<p>Desde el momento en que el ordenador se pone en marcha hasta que el sistema operativo inicia
su ejecución se realizan una serie de operaciones.
Estos son los pasos más comunes en el arranque de un sistema:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Llega a la CPU una señal de RESET motivada por el encendido del sistema o por un reinicio.</p>
</li>
<li>
<p>La CPU inicializa el contador de programa a una dirección predefinida de la memoria.
En esa dirección está el <em>bootstrap</em> inicial.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>El <em>bootstrap</em> es el programa que se encarga en primera instancia del arranque.
Debe estar almacenado en una memoria no volátil —ROM o Flash— por que la RAM está en un estado indeterminado en el momento del arranque.</p>
</div>
<div class="paragraph">
<p>En los PC el <em>bootstrap</em> forma parte del <em>firmware</em> —sea BIOS o UEFI— de las placas madres.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>El término <em>firmware</em> viene de que por sus características se sitúa en algún lugar entre el hardware y el software.
Concretamente es un componente de software instalado en un dispositivo hardware para encargase de su control a bajo nivel.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_tareas_del_bootstrap">7.6.1. Tareas del bootstrap</h4>
<div class="paragraph">
<p>El <em>bootstrap</em> debe realizar diversas tareas:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Diagnostico de la máquina</strong> —o <em>Power-on Self-Test</em> (POST)—.
El <em>bootstrap</em> se detiene en este punto si el sistema no supera el diagnostico.</p>
</li>
<li>
<p><strong>Inicializar el sistema</strong>.
Por ejemplo, configurar los registros de la CPU, inicializar los dispositivos y contenido de la memoria, etc.</p>
</li>
<li>
<p><strong>Iniciar el sistema operativo</strong>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Al iniciar el sistema operativo hay que considerar que puede estar en diferentes ubicaciones según el tipo de dispositivo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En <strong>consolas de videojuegos, móviles y otros dispositivos empotrados</strong> se almacena el sistema operativo en alguna forma de memoria de sólo lectura —ROM o Flash—.
Como la ejecución en esas memorias es más lenta que en la RAM, muchas veces el <em>bootstrap</em> suele copiar el sistema a la RAM durante el arranque, antes de iniciarlo.</p>
</li>
<li>
<p>En <strong>sistemas operativos de gran tamaño</strong> —incluidos los de propósito general— el sistema se almacena en disco.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>En los sistemas mas antiguos, el <em>bootstrap</em> lee de una posición fija del disco —generalmente el bloque 0— el gestor de arranque, lo copia en la memoria y lo ejecuta.
Esto es lo que ocurre en los PC más antiguos que utilizan BIOS y particiones MBR.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>También se llama MBR a ese bloque 0 del disco donde está el gestor de arranque.
De hecho MBR son las siglas de <em>Master Boot Record</em> o <a href="https://es.wikipedia.org/wiki/Registro_de_arranque_principal">registro de arranque principal</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Aunque en ocasiones el código de ese bloque inicial de arranque sabe cargar e iniciar el sistema operativo completo, es común que sólo sepa donde está el resto del gestor de arranque en el disco, para cargarlo y ejecutarlo.
No debemos olvidar que el código cargado por el <em>bootstrap</em> debe caber en un sólo bloque del disco, que generalmente tiene solo 512 bytes.</p>
</div>
<div class="paragraph">
<p>En los PC más modernos que utilizan UEFI y particiones GPT, la UEFI tiene la capacidad de leer el sistema de archivo en las particiones para buscar directamente los archivos del gestor de arranque completo.
Una vez el <em>bootstrap</em> los encuentra, los carga y ejecuta.</p>
</div>
<div class="paragraph">
<p>En ambos casos, el gestor de arranque completo es el programa que sabe como iniciar el sistema operativo así que: explora el sistema de ficheros en busca del núcleo del sistema, lo carga e inicia su ejecución.</p>
</div>
<div class="paragraph">
<p>A partir de esto punto cada sistema operativo prosigue de forma diferente.
A modo de ejemplo, veremos como prosigue el arranque en sistemas UNIX en modo texto.</p>
</div>
</div>
<div class="sect3">
<h4 id="_arranque_de_sistemas_unix">7.6.2. Arranque de sistemas UNIX</h4>
<div class="paragraph">
<p>Al iniciarse el núcleo del sistema, este realiza una serie de tareas:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Configura el sistema para crear un entorno adecuado para la ejecución de los procesos: configuración de interrupciones, configuración de los modos de ejecución —privilegiado y usuario— y de la gestión de la memoria; inicialización de dispositivos y controladores; montaje del sistema de ficheros raíz; creación del proceso inactivo —que se ejecutará cuando no haya nada que hacer— etc.</p>
</li>
<li>
<p>Crea el proceso <strong>init</strong> —que por ser el primero tiene PID 1— a partir de la carga del programa <code>init</code> almacenado en el sistema de ficheros raíz.
En los sistemas GNU/Linux actuales el proceso <strong>init</strong> más común es <a href="https://es.wikipedia.org/wiki/Systemd">systemd</a>.</p>
</li>
<li>
<p>El planificador de la CPU toma el control de la gestión de la CPU y el núcleo queda dormido.
Puesto que la función del planificador es asignar procesos a la CPU y solo hay uno, el proceso <strong>init</strong>, éste es escogido y comienza su ejecución.</p>
</li>
<li>
<p>El proceso <strong>init</strong> lanza los <em>scripts</em> encargados de configurar los servicios —también llamados demonios— del sistema.
Por ejemplo, para el registro de eventos del sistema, gestión de dispositivos, particiones, impresoras, entre otros.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>El proceso <strong>init</strong> también configura el entorno de usuario.
Configura las terminales del sistema, inicia un proceso <strong>login</strong> conectado a cada una y se duerme a la espera.
Estos procesos <strong>login</strong> son monitorizados por <strong>init</strong> para reiniciarlos en caso de que mueran.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Aunque, por lo general, un sistema de escritorio tiene una única pareja de teclado y monitor y, por lo tanto, una única terminal real; el sistema suele esta configurado para crear varios terminales virtuales entre los que el usuario puede conmutar usando las combinaciones de teclas adecuadas.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Los procesos <strong>login</strong> se encargan de autenticar a los usuarios y de iniciar y configurar su sesión:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Muestran una pantalla de inicio de sesión donde se solicita el nombre del usuario y su contraseña.</p>
</li>
<li>
<p>Autentican al usuario comprobando las credenciales proporcionadas por el mismo.</p>
</li>
<li>
<p>Si la autenticación es positiva, el proceso <strong>login</strong> cambia su identidad actual —generalmente de <em>root</em> o administrador del sistema— por la del usuario autenticado, configura la sesión y sustituye su programa actual por el del intérprete de comandos que tiene configurado ese usuario (véase el <a href="#procesos_posix_api">Apartado 9.7.3.2</a>).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>El intérprete de comandos completa la configuración del entorno en base a sus ficheros de configuración, muestra el <a href="https://es.wikipedia.org/wiki/Prompt">prompt</a> y queda a la espera del primer comando del usuario.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sistemas_operativos_por_su_estructura">8. Sistemas operativos por su estructura</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>10 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Ya hemos discutido anteriormente acerca de los componentes más comunes en un sistema operativo (véase el <a href="#_componentes_del_sistema">Capítulo 4</a>).
En esta sección comentaremos cómo se clasifican los distintos sistemas operativos según la organización e interconexión de sus componentes.</p>
</div>
<div class="sect2">
<h3 id="_estructura_sencilla">8.1. Estructura sencilla</h3>
<div class="paragraph">
<p></p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Los sistemas con <strong>estructura sencilla</strong> se caracterizan por:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>No tener una estructura bien definida.
Los componentes no están bien separados y las interfaces entre ellos no están bien definidas.</p>
</li>
<li>
<p>Son sistemas <strong>monolíticos</strong>, dado que gran parte de la funcionalidad del sistema se implementa en el núcleo.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ms_dos_2">8.1.1. MS-DOS</h4>
<div class="paragraph">
<p>Por ejemplo, en el <a href="https://es.wikipedia.org/wiki/MS-DOS">MS-DOS</a> los programas de aplicación podían acceder directamente a toda la memoria y a cualquier dispositivo.
Disponiendo de esa libertad un programa erróneo cualquiera podía corromper el sistema completo.</p>
</div>
<div id="estructura_msdos" class="imageblock">
<div class="content">
<img src="C08-estructura/media/estructura_msdos.svg" alt="estructura msdos">
</div>
<div class="title">Figura 21. Esquema de la estructura de MS-DOS.</div>
</div>
<div class="paragraph">
<p>Como el <a href="https://es.wikipedia.org/wiki/Intel_8086_y_8088">Intel 8086</a> para el que fue escrito MS-DOS no proporcionaba un modo dual de operación, los diseñadores del sistema no tuvieron más opción que dejar accesible el hardware a los programas de usuario.</p>
</div>
</div>
<div class="sect3">
<h4 id="_unix_2">8.1.2. UNIX</h4>
<div class="paragraph">
<p>Otro ejemplo es el de <a href="https://es.wikipedia.org/wiki/Unix">UNIX original</a>, donde si había una separación clara entre procesos de usuario y código del sistema, pero juntaba un montón de funcionalidad en el núcleo del sistema.</p>
</div>
<div id="estructura_unix" class="imageblock">
<div class="content">
<img src="C08-estructura/media/estructura_unix.svg" alt="estructura unix">
</div>
<div class="title">Figura 22. Esquema de la estructura de UNIX.</div>
</div>
<div class="paragraph">
<p>El núcleo proporciona la planificación de CPU, la gestión de la memoria, el soporte de los sistemas de archivos y muchas otras funcionalidades del sistema operativo.
En general se trata de una enorme cantidad de funcionalidad que es difícil de implementar y mantener, si no se compartimenta adecuadamente.</p>
</div>
<div class="paragraph">
<p>Tanto MS_DOS como UNIX eran originalmente sistemas pequeños y simples, limitados por las funcionalidades del hardware de su época, que fueron creciendo más allá de las previsiones originales.
Lo cierto es que con mejor soporte del hardware se puede dividir el sistema operativo en piezas más pequeñas y apropiadas que las del MS-DOS y el UNIX original.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_estructura_en_capas">8.2. Estructura en capas</h3>
<div class="paragraph">
<p></p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Los sistemas con <strong>estructura en capas</strong> se caracterizan por:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La funcionalidad se divide en capas, de tal forma que una capa solo utiliza funciones y servicios de la capa inmediatamente inferior y lo hace a través de una interfaz bien definida.</p>
</li>
<li>
<p>Como en la programación orientada a objetos, cada capa oculta a la capa superior los detalles de su implementación.
Por ejemplo, las estructuras de datos internas que usa y las operaciones o el hardware de la capa inferior que utiliza.</p>
</li>
<li>
<p>Escalan mejor que los sistemas con <strong>estructura sencilla</strong> porque las capas hacen que el código esté mejor compartimentado.
Por ejemplo, al corregir un <em>bug</em> o añadir una nueva funcionalidad solo hay que preocuparse de su efecto en la capa a la que afecta y no en todo el código del núcleo —siempre que no se altere la interfaz de la capa con el exterior—.</p>
</li>
<li>
<p>Ser menos eficiente que la de los sistemas de <strong>estructura sencilla</strong>.
En cada capa los argumentos son transformados y los datos necesarios deben de ser transferidos al invocar operaciones en la capa inferior, por lo que cada una añade cierto nivel de sobrecarga al funcionamiento del sistema.</p>
</li>
<li>
<p>También son sistemas <strong>monolíticos</strong>, dado que gran parte de la funcionalidad del sistema se implementa en el núcleo, aunque ahora el núcleo esté compartimentado en capas.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Un ejemplo de este tipo de sistemas operativos es el <a href="https://es.wikipedia.org/wiki/OS/2">OS/2</a>.</p>
</div>
<div id="estructura_os2" class="imageblock">
<div class="content">
<img src="C08-estructura/media/estructura_os2.svg" alt="estructura os2">
</div>
<div class="title">Figura 23. Esquema de la estructura de IBM OS/2.</div>
</div>
<div class="sect3">
<h4 id="_dificultades_con_el_diseño">8.2.1. Dificultades con el diseño</h4>
<div class="paragraph">
<p>Es importante tener en cuenta que diseñar un sistema con <strong>estructura en capas</strong> no es tan sencillo como pudiera parecer.
La definición de las capas y sus funcionalidades debe ser planificada cuidadosamente debido a la restricción, comentada anteriormente, de que un capa sólo puede utilizar los servicios de las capas inferiores.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, el planificador de la CPU suele tener información de los procesos que están en la memoria.
Parte de esa información puede ser almacenada en el disco para aumentar la memoria principal disponible.
Esto nos debería llevar a pensar que la gestión del almacenamiento secundario debe ir en una capa inferior a la del planificador de la CPU, para que así el segundo pueda pedir al primero que guarde los datos en disco.</p>
</div>
<div class="paragraph">
<p>Sin embargo, el planificador de la CPU debe asignar la CPU a otro proceso cuando el proceso que actualmente la ocupa solicita alguna operación de E/S —lo típico en multiprogramación—.
Como es la gestión del almacenamiento secundario el que debe pedir una operación al planificador de la CPU, ahora el primero debe estar sobre el segundo.</p>
</div>
<div class="paragraph">
<p>La solución a esta dependencia circular es hacer que ambos componentes estén en la misma capa.
Este tipo de dependencias no son raras, ocurre en muchos otros casos, ya que los componentes del sistema operativo suelen depender mucho unos de otros.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Al final, la solución de compromiso es tender hacia sistemas con muy pocas capas donde cada una tiene mucha funcionalidad.
Esto limita mucho las ventajas de esta técnica porque no permite compartimentar el núcleo tanto como sería deseable.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_microkernel">8.3. Microkernel</h3>
<div class="paragraph">
<p>
</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Los sistemas con <strong>estructura microkernel</strong> se caracterizan por:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Eliminar todos los componentes no esenciales del núcleo e implementarlos como procesos a nivel de usuario.</p>
</li>
<li>
<p>Un núcleo <strong>microkernel</strong> proporciona funciones mínimas de gestión de procesos y de memoria y algún mecanismo de comunicación entre procesos.
Sin embargo, hay que tener en cuenta que hay poco consenso a este respecto, por lo que algunos <strong>microkernel</strong> reales incluyen en el núcleo algunas funcionales adicionales.</p>
</li>
<li>
<p>El mecanismo de comunicación permite a los procesos de los usuarios solicitar servicios a los componentes del sistema.
También sirve para que los componentes del sistema se comuniquen entre sí y se pidan servicio.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Dado que los componentes del sistema están aislados unos de otros —ya que se implementan como procesos de usuario— el mecanismo de comunicación entre procesos es la única forma que tienen los procesos de los usuarios y los componentes, de solicitarles un servicio.</p>
</div>
<div id="estructura_minix3" class="imageblock">
<div class="content">
<img src="C08-estructura/media/estructura_minix3.svg" alt="estructura minix3">
</div>
<div class="title">Figura 24. Esquema de la estructura microkernel de MINIX 3.</div>
</div>
<div class="paragraph">
<p>Generalmente esta comunicación se implementa mediante paso de mensajes (véase el <a href="#_comunicación_entre_procesos">Apartado 9.8.2</a>).</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Entre los beneficios de estos sistemas operativos se incluyen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Facilidad a la hora de añadir nuevas funcionalidades</strong>.
Los nuevos servicios son añadidos como aplicaciones de nivel de usuario, por lo que no es necesario hacer modificaciones en el núcleo.
Desarrollar en el modo privilegiado siempre es más peligrosos que en el modo usuario porque los errores pueden ser catastróficos: bloqueo o caída del sistema, corrupción de datos, etc.</p>
</li>
<li>
<p><strong>Facilidad a la hora de portar el sistema a otras plataformas</strong>.
Puesto que el núcleo es muy pequeño, resulta muy sencillo de portar a otras plataformas.</p>
</li>
<li>
<p><strong>Más seguridad y fiabilidad</strong>.
Puesto que la mayor parte de los servicios se ejecutan a nivel de usuario en procesos separados, un servicio que falla no puede afectar a otros ni puede ser utilizado para ganar acceso a otros servicios o al núcleo.
Además se pueden implementar estrategias para mejorar la tolerancia a fallos, como reiniciar un servicio que ha fallado, como si fuera un programa cualquiera.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_rendimiento">8.3.1. Rendimiento</h4>
<div class="paragraph">
<p>El mayor inconveniente es el pobre rendimiento que puede tener, causado por la sobrecarga que añade el mecanismo de comunicación.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, <a href="https://es.wikipedia.org/wiki/Windows_NT">Microsoft Windows NT</a> nació con una estructura de <strong>microkernel</strong> en capas donde una parte importante de los servicios eran proporcionados por unos procesos de usuario llamados subsistemas.</p>
</div>
<div class="paragraph">
<p>El sistema operativo podía mostrar diferentes personalidades o <em>entornos operativos</em> —básicamente de OS/2, POSIX y MS-DOS— a través del uso de subsistemas ambientales, que también se ejecutaban como procesos de usuario.
Las aplicaciones de Microsoft Windows NT se comunicaban con estos subsistemas utilizando un mecanismo de comunicación denominado <a href="https://en.wikipedia.org/wiki/Local_Inter-Process_Communication">LPC</a> (<em>Local Inter-Process Communication</em>).</p>
</div>
<div class="paragraph">
<p>Con esta estructura, la pérdida de rendimiento respecto a Microsoft Windows 95 era tan importante —especialmente en lo relativo a operaciones gráficas— que los diseñadores se vieron obligados a mover más servicios al espacio del núcleo en la versión 4.0.
El resultado es que los Windows sucesores a Windows NT 4.0 tienen una arquitectura más monolítica que microkernel, ya que aunque muchos servicios siguen siendo proporcionados por procesos de usuario, esto sólo ocurre con aquellos donde el rendimiento no es un factor crítico.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Microsoft Windows XP tiene 280 llamadas al sistema a las que hay que sumar las más de 650 llamadas del subsistema gráfico, que también se aloja en el núcleo desde Microsoft Windows NT 4.0.
Mientras que Microsoft Windows NT 3.51 tenía algo menos de 200 llamadas al sistema.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Sin embargo varios sistemas operativos siguen utilizando núcleos <strong>microkernel</strong>, como <a href="https://es.wikipedia.org/wiki/QNX">QNX</a> o <a href="https://en.wikipedia.org/wiki/MINIX_3">MINIX 3</a>.
Ambos son sistemas operativos de tiempo real, que basan en la estructura de <strong>microkernel</strong> su estabilidad como sistema para tareas críticas.</p>
</div>
<div class="paragraph">
<p>En la <a href="#estructura_minix3">Figura 24</a>, por ejemplo, se puede observar un esquema de <a href="https://en.wikipedia.org/wiki/MINIX_3">MINIX 3</a>.
El núcleo es muy pequeño —apenas tiene 5000 líneas de código— por lo que la mayor parte de la funcionalidad reside en los procesos de servicios y de controladores de dispositivo.</p>
</div>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/MINIX_3">MINIX 3</a> es un sistema compatible POSIX.
Así que soporta las llamadas al sistema definidas por este estándar, pero éstas se convierten en mensajes enviados al servidor correspondiente con la petición, y no en llamadas directas al núcleo.
Para que un servidor pueda atender una petición, quizás tenga que enviar peticiones a otros servidores o controladores de dispositivo.
Incluso pueden tener que hacer llamadas al núcleo, para solicitar alguna operación privilegiada que no se puede implementar en el modo usuario.
Por ejemplo, operaciones de E/S —fundamentales para los controladores de dispositivo— o el acceso a tablas del núcleo —como la tabla de procesos—.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Es este trasiego de mensaje con peticiones y respuestas —y la correspondiente conmutación de procesos en la CPU para ejecutar el proceso que atiende cada mensaje— para resolver una petición de un proceso de usuario, lo que teóricamente justica el menor rendimiento de los sistemas <strong>microkernel</strong>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_estructura_modular">8.4. Estructura modular</h3>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Los sistemas con <strong>estructura modular</strong> se caracterizan por:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Dividir el núcleo en módulos, cada uno de los cuales implementa funciones y servicios concretos y se comunican entre sí a través de una interfaz bien definida.</p>
</li>
<li>
<p>Como en la programación orientada a objetos, cada módulo oculta al resto los detalles de su implementación.</p>
</li>
<li>
<p>Todos los módulos pueden llamar a funciones de la interfaz de cualquier otro módulo, a diferencia de los sistemas operativos con <strong>estructura en capas</strong>, donde una capa solo podía usar a la inmediatamente inferior.</p>
</li>
<li>
<p>También son sistemas <strong>monolíticos</strong>, dado que gran parte de la funcionalidad del sistema se implementa en el núcleo, aunque ahora el núcleo esté compartimentado en módulos.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Estos núcleos suelen disponer de un pequeño conjunto de componentes fundamentales que se cargan durante el arranque.
Posteriormente pueden cargar módulos adicionales, tanto durante la inicialización del sistema como en tiempo de ejecución.</p>
</div>
<div id="estructura_linux" class="imageblock">
<div class="content">
<img src="C08-estructura/media/estructura_linux.svg" alt="estructura linux">
</div>
<div class="title">Figura 25. Esquema de la estructura del núcleo Linux.</div>
</div>
<div class="paragraph">
<p>En este aspecto se asemejan a los núcleos <strong>microkernel</strong>, ya que el módulo principal sólo tiene funciones básicas.
Sin embargo los núcleos modulares:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Son más eficientes</strong> al no necesitar un mecanismo de comunicación, puesto que los componentes se cargan en la memoria destinada al núcleo, por lo que pueden llamarse directamente.</p>
</li>
<li>
<p><strong>Son menos seguros y fiables</strong>, puesto que gran parte de su funcionalidad se ofrece desde el modo privilegiado.
Un error en cualquier componente puede comprometer o hacer caer el sistema.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Este tipo de estructura es la utilizada en los UNIX modernos, como <a href="https://es.wikipedia.org/wiki/Solaris_(sistema_operativo)">Oracle/Sun Microsystems Solaris</a>, <a href="https://es.wikipedia.org/wiki/FreeBSD">FreeBSD</a>, <a href="https://es.wikipedia.org/wiki/GNU/Linux">Linux</a> (véase la <a href="#estructura_linux">Figura 25</a>) y <a href="https://es.wikipedia.org/wiki/MacOS">macOS</a>.</p>
</div>
</div>
</div>
</div>
<h1 id="_gestión_de_procesos" class="sect0">Parte III: Gestión de procesos</h1>
<div class="sect1">
<h2 id="_procesos">9. Procesos</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>39 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Los primeros sistemas informáticos solo permitían que un programa se ejecutara cada vez.
Dicho programa tenía control completo sobre el sistema y acceso a todos los recursos del mismo.
Por el contrario, los sistemas <strong>multitarea</strong> actuales permiten que múltiples programas sean cargados y ejecutados concurrentemente.</p>
</div>
<div class="paragraph">
<p>Obviamente esta evolución implica un control más fino y la compartimentación de los diversos programas, para que no interfieran unos con otros.
Esto, a su vez, conduce a la aparición de la noción de <strong>proceso</strong>, que no es sino la unidad de trabajo en un sistema operativo moderno de tiempo compartido.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Por simplicidad, en este capítulo utilizaremos los términos <strong>trabajo</strong> y <strong>proceso</strong> de forma indistinta.
A fin de cuentas tanto los <strong>trabajos</strong> en los antiguos <em>mainframes</em> como los <strong>procesos</strong> en los sistemas modernos son la unidad de trabajo en sus respectivos sistemas y el origen de toda actividad en la CPU.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Por último, antes de continuar, es importante señalar que en un sistema operativo hay varios tipos de procesos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Procesos del sistema</strong>.
Ejecutan el código del sistema operativo contenido en los <strong>programas del sistema</strong>, que generalmente sirven para hacer tareas del sistema operativo que es mejor mantener fuera del núcleo.</p>
</li>
<li>
<p><strong>Procesos de usuario</strong>
Ejecutan el código contenido en los <em>programas de aplicación</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Sin embargo, en lo que resta de capítulo, no estableceremos ninguna distinción entre ellos.
En lo que respecta a la gestión de estos procesos en el sistema, no hay ninguna diferencia.</p>
</div>
<div class="sect2">
<h3 id="_el_proceso">9.1. El proceso</h3>
<div class="paragraph">
<p>Como ya hemos comentado con anterioridad, un <strong>proceso</strong> es un programa en ejecución (véase el <a href="#componente_gestión_de_procesos">Apartado 4.1</a> para una definición más completa).
Sin embargo, los procesos no solo están compuestos por el código del programa, sino que también son importantes otros elementos:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1">Segmento de código</dt>
<dd>
<p>Contiene las instrucciones ejecutables del programa.
También es conocido como segmento <strong>text</strong> o <strong>.text</strong>.</p>
</dd>
<dt class="hdlist1">Segmento de datos</dt>
<dd>
<p>Contiene las variables globales y estáticas del programa que se inicializan con un valor predefinido.
También es conocido como segmento <strong>.data</strong>.</p>
</dd>
<dt class="hdlist1">Segmento BSS</dt>
<dd>
<p>Contiene las variables globales y estáticas del programa inicializadas a 0 o sin inicialización explícita   .
También es conocido como segmento <strong>.bss</strong>.</p>
</dd>
<dt class="hdlist1">Pila</dt>
<dd>
<p>Contiene datos temporales, como los parámetros y direcciones de retorno de las funciones y las variables locales.</p>
</dd>
<dt class="hdlist1">Montón</dt>
<dd>
<p>Contiene el espacio de la memoria que se asigna dinámicamente durante la ejecución del proceso.
También es conocido como <strong>heap</strong>.</p>
</dd>
<dt class="hdlist1">Información sobre el estado actual de ejecución</dt>
<dd>
<p>Como el <strong>contador de programa</strong>, los valores de los <strong>registros de la CPU</strong>, el <strong>estado</strong> del proceso y más (véase el <a href="#_bloque_de_control_de_proceso">Apartado 9.3</a>).</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>Los <strong>segmentos de código</strong>, <strong>datos</strong> y <strong>BSS</strong> por lo general son secciones dentro del archivo ejecutable que contiene el programa.
El resto de elementos los crea el sistema operativo al cargar el programa y crear el proceso.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Como vimos en el <a href="#componente_gestión_de_procesos">Apartado 4.1</a> varios procesos pueden estar asociados al mismo programa pero no por eso dejan de ser distintos procesos.
Todos tendrán una copia del mismo segmento de código, pero diferente: contador de programa, valores en los registros de la CPU, pila, segmento de datos, montón y demás propiedades.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>En la <a href="#proceso_en_memoria">Figura 26</a> se puede observar la disposición de algunos de estos elementos de un proceso en el espacio de usuario en la memoria.</p>
</div>
<div id="proceso_en_memoria" class="imageblock">
<div class="content">
<img src="C09-procesos/media/proceso_en_memoria.svg" alt="proceso en memoria">
</div>
<div class="title">Figura 26. Anatomía de un proceso en memoria.</div>
</div>
</div>
<div class="sect2">
<h3 id="_estados_de_los_procesos">9.2. Estados de los procesos</h3>
<div class="paragraph">
<p>Cada proceso tiene un <strong>estado</strong> que cambia a lo largo de su ejecución y que está definido, parcialmente, por la actividad que realiza actualmente el propio proceso.</p>
</div>
<div id="diagrama_estado_proceso" class="imageblock">
<div class="content">
<img src="C09-procesos/media/diagrama_estado_proceso.svg" alt="diagrama estado proceso">
</div>
<div class="title">Figura 27. Diagrama de estado de un proceso.</div>
</div>
<div class="paragraph">
<p>Los estados por los que puede pasar un procesos varían de un sistema operativo a otro, aunque los siguientes son comunes a todos ellos:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Nuevo</dt>
<dd>
<p>El proceso está en proceso de creación.
Este estado existe porque la creación de un proceso no es algo instantáneo.
Necesita de varias operaciones que pueden tardar tiempo en realizarse, como: reservar memoria libre, cargar el programa en la memoria, inicializar estructuras de datos y configurar el entorno de ejecución.</p>
</dd>
<dt class="hdlist1">Ejecutando</dt>
<dd>
<p>El proceso está siendo ejecutado en la CPU.
Para eso tiene que haber sido escogido por el planificador de la CPU de entre todos los procesos en estado <strong>preparado</strong>.
Sólo puede haber un proceso en este estado por CPU en el sistema.</p>
</dd>
<dt class="hdlist1">Esperando</dt>
<dd>
<p>El proceso está esperando por algún <strong>evento</strong> como, por ejemplo, que termine una operación de E/S solicitada previamente o que otro proceso termine su ejecución.
Múltiples procesos pueden estar en este estado de espera.</p>
</dd>
<dt class="hdlist1">Preparado</dt>
<dd>
<p>El proceso está esperando a poder usar la CPU.
Múltiples procesos pueden estar en este estado.</p>
</dd>
<dt class="hdlist1">Terminado</dt>
<dd>
<p>El proceso ha finalizado su ejecución y espera a que el sistema operativo recupere los recursos que le fueron asignados.
Como en el caso del estado <strong>nuevo</strong>, este estado existe porque terminar un proceso no es algo instantáneo.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>El diagrama de estados de los procesos, con las transiciones posibles entre ellos, se muestra en la <a href="#diagrama_estado_proceso">Figura 27</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_bloque_de_control_de_proceso">9.3. Bloque de control de proceso</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El <strong>bloque de control de proceso</strong> o <strong>PCB</strong> (<em>Process Control Block</em>) es una estructura de datos que representa a cada proceso en el sistema operativo y que guarda información sobre su estado de actividad actual.</p>
</div>
<div class="paragraph">
<p>En el sistema hay un PCB por proceso y sirve de almacén para cualquier información que puede variar de un proceso a otro:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Estado del proceso</strong>.
El estado actual del proceso de la lista que hemos visto anteriormente.
Por ejemplo: nuevo, preparado, esperando, etc.</p>
</li>
<li>
<p><strong>Contador de programa</strong>.
Indica la dirección de la próxima instrucción del proceso que debe ser ejecutada por la CPU.
Obviamente, durante el estado <strong>ejecutando</strong> el contador de programa está en el registro correspondiente de la CPU.
Su valor se guarda en el PCB al salir el proceso de la CPU para que comience ejecutarse en ella otro proceso.</p>
</li>
<li>
<p><strong>Registros de la CPU</strong>.
El valor de los registros de la CPU también forman parte del estado de actividad del proceso.
Como en el caso del <strong>contador de programa</strong>, durante el estado <strong>ejecutando</strong> los valores están en los registros de la CPU, pero se guardan en el PCB cuando el proceso sale de la CPU para que se ejecute otro proceso.</p>
</li>
<li>
<p><strong>Información de planificación de la CPU</strong>.
Incluye la información requerida por el planificador de la CPU.
Por ejemplo la prioridad del proceso, punteros a las colas de planificación donde está el proceso, punteros al PCB del proceso padre y de los procesos hijos, etc.</p>
</li>
<li>
<p><strong>Información de gestión de la memoria</strong>.
Incluye la información requerida para la gestión de la memoria.
Por ejemplo los valores de los registros base y límite que definen el área de la memoria física que ocupa el proceso —en el caso de se use asignación contigua de memoria (véase el <a href="#_asignación_contigua_de_memoria">Apartado 15.5</a> o la dirección a la tabla de páginas —en el caso de que se use paginación (véase el <a href="#_paginación">Capítulo 16</a>)—.</p>
</li>
<li>
<p><strong>Información de registro</strong>.
Aquí se incluye la cantidad de CPU usada, límites de tiempo en el uso de la CPU, estadísticas de la cuenta del usuario a la que pertenece el proceso, estadísticas de la ejecución del proceso, etc.</p>
</li>
<li>
<p><strong>Información de estado de la E/S</strong>.
Incluye la lista de dispositivos de E/S reservados por el proceso, la lista de archivos abiertos, etc.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_colas_de_planificación">9.4. Colas de planificación</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>En los sistemas operativos hay diferentes <strong>colas de planificación</strong> para los procesos en distintos <strong>estados</strong>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Cola de trabajo</dt>
<dd>
<p>Contiene a todos los trabajos en el sistema, de manera que cuando entran en el sistema van a esta cola, a la espera de ser escogidos para ser cargados en la memoria y ejecutados.
Esta cola existía en los <strong>sistemas multiprogramados</strong> pero no existe en los sistemas operativos modernos.</p>
</dd>
<dt class="hdlist1">Cola de preparados</dt>
<dd>
<p>Contiene a los procesos que están en estado <strong>preparado</strong>.
Es decir, procesos cargados en la memoria principal que esperan para usar la CPU.
La cola de preparados es generalmente una lista enlazada de PCB, donde cada uno incluye un puntero al PCB del siguiente proceso en la cola.</p>
</dd>
<dt class="hdlist1">Colas de espera</dt>
<dd>
<p>Contienen a los procesos que están en estado <strong>esperando</strong>.
Es decir, que esperan por un evento concreto, como por ejemplo la finalización de una petición de E/S.
Estas colas también suelen ser implementadas como listas enlazadas de PCB y suele haber una por evento, de manera que cuando ocurre algún evento todos los procesos en la cola asociada pasan automáticamente al estado <strong>preparado</strong> y a la <strong>cola de preparados</strong>.</p>
</dd>
<dt class="hdlist1">Colas de dispositivo</dt>
<dd>
<p>Son un caso particular de cola de espera.
Cada dispositivo de E/S tiene asociada una <strong>cola de dispositivo</strong> que contiene los procesos que están <strong>esperando</strong> por ese dispositivo en particular.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Una manera habitual de representar la planificación de procesos es a través de un diagrama de colas como el de la <a href="#colas_de_planificación_procesos">Figura 28</a>.</p>
</div>
<div id="colas_de_planificación_procesos" class="imageblock">
<div class="content">
<img src="C09-procesos/media/colas_planificación_procesos.svg" alt="colas planificación procesos">
</div>
<div class="title">Figura 28. Diagrama de colas de la planificación de procesos.</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Analizándolo podemos tener una idea clara del flujo típico de los procesos dentro del sistema:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Un nuevo proceso llega al sistema</strong>.
Una vez pasa del estado <strong>nuevo</strong> a <strong>preparado</strong> es colocado en la <strong>cola de preparados</strong>.
Allí espera hasta que es seleccionado por el <strong>planificado de la CPU</strong> para su ejecución y se le asigna la CPU.
Mientras se ejecuta pueden ocurrir varias cosas:</p>
<div class="ulist">
<ul>
<li>
<p><strong>El proceso solicita una operación de E/S</strong> por lo que abandona la CPU y es colocado en la <em>cola de dispositivo</em> correspondiente en estado <strong>esperando</strong>.
No debemos olvidar que aunque en nuestro diagrama no exista más que una de estas colas, en un sistema operativo real suele haber una para cada dispositivo.</p>
</li>
<li>
<p><strong>El proceso puede querer esperar por un evento</strong>.
Por ejemplo, puede crear otro proceso y esperar a que termine.
En ese caso el proceso hijo es creado, mientras el proceso padre abandona la CPU y es colocado en una <strong>cola de espera</strong> en estado <strong>esperando</strong> hasta que el proceso hijo termine.
La terminación del proceso hijo es el evento que espera el proceso padre para salir de la <strong>cola de espera</strong> y entrar en la <strong>cola de preparados</strong> para continuar su ejecución en la CPU cuando sea posible.</p>
</li>
<li>
<p><strong>El proceso puede ser sacado forzosamente de la CPU</strong>, como resultado de la interrupción del temporizador, que permite determinar cuando un proceso lleva demasiado tiempo ejecutándose, así que es colocado en la <strong>cola de preparados</strong> en estado <strong>preparado</strong>.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Cuando las esperas concluyen, los procesos vuelven a la cola de preparado</strong>, pasando del estado de espera al de preparado.</p>
</li>
<li>
<p><strong>Los procesos repiten este ciclo hasta que terminan</strong>.
En ese momento son eliminados de todas las colas mientras el PCB y los recursos asignados son recuperados por parte del sistema operativo para poder usarlos con otros procesos.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_planificación_de_procesos">9.5. Planificación de procesos</h3>
<div class="paragraph">
<p>Durante su ejecución, los procesos se mueven entre las diversas colas de planificación a criterio del sistema operativo.
Este proceso de selección debe ser realizado por el <strong>planificador</strong> adecuado:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>El <strong>planificador de largo plazo</strong> o <strong>planificador de trabajos</strong>— selecciona los trabajos desde la cola de trabajos en el almacenamiento secundario —dónde están todos almacenados— y los carga en memoria.</p>
<div class="paragraph">
<p>Este planificador se usaba en los sistemas multiprogramados, donde había cola de trabajos.
Los sistemas de tiempo compartido posteriores y los sistemas modernos, carecen de planificador de trabajos, porque los programas se cargan directamente en memoria para ser ejecutados, cuando el usuario lo solicita.</p>
</div>
</li>
<li>
<p>El <strong>planificador de corto plazo</strong> o <strong>planificador de CPU</strong> selecciona uno de los procesos en la cola de preparados y lo asigna a la CPU.
Obviamente este planificador es invocado cuando un proceso en ejecución abandona la CPU, dejándola disponible para otro proceso.</p>
</li>
<li>
<p>El <strong>planificador de medio plazo</strong>  era utilizado en algunos sistemas para sacar procesos de la memoria cuando escasea y reintroducirlos posteriormente cuando vuelve a haber suficiente memoria libre.
A este esquema se le denomina <strong>intercambio</strong> —o <strong><em>swapping</em></strong>.</p>
<div class="paragraph">
<p>Esto era útil en sistemas antiguos donde un proceso tenía que estar cargado completamente en la memoria para poder ejecutarse.
Así que si faltaba memoria, se podía suspender un proceso completo, preservar el contenido de su memoria en disco y liberar la memoria ocupada para usarla con otros procesos.</p>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En los sistemas de propósito general modernos no se utiliza <strong>planificador de medio plazo</strong> porque utilizan técnicas de <strong>memoria virtual</strong> (véase el <a href="#_memoria_virtual">Capítulo 17</a>), que permite mover parte de la memoria de los procesos al disco para liberar memoria, sin tener que suspender su ejecución.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_cambio_de_contexto">9.6. Cambio de contexto</h3>
<div class="paragraph">
<p>El <strong>cambio de contexto</strong> es la tarea de asignar la CPU a un proceso distinto al que la tiene asignada en el momento actual.
Esto implica salvar el estado del viejo proceso en su PCB y cargar en la CPU el estado del nuevo.
Entre la información que debe ser preservada en el PCB se incluyen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>El <strong>contador de programa</strong>.</p>
</li>
<li>
<p>Los <strong>registros de la CPU</strong>.</p>
</li>
<li>
<p>El <strong>estado del proceso</strong>.</p>
</li>
<li>
<p>La <strong>información de gestión de la memoria</strong>.
Por ejemplo, la información necesaria para configurar el espacio de direcciones del proceso.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El cambio de contexto es sobrecarga pura, puesto que no hace ningún trabajo útil mientras se conmuta.
Su velocidad depende de aspectos tales como: el número de registros, la velocidad de la memoria y la existencia de instrucciones especiales.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Algunas CPU disponen de instrucciones especiales para salvar y cargar todos los registros de manera eficiente.
Esto reduce el tiempo que la CPU está ocupada en los cambios de contexto.</p>
</div>
<div class="paragraph">
<p>Otra opción es el uso de <a href="https://en.wikipedia.org/wiki/Register_file">juegos de registros</a>, como es el caso de los procesadores <a href="https://es.wikipedia.org/wiki/UltraSPARC">Sun UltraSPARC</a> e <a href="https://es.wikipedia.org/wiki/Intel_Itanium">Intel Itanium</a>.
Con ellos el juegos de registros actual de la CPU se mapea sobre un banco de registros mucho más extenso.
Al hacer cambio de contexto, se mapea el juego de registros a otros registros diferentes del banco.
Esto permite que la CPU almacene de forma eficiente el valor de los registros de más de un proceso, sin que en cada cambio de contexto sea necesario copiarlos al PCB del proceso en la memoria principal.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_operaciones_sobre_los_procesos">9.7. Operaciones sobre los procesos</h3>
<div class="paragraph">
<p>En general es necesario que los procesos pueden ser creados y eliminados dinámicamente, por lo que los sistemas operativos deben proporcionar servicios para la creación y terminación de los mismos.</p>
</div>
<div class="sect3">
<h4 id="_creación_de_procesos">9.7.1. Creación de procesos</h4>
<div class="paragraph">
<p>Un proceso —denominado <strong>padre</strong>— puede crear múltiples procesos —los <strong>hijos</strong>— utilizando una llamada al sistema específica para la creación de procesos.
Cada proceso creado se identifica de manera unívoca mediante un <strong>identificador de proceso</strong> o <strong>PID</strong> (<em>Process Identifier</em>), que normalmente es un número entero.</p>
</div>
<div class="paragraph">
<p>Por ejemplo en sistemas POSIX un programa puede crear otro proceso así:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">pid_t</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>mientras que en Windows API es así:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">PROCESS_INFORMATION</span> <span class="n">pi</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">CreateProcess</span><span class="p">(</span> <span class="s">"C:</span><span class="se">\\</span><span class="s">Windows</span><span class="se">\\</span><span class="s">System32</span><span class="se">\\</span><span class="s">charmap.exe"</span><span class="p">,</span> <span class="cm">/* ... */</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pi</span> <span class="p">))</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">pi</span><span class="p">.</span><span class="n">dwhProcessId</span><span class="p">;</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="n">HANDLE</span> <span class="n">handle</span> <span class="o">=</span> <span class="n">pi</span><span class="p">.</span><span class="n">hProcess</span><span class="p">;</span> <i class="conum" data-value="3"></i><b>(3)</b>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a> devuelve <code>TRUE</code> si el proceso se creó con éxito.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-process_information">PROCESS_INFORMATION</a> contiene el <strong>identificador de proceso</strong> del nuevo proceso, si <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a> ha tenido éxito.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-process_information">PROCESS_INFORMATION</a> también contiene el manejador del proceso —o <em>handle</em> en inglés— que sirve para obtener y manipular el nuevo proceso.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>En ambos casos <code>pid</code> identifica al nuevo proceso en el sistema.
Sin embargo, mientras que los sistemas POSIX ese identificador se puede usar en otras llamadas al sistema para indicar futuras operaciones sobre el proceso, en Windows lo que se utiliza es el manejador <code>hProcess</code> devuelto en <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-process_information">PROCESS_INFORMATION</a>.</p>
</div>
<div class="paragraph">
<p>Obviamente, cada proceso puede obtener del sistema su propio identificador de procesos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cm">/* POSIX API */</span>
<span class="n">pid_t</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>

<span class="cm">/* Windows API */</span>
<span class="n">HANDE</span> <span class="n">handle</span> <span class="o">=</span> <span class="n">GetCurrentProcess</span><span class="p">();</span>
<span class="n">DWORD</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">GetProcessId</span><span class="p">(</span> <span class="n">handle</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>o el de su padre:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cm">/* POSIX API */</span>
<span class="n">pid_t</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">getppid</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_árbol_de_procesos">Árbol de procesos</h5>
<div class="paragraph">
<p>Puesto que cada nuevo proceso puede a su vez crear otros procesos, al final se acaba obteniendo un <strong>árbol de procesos</strong>.
En los sistemas POSIX es muy sencillo de ver ejecutando el comando <a href="https://man7.org/linux/man-pages/man1/pstree.1.html">pstree</a>.</p>
</div>
<div class="paragraph">
<p>En estos sistemas el proceso <strong>init</strong> es el proceso padre raíz de todos los procesos de usuario.
Su PID siempre es 1 ya que es el primer proceso creado por el sistema operativo al terminar la inicialización del núcleo.
Por lo tanto, es el responsable de crear todos los otros procesos que son necesarios para el funcionamiento del sistema.</p>
</div>
</div>
<div class="sect4">
<h5 id="_cómo_obtienen_los_procesos_hilos_los_recursos_que_necesitan">Cómo obtienen los procesos hilos los recursos que necesitan</h5>
<div class="paragraph">
<p>Hay varios aspectos en la creación de los procesos que pueden variar de un sistema operativo a otro.
Uno de ellos es cómo obtienen los procesos hilos los recursos que necesitan para hacer su trabajo.</p>
</div>
<div class="paragraph">
<p>Fundamentalmente existen dos alternativas:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Que cada proceso hijo pueda solicitar y obtener los recursos directamente del sistema operativo, compitiendo por los recursos del sistema en las mismas condiciones que el resto de procesos en ejecución.
Esta es la opción más común en los sistemas de propósito general actuales, como Microsoft Windows, Android, Linux, macOS, UNIX BSD y muchos otros.</p>
</li>
<li>
<p>Que los procesos hijo solo puedan aspirar a obtener un subconjunto de los recursos de su padre.
Esto es interesante en sistemas diseñados para ser muy robustos, ya que evita que un proceso pueda sobrecargar el sistema creando múltiples procesos que consuman demasiada memoria o tiempo de CPU.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>En este último caso, el proceso padre puede estar obligado a repartir sus recursos entre los procesos hijo. O pueda que el sistema les permita compartir algunos de esos recursos —como memoria o archivos— con algunos de sus hijos.</p>
</div>
</div>
<div class="sect4">
<h5 id="_cómo_pasar_parámetros_de_inicialización_a_los_procesos_hijo">Cómo pasar parámetros de inicialización a los procesos hijo</h5>
<div class="paragraph">
<p>Generalmente, el proceso padre suele disponer de algún mecanismo para pasar parámetros de inicialización a sus procesos hijo.</p>
</div>
<div class="sect5">
<h6 id="_argumentos_de_línea_de_comandos">Argumentos de línea de comandos</h6>
<div class="paragraph">
<p>Por ejemplo, en Windows API un proceso puede usar el segundo argumento de <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a> para indicar al proceso hijo opciones y argumentos de línea de comandos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">HANDLE</span> <span class="n">handle</span> <span class="o">=</span> <span class="n">CreateProcess</span><span class="p">(</span><span class="s">"C:</span><span class="se">\\</span><span class="s">holamundo.exe"</span><span class="p">,</span> <span class="s">"/v /s foo.txt bar.png"</span><span class="p">,</span> <span class="cm">/* ... */</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Si el proceso hijo está programado en C o C&#43;&#43;, podrá acceder a los argumentos <code>/v</code>, <code>/s</code>, <code>foo.txt</code> y <code>bar.png</code> a través de los argumentos <code>argc</code> y <code>argv</code> de la función <a href="https://en.cppreference.com/w/c/language/main_function">main()</a> del programa:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="cm">/* . . . */</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>de forma que <code>argv[0]</code> contendrá <code>/v</code>, <code>argv[2]</code> contendrá <code>/s</code> y así sucesivamente.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Obviamente, en otros lenguajes de programación se accede de manera diferente a estos argumentos de línea de comandos.</p>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_variables_de_entorno">Variables de entorno</h6>
<div class="paragraph">
<p>Otra forma de pasar parámetros a un proceso hijo es usando las <strong>variables de entorno</strong>, que no son sino variables dinámicas que se pueden crear, leer y modificar durante la ejecución del proceso.</p>
</div>
<div class="paragraph">
<p>Las <strong>variables de entorno</strong> se gestionan con funciones específicas ofrecidas por la API del sistema operativo:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 1. Funciones de la API para gestionar variables de entorno.</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">POSIX API</th>
<th class="tableblock halign-left valign-top">Windows API</th>
</tr>
</thead>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Leer</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/getenv.3.html">getenv()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getenvironmentvariable">GetEnvironmentVariable()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Leer todos</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man7/environ.7.html">environ</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/processenv/nf-processenv-getenvironmentstrings">GetEnvironmentStrings()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Crear / modificar</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/setenv.3.html">setenv()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setenvironmentvariable">SetEnvironmentVariable()</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>por ejemplo, en sistemas POSIX un programa leer la variable de entorno <code>PATH</code> así:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">char</span><span class="o">*</span> <span class="n">path</span> <span class="o">=</span> <span class="n">getenv</span><span class="p">(</span><span class="s">"PATH"</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>mientras que en Windows API es así:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">DWORD</span> <span class="n">buffSize</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
<span class="n">TCHAR</span> <span class="n">path</span><span class="p">[</span><span class="n">buffSize</span><span class="p">];</span>
<span class="n">GetEnvironmentVariable</span><span class="p">(</span><span class="s">"PATH"</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">buffSize</span><span class="p">);</span> <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>El valor de la variable de entorno <code>PATH</code> se copia en <code>path</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Usando <a href="https://man7.org/linux/man-pages/man3/setenv.3.html">setenv()</a> o <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setenvironmentvariable">SetEnvironmentVariable()</a> de forma similar, cualquier proceso puede crear variables de entorno que serán accesibles a sus procesos hijos, porque por defecto los nuevos procesos heredan un duplicado de las variables de entorno de su proceso padre.
Así se pueden pasar parámetros de configuración para alterar el comportamiento de los procesos hijo.</p>
</div>
<div class="paragraph">
<p>Todas las variantes de sistemas UNIX, así como MS-DOS y todas las versiones de Microsoft Windows soportan variables de entorno.</p>
</div>
</div>
<div class="sect5">
<h6 id="_herencia_de_recursos">Herencia de recursos</h6>
<div class="paragraph">
<p>En algunos sistemas operativos los procesos hijos pueden heredar cierto tipo de recursos del proceso padre, lo que también puede servir para inicializar y alterar el comportamiento del proceso hijo.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, en los sistemas POSIX todos los archivos abiertos por un proceso son heredados en el mismo estado por sus hijos.
Lo interesante es que en estos sistemas muchos recursos se gestionan como archivos.
Algunos ejemplo podrían ser: dispositivos de E/S, memoria compartida, tuberías, <em>sockets</em> y otros mecanismos de comunicación.</p>
</div>
<div class="paragraph">
<p>En POSIX todo proceso tiene, por defecto, tres archivos abiertos que corresponden a tres dispositivos de E/S especiales:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Entrada estándar</strong>, de dónde los procesos leen la entrada del teclado de la terminal.</p>
</li>
<li>
<p><strong>Salida estándar</strong>, donde el proceso escribe para mostrar texto en la pantalla de la terminal.</p>
</li>
<li>
<p><strong>Salida de error</strong>, usada para mostrar errores en la pantalla de la terminal.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Debido a la herencia de los archivos abiertos del proceso padre, todo proceso hijo tiene acceso a estos tres mismos dispositivos.
Y a su vez también la tendrán sus hijos y los hijos de éstos.
De esta manera, todo proceso tiene acceso a los dispositivos de E/S de la terminal donde se ejecuta.
Pero también permite a un proceso controlar el destino de la E/S de un proceso hijo —y de los hijos de éste—.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, si antes de crear el proceso hijo sustituye el dispositivo de salida estándar por un archivo real, todo lo que el hijo intente mostrar por pantalla se guardará en dicho archivo, en lugar de mostrarse.
Mientras que si lo hace con el dispositivo de entrada estándar, todo lo que pretenda leer de teclado realmente lo leerá de un archivo que el padre puede haber preparado, como si de algún tipo de control remoto se tratara.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Esta misma idea se puede extender a procesos que ofrecen servicios, ya sea a otros procesos del mismo sistema o a redes de ordenadores, como Internet.</p>
</div>
<div class="paragraph">
<p>Cada conexión con un cliente es como archivo abierto, por lo que los hijos del proceso heredan las conexiones.
Así que es común la estrategia de crear un hijo por conexión para que la atienda en nombre del padre, mientras éste se encarga de recibir nuevas conexiones.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>En Microsoft Windows existe un mecanismo similar pero no por defecto.
La función <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a> de Windows API permite indicar si se quiere que el nuevo proceso herede los recursos abiertos.
Y también tiene ajustes específicos para la entrada y salida estándar y la salida de error del nuevo proceso.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_qué_ocurre_con_la_ejecución_del_padre">Qué ocurre con la ejecución del padre</h5>
<div class="paragraph">
<p>Se suelen contemplar dos posibilidades en términos de la ejecución del padre:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Que el padre continúe ejecutándose al mismo tiempo que el hijo.
Es lo más común en los sistemas multitarea actuales.</p>
</li>
<li>
<p>Que le padre quede detenido a la espera que de algunos o todos sus hijos terminen.
Era lo más frecuente en sistemas monotarea, como <a href="https://es.wikipedia.org/wiki/MS-DOS">MS-DOS</a>.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_cómo_se_construye_el_espacio_de_direcciones_de_los_procesos_hijo">Cómo se construye el espacio de direcciones de los procesos hijo</h5>
<div class="paragraph">
<p>En general hay dos posibilidades:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Que el espacio de direcciones del proceso hijo sea un duplicado del que tiene el padre.
Es decir, que inicialmente el hijo tenga el mismo código y datos que el padre.
Es lo que hace <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> en los sistemas POSIX.</p>
</li>
<li>
<p>Que el espacio de direcciones del proceso hijo se cree desde cero y se cargue en él un nuevo programa.
Es lo que hace <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a> en Windows.
Por eso siempre hay que indicarle el nombre del programa que se quiere ejecutar en el nuevo proceso.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Esto lo veremos con más detalle en el <a href="#_ejemplos_de_operaciones_con_procesos">Apartado 9.7.3</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_terminación_de_procesos">9.7.2. Terminación de procesos</h4>
<div class="paragraph">
<p>Un proceso termina cuando se lo indica al sistema operativo con la llamada al sistema <strong>exit</strong>.
En ese momento puede devolver un valor de estado a su padre.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Esto ocurre en C y C&#43;&#43; incluso si el programa termina usando la sentencia <code>return</code> en <a href="https://en.cppreference.com/w/c/language/main_function">main()</a>.
Lo que ocurre es que es el código, introducido por el compilador, que llamó a <a href="https://en.cppreference.com/w/c/language/main_function">main()</a> es el que llama a <strong>exit</strong> usando el valor devuelto por <a href="https://en.cppreference.com/w/c/language/main_function">main()</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>El proceso padre puede esperar a que el hijo termine y recuperar ese valor a través de la llamada al sistema <strong>wait</strong>.
Cuando un proceso termina, todos los recursos son liberados, incluyendo: la memoria física y virtual, archivos y dispositivos abiertos, búferes de E/S, etc.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 2. Funciones de la API para salir, esperar y terminar procesos.</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">POSIX API</th>
<th class="tableblock halign-left valign-top">Windows API</th>
</tr>
</thead>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Salir</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.man7.org/linux/man-pages/man3/exit.3.html">exit()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess">ExitProcess()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Esperar (un hijo concreto)</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/waitpid.2.html">waitpid()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject">WaitForSingleObject()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Esperar (múltiples hijos)</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/wait.2.html">wait()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects">WaitForMultipleObject()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Terminar otro proceso</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/kill.2.html">kill()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminateprocess">TerminateProcess()</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>En todo caso un proceso puede provocar la terminación de otro proceso a través de una llamada al sistema.
Por ejemplo, en sistemas POSIX se usa un mecanismo llamado <strong>señales</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">kill</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">SIGTERM</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>mientras que en Windows API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">TerminateProcess</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Habitualmente el proceso que invoca estas funciones es el proceso padre, ya que puede que sea el único con permisos para hacerlo.</p>
</div>
<div class="paragraph">
<p>Los motivos para terminar un procesos hijo pueden ser:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>El hijo ha excedido el uso de algunos de los recursos reservados</strong>.
Obviamente esto tiene sentido cuando los hijos utilizan un subconjunto de los recursos asignados al padre.</p>
</li>
<li>
<p><strong>La tarea asignada al hijo ya no es necesaria</strong>.
Por ejemplo, se creó para comprimir un archivo pero el usuario ha pedido cancelar la operación.</p>
</li>
<li>
<p><strong>El padre termina y el sistema operativo está diseñado para no permitir que el hijo pueda seguir ejecutándose si no tiene un padre</strong>.
En esos sistemas, la terminación de un proceso provoca que el sistema operativo inicie lo que se denomina una <strong>terminación en cascada</strong>, en la que termina todos los procesos que cuelgan de dicho proceso.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En sistemas UNIX y estilo UNIX, si un proceso muere a sus hijos no terminan sino que se les reasigna como padre el proceso <strong>init</strong>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplos_de_operaciones_con_procesos">9.7.3. Ejemplos de operaciones con procesos</h4>
<div class="paragraph">
<p>En C estándar la función <a href="https://en.cppreference.com/w/c/program/system">system()</a> de la librería estándar permite ejecutar otro proceso, con sus argumentos, esperar a que termine y obtener el valor de estado con el que finalizó el proceso.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">system</span><span class="p">(</span><span class="s">"holamundo -v foo.txt"</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Esta función es portable.
Está disponible en cualquier sistema donde haya un compilador de C estándar, pero sus funcionalidades son bastante limitadas.
Por ejemplo, no permite que el programa padre continúe su ejecución mientras se ejecuta el hijo, aunque el sistema sea multitarea y ese sea el comportamiento por defecto.
Tampoco facilita el control de los recursos que son heredados por el proceso hijo o hacer redirecciones de los dispositivos de E/S estándar.</p>
</div>
<div class="paragraph">
<p>Como hemos comentado anteriormente, para acceder a todas las funcionalidades ofrecidas por los sistemas operativos, muchas veces es necesario utilizar directamente la librería del sistema.</p>
</div>
<div class="sect4">
<h5 id="_windows_api_2">Windows API</h5>
<div class="paragraph">
<p>En Windows la librería del sistema ofrece la función <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a>.
A diferencia de <a href="https://en.cppreference.com/w/c/program/system">system()</a>, recibe muchísimos argumentos, ya que permite configurar bastantes aspectos de la creación de un nuevo proceso.</p>
</div>
<div class="paragraph">
<p>En el <a href="#ejemplo_createprocess">Ejemplo 2</a> se puede ver como se usa <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a> para ejecutar un programa y esperar a que termine, de forma similar a como lo hace <a href="https://en.cppreference.com/w/c/program/system">system()</a>.</p>
</div>
<div id="ejemplo_createprocess" class="exampleblock">
<div class="title">Ejemplo 2. Crear un proceso usando Windows API</div>
<div class="content">
<div class="paragraph">
<p>El código fuente completo de este ejemplo está disponible en <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap09/createprocess.c">createprocess.c</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">STARTUPINFO</span> <span class="n">si</span> <span class="o">=</span> <span class="p">{</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">STARTUPINFO</span><span class="p">)</span> <span class="p">};</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="n">PROCESS_INFORMATION</span> <span class="n">pi</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span> <i class="conum" data-value="2"></i><b>(2)</b>

<span class="c1">// Crear procesos hijo y comprobar si no se creó con éxito.</span>
<span class="k">if</span><span class="p">(</span> <span class="o">!</span> <span class="n">CreateProcess</span><span class="p">(</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="nb">NULL</span><span class="p">,</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="s">"C:</span><span class="se">\\</span><span class="s">Windows</span><span class="se">\\</span><span class="s">System32</span><span class="se">\\</span><span class="s">charmap.exe"</span><span class="p">,</span>  <i class="conum" data-value="4"></i><b>(4)</b> <i class="conum" data-value="5"></i><b>(5)</b>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="n">FALSE</span><span class="p">,</span> <i class="conum" data-value="6"></i><b>(6)</b>
    <span class="mi">0</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span>  <i class="conum" data-value="7"></i><b>(7)</b>
    <span class="nb">NULL</span><span class="p">,</span>  <i class="conum" data-value="8"></i><b>(8)</b>
    <span class="o">&amp;</span><span class="n">si</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">pi</span> <span class="p">))</span>
<span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span> <span class="n">stderr</span><span class="p">,</span> <span class="s">"Error (%d) al crear el proceso.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">()</span> <span class="p">);</span> <i class="conum" data-value="9"></i><b>(9)</b>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">printf</span><span class="p">(</span> <span class="s">"[PADRE] El PID del nuevo proceso hijo es: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pi</span><span class="p">.</span><span class="n">dwProcessId</span> <span class="p">);</span>

<span class="c1">// Esperar hasta que el hijo termine.</span>
<span class="n">WaitForSingleObject</span><span class="p">(</span> <span class="n">pi</span><span class="p">.</span><span class="n">hProcess</span><span class="p">,</span> <span class="n">INFINITE</span> <span class="p">);</span> <i class="conum" data-value="10"></i><b>(10)</b>

<span class="n">DWORD</span> <span class="n">dwExitCode</span><span class="p">;</span>
<span class="n">GetExitCodeProcess</span><span class="p">(</span> <span class="n">pi</span><span class="p">.</span><span class="n">hProcess</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dwExitCode</span> <span class="p">);</span> <i class="conum" data-value="11"></i><b>(11)</b>
<span class="n">printf</span><span class="p">(</span> <span class="s">"[PADRE] El valor de salida del proceso hijo es: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dwExitCode</span> <span class="p">);</span>

<span class="c1">// Cerrar los manejadores del proceso y del hilo principal del proceso.</span>
<span class="n">CloseHandle</span><span class="p">(</span> <span class="n">pi</span><span class="p">.</span><span class="n">hProcess</span> <span class="p">);</span> <i class="conum" data-value="12"></i><b>(12)</b>
<span class="n">CloseHandle</span><span class="p">(</span> <span class="n">pi</span><span class="p">.</span><span class="n">hThread</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfoa">STARTUPINFO</a> sirve para pasar a <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a> parámetros adicionales sobre el inicio de la aplicación, como configurar la redirección de la E/S estándar o características de la primera ventana creada por la aplicación —en aplicaciones con interfaz gráfica—.
Si no se va a usar, debe inicializarse a 0, excepto el primer campo que debe contener el tamaño de la estructura.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-process_information">PROCESS_INFORMATION</a> sirve para devolver el manejador y el <strong>identificador de proceso</strong> del nuevo proceso.
Es común inicializar la estructura a 0.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a> devuelve <code>TRUE</code> o <code>FALSE</code>, en función de si ha tenido éxito o no, respectivamente.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>El primer argumento —<code>lpApplicationName</code>— se usa para pasar la ruta del ejecutable, mientras que los argumentos de línea de comando generalmente se pasan por el segundo —<code>lpCommandLine</code>—.
Si en <code>lpApplicationName</code> se indica NULL, se puede pasar todo junto por <code>lpCommandLine</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>En <code>lpCommandLine</code> indicamos la ruta al ejecutable y los argumentos de la línea de comandos, si hicieran falta.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Con <code>bInheritHandles</code> a <code>FALSE</code> señalamos que no queremos que el proceso hijo herede ningún manejador abierto del proceso padre.
Estos manejadores son recursos a los que el padre tiene acceso y, si fuera necesario, el hijo también podría tenerlo.
Los manejadores pueden representar, por ejemplo, archivos abiertos, tuberías, <em>sockets</em> u otros mecanismos de comunicación, procesos o archivos mapeados en memoria, entre muchos otros tipos de recursos.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Con <code>NULL</code> en <code>lpEnvironment</code> indicamos que el hijo herede el conjunto de variables de entorno directamente del padre.
La otra opción es indicar un nuevo conjunto de variables de entorno.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td><code>lpCurrentDirectory</code> sirve para indicar el directorio del trabajo del proceso hijo.
Es decir, el directorio respecto al que se resolverán las rutas de archivo relativas.
Con <code>NULL</code> indicamos que utilice la misma ruta que el proceso padre.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>Si <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a> falla, devuelve <code>FALSE</code>.
Llamando a <a href="https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError()</a> obtiene el código que identifica el motivo del error de la última función utilizada de Windows API.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>Usando <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject">WaitForSingleObject()</a> hacemos que el proceso padre se quede en estado <strong>esperando</strong> —sin que pueda seguir ejecutándose— hasta que el proceso hijo termine.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>Cuando el proceso ha terminado, el padre puede conocer su valor de salida.
Es decir, el valor usado para terminar en la sentencia <code>return</code> de <a href="https://en.cppreference.com/w/c/language/main_function">main()</a> o al llamar a  <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess">ExitProcess()</a> en el programa del proceso hijo.
Como convención, el hijo indica con un 0 que terminó con éxito, mientras que con un valor distinto indica que tuvo algún tipo de problema.</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>Cuando ya no hace falta obtener información del proceso hijo o manipularlo, es necesario cerrar los manejadores devueltos por <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a>.
Así el sistema operativo sabe que las estructuras de datos relacionadas con el proceso hijo ya no son necesarias, por lo que pueden liberarse.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a> siempre necesita la ruta a un ejecutable —sea en el primer o en el segundo argumento de la función— porque se utiliza para crear un proceso completamente limpio y ejecutar en él un nuevo programa.</p>
</div>
</div>
<div class="sect4">
<h5 id="procesos_posix_api">POSIX API</h5>
<div class="paragraph">
<p>Por el contrario, en los sistemas POSIX se utiliza una estrategia muy diferente.
Los nuevos procesos se crean con la llamada <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>, que se encargar de crearlo como una copia del proceso padre.</p>
</div>
<div class="exampleblock">
<div class="title">Ejemplo 3. Crear un proceso en sistemas POSIX</div>
<div class="content">
<div class="paragraph">
<p>El código fuente completo de este ejemplo está disponible en <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap09/fork.c">fork.c</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">pid_t</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span> <i class="conum" data-value="7"></i><b>(7)</b>

<span class="c1">// Crear un proceso hijo</span>
<span class="n">pid_t</span> <span class="n">child</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span> <i class="conum" data-value="1"></i><b>(1)</b>

<span class="k">if</span> <span class="p">(</span><span class="n">child</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">{</span>
    <span class="c1">// Aquí solo entra el proceso hijo</span>
    <span class="n">puts</span><span class="p">(</span> <span class="s">"[HIJO] ¡Soy el proceso hijo!"</span> <span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[HIJO] El valor de mi variable 'child' es: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">child</span> <span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[HIJO] Este es mi PID: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">()</span> <span class="p">);</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[HIJO] El valor de mi variable 'pid' es: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pid</span> <span class="p">);</span> <i class="conum" data-value="7"></i><b>(7)</b>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[HIJO] El PID de mi padre es: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getppid</span><span class="p">()</span> <span class="p">);</span> <i class="conum" data-value="7"></i><b>(7)</b>

    <span class="n">puts</span><span class="p">(</span> <span class="s">"[HIJO] Durmiendo 10 segundos..."</span> <span class="p">);</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[HIJO] Salgo con %d ¡Adios!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">status</span> <span class="p">);</span>
    <span class="k">return</span> <span class="n">status</span><span class="p">;</span> <i class="conum" data-value="9"></i><b>(9)</b>
<span class="p">}</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">child</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>  <i class="conum" data-value="3"></i><b>(3)</b> <i class="conum" data-value="4"></i><b>(4)</b>
<span class="p">{</span>
    <span class="c1">// Aquí solo entra el proceso padre</span>
    <span class="n">puts</span><span class="p">(</span> <span class="s">"[PADRE] ¡Soy el proceso padre!"</span> <span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[PADRE] El valor de mi variable 'child' es: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">child</span> <span class="p">);</span>  <i class="conum" data-value="3"></i><b>(3)</b> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[PADRE] Este es mi PID: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">()</span> <span class="p">);</span> <i class="conum" data-value="7"></i><b>(7)</b>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[PADRE] El valor de mi variable 'pid' es: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pid</span> <span class="p">);</span> <i class="conum" data-value="7"></i><b>(7)</b>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[PADRE] El PID de mi padre es: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getppid</span><span class="p">()</span> <span class="p">);</span>

    <span class="n">puts</span><span class="p">(</span> <span class="s">"[PADRE] Voy a esperar a que mi hijo termine..."</span> <span class="p">);</span>

    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
    <span class="n">wait</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">status</span> <span class="p">);</span>  <i class="conum" data-value="8"></i><b>(8)</b> <i class="conum" data-value="9"></i><b>(9)</b>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[PADRE] El valor de salida de mi hijo fue: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">WEXITSTATUS</span><span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">);</span> <i class="conum" data-value="9"></i><b>(9)</b>

    <span class="n">puts</span><span class="p">(</span> <span class="s">"[PADRE] ¡Adios!"</span> <span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span> <i class="conum" data-value="5"></i><b>(5)</b>
    <span class="c1">// Aquí solo entra el padre si no pudo crear el hijo</span>
    <span class="n">fprintf</span><span class="p">(</span> <span class="n">stderr</span><span class="p">,</span> <span class="s">"Error (%d) al crear el procesos: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">errno</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">)</span> <span class="p">);</span> <i class="conum" data-value="6"></i><b>(6)</b>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>El proceso llama a <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> pero al retornar de la llamada vuelven dos procesos: el proceso padre, que es el que llamó originalmente a <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>, y el proceso hijo.
Como el proceso hijo es una copia del padre, tiene el mismo código, las mismas variables y los mismos recursos que tenía el padre en el momento de llamar a <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>.
La única diferencia es el valor devuelto por <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>, que guardamos en <code>child</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Los dos procesos ejecutan el mismo programa, así que ambos llegan a la línea detrás del <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>.
Como queremos que cada proceso haga cosas diferentes, necesitamos que cada uno vaya a ramas distintas del código.
Eso se hace comprobando el valor de <code>child</code>, porque si vale 0 es que el proceso que actualmente ejecuta el programa es el hijo.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Si, por el contrario, el valor de <code>child</code> es mayor de 0, el proceso que ejecuta el programa es el padre y el valor de <code>child</code> es el PID del proceso hijo creado.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Así que el valor de <code>child</code> en el padre coincide con el devuelto por <a href="https://man7.org/linux/man-pages/man2/getpid.2.html">getpid()</a> en el hijo.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Finalmente, si el valor devuelto por <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> es negativo, es que ocurrió un error y el proceso hijo no llegó a crearse.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>En los sistemas POSIX es común que las llamadas al sistema devuelvan un valor negativo para indicar un error.
El motivo del error se puede conocer a través de la variable global <a href="https://man7.org/linux/man-pages/man3/errno.3.html">errno</a>, que siempre guarda el código de identificación del error en la última función invocada de la API POSIX.
La función <a href="https://man7.org/linux/man-pages/man3/strerror.3.html">strerror()</a> permite obtener un texto descriptivo de cualquier valor de <a href="https://man7.org/linux/man-pages/man3/errno.3.html">errno</a>, lo que siempre resulta útil para crear mensajes de error que ayuden a determinar dónde estuvo el problema.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>A modo de ejemplo hemos guardado el PID del proceso en la variable <code>pid</code>, antes de la llamada a <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>.
Como el proceso hijo es una copia del proceso padre, la variable existe en ambos pero en el proceso hijo su valor coincide con lo devuelto por <a href="https://man7.org/linux/man-pages/man2/getppid.2.html">getppid()</a> mientras que en el proceso padre con lo devuelto por <a href="https://man7.org/linux/man-pages/man2/getpid.2.html">getpid()</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td><a href="https://man7.org/linux/man-pages/man2/wait.2.html">wait()</a> hace que el proceso padre interrumpa su ejecución hasta que algún hijo termine y devuelve el estado de salida en <code>status</code>.
<div class="paragraph">
<p>Debemos asegurarnos de llamar a <a href="https://man7.org/linux/man-pages/man2/wait.2.html">wait()</a> o <a href="https://man7.org/linux/man-pages/man2/waitpid.2.html">waitpid()</a> una vez por cada proceso hijo, en algún momento, porque así es como el sistema sabe que el padre ya no tiene más interés en el proceso y puede liberar su PCB, dónde se guarda el estado de salida.
No hacerlo genera <strong>procesos zombi</strong> o <em>defunct</em>.</p>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>El valor de salida del proceso hijo lo obtiene el proceso a través del estado de salida devuelto por <a href="https://man7.org/linux/man-pages/man2/wait.2.html">wait()</a>.
Pero ese estado contiene más información sobre la causa por la que el proceso terminó.
Para recuperar el valor de salida se usa la macro <code>WEXITSTATUS</code> sobre el estado de salida.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Lo siguiente es un posible resultado de ejecutar el programa anterior en una terminal de Linux,
numerado con las anotaciones realizadas al código:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./fork
[PADRE] ¡Soy el proceso padre!
[PADRE] El valor de mi variable 'child' es: 2360 <i class="conum" data-value="4"></i><b>(4)</b>
[PADRE] Este es mi PID: 2359 <i class="conum" data-value="7"></i><b>(7)</b>
[PADRE] El valor de mi variable 'pid' es: 2359 <i class="conum" data-value="7"></i><b>(7)</b>
[HIJO] ¡Soy el proceso hijo!
[PADRE] El PID de mi padre es: 1857
[PADRE] Voy a esperar a que mi hijo termine...
[HIJO] El valor de mi variable 'child' es: 0 <i class="conum" data-value="2"></i><b>(2)</b>
[HIJO] Este es mi PID: 2360
[HIJO] El valor de mi variable 'pid' es: 2359 <i class="conum" data-value="7"></i><b>(7)</b>
[HIJO] El PID de mi padre es: 2359 <i class="conum" data-value="7"></i><b>(7)</b>
[HIJO] Durmiendo 10 segundos...
[HIJO] Salgo con 42 ¡Adios! <i class="conum" data-value="9"></i><b>(9)</b>
[PADRE] El valor de salida de mi hijo fue: 42 <i class="conum" data-value="9"></i><b>(9)</b>
[PADRE] ¡Adios!</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Aunque pueda parecer algo complejo, esta estrategia facilita la comunicación entre procesos.
Es muy sencillo lanzar otro proceso para hacer una tarea en paralelo que tendrá automáticamente una copia de los datos del proceso original.</p>
</div>
<div class="paragraph">
<p>Como se trata de una copia, las nuevas variables o la modificación de variables existentes que realice cualquiera de los procesos, no serán visibles para el otro.
Es decir, después del <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> ambos procesos son complemente independientes.
Pero como el proceso hijo hereda el acceso a todo tipo de recursos abiertos por el proceso padre, como: archivos, tuberías, <em>sockets</em> o regiones de memoria compartida, entre muchos otros recursos; es muy sencillo crear un canal de comunicación entre ambos procesos, si fuera necesario.</p>
</div>
<div class="paragraph">
<p>Sin embargo, <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> no proporciona una funcionalidad similar a la de <a href="https://en.cppreference.com/w/c/program/system">system()</a>.
No sirve para crear otro proceso con un programa diferente.
Para eso necesitamos <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a>, una familia de funciones cuyo propósito es cargar un nuevo programa en el proceso que la invoca.</p>
</div>
<div class="exampleblock">
<div class="title">Ejemplo 4. Ejecutar otro programa en un proceso nuevo en sistemas POSIX</div>
<div class="content">
<div class="paragraph">
<p>El código fuente completo de este ejemplo está disponible en <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap09/fork-exec.c">fork-exec.c</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="c1">// Crear un proceso hijo</span>
<span class="n">pid_t</span> <span class="n">child</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span> <i class="conum" data-value="1"></i><b>(1)</b>

<span class="k">if</span> <span class="p">(</span><span class="n">child</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Aquí solo entra el proceso hijo</span>
    <span class="n">puts</span><span class="p">(</span> <span class="s">"[HIJO] ¡Soy el proceso hijo!"</span> <span class="p">);</span>
    <span class="n">puts</span><span class="p">(</span> <span class="s">"[HIJO] Voy a ejecutar el comando 'ls'"</span> <span class="p">);</span>

    <span class="cm">/* Hacer otras cosas necesarias antes de ejecutar el programa... */</span> <i class="conum" data-value="4"></i><b>(4)</b>

    <span class="n">execl</span><span class="p">(</span> <span class="s">"/bin/ls"</span><span class="p">,</span> <span class="s">"ls"</span><span class="p">,</span> <span class="s">"-l"</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">);</span>   <i class="conum" data-value="2"></i><b>(2)</b> <i class="conum" data-value="3"></i><b>(3)</b> <i class="conum" data-value="5"></i><b>(5)</b>

    <span class="n">fprintf</span><span class="p">(</span> <span class="n">stderr</span><span class="p">,</span> <span class="s">"Error (%d) al ejecuta el programa: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">errno</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">)</span> <span class="p">);</span> <i class="conum" data-value="6"></i><b>(6)</b>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <i class="conum" data-value="7"></i><b>(7)</b>
<span class="p">}</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">child</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Aquí solo entra el proceso padre</span>
    <span class="n">puts</span><span class="p">(</span> <span class="s">"[PADRE] ¡Soy el proceso padre!"</span> <span class="p">);</span>
    <span class="n">puts</span><span class="p">(</span> <span class="s">"[PADRE] Voy a esperar a que mi hijo termine..."</span> <span class="p">);</span>

    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
    <span class="n">wait</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">status</span> <span class="p">);</span> <i class="conum" data-value="8"></i><b>(8)</b>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[PADRE] El valor de salida de mi hijo fue: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">WEXITSTATUS</span><span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">);</span>

    <span class="n">puts</span><span class="p">(</span> <span class="s">"[PADRE] ¡Adios!"</span> <span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="c1">// Aquí solo entra el padre si no pudo crear el hijo</span>
    <span class="n">fprintf</span><span class="p">(</span> <span class="n">stderr</span><span class="p">,</span> <span class="s">"Error (%d) al crear el procesos: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">errno</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">)</span> <span class="p">);</span>
    <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Primero creamos un proceso hijo, donde ejecutaremos el nuevo programa.
Si nos diera por llamar directamente a una función de la familia <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a>, nuestro programa sería sustituido y no tendríamos ningún control sobre lo que pase después.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>En la rama de código que se va a ejecutar en el hijo —gracias a la comprobación del valor devuelto por <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>— ejecutamos la función de la familia <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> que más nos interese.
Esta función no crea otro proceso, sino que carga el programa indicado en el proceso hijo, sustituyendo así a nuestro programa.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Todas las funciones de la familia <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> reciben como primer argumento la ruta al ejecutable, pero en <code>execlp()</code> en particular, a continuación se indican los argumentos de línea de comandos, tal y como queremos que los reciba el programa en el argumento <code>argv</code> de su <a href="https://en.cppreference.com/w/c/language/main_function">main()</a>.
Es decir, que el programa del comando <code>/bin/ls</code> recibirá <code>ls</code> y <code>-l</code> en <code>argv[0]</code> y <code>argv[1]</code>, respectivamente.
El <code>NULL</code> del final indica cuando no hay más argumentos de línea de comandos para pasar.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Antes de ejecutar la función <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> se pueden hacer cosas para configurar adecuadamente el proceso donde se ejecutará el nuevo programa.
Por ejemplo, cambiar las variables de entorno, redirigir la E/S estándar, cambiar el usuario al que pertenece el proceso —si originalmente se ejecuta con un usuario con ese privilegio— o cerrar archivos abiertos del procesos padre que ha heredado el proceso hijo y que, obviamente, no queremos que se queden abiertos para programas diferentes al nuestro.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Las funciones <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> no retornan si tienen éxito, porque el programa actual es sustituido por el indicado, que comenzará a ejecutarse de su <a href="https://en.cppreference.com/w/c/language/main_function">main()</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Si la función <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> retorna es porque falló y, como es común, el motivo del error está disponible en <a href="https://man7.org/linux/man-pages/man3/errno.3.html">errno</a>.
Un motivo de fallo muy típico es que el ejecutable indicado no exista.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Si la función <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> retorna, la ejecución del programa en el proceso hijo continua hasta salir de <a href="https://en.cppreference.com/w/c/language/main_function">main()</a>.
Generalmente, el proceso hijo no es útil si no puede ejecutar el programa que le hemos indicado.
Por eso es importante asegurarnos de que el proceso hijo termina, si <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> falla.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Mientras todo lo anterior ocurre en el proceso hijo, el proceso padre espera.
Cuando el proceso hijo termine, el padre podrá obtener su estado de salir para saber si tuvo éxito o no.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Lo siguiente es un posible resultado de ejecutar el programa anterior en una terminal de Linux,
numerado con las anotaciones realizadas al código:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./fork-exec
[PADRE] ¡Soy el proceso padre!
[PADRE] Voy a esperar a que mi hijo termine...
[HIJO] ¡Soy el proceso hijo!
[HIJO] Voy a ejecutar el comando 'ls'
total 628 <i class="conum" data-value="2"></i><b>(2)</b>
-rwxr--r-- 1 jesus jesus 72640 Sep 16 13:41 fifo-client
-rwxr--r-- 1 jesus jesus 72784 Sep 16 13:41 fifo-server
-rwxr--r-- 1 jesus jesus 20056 Sep 16 13:41 fork
-rwxr-xr-x 1 jesus jesus 19896 Sep 18 13:24 fork-exec
-rwxr--r-- 1 jesus jesus 80744 Sep 16 13:41 mmap
-rwxr--r-- 1 jesus jesus 45712 Sep 16 13:41 pipe
-rwxr--r-- 1 jesus jesus 87024 Sep 16 13:41 shared-memory
-rwxr--r-- 1 jesus jesus 77696 Sep 16 13:41 shared-memory-sync
-rwxr--r-- 1 jesus jesus 19608 Sep 16 13:41 softstack-c
-rwxr--r-- 1 jesus jesus 39328 Sep 16 13:41 softstack-cpp
-rwxr--r-- 1 jesus jesus  9920 Sep 16 13:41 syscall
-rwxr--r-- 1 jesus jesus 40712 Sep 16 13:41 threads-mutex-pthread
-rwxr--r-- 1 jesus jesus 39944 Sep 16 13:41 threads-pthread
[PADRE] El valor de salida de mi hijo fue: 0 <i class="conum" data-value="8"></i><b>(8)</b>
[PADRE] ¡Adios!</pre>
</div>
</div>
<div class="paragraph">
<p>Veamos qué ocurre si la línea de la función <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> fuera:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">execl</span><span class="p">(</span> <span class="s">"/bin/ls"</span><span class="p">,</span> <span class="s">"ls"</span><span class="p">,</span> <span class="s">"-l"</span><span class="p">,</span> <span class="s">"/foo"</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>para intentar ver el contenido del directorio <code>/foo</code>, que no existe:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./fork-exec
[PADRE] ¡Soy el proceso padre!
[PADRE] Voy a esperar a que mi hijo termine...
[HIJO] ¡Soy el proceso hijo!
[HIJO] Voy a ejecutar el comando 'ls'
ls: cannot access '/foo': No such file or directory <i class="conum" data-value="1"></i><b>(1)</b>
[PADRE] El valor de salida de mi hijo fue: 2 <i class="conum" data-value="2"></i><b>(2)</b>
[PADRE] ¡Adios!</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>El comando <code>ls</code> se ejecuta pero falla porque el directorio indicado no existe.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Por eso el programa, al terminar el proceso, no devuelve 0 sino 2 y es ese el valor que recibe el proceso padre.
Esto le permite saber al proceso padre que el comando <code>ls</code> no tuvo éxito.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Y finalmente cambiemos la línea de la función <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> así:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">execl</span><span class="p">(</span> <span class="s">"/noexists"</span><span class="p">,</span> <span class="s">"ls"</span><span class="p">,</span> <span class="s">"-l"</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>para que intente ejecutar un programa que no existe:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./fork-exec
[PADRE] ¡Soy el proceso padre!
[PADRE] Voy a esperar a que mi hijo termine...
[HIJO] ¡Soy el proceso hijo!
[HIJO] Voy a ejecutar el comando 'ls'
Error (2) al ejecuta el programa: No such file or directory <i class="conum" data-value="1"></i><b>(1)</b>
[PADRE] El valor de salida de mi hijo fue: 255 <i class="conum" data-value="2"></i><b>(2)</b>
[PADRE] ¡Adios!</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> falla y se muestra el mensaje de error con el motivo.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>El proceso hijo termina con -1 y así llega ese valor al proceso padre.
Al utilizar un valor de salida diferente a los que usa el programa que intenta ejecutar, el padre distingue las terminaciones causadas por errores al llamar a <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> de los errores del propio programa.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Todas las funciones <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> hacen lo mismo.
Primero liberan la memoria reservada en el proceso, después cargan el nuevo programa y finalmente inicia la ejecución del programa desde su punto de entrada.
La diferencia entre las distintas funciones está en los argumentos que aceptan.
Esa diferencia se puede conocer fijándonos en las letras al final del nombre de cada función:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Sin 'p'</strong>, como <code>execl()</code> o <code>execv()</code>, el primer argumento de la función es la ruta hasta el ejecutable del programa que se quiere ejecutar.</p>
</li>
<li>
<p><strong>Con 'p'</strong>, como <code>execlp()</code> o <code>execvp()</code>, la función busca el ejecutable como lo hace la <em>shell</em>.
Es decir, si el primer argumento no contiene ninguna '/' se toma como el nombre del ejecutable y se busca en los directorios listados en la variable de entorno <code>PATH</code>.
Si el primero argumento contienen alguna '/', se considera una ruta y se busca directamente el ejecutable en ella.</p>
</li>
<li>
<p><strong>Con 'l'</strong>, como <code>execl()</code> o <code>execlp()</code>, los argumentos de línea de comandos para pasar al programa se indican directamente como argumentos diferentes de la función —por ejemplo <code>execl("/bin/ls", "ls", "-l", "-a" NULL)</code>— lo que es ideal cuando el número de argumentos es fijo.
La lista de argumentos debe terminar en <code>NULL</code>.</p>
</li>
<li>
<p><strong>Con 'v'</strong>, como <code>execv()</code> o <code>execvp()</code>, los argumentos de la línea de comandos para pasar al programa se indican en un <em>array</em> de punteros a cadenas terminadas en '\0', lo que resulta muy práctico si el número de argumentos es desconocido en el momento de compilar.
El último elemento del <em>array</em> debe apuntar a <code>NULL</code>.
Por ejemplo:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">"ls"</span><span class="p">,</span> <span class="s">"-l"</span><span class="p">,</span> <span class="s">"-a"</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>
<span class="n">execv</span><span class="p">(</span><span class="s">"/bin/ls"</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p><strong>Con 'e'</strong>, como <code>execvpe()</code> o <code>execle()</code>, la función admite un argumento adicional para indicar el conjunto de variables de entorno con el que se ejecutará el nuevo programa.
Con las otras funciones <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> se conservan las variables de entorno actuales en el proceso que llama a la función.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_procesos_cooperativos">9.8. Procesos cooperativos</h3>
<div class="paragraph">
<p>Desde el punto de vista de la cooperación podemos clasificar los procesos en dos grupos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Los <strong>procesos independientes</strong>, que no afectan o pueden ser afectados por otros procesos del sistema. Cualquier proceso que no comparte datos —temporales o persistentes— con otros procesos es independiente.</p>
</li>
<li>
<p>Los <strong>procesos cooperativos</strong>, que pueden afectar o ser afectados por otros procesos ejecutados en el sistema.
Los procesos que comparten datos, sea cual sea la forma en la que lo hacen, siempre son cooperativos.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_motivaciones_para_la_colaboración_entre_procesos">9.8.1. Motivaciones para la colaboración entre procesos</h4>
<div class="paragraph">
<p>Hay diversos motivos para proporcionar un entorno que permita la cooperación de los procesos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Compartición de información</strong>.
Dado que varios usuarios pueden estar interesados en los mismos bloques de información —por ejemplo, en un archivo compartido— el sistema operativo debe proporcionar un entorno que permita el acceso concurrente a este tipo de recursos.</p>
</li>
<li>
<p><strong>Velocidad de cómputo</strong>.
Para que una tarea se ejecute más rápido se puede partir en subtareas que se ejecuten en paralelo.
Es importante destacar que la mejora en la velocidad sólo es posible si el sistema tiene varios componentes de procesamiento como procesadores —si se quiere acelerar la ejecución en la CPU— o canales E/S —si se quieren acelerar las operaciones de E/S —.</p>
</li>
<li>
<p><strong>Modularidad</strong>.
Podemos querer crear nuestro software de forma modular, dividiendo las funciones del programa en procesos separados que se comunican entre sí.</p>
</li>
<li>
<p><strong>Conveniencia</strong>.
Incluso un usuario individual puede querer hacer varias tareas al mismo tiempo.
Por ejemplo, editar, imprimir y compilar al mismo tiempo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Las ejecución simultánea de procesos cooperativos requiere mecanismos tanto para comunicar unos con otros como para sincronizar sus acciones (véase el <a href="#_sincronización">Capítulo 13</a>).</p>
</div>
</div>
<div class="sect3">
<h4 id="_comunicación_entre_procesos">9.8.2. Comunicación entre procesos</h4>
<div class="paragraph">
<p>Para comunicar procesos cooperativos existen diversas aproximaciones, que en general se pueden encajar en alguna de las siguientes estrategias:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Memoria compartida</dt>
<dd>
<p>Método de comunicación en el que los procesos utilizan regiones compartidas de la memoria principal para compartir información.</p>
</dd>
<dt class="hdlist1">Paso de mensajes</dt>
<dd>
<p>Método en el que los procesos utilizan funciones del sistema operativo para enviarse mensajes entre ellos, compartiendo información y sincronizando acciones, sin necesidad de compartir memoria.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>En la <a href="#modelos_de_comunicación">Figura 29</a> se puede un esquema comparativo entre ambos modelos de comunicación.
Veremos cada uno en detalle en el <a href="#_memoria_compartida">Capítulo 11</a> y el <a href="#_comunicación_mediante_de_paso_de_mensajes">Capítulo 10</a>, respectivamente.</p>
</div>
<div id="modelos_de_comunicación" class="imageblock">
<div class="content">
<img src="C09-procesos/media/modelos_comunicación.svg" alt="modelos comunicación">
</div>
<div class="title">Figura 29. Modelos de comunicación.</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comunicación_mediante_de_paso_de_mensajes">10. Comunicación mediante de paso de mensajes</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>32 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>El <strong>paso de mensajes</strong> es un mecanismo que permite a los procesos compartir información y sincronizar sus acciones sin necesidad de compartir recursos —compartir memoria, archivos, etc.—</p>
</div>
<div class="paragraph">
<p>Esto lo hace especialmente útil en entornos distribuidos, dónde los procesos a comunicar residen en ordenadores diferentes conectados a una red, por lo que tiene muy difícil —o incluso imposible— compartir memoria u otros recursos para comunicarse.
En este caso, el sistema operativo es el encargado de codificar los mensajes y enviarlos a través de la red para hacerlos llegar a su destinatario.
La web —donde un navegador se conecta a un servidor web para obtener contenido— y el resto de servicios de Internet son ejemplos de sistemas de paso de mensajes.</p>
</div>
<div class="paragraph">
<p>El sistema de paso de mensajes debe ser proporcionado por el sistema operativo que, a diferencia de cuando se usa memoria compartida, se encarga de la sincronización —ya que no existen riesgos en el envío y recepción de mensajes al mismo tiempo— y de establecer el formato que deben tener los datos del mensaje.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En alguna fuentes se sigue haciendo referencia al término <strong>IPC</strong> (<em>Interprocess Communication</em>) —o <strong>comunicación entre procesos</strong>— para identificarlo exclusivamente con <strong>sistemas de paso de mensajes</strong>.
Sin embargo, la <strong>memoria compartida</strong> y otras técnicas también sirven para «comunicar procesos», por lo que es más adecuado usar el término <strong>IPC</strong> para englobar todas las técnicas conocidas de comunicación entre procesos.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Los sistemas de paso de mensaje de cualquier sistema operativo debe proporcionar al menos dos llamadas al sistema similares a:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>send( message )</strong> para mandar mensajes a otro proceso.</p>
</li>
<li>
<p><strong>receive( &amp;message )</strong> para recibir mensajes de otro proceso y copiarlo en <em>message</em>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Vamos a hablar de funciones de un sistema de paso de mensajes hipotético.
Meros ejemplos para ilustrar la diferentes alternativas.
Esto no significa que en los sistemas operativos reales las funciones se llamen así y tengan esos mismos argumentos.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Para que estas llamadas puede enviar y recibir mensajes entre dos procesos es necesario que haya un <strong>enlace de comunicaciones</strong> entre ambos.
No trataremos aquí la implementación física del enlace —que por ejemplo puede ser mediante memoria compartida, un bus hardware o una red de ordenadores— sino de su implementación lógica, es decir, las características de la interfaz que usan las aplicaciones para comunicarse con sus correspondientes operaciones de envío y recepción.</p>
</div>
<div class="sect2">
<h3 id="_tamaño_del_mensaje">10.1. Tamaño del mensaje</h3>
<div class="paragraph">
<p>Los diseñadores del sistema operativo deben escoger entre implementar un sistema de paso de mensajes con mensajes de tamaño fijo o mensajes de tamaño variable:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Mensajes de tamaño fijo</strong>.
La implementación del sistema operativo es muy sencilla pero el uso de la interfaz por parte de las aplicaciones es mucho más compleja.</p>
<div class="paragraph">
<p>Por ejemplo, para comunicar procesos en un mismo ordenador cada enlace puede tener un búfer de tamaño fijo donde se copia el mensaje enviado y de donde se extrae el mensaje al recibirlo.
Esto es muy sencillo de implementar en el sistema operativo.
Sin embargo, si el desarrollador de la aplicación quiere enviar algo de mayor tamaño que el tamaño del mensaje, debe trocearlo en varios mensajes para enviarlo y reconstruirlo al recibirlo.</p>
</div>
</li>
<li>
<p><strong>Mensajes de tamaño variable</strong>.
La implementación del sistema operativo es más compleja, ya que ahora tiene que gestionar la memoria para almacenar mensajes de tamaño variable hasta que son recibidos.
Sin embargo, la programación de aplicaciones es más simple puesto que el programador puede mandar mensajes de cualquier tamaño sin ninguna preocupación</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_comunicación_orientada_a_flujos">10.1.1. Comunicación orientada a flujos</h4>
<div class="paragraph">
<p>En algunos sistemas con <strong>mensajes de tamaño variable</strong> no se preserva la separación entre mensajes al recibirlos.
Es decir, que los procesos leen un número arbitrario de bytes, donde puede haber parte de un mensaje o varios mensajes al mismo tiempo.
Por ejemplo, en esos sistemas el transmisor puede mandar tres mensajes de 16000, 3200 y 100 bytes, pero el receptor leer la secuencia de bytes en bloques de 512 bytes.</p>
</div>
<div class="paragraph">
<p>A esto se lo denomina <strong>comunicación orientada a flujos</strong> o <strong><em>(streams)</em></strong>.
Si usamos este tipo de sistema es importante conservar la separación entre los mensajes recibidos, será nuestra responsabilidad escoger un formato de mensaje adecuado que permita al receptor recuperar dónde comienza y termina un mensaje dentro de la secuencia de bytes.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_referenciación">10.2. Referenciación</h3>
<div class="paragraph">
<p>Los procesos que se quieran comunicar debe tener una forma de señalarse el uno al otro.
Para ello el diseñador del sistema puede elegir que el sistema de paso de mensajes sea con comunicación directa o indirecta.</p>
</div>
<div class="sect3">
<h4 id="_comunicación_directa">10.2.1. Comunicación directa</h4>
<div class="paragraph">
<p>En la <strong>comunicación directa</strong> cada proceso debe nombrar explícitamente al proceso destinatario o receptor de la información.
Por ejemplo, ahora las llamadas al sistema básicas podrían ser así:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>send( A, message )</strong> para mandar un mensaje al proceso identificado como «A».</p>
</li>
<li>
<p><strong>receive( A, &amp;message )</strong> para recibir un mensaje del proceso identificado como «A», copiándolo en «<em>message</em>».</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>De hecho el ejemplo anterior corresponde a un caso de <strong>comunicación directa</strong> con <strong>direccionamiento simétrico</strong> pero existe una variante de ese mismo esquema denominado <strong>direccionamiento asimétrico</strong> donde el receptor puede recibir mensajes de cualquier proceso, de forma que al volver de la llamada recibe el mensaje y la identidad del remitente.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>send( A, message )</strong> para mandar un mensaje al proceso identificado como «A»</p>
</li>
<li>
<p><strong>receive( &amp;pid, &amp;message )</strong> para recibir un mensaje de cualquier proceso, recibiendo en «<em>message</em>» una copia del <em>message</em> y en «pid» la identidad del remitente.</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>En resumen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En el <strong>direccionamiento simétrico</strong> tanto el proceso que envía como el que recibe tienen que identificar al otro para comunicarse.</p>
</li>
<li>
<p>En el <strong>direccionamiento asimétrico</strong> sólo el proceso que envía identifica a que recibe, mientras que este último no tiene que nombrar al remitente.
Es el sistema operativo el que informa de quién es el remitente del mensaje que se ha recibido.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Un <strong>enlace de comunicaciones</strong> según este esquema tiene las siguientes características:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Un enlace se establece automáticamente entre cada par de procesos que quieren comunicarse.
Por tanto, los procesos sólo necesitan conocer la identidad de los otros para comunicarse.</p>
</li>
<li>
<p>Cada enlace se asocia exactamente a dos procesos.</p>
</li>
<li>
<p>Entre cada par de procesos sólo hay un enlace.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>La principal desventaja de este tipo de comunicación es que si cambia el identificador de un proceso hay que actualizar todas las referencias en todos los procesos que se comunican con él.
En general cualquier técnica que requiera que los identificadores de los procesos sean establecidos explícitamente en el código de los programas no es deseable, puesto que en muchos sistemas los identificadores de los procesos cambian de una ejecución a otra.
Por lo tanto, lo mejor sería disponer de una solución con un nivel adicional de indirección que evite que los procesos usen sus identificadores para comunicarse.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Colas de mensajes en Windows API</div>
<div class="paragraph">
<p>En Windows API un hilo puede enviar mensajes a otro hilo usando <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-postthreadmessagea">PostThreadMessage()</a>.
Como aun no hemos visto el concepto de hilo, podemos asumir que es equivalente al de proceso.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">BOOL</span> <span class="nf">PostThreadMessage</span><span class="p">(</span>
    <span class="n">DWORD</span>  <span class="n">idThread</span><span class="p">,</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">UINT</span>   <span class="n">Msg</span><span class="p">,</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="n">WPARAM</span> <span class="n">wParam</span><span class="p">,</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="n">LPARAM</span> <span class="n">lParam</span> <i class="conum" data-value="3"></i><b>(3)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Identificador del hilo.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Un número entero que identifica el mensaje.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Parámetros del mensaje de tipo entero.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Como se puede observar, en las colas de mensajes de Windows API el <strong>tamaño del mensaje es fijo</strong> y con un estructura muy bien definida: un identificador del mensaje y dos enteros que sirven de parámetros opcionales del mensaje.</p>
</div>
<div class="paragraph">
<p>Para recibir el mensaje el proceso llama a <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmessagea">GetMessage()</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">BOOL</span> <span class="nf">GetMessage</span><span class="p">(</span>
    <span class="n">LPMSG</span> <span class="n">lpMsg</span><span class="p">,</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">HWND</span>  <span class="n">hWnd</span><span class="p">,</span>
    <span class="n">UINT</span>  <span class="n">wMsgFilterMin</span><span class="p">,</span>
    <span class="n">UINT</span>  <span class="n">wMsgFilterMax</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Puntero a una estructura <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-msg">MSG</a> que a la vuelta contendrá el identificador y los parámetros del mensaje recibido, entre otra información.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Como se puede observar, no se indica de qué hilo o proceso se quiere recibir el mensaje, por lo que se trata de un caso de <strong>comunicación directa asimétrica</strong>.
De hecho, si se quiere conocer la identidad del remitente, este tendría que poner su identificador en alguno de los parámetros del mensaje.</p>
</div>
<div class="paragraph">
<p>El sistema de colas de mensajes de Windows API es una pieza fundamental del entorno gráfico de Microsoft Windows.
Sin embargo, podemos definir nuestros propios mensaje privados para comunicar unos hilos o procesos con otros.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_comunicación_indirecta">10.2.2. Comunicación indirecta</h4>
<div class="paragraph">
<p>En la <strong>comunicación indirecta</strong> los mensajes son enviados a <strong>buzones</strong>, <strong><em>maillox</em></strong> o <strong>puertos</strong> que son objetos dónde los procesos pueden dejar y recoger mensajes.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>send( P, message )</strong> para mandar un mensaje al puerto «P»</p>
</li>
<li>
<p><strong>receive( P, &amp;message )</strong> para recibir un mensaje del puerto «P».</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Un <strong>enlace de comunicaciones</strong> según este esquema tiene las siguientes características:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Un enlace se establece entre un par de procesos solo si ambos comparten un mismo puerto, dado que cada enlace corresponde con un puerto.</p>
</li>
<li>
<p>Un enlace puede estar asociado a más de dos procesos, puesto que múltiples procesos pueden compartir el mismo puerto.</p>
</li>
<li>
<p>Entre cada par de procesos en comunicación pueden haber varios enlaces, cada uno de los
cuales corresponde a un puerto.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Colas de mensajes en sistemas POSIX</div>
<div class="paragraph">
<p>El estándar POSIX también define un sistema de colas de mensajes pero es bastante diferente a la solución en Windows API (véase <a href="https://www.man7.org/linux/man-pages/man7/mq_overview.7.html">«mq_overview(7)&#8201;&#8212;&#8201;Linux Manual»</a>).</p>
</div>
<div class="paragraph">
<p>Para usarlo, lo primero es abrir o crear —si aun no existe— la cola de mensajes llamando a <a href="https://man7.org/linux/man-pages/man3/mq_open.3.html">mq_open()</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">mqd_t</span> <span class="n">mqueue</span> <span class="o">=</span> <span class="n">mq_open</span><span class="p">(</span>
    <span class="s">"/foo-mqueue"</span><span class="p">,</span>      <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_RDWR</span><span class="p">,</span>   <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="mo">0644</span><span class="p">,</span>               <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="nb">NULL</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Nombre que identifica la cola de mensajes.
Como con los archivos, para que varios procesos puedan acceder a la misma cola, deben indicar el mismo nombre.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Valores que indican diferentes opciones a la hora de abrir la cola de mensajes.
Por ejemplo, usando <code>O_RDWR</code> se indica abrir para enviar o recibir y con <code>O_CREAT</code> se indica que la cola debe crearse si no existe previamente.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Indica los permisos de la cola de mensajes al crearla nueva, de forma similar a los permisos que se aplican a los archivos.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>El valor devuelto por <a href="https://man7.org/linux/man-pages/man3/mq_open.3.html">mq_open()</a> es el descriptor de la cola de mensajes.
Como otros descriptores, se hereda de padres a hijos al usar <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>.</p>
</div>
<div class="paragraph">
<p>Este descriptor se utiliza como primer argumento en funciones posteriores para indicar sobre qué cola queremos realizar la correspondiente operación.
Por ejemplo, para enviar un mensaje se utiliza <a href="https://man7.org/linux/man-pages/man3/mq_send.3.html">mq_send()</a> así:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="nf">mq_send</span><span class="p">(</span>
    <span class="n">mqueue</span><span class="p">,</span>                 <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">message</span><span class="p">,</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">message</span><span class="p">),</span>        <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="mi">0</span>                       <i class="conum" data-value="4"></i><b>(4)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Descriptor de la cola a la que enviar el mensaje.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Puntero a la dirección de memoria donde está el mensaje.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Tamaño del mensaje en bytes.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Prioridad del mensaje.
Los mensaje con mayor prioridad se entregarán antes.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Mientras que para recibir un mensaje se utiliza <a href="https://man7.org/linux/man-pages/man3/mq_receive.3.html">mq_receive()</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msg_prio</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">mq_receive</span><span class="p">(</span>
    <span class="n">mqueue</span><span class="p">,</span>                 <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">message</span><span class="p">,</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">message</span><span class="p">),</span>        <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="o">&amp;</span><span class="n">msg_prio</span>               <i class="conum" data-value="4"></i><b>(4)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Descriptor de la cola de la que recibir el mensaje.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Puntero a la dirección de memoria donde guardar el mensaje al recibirlo.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Tamaño máximo de espacio reservado en <code>message</code> para guardar el mensaje.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Puntero a variable entera dónde devolver la prioridad del mensaje recibido.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Como los mensajes no se dirigen directamente a los procesos sino a estas entidades llamadas colas de mensajes, se trata de un caso de <strong>comunicación indirecta</strong>.
Además, el <strong>tamaño de los mensajes es variable</strong>, aunque limitado por defecto a 8 KiB si no se configura de otra manera.</p>
</div>
<div class="paragraph">
<p>Si varios procesos intentan recibir de una misma cola de mensajes al mismo tiempo, queda en manos del sistema operativo decidir cuál recibirá el siguiente mensaje que llegue.
Por lo general es el primero en ser escogido por el planificador de la CPU para seguir ejecutándose.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_recepción_concurrente">Recepción concurrente</h5>
<div class="paragraph">
<p>Este tipo de comunicación da lugar a algunas situaciones que deben ser resueltas durante el diseño.</p>
</div>
<div class="paragraph">
<p>¿Qué ocurre, por ejemplo, si los procesos A, B y C comparten el puerto P; A manda un mensaje y B y C invocan <code>receive()</code> en el puerto P al mismo tiempo?.
La respuesta correcta dependerá de la elección de los los diseñadores del sistema:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>No permitir que cada enlace de comunicación —y por tanto cada puerto— esté asociado a más de dos procesos.</p>
</li>
<li>
<p>No permitir que más de un proceso puedan ejecutar <code>receive()</code> al mismo tiempo.
Por ejemplo, en algunos sistemas solo el proceso que crea el puerto tiene permisos para recibir de él.
Los sistemas que optan por esta solución suelen disponer de algún mecanismo para que un proceso pueda transferir el permiso de recibir a otros procesos.</p>
</li>
<li>
<p>Permitir que el sistema operativo escoja arbitrariamente quién recibe el mensaje si dos o más procesos ejecutan <code>receive()</code> al mismo tiempo.
La elección puede ser aleatoria, mediante algún algoritmo, por ejemplo, por turnos o el siguiente proceso en obtener la CPU, a criterio del planificador de la CPU.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_buffering_2">10.3. Buffering</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Los mensajes intercambiados por enlace de comunicación se almacenan en una cola temporal, a la espera de ser enviados o, tras recibirlos, a la espera de que los reclame el proceso.</p>
</div>
<div class="paragraph">
<p>Básicamente hay tres formas de implementar dicha cola:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Con <strong>capacidad cero</strong> o <strong>sin buffering</strong> la cola tiene una capacidad máxima de 0 mensajes, por lo que no puede haber ningún mensaje esperando en el enlace.
En este caso el proceso transmisor se bloquea en espera hasta que el receptor recibe el mensaje.</p>
</li>
<li>
<p>Con <strong>buffering automático</strong>, dónde existe dos opciones:</p>
<div class="ulist">
<ul>
<li>
<p>Con <strong>capacidad limitada</strong> la cola tiene una capacidad máxima de \$N\$ mensaje, por lo que si la cola se llena el proceso transmisor se bloquea a la espera de que haya espacio en la cola.
Obviamente, mientras la cola no se llene en transmisor puede seguir metiendo mensajes sin bloquearse.</p>
</li>
<li>
<p>Con <strong>capacidad ilimitada</strong> la cola es de longitud potencialmente infinita, lo que permite que el transmisor nunca espere.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Las colas de longitud infinita son imposibles, puesto que los recursos son limitados.
En realidad este término hace referencia a colas de longitud variable cuyo máximo viene determinado por la memoria principal disponible, que suele ser lo suficientemente grande como para que podamos considerar que las colas son infinitas.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Buffering en las colas de mensajes POSIX</div>
<div class="paragraph">
<p>Las colas de mensajes en sistemas POSIX tienen capacidad limitada.
Los límites se configuran al crear la cola, a través del último argumento de <a href="https://man7.org/linux/man-pages/man3/mq_open.3.html">mq_open()</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="k">struct</span> <span class="n">mq_attr</span> <span class="n">attr</span> <span class="o">=</span> <span class="p">{</span>  <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="p">.</span><span class="n">mq_maxmsg</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>      <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="p">.</span><span class="n">mq_msgsize</span> <span class="o">=</span> <span class="mi">2049</span>   <i class="conum" data-value="3"></i><b>(3)</b>
<span class="p">};</span>

<span class="n">mqd_t</span> <span class="n">mqueue</span> <span class="o">=</span> <span class="n">mq_open</span><span class="p">(</span>
    <span class="s">"/foo-queue"</span><span class="p">,</span>
    <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_RDWR</span><span class="p">,</span>
    <span class="mo">0644</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">attr</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Estructura con propiedades para la cola cuando ésta se crea nueva.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Una de las propiedades es el número máximo de mensajes en la cola al mismo tiempo.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Otra de las propiedades es el tamaño máximo de cada mensaje.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Estos limites tienen unos valores por defecto por si en el lugar de <code>attr</code> en <a href="https://man7.org/linux/man-pages/man3/mq_open.3.html">mq_open()</a> se indica <code>NULL</code>.
El estándar POSIX indica que esos valores por defecto dependen de cada sistema operativo, por lo que es necesario ir a la documentación para desarrolladores de cada sistema para conocer los detalles en cada caso concreto.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, en Linux los valores por defecto son 10 mensajes y 8 KiB por mensaje, siendo estos, además, los valores máximos que admiten esas propiedades.
Estos valores máximos y por defecto se pueden cambiar de forma global para todo el sistema, por si tuviéramos interés en valores más altos.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_operaciones_síncronas_y_asíncronas">10.4. Operaciones síncronas y asíncronas</h3>
<div class="paragraph">
<p>La comunicación entre dos procesos tiene lugar por medio de las llamadas <code>send()</code> y <code>receive()</code>; de tal forma que generalmente la primera se bloquea cuando la cola de transmisión se llena —en función del tipo de <em>buffering</em>— mientras que la segunda lo hace cuando la cola de recepción está vacía.</p>
</div>
<div class="paragraph">
<p>Sin embargo, en lugar de bloquearse, puede que aun proceso le interese ejecutar otras tareas en la CPU.
A fin de cuentas las comunicaciones son bastante lentas, por lo que en caso de bloquearse podría estar dejando de aprovechar bastante tiempo de CPU.
Incluso puede darse el caso que tengan conexión con otros procesos y que quiera aprovechar para intentar comunicarse con alguno de ellos.</p>
</div>
<div class="paragraph">
<p>Por eso existen diferentes opciones de diseño a la hora de implementar las llamadas anteriores en función de si se pueden bloquear o no.
Concretamente, el paso de mensajes puede ser <strong>síncrono</strong> —con bloqueo— o <strong>asíncrono</strong> —sin bloqueo—.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Cuando el envío es asíncrono</strong>, el proceso transmisor nunca se bloquea.
Si se llama a <code>send()</code> cuando la cola de mensajes esté llena, lo más común es que retorne con un código de retorno que indique que el proceso debe volver a intentar el envío más tarde.</p>
</li>
<li>
<p><strong>Cuando el envío es síncrono</strong>, el proceso transmisor se bloquea cuando no queda espacio en la cola de mensajes y hasta que pueda depositar el mensaje en la misma.</p>
</li>
<li>
<p><strong>Cuando la recepción es asíncrona</strong>, el proceso receptor nunca se bloquea.
En caso de que la cola de mensajes esté vacía, el sistema operativo puede indicar al proceso que lo intente más tarde a través de un código de retorno o devolviendo un mensaje vacío.</p>
</li>
<li>
<p><strong>Cuando la recepción es con bloqueo</strong>, el receptor se bloquea cuando no hay mensajes en la cola y hasta que llegue alguno.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Algunos sistemas de paso de mensajes son claramente síncronos o asíncronos.
Mientras que otros permiten activar un modo u otro según las necesidades del aplicación.
E incluso los hay que soportan que transmisión y recepción sean síncronas o asíncronas de manera totalmente independiente.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Comunicaciones asíncronas con colas de mensajes POSIX</div>
<div class="paragraph">
<p>Por defecto las colas de mensajes son síncronas, tanto en envío como en recepción.
Es decir, si al enviar un mensaje la cola está llena, el proceso transmisor quedará bloqueado en estado <strong>esperando</strong> hasta que haya un hueco libre para depositar el nuevo mensaje.
Si al recibir un mensaje la cola está vacía, el proceso receptor quedará bloqueado hasta que otro proceso deposite un mensaje.</p>
</div>
<div class="paragraph">
<p>Sin embargo, si en el argumento <code>oflag</code> de <a href="https://man7.org/linux/man-pages/man3/mq_open.3.html">mq_open()</a> un proceso indica la opción <code>O_NONBLOCK</code> estas operaciones para ese proceso en esa cola serán asíncronas:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">mqd_t</span> <span class="n">mqueue</span> <span class="o">=</span> <span class="n">mq_open</span><span class="p">(</span>
    <span class="s">"foo-mqueue"</span><span class="p">,</span>
    <span class="n">O_RDONLY</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span><span class="p">,</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="mo">0644</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">attr</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Abrir la cola de mensajes para solo lectura —con <code>O_RDONLY</code>— y para comunicaciones asíncronas —con <code>O_NONBLOCK</code>—.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Eso quiere decir que las funciones <a href="https://man7.org/linux/man-pages/man3/mq_send.3.html">mq_send()</a> y <a href="https://man7.org/linux/man-pages/man3/mq_receive.3.html">mq_receive()</a>, en lugar de bloquear el proceso en estado de esperando, devolverán -1 y el valor de <a href="https://man7.org/linux/man-pages/man3/errno.3.html">errno</a> será <code>EAGAIN</code>.
Así el proceso puede aprovechar el tiempo de CPU del que dispone para realizar otras tareas mientras tanto y volver a intentarlo más tarde.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="n">return_code</span> <span class="o">=</span> <span class="n">mq_receive</span><span class="p">(</span><span class="n">mqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">message</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">msg_prio</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">return_code</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="p">{</span>
    <span class="c1">// Aquí va código para usar el mensaje recibido...</span>
<span class="p">}</span>
<span class="k">else</span> <span class="nf">if</span><span class="p">(</span> <span class="n">return_code</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">errno</span> <span class="o">!=</span> <span class="n">EAGAIN</span><span class="p">)</span> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">{</span>
    <span class="c1">// Aquí va código para manejar el error de mq_receive()...</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Si todo va bien, <a href="https://man7.org/linux/man-pages/man3/mq_receive.3.html">mq_receive()</a> devuelve el tamaño en bytes del mensaje.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Si devuelve -1, es que ha ocurrido un error. Pero solo será un error eal si el código de error en <a href="https://man7.org/linux/man-pages/man3/errno.3.html">errno</a> no es <code>EAGAIN</code>.
Si es <code>EAGAIN</code>, se pueden ejecutar otras partes del programa y volver a intentar la recepción más adelante.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Si un proceso debe comunicarse mediante varias colas de mensajes, la comunicación asíncrona también sirve para intentar recibir y enviar de varias colas sin bloquearse en ninguna.
Para este caso algunos sistemas ofrece una alternativa más sencilla y eficiente, que veremos en el <a href="#_colas_de_mensajes_posix">Apartado 10.5.1</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ejemplos_de_sistemas_de_paso_de_mensajes">10.5. Ejemplos de sistemas de paso de mensajes</h3>
<div class="sect3">
<h4 id="_colas_de_mensajes_posix">10.5.1. Colas de mensajes POSIX</h4>
<div class="paragraph">
<p>Como hemos comentado a lo largo de capítulo, las colas de mensajes POSIX son un caso de <strong>comunicación indirecta</strong>, con <strong>tamaño de mensaje variable</strong>, <em>buffering</em> con <strong>capacidad limitad</strong> y que soporta operaciones <strong>asíncronas</strong>.</p>
</div>
<div class="paragraph">
<p>Las colas de mensajes son útiles para enviar mensajes de pequeño tamaño entre procesos que se ejecutan en el mismos sistema.
Además tienen la posibilidad de asociar a cada mensaje una prioridad, de tal forma que se reciban primero los mensajes de prioridad más alta.
Su uso es relativamente común en sistemas de tiempo real, aunque lo más frecuente en los sistemas de propósito general es usar <em>sockets</em>.</p>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/message_queue.hpp">message_queue.hpp</a> se puede ver un ejemplo de una clase desarrollada en C&#43;&#43; para utilizar colas de mensajes POSIX.
En los distintos métodos se puede ver como se utilizan las funciones de la librería del sistema para crear la cola y enviar y recibir mensajes.</p>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/mqueue-server.cpp">mqueue-server.cpp</a> y <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/mqueue-client.cpp">mqueue-client.cpp</a> se puede ver un ejemplo de cómo se utiliza la clase en <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/message_queue.hpp">message_queue.hpp</a>.
El primero es un programa que muestra la hora del sistema periódicamente.
El segundo se puede comunicar con el primero a través de una cola de mensajes para controlarlo.
En ejemplo es muy sencillo, así que, por el momento, lo único que puede hacer <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/mqueue-client.cpp">mqueue-client.cpp</a> es pedirle a <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/mqueue-server.cpp">mqueue-server.cpp</a> que termine.
Aunque no costaría nada añadir otras órdenes, como pedir que cambie la hora del sistema o la periodicidad con la que la muestra.</p>
</div>
<div class="paragraph">
<p>En Linux los descriptores de colas de mensajes son descriptores de archivo —como también lo son los descriptores de <em>sockets</em>, tuberías y los de archivos abiertos con <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a>, entre otros—. Esta particularidad implica que en Linux, mediante las funciones <a href="https://man7.org/linux/man-pages/man2/select.2.html">select()</a>, <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a> o <a href="https://man7.org/linux/man-pages/man7/epoll.7.html">epoll()</a>, se pueden monitorizar al mismo tiempo varios descriptores de colas de mensajes, para así saber cuándo se puede enviar o recibir por ellas sin que el proceso se bloquee.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Este comportamiento es específico de Linux.
No está contemplado en el estándar POSIX, por lo que otros sistemas POSIX no tienen por qué soportarlo.
Así que no es portable.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A continuación se puede ver un ejemplo específico con <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a>, aunque las tres funciones se utilizan empleando un patrón similar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">mqd_t</span> <span class="n">mqueue1</span> <span class="o">=</span> <span class="n">mq_open</span><span class="p">(</span> <span class="s">"/foo-queue"</span><span class="p">,</span> <span class="cm">/* ... */</span> <span class="p">);</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="n">mqd_t</span> <span class="n">mqueue2</span> <span class="o">=</span> <span class="n">mq_open</span><span class="p">(</span> <span class="s">"/bar-queue"</span><span class="p">,</span> <span class="cm">/* ... */</span> <span class="p">);</span>

<span class="k">struct</span> <span class="n">pollfd</span> <span class="n">fds</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">{</span>
        <span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">mqueue1</span><span class="p">,</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">POLLIN</span><span class="p">,</span> <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="p">.</span><span class="n">revents</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">},</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">mqueue2</span><span class="p">,</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLOUT</span><span class="p">,</span> <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="p">.</span><span class="n">revents</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">while</span> <span class="p">(</span> <span class="o">!</span><span class="n">quit_app</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">return_code</span> <span class="o">=</span> <span class="n">poll</span><span class="p">(</span> <span class="n">fds</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">);</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="k">if</span> <span class="p">(</span><span class="n">return_code</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <i class="conum" data-value="5"></i><b>(5)</b>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">revents</span> <span class="o">&amp;</span> <span class="n">POLLIN</span><span class="p">)</span> <i class="conum" data-value="7"></i><b>(7)</b>
        <span class="p">{</span>
            <span class="n">mq_receive</span><span class="p">(</span> <span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">fd</span><span class="p">,</span> <span class="cm">/* ... */</span> <span class="p">);</span>

            <span class="c1">// Aquí va código para usar el mensaje recibido...</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">fds</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">revents</span> <span class="o">&amp;</span> <span class="n">POLLIN</span><span class="p">)</span> <i class="conum" data-value="7"></i><b>(7)</b>
        <span class="p">{</span>
            <span class="n">mq_receive</span><span class="p">(</span> <span class="n">fds</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">fd</span><span class="p">,</span> <span class="cm">/* ... */</span> <span class="p">);</span>

            <span class="c1">// Aquí va código para usar el mensaje recibido...</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">fds</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">revents</span> <span class="o">&amp;</span> <span class="n">POLLOUT</span><span class="p">)</span> <i class="conum" data-value="7"></i><b>(7)</b>
        <span class="p">{</span>
            <span class="c1">// Aquí va código para preparar el mensaje a enviar...</span>

            <span class="n">mq_send</span><span class="p">(</span> <span class="n">fds</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">fd</span><span class="p">,</span> <span class="cm">/* ... */</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">return_code</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <i class="conum" data-value="6"></i><b>(6)</b>
    <span class="p">{</span>
        <span class="c1">// Error en poll().</span>
        <span class="c1">// Aquí va código para leer errno y manejar el error...</span>

        <span class="n">quit_app</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Abrimos o creamos las colas que vamos a utilizar.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Creamos un <em>array</em> de la estructura <code>pollfd</code> con un elemento por cola que vamos a monitorizar con <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a>.
En cada estructura, en el campo <code>fd</code>, se indica el descriptor de cada una de las cola de mensajes.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Para cada cola hay que utilizar el campo <code>events</code> para indicar qué queremos que monitorice <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a>.
<code>events</code> es una máscara de bit donde a cada evento monitorizable le corresponde un bit.
Si queremos monitorizar un evento, debemos poner su bit a 1.
<div class="paragraph">
<p>Para eso nos podemos ayudar de macros como <code>POLLIN</code> y <code>POLLOUT</code>.
Por ejemplo, para <code>mqueue1</code> se quiere monitorizar cuándo hay mensajes para recibir, por lo que se activa <code>POLLIN</code>.
Mientras que para <code>mqueue2</code> se quiere saber tanto cuándo hay mensajes para recibir como cuándo hay un hueco en la cola para enviar sin bloqueos, por lo que se activan <code>POLLIN</code> y <code>POLLOUT</code>.</p>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Iterativamente se llama a <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a> —mientras no queramos que termine la aplicación— que pondrá el proceso en estado <strong>esperando</strong> hasta que ocurra alguno de los eventos que nos interesan.
<a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a> necesita <code>fds</code> —el <em>array</em> de la estructura <code>pollfd</code> que hemos inicializado previamente— el número de elementos en el <em>array</em> y el tiempo máximo que debe mantener bloqueado el proceso esperando a que ocurra alguno de los eventos.
Con un número negativo en este último campo, se indica que queremos que espere indefinidamente.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Si <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a> tiene éxito, devuelve un numero positivo que indica en cuántos descriptores se ha detectado un evento.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Si <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a> devuelve un valor negativo, es que ha ocurrido algún error.
El motivo del error se puede conocer comprobando el valor de la variable global <a href="https://man7.org/linux/man-pages/man3/errno.3.html">errno</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>El campo <code>revents</code> es una máscara de bits similar a <code>events</code>, pero al retornar de <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a> indica qué eventos se han detectado, para cada cola de mensajes en <code>fds</code>.
<div class="paragraph">
<p>Por ejemplo, en ambas colas se comprueba si <code>POLLIN</code> está activo.
En caso afirmativo, sabemos que podemos leer un mensaje sin que <a href="https://man7.org/linux/man-pages/man3/mq_receive.3.html">mq_receive()</a> se bloquee.
Igualmente, sabemos si <code>mqueue2</code> tiene hueco para enviar un mensaje comprobando si <code>POLLOUT</code> está activo.
En caso afirmativo, podemos enviar un mensaje con <a href="https://man7.org/linux/man-pages/man3/mq_send.3.html">mq_send()</a> sabiendo que no se bloqueará.</p>
</div></td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_señales_en_sistemas_operativos_posix">10.5.2. Señales en sistemas operativos POSIX</h4>
<div class="paragraph">
<p>En los sistemas POSIX, una forma más sencilla de comunicar dos procesos del mismo sistema es mediante el envío de una <strong>señal</strong> de uno al otro.</p>
</div>
<div class="paragraph">
<p>Los procesos pueden mandar señales utilizando la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/kill.2.html">kill()</a>, que sólo requiere el identificador del proceso de destino y el número que identifica la señal.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">kill</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">SIGTERM</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Como se usa el identificado del proceso, estamos hablando de un mecanismo de <strong>comunicación directa</strong>.</p>
</div>
<div class="paragraph">
<p>El <strong>tamaño y formato del mensaje es fijo</strong>.
Las señales solo pueden portar la información de que ha ocurrido un evento, indicado qué evento es a través del número que identifica la señal.</p>
</div>
<div class="paragraph">
<p>Cada señal tiene un efecto particular por defecto —que por lo general es matar al proceso— en el proceso que las recibe.
Sin embargo, cada proceso puede declarar un <strong>manejador de señal</strong>.
Una función del programa que será invocada por el sistema operativo para tratar una señal determinada, interrumpiendo lo que esté haciendo el proceso en ese momento.
En ese sentido las señales en POSIX puede interpretarse como una forma de interrupción por software.</p>
</div>
<div class="paragraph">
<p>El <strong>manejador de señal</strong> se puede configurar usando la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/signal.2.html">signal()</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">signal</span><span class="p">(</span>
    <span class="n">SIGTERM</span><span class="p">,</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="o">&amp;</span><span class="n">mi_manejador_de_sigterm</span> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Identificador de la señal a recibir.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Puntero al manejador de señal.
Es decir, la del programa que será llamada por el sistema operativo cuando llegue la señal <code>SIGTERM</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>El problema de <a href="https://man7.org/linux/man-pages/man2/signal.2.html">signal()</a> es que el estándar POSIX permite diferencias que hacen que se pueda comportar de forma distinta en diferentes sistemas operativos.
Para resolverlo, el estándar recomienda usar <a href="https://man7.org/linux/man-pages/man2/sigaction.2.html">sigaction()</a> en su lugar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="k">struct</span> <span class="n">sigaction</span> <span class="n">act</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mi_manejador_de_sigterm</span><span class="p">,</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="p">.</span><span class="n">sa_sigaction</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>   <i class="conum" data-value="5"></i><b>(5)</b>
    <span class="p">.</span><span class="n">sa_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>           <i class="conum" data-value="6"></i><b>(6)</b>
    <span class="p">.</span><span class="n">sa_flags</span> <span class="o">=</span> <span class="n">SA_RESTART</span><span class="p">,</span> <i class="conum" data-value="7"></i><b>(7)</b>
<span class="p">}</span>

<span class="n">sigaction</span><span class="p">(</span>
    <span class="n">SIGTERM</span><span class="p">,</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="o">&amp;</span><span class="n">act</span><span class="p">,</span>    <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="nb">NULL</span>     <i class="conum" data-value="3"></i><b>(3)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Identificador de la señal a recibir.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Puntero a una estructura de tipo <code>sigaction</code> que describe los detalles de como tratar la señal cuando llega al proceso.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Puntero a una estructura de tipo <code>sigaction</code> donde <a href="https://man7.org/linux/man-pages/man2/sigaction.2.html">sigaction()</a> guarda la configuración anterior sobre como tratar la señal indicada.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Puntero al manejador de señal para la señal indicada.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Puntero a un manejador de señal alternativo al de <code>sa_handler</code>.
Este manejador recibe más información sobre la señal cuando es llamado.
Para activar es necesario indicar <code>SA_SIGINFO</code> en el campo <code>sa_flags</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Máscara de bits de señales a bloquear durante el manejo de la señal.
Cada bit de la máscara identifica a una señal.
Deben ponerse a 1 aquellas señales que queremos que estén bloqueadas —es decir, que no se puedan recibir— mientras se ejecuta el manejador de señal porque ha llegado una.
Es especialmente útil si se va a usar el mismo manejador para varias señales.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Opciones de configuración.
Por ejemplo, <code>SA_RESTART</code> indica que si la señal llega durante una llamada al sistema, la llamada debe continuar una vez se haya salido del manejador de señal.
El comportamiento por defecto, sin esta opción, es que la llamada al sistema interrumpida falle con el error <code>EINTR</code> en <a href="https://man7.org/linux/man-pages/man3/errno.3.html">errno</a>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Las señales fueron diseñadas originalmente como un mecanismo para que el sistema operativo notificara a los programas ciertos errores y sucesos críticos.
Por ejemplo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La señal <code>HUP</code> o <code>SIGHUP</code> es enviada a cada proceso iniciado desde una sesión de terminal cuando dicha sesión termina —o cuando se usa la combinación de teclas <span class="keyseq"><kbd>CTRL</kbd>+<kbd>D</kbd></span>, que tiene el mismo efecto—.</p>
<div class="paragraph">
<p>En el caso de los servicios del sistema —que, como no son interactivos, no están conectados a ninguna terminar— esta señal suele usarse para indicarles que deben reiniciarse, volviendo a leer sus archivos de configuración, o para que guarden su estado interno en algún sitio conocido del almacenamiento.</p>
</div>
</li>
<li>
<p>La señal <code>INT</code> o <code>SIGINT</code> es enviada al proceso que está enganchado a la consola cuando el usuario pulsa el carácter de interrupción —frecuentemente la combinación de teclas <span class="keyseq"><kbd>CTRL</kbd>+<kbd>C</kbd></span>—.</p>
</li>
<li>
<p>La señal <code>TERM</code> o <code>SIGTERM</code> es enviada al proceso cuando debe terminar.
Por ejemplo, el sistema operativo envía esta señal a todos los procesos cuando se está apagando el sistema.</p>
</li>
<li>
<p>La señal <code>SEGV</code> o <code>SIGSEGV</code> es enviada a un proceso cuando intenta acceder a una zona de memoria a la que no tiene permiso.
Si no se maneja esta señal, el programa termina con el conocido mensaje de <strong>violación de segmento</strong>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Obviamente hay muchas más señales.
Entre todas, el estándar POSIX incluye dos señales —<code>USR1</code> y <code>USR2</code>— especialmente indicadas para usarlas con el significado que nosotros queramos.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Se puede consultar una lista de las señales del estándar POSIX en <a href="https://es.wikipedia.org/wiki/Se%C3%B1al_(inform%C3%A1tica)">«Señales (informática)&#8201;&#8212;&#8201;Wikipedia»</a>.
Mientras que la lista completa de señales soportadas en Linux se puede consultar en <a href="https://man7.org/linux/man-pages/man7/signal.7.html#:~:text=Standard%20signals">«signal(7)&#8201;&#8212;&#8201;Linux Manual»</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>El ejemplo en <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/mqueue-server.cpp">mqueue-server.cpp</a> y en otros ejemplos de este capítulo, utiliza señales para manejar <code>SIGINT</code>, <code>SIGTERM</code> y para mostrar la hora periódicamente.
El código dedicado a eso está en <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/common/timeserver.c">timeserver.c</a> y se comparte entre todos los ejemplos.</p>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/signals.c">signals.c</a> hay un programa de ejemplo que muestra cómo manejar las señales del sistema y que sirve para ver como funcionan.
Solo hay que ejecutarlo y luego enviarle señales con el comando <code>kill</code> desde otra terminal.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tuberías">10.5.3. Tuberías</h4>
<div class="paragraph">
<p>Las <strong>tuberías</strong> son un mecanismo de paso de mensajes de <strong>comunicación indirecta</strong>, <strong>orientada a flujos</strong>, <strong>capacidad limitada</strong> y, generalmente, <strong>comunicación síncrona</strong> —aunque en algunos sistema operativos también puede soportar asíncrona—.</p>
</div>
<div class="paragraph">
<p>Conceptualmente cada tubería tiene dos extremos en los que se puede leer y escribir mediante las operaciones básicas de lectura y escritura de archivos <code>read()</code> y <code>write()</code>.
Un extremo permite a los procesos en ese extremo escribir en la tubería, mientras el otro extremo permite a los procesos leer de la tubería los datos escritos desde el otro extremo.</p>
</div>
<div class="paragraph">
<p>Existen dos tipos de tuberías:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Las <strong>tuberías anónimas</strong> que sólo existen en el espacio de direcciones del proceso que las crea, de tal forma que debe heredarse de padres a hijos para que otros procesos puedan tener acceso.</p>
</li>
<li>
<p>Las <strong>tuberías con nombre</strong> son públicas al resto del sistema, por lo que teóricamente cualquier proceso con permisos puede abrir una para comunicarse con otros procesos.
Por eso se suele utilizar en aplicaciones cliente-servidor, dónde un proceso servidor ofrece algún servicio a otros procesos cliente a través de la tubería.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En los sistemas POSIX las <strong>tuberías con nombre</strong> se denominan <em>FIFO</em> y tienen presencia en el sistema de archivos como archivos especiales.</p>
</div>
</td>
</tr>
</table>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 3. Funciones de la API para manipular tuberías.</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">POSIX API</th>
<th class="tableblock halign-left valign-top">Windows API</th>
</tr>
</thead>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Crear tubería anónima</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/pipe.2.html">pipe()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-createpipe">CreatePipe()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Crear tubería con nombre</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/mkfifo.3.html">mkfifo()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea">CreateNamedPipe()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Abrir tubería con nombre</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Leer</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile">ReadFile()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Escribir</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile">WriteFile()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Cerrar</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/close.2.html">close()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle">CloseHandle()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Destruir tubería con nombre</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/unlink.2.html">unlink()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="lightcell">[Automático]</span></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Con <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> es muy sencillo lanzar otros procesos para que ejecuten tareas en paralelo.
El proceso hijo tiene acceso a los datos del padre por la forma en la que funciona <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> y gracias a las tuberías anónimas puede comunicar los resultados al padre.
En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/master/src/cap10/fork-pipe.cpp">fork-pipe.cpp</a> se puede observar un ejemplo de esto.</p>
</div>
<div class="paragraph">
<p>Además, el hecho de que cada extremo se comporte como un archivo —uno en modo solo lectura y el otro en modo solo escritura— hace posible redirigir la E/S estándar del proceso hijo.
Es decir, conectar la entrada, la salida estándar o la salida de error a una tubería, desde la que leer lo que el proceso intenta imprimir por la pantalla de la terminal o proporcionarle lo que debe leer, como si fuera desde el teclado.
En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/fork-redir.c">fork-redir.c</a> se puede ver un ejemplo de como ejecutar el comando <code>ls</code> y redirigir su salida al proceso padre para contar el número de líneas en lo que el comando quería mostrar por pantalla.</p>
</div>
<div class="paragraph">
<p>Por otro lado, las tuberías con nombre permiten que un proceso se comunique con cualquier otro, solo con conocer la ruta de la tubería.
En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/fifo-client.c">fifo-server.c</a> tenemos un ejemplo de un programa que muestra la hora del sistema de forma periódica, mientras espera órdenes de una tubería que sirve de canal de control remoto.
Los programas en <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/fifo-client.c">fifo-client.c</a> y <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/fifo-client.cpp">fifo-client.cpp</a> pueden conectarse a esa tubería y mandar el comando que hace terminar <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/fifo-client.c">fifo-server.c</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_sockets">10.5.4. Sockets</h4>
<div class="paragraph">
<p>Mientras que las tuberías son conceptualmente un enlace de comunicación unidireccional que tiene dos extremos, un <strong><em>socket</em></strong> representa un solo extremo en un enlace de comunicación bidireccional.
Para que una pareja de procesos se pueda comunicar son necesarios dos <em>sockets</em> —uno en cada proceso— de manera que cada uno de ellos es el medio por el que el proceso accede al enlace de comunicación.</p>
</div>
<div class="paragraph">
<p>La API de <em>sockets</em> fue creada por la Universidad de Berkeley para abstraer el acceso a la familia de protocolos de Internet en el UNIX desarrollado por esa misma universidad.
Sin embargo, rápidamente se convirtió en el estándar de facto para la comunicación en red, por lo que todos los sistemas operativos modernos —incluidos los sistemas POSIX y Microsoft Windows— tienen una implementación de la misma.</p>
</div>
<div class="paragraph">
<p>Pese a sus orígenes en Internet, los <em>sockets</em> se diseñaron para ser independientes de la tecnología de red subyacente con la que se implementa el enlace de comunicación.
En Linux, por ejemplo, se puede utilizar como interfaz de programación para utilizar dos decenas de familias de protocolos y tecnologías diferentes.</p>
</div>
<div class="paragraph">
<p>Para crear un <em>socket</em> te utiliza la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/socket.2.html">socket()</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">AF_UNIX</span><span class="p">,</span>         <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="n">SOCK_DGRAM</span><span class="p">,</span>      <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="mi">0</span>
<span class="p">)</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>En sistemas POSIX la función devuelve un <code>int</code> con el descriptor del socket mientras que en Microsoft Windows devuelve un <code>HANDLE</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>En el primer argumento se especifica la familia de protocolos.
<code>AF_UNIX</code> son un tipo de <em>socket</em> que solo sirve para comunicar procesos en el mismo sistema, denominado <strong>socket de dominio UNIX</strong>.
Otras familias muy comunes son <code>AF_INET</code>, que corresponde a la la familia de protocolos TCP/IP y <code>AF_INET6</code> para los protocolos IPv6.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>En el segundo argumento se especifica el tipo del <em>socket</em>.
Cada tipo suele corresponde con un protocolo concreto de la familia elegida.
Por ejemplo, los <em>sockets</em> <code>SOCK_DGRAM</code> son «no orientados a conexión», no fiables y de longitud máxima fija, así que en la familia <code>AF_INET</code> estos <em>sockets</em> utiliza UDP.
Mientras que los <em>sockets</em> <code>SOCK_STREAM</code> son orientados a conexión, fiables, bidireccionales y orientados a flujo, por lo que en la familia <code>AF_INET</code> utilizan TCP.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Un <em>socket</em> recién creado no tiene un nombre que otro proceso pueda usar para identificarlo y comunicarse con él.
Para asignar ese nombre o dirección se utiliza <a href="https://man7.org/linux/man-pages/man2/bind.2.html">bind()</a>.
La dificultad es que cada familia de protocolos tiene un formato de direcciones diferente, así que hay que tener cuidado de usar el adecuado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="k">struct</span> <span class="n">sockaddr_un</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">sun_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">,</span>        <i class="conum" data-value="5"></i><b>(5)</b>
    <span class="p">.</span><span class="n">sun_path</span> <span class="o">=</span> <span class="s">"/tmp/foo-socket"</span> <i class="conum" data-value="6"></i><b>(6)</b>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">result_code</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">sockfd</span><span class="p">,</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <i class="conum" data-value="4"></i><b>(4)</b>
<span class="p">)</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Como en el resto de llamadas al sistema, en caso de error se devuelve un número negativo y <a href="https://man7.org/linux/man-pages/man3/errno.3.html">errno</a> contendrá el código del error.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>El descriptor del <em>socket</em> al que se le quiere cambiar la dirección.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>La nueva dirección del <em>socket</em> especificada como una estructura adecuada para la familia del <em>socket</em>.
En <em>socket</em> de tipo <code>AF_UNIX</code> la estructura debe ser de tipo <code>sockaddr_un</code> mientras que en los de tipo <code>AF_INET</code> es del tipo <code>sockaddr_in</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>El tamaño en bytes de la estructura con la nueva dirección.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>En la estructura con la dirección, el primero campo siempre es para
indicar la familia.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>En los <em>sockets</em> de dominio UNIX la dirección es una ruta en el sistema de archivos.
Para otras familias, la direcciones se indica de otra manera, por lo que es necesario consultar la documentación.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>La API de <em>sockets</em> incluye muchas otras funciones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://man7.org/linux/man-pages/man2/listen.2.html">listen()</a>, para poner <em>sockets</em> tipo <code>SOCK_STREAM</code> a la espera de conexiones.</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man2/connect.2.html">connect()</a>, para conectar un <em>socket</em> tipo <code>SOCK_STREAM</code> con otro que esté a la espera de conexiones.</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man2/accept.2.html">accept()</a> para que un <em>socket</em> tipo <code>SOCK_STEAM</code> a la espera de conexiones acepte una solicitud de conexión.</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man2/shutdown.2.html">shutdown()</a> para cerrar uno de los sentidos de una conexión.</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man2/close.2.html">close()</a> para destruir un <em>socket</em>.</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man2/send.2.html">send()</a>, <a href="https://man7.org/linux/man-pages/man2/send.2.html">sendto()</a> y <a href="https://man7.org/linux/man-pages/man2/send.2.html">sendmsg()</a> para enviar mensajes.
<a href="https://man7.org/linux/man-pages/man2/send.2.html">send()</a> sólo se puede utilizar con <em>sockets</em> conectados.
Mientras que <a href="https://man7.org/linux/man-pages/man2/send.2.html">sendto()</a> permiten indicar la dirección del <em>socket</em> de destino, por lo que es útil en <em>sockets</em> no orientados a conexión <code>SOCK_DGRAM</code>.</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man2/recv.2.html">recv()</a>, <a href="https://man7.org/linux/man-pages/man2/recvfrom.2.html">recvfrom()</a> y <a href="https://man7.org/linux/man-pages/man2/recvmsg.2.html">recvmsg()</a> para recibir mensajes.
<a href="https://man7.org/linux/man-pages/man2/recvfrom.2.html">recvfrom()</a> permite obtener la dirección del <em>socket</em> del que llegó el mensaje.
Por eso es útil en <em>sockets</em> no orientados a conexión <code>SOCK_DGRAM</code>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="k">struct</span> <span class="n">sockaddr_un</span> <span class="n">addr</span><span class="p">;</span>
<span class="n">socklen_t</span> <span class="n">addrlen</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">result_code</span> <span class="o">=</span> <span class="n">recvfrom</span><span class="p">(</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">sockfd</span><span class="p">,</span>          <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="o">&amp;</span><span class="n">message</span><span class="p">,</span>        <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">message</span><span class="p">),</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="mi">0</span><span class="p">,</span>               <i class="conum" data-value="5"></i><b>(5)</b>
    <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <i class="conum" data-value="6"></i><b>(6)</b>
    <span class="o">&amp;</span><span class="n">addrlen</span>         <i class="conum" data-value="7"></i><b>(7)</b>
<span class="p">)</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>En caso de éxito devuelve número de bytes del mensaje recibido.
En caso de error, un -1 y <a href="https://man7.org/linux/man-pages/man3/errno.3.html">errno</a> contiene el código del error.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>El descriptor del <em>socket</em> al que se le quiere cambiar la dirección.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Puntero a la dirección de memoria donde está el mensaje.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Tamaño del mensaje en bytes.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Opciones adicionales de configuración.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Estructura de dirección vacía donde se copiará la dirección del <em>socket</em> que remite el mensaje.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Puntero donde la llamada al sistema copiará el tamaño de la estructura copiada en <code>addr</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Las operaciones con <em>sockets</em> son síncronas por defecto.
Sin embargo, es posible configurarlos en modo asíncrono, para que así cualquiera de estas funciones falle, retornando -1 y código de error <code>EAGAIN</code> o <code>EWOULDBLOCK</code>, antes de poner el proceso en estado <strong>esperando</strong>.</p>
</div>
<div class="paragraph">
<p>También se pueden utilizar las funciones <a href="https://man7.org/linux/man-pages/man2/select.2.html">select()</a> y <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a> para monitorizar varios <em>sockets</em> al mismo tiempo, de forma similar a como se hace para colas de mensajes POSIX (véase el <a href="#_colas_de_mensajes_posix">Apartado 10.5.1</a>).</p>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/socket-server.cpp">socket-server.cpp</a> y <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/socket-client.cpp">socket-client.cpp</a> se puede observar un ejemplo similar al que usamos con las tuberías y las colas de mensajes, pero empleando <em>sockets</em> de dominio UNIX.
Ambos programas utilizan la cabecera <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/socket.hpp">socket.hpp</a> que incluye un ejemplo de clase en C&#43;&#43; para comunicaciones mediante <em>sockets</em>.
En los distintos métodos se puede ver como se utilizan las funciones de la librería del sistema para crear <em>sockets</em>, asignarles dirección y usarlos para enviar y recibir mensajes.</p>
</div>
<div class="paragraph">
<p>En resumen, los <strong><em>sockets</em></strong> son un mecanismo de paso de mensajes de <strong>comunicación indirecta</strong>, que admite tanto comunicación <strong>orientada a flujos</strong> como <strong>mensajes de tamaño variable</strong>, <em>buffering</em> de <strong>capacidad limitada</strong> y tanto <strong>comunicación síncrona</strong> como <strong>asíncrona</strong>, aunque el comportamiento real final de la interfaz depende de la tecnología de red utilizada.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_memoria_compartida">11. Memoria compartida</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>5 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>La <strong>memoria compartida</strong> es una estrategia para comunicar procesos dónde uno de ellos gana acceso a regiones de la memoria del otro; algo que por lo general el sistema operativo siempre intenta evitar.
Por eso, para que pueda haber memoria compartida es necesario que los dos procesos estén de acuerdo en eliminar dicha restricción.</p>
</div>
<div class="paragraph">
<p>Dos procesos que comparten una región de la memoria pueden intercambiar información simplemente leyendo y escribiendo datos en la misma.
Sin embargo debemos tener en cuenta que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La estructura de los datos y su localización dentro de la región compartida la determinan los procesos en comunicación y no el sistema operativo, a diferencia de lo que ocurre en los sistemas de paso de mensajes.</p>
</li>
<li>
<p>Los procesos son responsables de sincronizarse para no escribir y leer en el mismo sitio de la memoria al mismo tiempo, pues esto puede generar inconsistencias (véase el <a href="#_sincronización">Capítulo 13</a>) .</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Las principales ventajas de la memoria compartida frente a otros mecanismos de comunicación son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Eficiencia</strong>.
Puesto que la comunicación tiene lugar a la velocidad de la memoria principal, se trata de un mecanismo tremendamente rápido.</p>
</li>
<li>
<p><strong>Conveniencia</strong>.
Puesto que el mecanismo de comunicación sólo requiere leer y escribir de la memoria, se trata de un sistema muy sencillo y fácil de utilizar.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Como ocurre con las tuberías (véase el <a href="#_tuberías">Apartado 10.5.3</a>) la memoria compartida puede ser anónima o con nombre.</p>
</div>
<div class="sect2">
<h3 id="_memoria_compartida_anónima">11.1. Memoria compartida anónima</h3>
<div class="paragraph">
<p>La <strong>memoria compartida anónima</strong> solo existe para el proceso que la crea y para sus procesos hijos, que heredan el acceso.
Es por tanto, una forma eficiente de comunicar procesos padres e hijos.</p>
</div>
<div class="paragraph">
<p>En lo sistemas POSIX, las funciones y operadores de reserva de memoria como <a href="https://en.cppreference.com/w/c/memory/malloc">malloc()</a> y <a href="https://en.cppreference.com/w/cpp/language/new">new</a>, utilizan internamente la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a>.
Esta función se puede llamar de la siguiente manera para reservar <code>length</code> bytes de memoria.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">void</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="n">length</span><span class="p">,</span>     <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>      <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="n">MAP_ANONYMOUS</span> <span class="o">|</span> <span class="n">MAP_PRIVATE</span><span class="p">,</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="mi">0</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Si todo va bien, <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a> devuelve un puntero al primer byte de la memoria reservada.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Cantidad de memoria a reservar en bytes.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Permisos de acceso para la memoria reservada.
En este caso, se solicita permitir la lectura y la escritura de la memoria.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>MAP_ANONYMOUS</code> indica que la memoria no está respaldada por ningún archivo, por lo que su contenido inicial será cero.
Mientras que <code>MAP_PRIVATE</code> establece que la región de memoria es privada.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Lo interesante es que si se cambia <code>MAP_PRIVATE</code> por <code>MAP_SHARED</code> la región de memoria reservada es memoria compartida:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">void</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="n">length</span><span class="p">,</span>
    <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
    <span class="n">MAP_ANONYMOUS</span> <span class="o">|</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="mi">0</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Memoria anónima y compartida.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Es decir, que al crear un hijo con <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> este tendrá una copia de toda la memoria del proceso padre, excepto esta región en particular, que será la misma que la del padre.
Por lo tanto, escribiendo y leyendo en esa región, ambos procesos pueden comunicarse.</p>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap11/anom-shared-memory.cpp">anom-shared-memory.cpp</a> se puede ver un ejemplo muy simple, similar a <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/master/src/cap10/fork-pipe.cpp">fork-pipe.cpp</a> pero utilizando memoria compartida para comunicar ambos procesos.
Como se puede apreciar, la versión que usa memoria compartida es bastante más sencilla que la que utiliza tuberías.</p>
</div>
<div class="paragraph">
<p>En Microsoft Windows se puede hacer algo similar con <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga">CreateFileMapping()</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">HANDLE</span> <span class="n">hMapFile</span> <span class="o">=</span> <span class="n">CreateFileMapping</span><span class="p">(</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="n">INVALID_HANDLE_VALUE</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="n">PAGE_READWRITE</span><span class="p">,</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="mi">0</span><span class="p">,</span>
    <span class="n">length</span><span class="p">,</span>         <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="nb">NULL</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Permisos de acceso para la memoria reservada.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Cantidad de memoria a reservar en bytes.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A diferencia de <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a>, <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga">CreateFileMapping()</a> crea un objeto de memoria compartida pero no hace visible esa memoria para nuestro proceso.
Para eso hay que llamar a <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile">MapViewOfFile()</a> pasándole el manejador <code>hMapFile</code> devuelto por <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga">CreateFileMapping()</a>.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_memoria_compartida_con_nombre">11.2. Memoria compartida con nombre</h3>
<div class="paragraph">
<p>La <strong>memoria compartida con nombre</strong> es pública para el resto del sistema, por lo que teóricamente cualquier proceso con permisos puede acceder a ella para comunicarse con otros procesos.</p>
</div>
<div class="paragraph">
<p>Como ocurre en las tuberías con nombre, los <strong>objetos de memoria compartida con nombre</strong> hay que crearlos antes de comenzar a utilizarlos.
Para eso los sistemas POSIX ofrecen la función <a href="https://www.man7.org/linux/man-pages/man3/shm_open.3.html">shm_open()</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="n">shmfd</span> <span class="o">=</span> <span class="n">shm_open</span><span class="p">(</span>   <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="s">"/foo-shm"</span><span class="p">,</span>         <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_CREAT</span><span class="p">,</span>   <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="mi">666</span>                 <i class="conum" data-value="3"></i><b>(3)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Nombre que identifica al objeto de memoria compartida.
Como ocurre con los archivos, varios procesos pueden acceder al mismo objeto indicando el mismo nombre.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Valores que indican diferentes opciones a la hora de abrir el objeto.
Por ejemplo, usando <code>O_RDWR</code> indicamos que se abra para lectura y escritura.
Mientras que con <code>O_CREAT</code> se indica que el objeto debe crearse si no existía previamente.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Indica los permisos del objeto de memoria compartida al crearlo nuevo, de forma similar a los permisos que se aplican a los archivos en el sistema de archivos.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>El valor devuelto por <a href="https://www.man7.org/linux/man-pages/man3/shm_open.3.html">shm_open()</a> es el descriptor del objeto de memoria compartida, que utilizaremos posteriormente con <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a> al reservar una región de la memoria de nuestro proceso donde ese objeto de memoria compartida será visible:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">void</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="n">length</span><span class="p">,</span>                 <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
    <span class="n">MAP_SHARED</span><span class="p">,</span>             <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">shmfd</span><span class="p">,</span>                  <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="mi">0</span>                       <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Al pasar el descriptor del objeto de memoria compartida, ya no se puede indicar <code>MAP_ANONYMOUS</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Se puede hacer visible para el proceso todo el objeto de memoria compartida o solo una parte.
Para esto último se indica el tamaño de la región y el desplazamiento dentro del objeto, que es el último argumento de <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Un objeto de memoria compartida recién creado tiene tamaño 0.
Para redimensionarlo se utiliza <a href="https://linux.die.net/man/2/ftruncate">ftruncate()</a>, que lo que necesita es el descriptor del objeto y el nuevo tamaño.</p>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap11/shared-memory-server.c">shared-memory-server.c</a> y <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap11/shared-memory-client.cpp">shared-memory-client.cpp</a> se puede ver el ejemplo de un programa que muestra periódicamente la hora del sistema.
En este caso controlado por otro mediante memoria compartida.
Ambos programas usan la clase definida en <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap11/shared_memory.hpp">shared_memory.hpp</a> para gestionar el objeto de memoria compartida.
Sus métodos muestran de forma práctica cómo utilizar las llamadas al sistema comentadas.</p>
</div>
<div class="paragraph">
<p>En Microsoft Windows también se utiliza <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga">CreateFileMapping()</a> para crear el objeto de memoria compartida con nombre.
Simplemente hay que indicar el nombre en el último argumento de la función.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">HANDLE</span> <span class="n">hMapFile</span> <span class="o">=</span> <span class="n">CreateFileMapping</span><span class="p">(</span>
    <span class="n">INVALID_HANDLE_VALUE</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="n">PAGE_READWRITE</span><span class="p">,</span>
    <span class="mi">0</span><span class="p">,</span>
    <span class="n">length</span><span class="p">,</span>
    <span class="s">"Global</span><span class="se">\\</span><span class="s">FooMemoriaCompartida"</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Nombre del nuevo objeto de memoria compartida.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hilos">12. Hilos</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>35 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>En el modelo de proceso que hemos descrito hasta el momento, cada proceso tiene una única secuencia de instrucciones que se ejecuta en la CPU.
Si los procesos solo pueden tener una única secuencia de instrucciones, solo pueden realizar una tarea a la vez.
Por ejemplo, en un procesador de textos en un sistema operativo con este modelo de procesos, el usuario nunca podría escribir al mismo tiempo que se comprueba la ortografía.
Si queremos hacer varias tareas al mismo tiempo, estamos obligados a crear varios procesos y seleccionar un mecanismo de comunicación para que éstos colaboren.</p>
</div>
<div class="paragraph">
<p>Por eso muchos sistemas operativos modernos han extendido el concepto de proceso para permitir que cada uno tenga múltiples secuencias de instrucciones para ejecutarse en la CPU.
A cada una de estas secuencias de instrucciones se las conoce como <strong>hilo</strong> de ejecución.
Los procesos con varios hilos pueden realizar varias tareas a la vez.</p>
</div>
<div class="sect2">
<h3 id="_introducción_2">12.1. Introducción</h3>
<div class="paragraph">
<p>Desde que introducimos el concepto de <strong>proceso</strong> hemos considerado que es la unidad básica de uso de la CPU.
Es decir, que la CPU se asignaba a los procesos, que la usaban para ejecutar sus instrucciones.
Sin embargo, en los <strong>sistemas operativos multihilo</strong> es el <strong>hilo</strong> la unidad básica de uso de la CPU.</p>
</div>
<div id="multihilo" class="imageblock">
<div class="content">
<img src="C12-hilos/media/procesos_multihilo.svg" alt="procesos multihilo">
</div>
<div class="title">Figura 30. Comparación entre procesos monohilo y proceso multihilo.</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Cada hilo tiene una serie de recursos propios dentro del proceso (véase la <a href="#multihilo">Figura 30</a>):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>El identificador del hilo</strong>, que es único para cada hilo y sirve para identificarlos, de la misma manera que lo hace el identificador de proceso con cada proceso.</p>
</li>
<li>
<p><strong>El contador de programa</strong>, que es el registro de la CPU que indica la dirección de la próxima instrucción del hilo que debe ser ejecutada por la CPU.</p>
</li>
<li>
<p><strong>Los registros de la CPU</strong>, cuyos valores son diferentes en cada hilo puesto que, aunque todos los hilos ejecutan el mismo programa, pueden ejecutar diferentes partes del mismo.</p>
</li>
<li>
<p><strong>La pila</strong>, que contiene datos temporales como argumentos y direcciones de retorno de las funciones y variables locales.
Al igual que ocurre con los registros de la CPU, cada hilo necesita su pila porque recorre el programa de manera diferente.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Sin embargo hay otros recursos del proceso que se comparten entre todos los hilos del mismo (véase la <a href="#multihilo">Figura 30</a>):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>El código del programa</strong>.
El programa es el mismo para todos los hilos.</p>
</li>
<li>
<p><strong>Los segmentos BSS y de datos y el montón</strong>.
Las secciones de datos diferentes de la pila son accesibles a todos los hilos.
Eso quiere decir, por ejemplo, que cualquier hilo puede acceder y modificar una variable global o una asignada dinámicamente mediante <a href="https://en.cppreference.com/w/c/memory/malloc">malloc()</a> o <a href="https://en.cppreference.com/w/cpp/language/new">new</a>.</p>
</li>
<li>
<p><strong>Otros recursos del proceso</strong> como archivos, <em>sockets</em>, tuberías y dispositivos abiertos, regiones de memoria compartida, señales, directorio actual de trabajo, entre muchos otros recursos.</p>
</li>
</ul>
</div>
</div>
</div>
<div id="proceso_multihilo_en_memoria" class="imageblock">
<div class="content">
<img src="C12-hilos/media/proceso_multihilo_en_memoria.svg" alt="proceso multihilo en memoria">
</div>
<div class="title">Figura 31. Anatomía de un proceso multihilo en memoria.</div>
</div>
<div class="paragraph">
<p>En la <a href="#proceso_multihilo_en_memoria">Figura 31</a> se puede observar como cambia la disposición de los elementos de un proceso en la memoria cuando es multihilo, respecto a lo que vimos en el <a href="#_el_proceso">Apartado 9.1</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_beneficios">12.2. Beneficios</h3>
<div class="paragraph">
<p>Son muchos los beneficios que aporta la programación multihilo:</p>
</div>
<div class="sect3">
<h4 id="_tiempo_de_respuesta">12.2.1. Tiempo de respuesta</h4>
<div class="paragraph">
<p>Una aplicación multihilo interactiva puede continuar ejecutando tareas aunque uno o varios hilos de la misma estén bloqueados o realizando operaciones muy lentamente, mejorando así el tiempo de respuesta al usuario.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, un navegador web multihilo puede gestionar la interacción del usuario a través de un hilo, mientras el contenido solicitado se descarga en otro.
Para hacer lo mismo en un navegador monohilo habría que utilizar comunicaciones asíncronas, de lo contrario, mientras el proceso está en estado <strong>esperando</strong>, a la espera de que lleguen los datos a través de la red, no puede atender las acciones del usuario.</p>
</div>
</div>
<div class="sect3">
<h4 id="_compartición_de_recursos">12.2.2. Compartición de recursos</h4>
<div class="paragraph">
<p>En sistemas operativos monohilo se pueden crear varios procesos y comunicarlos mediante memoria compartida para conseguir algo similar a lo que ofrecen los sistemas multihilo.
Sin embargo, al utilizar hilos, las tareas ejecutadas en ellos comparten los recursos automáticamente, sin que tengamos que hacer nada.
Además, los hilos no solo comparten la memoria, sino también otros muchos recursos del proceso.
Por lo que los hilos son una forma más conveniente de tener procesos que realizan diferentes actividades al mismo tiempo.</p>
</div>
</div>
<div class="sect3">
<h4 id="_economía">12.2.3. Economía</h4>
<div class="paragraph">
<p>Reservar memoria y otros recursos para la creación de un proceso es muy costoso.
Por eso los sistemas operativos modernos han desarrollado diversas técnicas para que sea lo más eficaz posible.</p>
</div>
<div class="paragraph">
<p>Aun así, puesto que los hilos comparten los recursos de los procesos a los que pertenecen, son mucho más económicos de crear.
También es más económico el cambio de contexto entre ellos ya que hay que guardar y recuperar menos información al cambiar entre dos hilos de un mismo proceso.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, en Microsoft Windows crear un procesos puede ser 300 veces más costoso que un hilo. Mientras que en sistemas Linux es 3 veces más lento, por la eficiencia de <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_aprovechamiento_de_las_arquitecturas_multiprocesador">12.2.4. Aprovechamiento de las arquitecturas multiprocesador.</h4>
<div class="paragraph">
<p>En los sistemas multiprocesador diferentes hilos pueden ejecutarse en paralelo en distintos procesadores.
Por el contrario, un proceso monohilo sólo se puede ejecutar en una CPU a la vez, independientemente de cuantas CPU estén disponibles para ejecutarlo.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_soporte_multihilo">12.3. Soporte multihilo</h3>
<div class="paragraph">
<p>Las <strong>librerías de hilos</strong> proporcionan al programador la interfaz de programación para crear y gestionar los hilos de su proceso.
Hay dos formas de implementar una librería de hilos: en el espacio de usuario o en el núcleo.</p>
</div>
<div class="sect3">
<h4 id="_librería_de_hilos_en_el_espacio_de_usuario">12.3.1. Librería de hilos en el espacio de usuario</h4>
<div class="paragraph">
<p>La librería de hilos se puede implementar en el espacio de usuario, junto al código y los datos del proceso, sin requerir ningún soporte especial por parte del núcleo.</p>
</div>
<div class="paragraph">
<p>Estos hilos no existen para el núcleo del sistema operativo, solo para el proceso que los ha creado.
Por ese motivo se los denomina <strong>hilos de usuario</strong> o <strong>hilos del nivel de usuario</strong>.</p>
</div>
<div class="paragraph">
<p>Como el código y los datos de la librería residen en el espacio de usuario, invocar una función de la misma se reduce a una simple llamada a una función, evitando el coste de hacer llamadas al sistema.</p>
</div>
</div>
<div class="sect3">
<h4 id="_librería_de_hilos_en_el_núcleo">12.3.2. Librería de hilos en el núcleo</h4>
<div class="paragraph">
<p>Si la librería de hilos se implementa en el núcleo, es el núcleo del sistema el que se encarga de darles soporte.
Por ese motivo se los denomina <strong>hilos de núcleo</strong> o <strong>hilos del nivel de núcleo</strong>.</p>
</div>
<div class="paragraph">
<p>Aparte del <strong>PCB</strong> que vimos en el <a href="#_bloque_de_control_de_proceso">Apartado 9.3</a>, cada hilo tiene una estructura llamada <strong>bloque de control del hilo</strong> o TCB (<em>Thread Control Block</em>) que representa a cada hilo en el sistema operativo y que guarda información sobre su estado de actividad actual.</p>
</div>
<div class="paragraph">
<p>En estos sistemas, es el hilo la unidad básica de uso de la CPU.
Son los hilos los que se mueven por los estados del <a href="#diagrama_estado_proceso">Figura 27</a> y las colas de la <a href="#colas_de_planificación_procesos">Figura 28</a> y no los procesos.
El planificador de la CPU selecciona un hilo para ejecutarse en la CPU de entre todos los que están en el estado <strong>preparado</strong> en el sistema y el <strong>cambio de contexto</strong> asigna la CPU a un hilo distinto al que la tiene asignada en el momento actual.</p>
</div>
<div class="paragraph">
<p>Por tanto, es en <strong>TCB</strong> —y no en el <strong>PCB</strong>— donde se guarda la información privada del hilo necesaria para la gestión de los estados y para el cambio de contexto, como: los valores de los registros de la CPU y el contador de programa, el estado o la información de planificación de la CPU; además de un puntero al <strong>PCB</strong> al que pertenece el hilo con el resto de la información privada del proceso.</p>
</div>
<div class="paragraph">
<p>Como el código y los datos de la librería residen en el espacio del núcleo, invocar una función de la misma requiere frecuentemente hacer una llamada al sistema.
Obviamente, la librería del sistema ofrece funciones para no tener que hacer la llamada al sistema directamente.</p>
</div>
<div class="paragraph">
<p>En la actualidad, en los diferentes sistemas operativos se pueden encontrar librerías de ambos tipos.
Por ejemplo, la librería de hilos de Windows API se implementa en el núcleo (véase <a href="https://docs.microsoft.com/en-us/windows/win32/procthread/using-processes-and-threads">«Using Processes and Threads&#8201;&#8212;&#8201;Microsoft Docs»</a>) mientras que la librería de hilos <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a> —frecuentemente utilizada en los sistemas POSIX— puede ser de ambos tipos, dependiendo solamente del sistema donde se implemente. En Linux y en la mayor parte de los UNIX modernos, POSIX Threads se implementa en el núcleo del sistema.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_modelos_multihilo">12.4. Modelos multihilo</h3>
<div class="paragraph">
<p>Las distintas formas de implementar los hilos comentadas anteriormente —en espacio de usuario o en el núcleo— no son excluyentes, ya que en un sistema operativo concreto se pueden implementar ambas, una de las dos o ninguna.</p>
</div>
<div class="paragraph">
<p>A continuación veremos los modelos a los que han dado lugar las distintas combinaciones.</p>
</div>
<div class="sect3">
<h4 id="_muchos_a_uno">12.4.1. Muchos a uno</h4>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>En el modelo <strong>muchos a uno</strong> los hilos que ve el proceso se mapean en un única «entidad planificable en la CPU» del núcleo.</p>
</div>
<div class="paragraph">
<p>Éste, por lo general, es el modelo utilizado cuando el núcleo no soporta múltiples hilos de ejecución.
En ese caso, la única entidad planificable en la CPU que conoce el núcleo es el proceso, la librería de hilos se implementa en el espacio de usuario —dentro del proceso— y los hilos que ve el proceso son <strong>hilos de usuario</strong> (véase la <a href="#modelo_muchos_a_uno">Figura 32</a>).</p>
</div>
<div id="modelo_muchos_a_uno" class="imageblock">
<div class="content">
<img src="C12-hilos/media/modelo_muchos_a_uno.svg" alt="modelo muchos a uno">
</div>
<div class="title">Figura 32. Modelo muchos a uno.</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Las principales características de este modelo son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La gestión de hilos se hace con una librería en el espacio de usuario, por lo que los hilos se pueden crear de forma rápida y con poco coste.
Como hemos visto anteriormente, la invocación de las funciones de la librería se hace por medio de simples llamadas a funciones.</p>
</li>
<li>
<p>Si uno de los hilos solicita al sistema operativo una operación que deba ser bloqueada a la espera —por ejemplo, operaciones de E/S sobre archivos, comunicaciones o esperar a que otro proceso termine— todo el proceso es bloqueado, no pudiendo ejecutarse otros hilos del mismo proceso mientras tanto.
Eso significa que si nuestros hilos hacen ese tipo de operaciones, el resultado es como si no tuviéramos hilos.</p>
</li>
<li>
<p>Como sólo un hilo puede ser asignado al proceso, los hilos de un mismo proceso no se pueden ejecutar en paralelo en sistemas multiprocesador.
El planificador de la librería de hilos es el encargado de determinar qué hilo de usuario es asignado al proceso y éste solo puede ejecutarse en una única CPU al mismo tiempo.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>El problema del bloqueo de procesos puede ser evitado interceptando las llamadas a funciones de la librería del sistema, para evitar el uso de llamadas al sistema que se puedan bloquear y sustituirlas por versiones equivalentes pero asíncronas.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, si un hilo llamase a las funciones <a href="https://man7.org/linux/man-pages/man2/recv.2.html">recv()</a> o <a href="https://man7.org/linux/man-pages/man2/send.2.html">send()</a> de la librería del sistema, habría que hacer que realmente se invocase una versión diferente que utilizase estas funciones de forma asíncrona.
Mientras la operación es ejecutada por el sistema operativo, en lugar de retornar de la función, se llama al planificador de la librería de hilos para que la ejecución continúe con otro hilo del proceso, dejando suspendido el que tiene pendiente la operación.
Obviamente, el planificador de la librería de hilos debe estar al tanto de cuándo las operaciones asíncronas son completadas para poder volver a planificar los <strong>hilos de usuario</strong> suspendidos.</p>
</div>
<div class="paragraph">
<p>Este procedimiento es a todas luces bastante complejo y requiere versiones no bloqueantes de todas las llamadas al sistema —que no siempre existen— así como modificar o interceptar de alguna forma las funciones bloqueantes de la librería del sistema para implementar el comportamiento descrito.</p>
</div>
<div class="sect4">
<h5 id="_implementaciones">Implementaciones</h5>
<div class="paragraph">
<p>A este modelo de hilos frecuentemente se lo llama <a href="https://en.wikipedia.org/wiki/Green_threads">Green Threads</a>.
En Java 1.1 era el único modelo soportado, pero debido a sus limitaciones se implementó el soporte del modelo <strong>uno a uno</strong> en versiones posteriores.</p>
</div>
<div class="paragraph">
<p>Otras implementaciones de este modelo son las <a href="https://docs.microsoft.com/en-us/windows/win32/procthread/fibers">fibras</a> de Windows API, <a href="http://www.stackless.com/">Stackless Python</a> y <a href="http://www.gnu.org/software/pth/">GNU Portable Threads</a>.
Estas implementaciones son muy útiles en los sistemas monohilo, de cara a poder ofrecer cierto soporte de hilos a las aplicaciones.
Pero también lo son en los sistemas multihilo, ya que debido a su bajo coste en recursos y a su alta eficiencia son ideales cuando la cantidad de hilos a crear —el nivel de concurrencia— va a ser previsiblemente muy alta.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_uno_a_uno">12.4.2. Uno a uno</h4>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>En el modelo <strong>uno a uno</strong> cada hilo que ve el proceso se mapea en una «entidad planificable en la CPU» diferente del núcleo.</p>
</div>
<div class="paragraph">
<p>Éste, por lo general, es el modelo utilizado cuando el núcleo del sistema operativo soporta hilos de ejecución.
En este caso, la librería de hilos se implementa en el núcleo, por lo que las entidades que planifica el núcleo en la CPU son los <strong>hilos de núcleo</strong> y los procesos pueden gestionar estos hilos mediante llamadas al sistema.</p>
</div>
<div id="modelo_uno_a_uno" class="imageblock">
<div class="content">
<img src="C12-hilos/media/modelo_uno_a_uno.svg" alt="modelo uno a uno">
</div>
<div class="title">Figura 33. Modelo uno a uno.</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Las principales características de este modelo son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Permite a otros hilos del mismo proceso ejecutarse aun cuando uno de ellos haga una llamada al sistema que debe bloquearse.
El núcleo se encarga de ponerlo en espera y planificar en la CPU a otro de los hilos preparados para ejecutarse de entre todos los existentes en el sistema.</p>
</li>
<li>
<p>Permite paralelismo en sistemas multiprocesador, ya que diferentes hilos pueden ser planificados por el núcleo en distintos procesadores.</p>
</li>
<li>
<p>Crear un hilo para un proceso implica crear ciertas estructuras de datos en el núcleo.
Debido a que la cantidad de memoria disponible para el núcleo suele estar limitada, muchos sistemas restringen la cantidad máxima de <strong>hilos de núcleo</strong> soportados.</p>
</li>
<li>
<p>La gestión de los hilos se hace con una librería en el espacio de núcleo, lo que requiere que el proceso haga llamadas al sistema para gestionarlos.
Esto siempre es más lento que invocar simplemente una función, como ocurre en el modelo <strong>muchos a uno</strong>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Este modelo se utilizar en la mayor parte de los sistemas operativos multihilo modernos.
Linux, Microsoft Windows —desde Windows 95— <a href="https://es.wikipedia.org/wiki/Solaris_(sistema_operativo)">Solaris</a> 9 y superiores, macOS y la familia de UNIX BSD; son ejemplos de sistemas operativos que utiliza el modelo <strong>uno a uno</strong>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_muchos_a_muchos">12.4.3. Muchos a muchos</h4>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>En teoría debería ser posible aprovechar lo mejor de los dos modelos anteriores con una librería de hilos en el núcleo, para crear <strong>hilos de núcleo</strong>, y otra en el espacio de usuario, para crear <strong>hilos de usuario</strong>.
Así los desarrolladores pueden utilizar la librería de hilos en el espacio de usuario para crear tantos hilos como quieran y que se ejecuten sobre los <strong>hilos de núcleo</strong>.</p>
</div>
<div class="paragraph">
<p>El planificador de la librería de hilos se encarga de determinar qué hilo de usuario es asignado a qué hilo de núcleo.
Mientras que el planificador de la CPU asigna la CPU a alguno de los <strong>hilos de núcleo</strong> del sistema.</p>
</div>
<div id="modelo_muchos_a_muchos" class="imageblock">
<div class="content">
<img src="C12-hilos/media/modelo_muchos_a_muchos.svg" alt="modelo muchos a muchos">
</div>
<div class="title">Figura 34. Modelo muchos a muchos.</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>En el modelo <strong>muchos a muchos</strong> se mapean los <strong>hilos de usuario</strong> en un menor o igual número de <strong>hilos de núcleo</strong> del proceso (véase la <a href="#modelo_muchos_a_muchos">Figura 34</a>).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Permite paralelismo en sistemas multiprocesador, ya que diferentes <strong>hilos de núcleo</strong> pueden ser planificados en distintos procesadores y en cada uno puede ejecutarse cualquier hilo de usuario.</p>
</li>
<li>
<p>Permite a otro hilo de usuario del mismo proceso ejecutarse cuando un hilo hace una llamada al sistema que debe bloquearse, puesto que si esto ocurre el correspondiente hilo de núcleo queda bloqueado.
Sin embargo, el resto de los <strong>hilos de usuario</strong> pueden seguir ejecutándose en los otros <strong>hilos de núcleo</strong> del proceso.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Este modelo se soportada en sistemas <a href="https://es.wikipedia.org/wiki/FreeBSD">FreeBSD</a> y versiones antiguas de <a href="https://es.wikipedia.org/wiki/NetBSD">NetBSD</a>, así como en UNIX comerciales, como: <a href="https://es.wikipedia.org/wiki/Solaris_(sistema_operativo)">Solaris</a> 8 y anteriores, {irixnix, <a href="https://es.wikipedia.org/wiki/HP-UX">HP-UX</a> y <a href="https://es.wikipedia.org/wiki/Tru64">Tru64 UNIX</a>.
También Microsoft Windows —a partir de Windows 7— soporta este modelo gracias a incorporar un mecanismo denominado planificación en modo usuario (véase <a href="https://docs.microsoft.com/en-us/windows/win32/procthread/user-mode-scheduling">«User-Mode Scheduling&#8201;&#8212;&#8201;Microsoft Docs»</a>).</p>
</div>
<div class="paragraph">
<p>Algunos lenguajes de programación implementan el modelo <strong>muchos a muchos</strong> sobre el modelo <strong>uno a uno</strong> soportado por la mayoría de sistemas operativos modernos.
Ese es el caso de <a href="https://es.wikipedia.org/wiki/Go_(lenguaje_de_programaci%C3%B3n)">Go</a>, <a href="https://es.wikipedia.org/wiki/Erlang">Erlang</a> y <a href="https://es.wikipedia.org/wiki/Elixir_(lenguaje_de_programaci%C3%B3n)">Elixir</a>.</p>
</div>
<div class="sect4">
<h5 id="_activación_del_planificador">Activación del planificador</h5>
<div class="paragraph">
<p>Tanto en el modelo <strong>muchos a muchos</strong> como en el de <strong>dos niveles</strong> es necesario cierto grado de coordinación entre el núcleo y la librería de hilos del espacio de usuario.
Dicha comunicación tiene como objeto ajustar dinámicamente el número de <strong>hilos de núcleo</strong> para garantizar la máxima eficiencia.</p>
</div>
<div class="paragraph">
<p>Uno de los esquemas de comunicación se denomina <strong>activación del planificador</strong> y consiste en que el núcleo informa a la librería de hilos en espacio de usuario que una llamada al sistema va a bloquear un hilo de un proceso.
Antes de dicha notificación, el núcleo se encarga de crear un nuevo hilo de núcleo en el proceso y se lo pasa la librería de hilos en la notificación.
Así, el planificador de la librería puede asignarle alguno de los otros <strong>hilos de usuario</strong>, evitando el bloqueo completo del proceso y ajustando el número de <strong>hilos de núcleo</strong> dinámicamente.</p>
</div>
<div class="paragraph">
<p>Debido a la complejidad del mecanismo descrito anteriormente y a la dificultad de coordinar el planificador de la libraría de hilos con el de la CPU para obtener un rendimiento óptimo, sistemas como Linux y <a href="https://es.wikipedia.org/wiki/Solaris_(sistema_operativo)">Solaris</a> —a partir de la versión 9— han optado finalmente por el modelo <strong>uno a uno</strong>.</p>
</div>
<div class="paragraph">
<p>Con el objetivo de evitar los problemas derivados del coste de dicho modelo, los desarrolladores de Linux han preferido concentrar sus esfuerzos en conseguir un planificador de CPU más eficiente, así como en reducir los costes de la creación de <strong>hilos de núcleo</strong>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_dos_niveles">12.4.4. Dos niveles</h4>
<div class="paragraph">
<p>Existe una variación del modelo <strong>muchos a muchos</strong> donde, además de funcionar de la forma comentada anteriormente, se permite que un hilo de usuario quede ligado indefinidamente a un único hilo de núcleo, como en el modelo <strong>uno a uno</strong>.</p>
</div>
<div class="paragraph">
<p>Esta variación se denomina, en ocasiones, modelo de <strong>dos niveles</strong> (véase la <a href="#modelo_de_dos_niveles">Figura 35</a>).</p>
</div>
<div id="modelo_de_dos_niveles" class="imageblock">
<div class="content">
<img src="C12-hilos/media/modelo_de_dos_niveles.svg" alt="modelo de dos niveles">
</div>
<div class="title">Figura 35. Modelo muchos a uno.</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_operaciones_sobre_los_hilos">12.5. Operaciones sobre los hilos</h3>
<div class="paragraph">
<p>Como ocurre con los procesos, es necesario que los hilos pueden ser creados y eliminados dinámicamente, por lo que los sistemas operativos deben proporcionar servicios para la creación y cancelación de los mismos.</p>
</div>
<div class="sect3">
<h4 id="_creación_de_hilos">12.5.1. Creación de hilos</h4>
<div class="paragraph">
<p>En un sistema operativo con librería de hilos implementada en el núcleo, todo proceso se crea con un hilo, denominado <strong>hilo principal</strong>.
Éste es con el que comienza a ejecutarse el programa al entrar en <a href="https://en.cppreference.com/w/c/language/main_function">main()</a> y el que provoca la terminación de todo el proceso —incluida la terminación de los otros hilos que existan— al retornar de dicha función.</p>
</div>
<div class="paragraph">
<p>El <strong>hilo principal</strong> puede crear otros hilos y estos, a su vez, crear los hilos que necesiten.
Pero, a diferencia de lo que ocurre con los procesos, no existe una relación de padres a hijos ni se crea un árbol del hilos.
Excepto por la características especial del <strong>hilo principal</strong> de que su finalización significa la terminación del proceso, todos los hilos son iguales entre sí.</p>
</div>
<div class="paragraph">
<p>En el <a href="#ejemplo_pthread">Ejemplo 5</a> se puede ver como se usa <a href="https://man7.org/linux/man-pages/man3/pthread_create.3.html">pthread_create()</a> en sistemas POSIX que implementan <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a> para crear varios hilos y esperar a que terminen con <a href="https://man7.org/linux/man-pages/man3/pthread_join.3.html">pthread_join()</a>.</p>
</div>
<div id="ejemplo_pthread" class="exampleblock">
<div class="title">Ejemplo 5. Calcular el factorial de un número con <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a>.</div>
<div class="content">
<div class="paragraph">
<p>Vamos a calcular el factorial de 122 repartiendo la tarea entre dos hilos con el objeto de paralelizar los cálculos en procesadores multinúcleo.</p>
</div>
<div class="paragraph">
<p>El código fuente completo de este ejemplo está disponible en <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap12/pthreads.cpp">pthreads.cpp</a> y, además, permite indicar el número que queramos para calcularle el factorial.
En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap12/threads.cpp">threads.cpp</a> se puede estudiar un ejemplo equivalente pero usando <a href="https://en.cppreference.com/w/cpp/thread/thread">std::thread</a> de la librería estándar de C&#43;&#43;, por lo que también compila en sistemas no POSIX, como Microsoft Windows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">struct</span> <span class="nc">factorial_thread_args</span> <i class="conum" data-value="9"></i><b>(9)</b>
<span class="p">{</span>
    <span class="n">BigInt</span> <span class="n">number</span><span class="p">;</span>
    <span class="n">BigInt</span> <span class="n">lower_bound</span><span class="p">;</span>
    <span class="n">BigInt</span> <span class="n">result</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">factorial_thread</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span>   <i class="conum" data-value="7"></i><b>(7)</b> <i class="conum" data-value="8"></i><b>(8)</b> <i class="conum" data-value="9"></i><b>(9)</b>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">fmt</span><span class="o">::</span><span class="n">format</span><span class="p">(</span> <span class="s">"Hilo creado: 0x{:x}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pthread_self</span><span class="p">()</span> <span class="p">);</span>    <i class="conum" data-value="10"></i><b>(10)</b>

    <span class="n">factorial_thread_args</span><span class="o">*</span> <span class="n">args</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">factorial_thread_args</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span> <i class="conum" data-value="9"></i><b>(9)</b>
    <span class="n">args</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">calculate_factorial</span><span class="p">(</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">lower_bound</span> <span class="p">);</span>

    <span class="k">return</span> <span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">;</span> <i class="conum" data-value="12"></i><b>(12)</b>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">return_code</span><span class="p">;</span>
    <span class="n">pthread_t</span> <span class="n">thread1</span><span class="p">,</span> <span class="n">thread2</span><span class="p">;</span>  <i class="conum" data-value="1"></i><b>(1)</b> <i class="conum" data-value="2"></i><b>(2)</b>

    <span class="n">factorial_thread_args</span> <span class="n">thread1_args</span> <span class="p">{</span>
        <span class="mi">122</span><span class="p">,</span>    <span class="c1">// El primer hilo calcula el factorial multiplicando</span>
        <span class="mi">61</span><span class="p">,</span>     <span class="c1">// desde 122 a 61.</span>
        <span class="mi">0</span>
    <span class="p">};</span>

    <span class="n">factorial_thread_args</span> <span class="n">thread2_args</span> <span class="p">{</span>
        <span class="mi">60</span><span class="p">,</span>     <span class="c1">// El segundo hilo calcula el factorial multiplicando</span>
        <span class="mi">2</span><span class="p">,</span>      <span class="c1">// desde 60 a 2</span>
        <span class="mi">0</span>
    <span class="p">};</span>

    <span class="kt">int</span> <span class="n">return_code</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span> <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="o">&amp;</span><span class="n">thread1</span><span class="p">,</span>           <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="nb">nullptr</span><span class="p">,</span>            <i class="conum" data-value="6"></i><b>(6)</b>
        <span class="n">factoria_thread</span><span class="p">,</span>    <i class="conum" data-value="7"></i><b>(7)</b>
        <span class="o">&amp;</span><span class="n">thread_args</span> <span class="p">);</span>      <i class="conum" data-value="8"></i><b>(8)</b> <i class="conum" data-value="9"></i><b>(9)</b>

    <span class="k">if</span> <span class="p">(</span><span class="n">return_code</span><span class="p">)</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">fmt</span><span class="o">::</span><span class="n">format</span><span class="p">(</span> <span class="s">"Error ({}) al crear el hilo: {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="n">return_code</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">return_code</span><span class="p">)</span> <span class="p">);</span> <i class="conum" data-value="5"></i><b>(5)</b>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">return_code</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">thread2</span><span class="p">,</span> <span class="cm">/* ... */</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">return_code</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="n">BigInt</span><span class="o">*</span> <span class="n">thread1_result</span><span class="p">,</span> <span class="o">*</span><span class="n">thread2_result</span><span class="p">;</span>
    <span class="n">pthread_join</span><span class="p">(</span> <i class="conum" data-value="11"></i><b>(11)</b>
        <span class="n">thread1</span><span class="p">,</span>
        <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">**&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread1_result</span><span class="p">)</span> <span class="p">);</span> <i class="conum" data-value="13"></i><b>(13)</b>
    <span class="n">pthread_join</span><span class="p">(</span> <span class="n">thread2</span><span class="p">,</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">**&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread2_result</span><span class="p">)</span> <span class="p">);</span>

    <span class="c1">// Multiplicar ambos resultados para obtener el factorial</span>
    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="o">*</span><span class="n">thread1_result</span> <span class="o">*</span> <span class="o">*</span><span class="n">thread2_result</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">fmt</span><span class="o">::</span><span class="n">format</span><span class="p">(</span> <span class="s">"El factorial de {} es {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
        <span class="n">number</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span> <span class="n">result</span><span class="p">.</span><span class="n">to_string</span><span class="p">()</span> <span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>En <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a> se usa <a href="https://man7.org/linux/man-pages/man3/pthread_create.3.html">pthread_create()</a> para crear hilos.
Devuelve un manejador de tipo <code>pthread_t</code> que podemos usar con otras funciones de la API para indicar el hilo que queremos gestionar.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>pthread_t</code> no es el equivalente al PID de los hilos.
Si el sistema implementa la librería de hilos en el núcleo, por lo general, cada hilo tiene un identificador único; pero <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a> no ofrece una forma de obtenerlo.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>La variable <code>pthread_t</code> se pasa a <a href="https://man7.org/linux/man-pages/man3/pthread_create.3.html">pthread_create()</a> como puntero para que al retornar, si todo ha ido bien, contenga el manejador del hilo.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Si el hilo se puede crear, <a href="https://man7.org/linux/man-pages/man3/pthread_create.3.html">pthread_create()</a> devuelve 0.
En caso contrario devuelve un código de error.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Los códigos de error son los mismos que hasta ahora veíamos en <a href="https://man7.org/linux/man-pages/man3/errno.3.html">errno</a>.
Así que podemos llamar a <a href="https://man7.org/linux/man-pages/man3/strerror.3.html">strerror()</a> pasando el valor retornado, para obtener un texto descriptivo del error.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Es opcional pasar a <a href="https://man7.org/linux/man-pages/man3/pthread_create.3.html">pthread_create()</a> una estructura con atributos tales como: tamaño y posición de la pila, política y parámetros de planificación, entre otros.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Todo hilo tiene una función principal que será dónde comience la ejecución del hilo.
Cuando esa función termine, el hilo finalizará.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Los hilos pueden recibir un argumento en la forma de un puntero a <code>void*</code>.
Si queremos pasar varios, lo más sencillo es crear una estructura.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>En este ejemplo definimos <code>factorial_thread_args</code> para pasar los argumentos a los hilos y lo pasamos como <code>void *</code> a la función principal.
Allí hacemos un <em>typecast</em> para recuperar el puntero a la estructura <code>factorial_thread_args</code> y poder acceder a sus campos.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>En cualquier momento se puede llamar a <a href="https://man7.org/linux/man-pages/man3/pthread_self.3.html">pthread_self()</a> para obtener el manejador <code>pthread_t</code> del hilo actual.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>El hilo que invoca <a href="https://man7.org/linux/man-pages/man3/pthread_join.3.html">pthread_join()</a> se queda dormido hasta que el hilo indicado en el primer argumento termine.
Si el hilo principal sale de <a href="https://en.cppreference.com/w/c/language/main_function">main()</a> sin esperar a que todos los hilos del proceso terminen, éstos mueren inmediatamente, junto con el proceso.</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>El hilo puede retornar un resultado mediante un puntero 'void*'.
Éste se indica en la sentencia <code>return</code> de la función principal del hilo o invocando <a href="https://man7.org/linux/man-pages/man3/pthread_exit.3.html">pthread_exit()</a> para terminar.</td>
</tr>
<tr>
<td><i class="conum" data-value="13"></i><b>13</b></td>
<td>La función <a href="https://man7.org/linux/man-pages/man3/pthread_join.3.html">pthread_join()</a> acepta un puntero a <code>void*</code> para devolver ese valor de retorno al hilo que la invoca.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Como los hilos de <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a> devuelven punteros, es importante no intentar devolver variables locales, ya que se destruirán cuando el hilo termine y el punto devuelto no será válido.</p>
</div>
<div class="paragraph">
<p>Una alternativa es devolver los resultados a través de la estructura pasada como argumento.
Por ejemplo, el campo <code>result</code> de la estructura <code>factorial_thread_args</code> ofrece una manera más cómoda de obtener el resultado del cálculo de cada hilo.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_cancelación_de_hilos">12.5.2. Cancelación de hilos</h4>
<div class="paragraph">
<p>La <strong>cancelación</strong> es la operación de terminar un hilo antes de que termine su trabajo.
Por ejemplo, en un navegador web un hilo se puede encargar de la interfaz de usuario mientras otros hilos se encargan de descargar las páginas y las imágenes de la misma.
Si el usuario pulsa el botón <strong>Cancelar</strong> es necesario que todos los hilos que intervienen en la descarga sean cancelados.</p>
</div>
<div class="paragraph">
<p>Esto puede ocurrir de dos maneras:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En la <strong>cancelación asíncrona</strong> el hilo termina inmediatamente.
Esto puede causar problemas al no liberarse los recursos reservados en el proceso por parte del hilo
Por ejemplo, antes de terminar no se cierran archivos abiertos ni se libera memoria de los que solo este hilo tiene los descriptores de archivo y los punteros, respectivamente.</p>
<div class="paragraph">
<p>Además, si el hilo que termina estaba modificando datos que compartía con otros hilos, estos cambios podrían quedar a medias.
Esto puede dejar las estructuras de datos compartidas en un estado inconsistente, causando problemas en otros hilos.</p>
</div>
</li>
<li>
<p>En la <strong>cancelación en diferido</strong> el hilo comprueba periódicamente cuando debe terminar.
Si no se tiene cuidado, los problemas pueden ser similares a los de la <strong>cancelación asíncrona</strong>.
La diferencia es que ahora el desarrollador conoce de antemano los puntos donde podría terminar el hilo, lo que da una oportunidad de introducirlos solo dónde sea seguro terminar.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Se denomina <strong>fuga de memoria</strong> al error que ocurre cuando un bloque de memoria reservada no se libera durante la ejecución del programa.
También pueden ocurrir fugas con otros recursos del sistema operativo, como: archivos, <em>sockets</em>, colas de mensajes o regiones de memoria compartida.</p>
</div>
<div class="paragraph">
<p>Generalmente ocurre porque se pierden todas las referencias a un recurso, por lo que ya no hay oportunidad de liberarlo.
Por ejemplo, cuando se cancela un hilo que es el único que tiene algunas referencias, sin liberar antes esos recursos.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_cancelación_en_posix_threads">12.5.3. Cancelación en POSIX Threads</h4>
<div class="paragraph">
<p>En <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a> un hilo puede solicitar la cancelación de otro hilo usando [pthread_cancel()].</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="n">return_code</span> <span class="o">=</span> <span class="n">pthread_cancel</span><span class="p">(</span><span class="kr">thread</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>El hilo identificado por el manejador <code>thread</code> será cancelado si está configurado como cancelable.
Por defecto todos los hilos son cancelables, pero eso lo puede cambiar el propio hilo llamando a <a href="https://man7.org/linux/man-pages/man3/pthread_setcancelstate.3.html">pthread_setcancelstate()</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="n">return_code</span> <span class="o">=</span> <span class="n">pthread_setcancelstate</span><span class="p">(</span>
    <span class="n">PTHREAD_CANCEL_DISABLE</span><span class="p">,</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="o">&amp;</span><span class="n">oldstate</span>               <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Con <code>PTHREAD_CANCEL_DISABLE</code> se desactiva la cancelación en el hilo que llama la función.
El otro valor posible es <code>PTHREAD_CANCEL_ENABLE</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>La función devuelve a través de un puntero a <code>int</code> el valor anterior del estado de cancelación.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>El tipo de cancelación se puede configurar con <a href="https://www.man7.org/linux/man-pages/man3/pthread_setcanceltype.3.html">pthread_setcanceltype()</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="n">return_code</span> <span class="o">=</span> <span class="n">pthread_setcanceltypr</span><span class="p">(</span>
    <span class="n">PTHREAD_CANCEL_DEFERRED</span><span class="p">,</span>    <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="o">&amp;</span><span class="n">oldtype</span>                    <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Con <code>PTHREAD_CANCEL_DEFERRED</code> se activa la <strong>cancelación en diferido</strong>, que de todas formas es el tipo de cancelación por defecto. El otro valor posible es <code>PTHREAD_CANCEL_ASYNCHRONOUS</code>, que corresponde con la <strong>cancelación asíncrona</strong>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>La función devuelve a través de un puntero a <code>int</code> el valor anterior del tipo de cancelación.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Se pueden cambiar entre estado y tipo de cancelación en cualquier momento, según lo que encaje mejor con las características de las distintas parte del código.</p>
</div>
<div class="sect4">
<h5 id="_cancelación_asíncrona">Cancelación asíncrona</h5>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Por los motivos comentados anteriormente, no es recomendable la <strong>cancelación asíncrona</strong>, a menos que estemos muy seguros de que no puede causar problemas.
Uno de los pocos casos con los que es compatible es en bucles 100% dedicados a ejecutar cálculos en la CPU, como el siguiente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="n">factorial</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">number</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">factorial</span> <span class="o">=</span> <span class="n">factorial</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>La <strong>cancelación asíncrona</strong> no se debe usar si el código reserva memoria dinámicamente o solicita otros recurso del sistema operativo, porque el hilo podría terminar en cualquier momento sin liberarlos.
Tampoco si se modifican estructuras de datos, porque los cambios pueden quedar a medias.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, si la cancelación ocurre en medio de una llamada a <a href="https://en.cppreference.com/w/c/memory/malloc">malloc()</a> o <a href="https://en.cppreference.com/w/cpp/language/new">new</a> no hay forma de saber si ocurrió antes de que la memoria fuera reservada o después.
Incluso puede haber ocurrido en medio de la operación, dejando en estado inconsistente las estructuras de datos que sirven para seguir la pista de las zonas de memoria reservadas y libres.</p>
</div>
<div class="paragraph">
<p>El estándar POSIX solo indica que las funciones <a href="https://man7.org/linux/man-pages/man3/pthread_setcancelstate.3.html">pthread_setcancelstate()</a> y <a href="https://www.man7.org/linux/man-pages/man3/pthread_setcanceltype.3.html">pthread_setcanceltype()</a> deben ser seguras frente a la <strong>cancelación asíncrona</strong> del hilo.
En general, no se puede llamar a otras funciones de la librería del sistema de forma segura en un hilo cancelable asíncronamente.</p>
</div>
</div>
<div class="sect4">
<h5 id="_cancelación_en_diferido">Cancelación en diferido</h5>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Por tanto, la <strong>cancelación en diferido</strong> es la mejor alternativa.
Con este tipo de cancelación, la terminación del hilo ocurre en puntos concretos del código.</p>
</div>
<div class="paragraph">
<p>En la terminología de <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a> a estos puntos se los denomina <strong>puntos de cancelación</strong> y la inmensa mayoría de las llamadas al sistema que puede poner el hilo en estado <strong>esperando</strong> lo son por si mismas.
Por ejemplo, <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a>, <a href="https://man7.org/linux/man-pages/man2/close.2.html">close()</a>, <a href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a>, <a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a>, <a href="https://man7.org/linux/man-pages/man2/recv.2.html">recv()</a>, <a href="https://man7.org/linux/man-pages/man2/send.2.html">send()</a>, <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a> y <a href="https://man7.org/linux/man-pages/man3/sleep.3.html">sleep()</a>, entre muchas otras (véase la lista en la sección «<em>Cancellation points</em>» de la documentación de <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a>).
Eso significa que seguramente también sean <strong>puntos de cancelación</strong>, las funciones de la librería del sistema y de la librería estándar del lenguaje que utilizan esas llamadas al sistema.</p>
</div>
<div class="paragraph">
<p>Sabiendo esto, se puede estudiar cada caso.
Si no es seguro permitir la cancelación de un hilo en la invocación de una de estas funciones en nuestro código, se puede usa <a href="https://man7.org/linux/man-pages/man3/pthread_setcancelstate.3.html">pthread_setcancelstate()</a> para desactivar temporalmente el mecanismo de cancelación.
Por ejemplo, una llamada a <a href="https://en.cppreference.com/w/c/io/fprintf">printf()</a> como ayuda para depurar, en medio de los pasos para modificar una estructura de datos —como una lista enlazada o una cola— introduce un <strong>punto de cancelación</strong> en lugar poco seguro; porque
si el hilo se cancela en ese punto, la estructura de datos quedará en estado inconsistente.
La solución es eliminar la llamada a <a href="https://en.cppreference.com/w/c/io/fprintf">printf()</a> o desactivar temporalmente el mecanismo de cancelación.</p>
</div>
<div class="paragraph">
<p>De forma inversa, se pueden introducir manualmente puntos de cancelación llamando a <a href="https://man7.org/linux/man-pages/man3/pthread_testcancel.3.html">pthread_testcancel()</a>.
Por ejemplo, el siguiente bucle no hace llamadas al sistema, por lo que no tiene puntos de cancelación:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="n">factorial</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">number</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">factorial</span> <span class="o">=</span> <span class="n">factorial</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Eso significa que ese código para calcular el factorial de <code>number</code> podría ejecutarse durante bastante tiempo sin ofrecer una oportunidad para cancelar el hilo; incluso aunque es un código muy seguro desde el punto de vista de la cancelación.
La solución es introducir manualmente un punto de cancelación:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="n">factorial</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">number</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">factorial</span> <span class="o">=</span> <span class="n">factorial</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">pthread_testcancel</span><span class="p">();</span>   <i class="conum" data-value="1"></i><b>(1)</b>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Comprobar si se ha solicitado la cancelación del hilo y si es así, cancelar el hilo.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>La <strong>cancelación en diferido</strong> también presenta retos desde el punto de visto de evitar las fugas de memoria y de otros recursos cuando un hilo es cancelado.
Por ejemplo, supongamos que tenemos una función que abre una tubería, crea un hilo para gestionar los mensajes que llegan y devuelve un puntero a una estructura de datos que se puede usar en otras funciones de la librería —de forma similar a <a href="https://en.cppreference.com/w/c/io/fopen">fopen()</a> y <code>FILE*</code>—:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">CONN</span><span class="o">*</span> <span class="nf">conn_open</span><span class="p">(</span> <span class="cm">/* ... */</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">CONN</span><span class="o">*</span> <span class="n">handler</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CONN</span><span class="p">)</span> <span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">handler</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">handler</span><span class="o">-&gt;</span><span class="n">fifofd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span> <span class="cm">/* ... */</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fifofd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">free</span><span class="p">(</span> <span class="n">handler</span> <span class="p">);</span> <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">return_code</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handler</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">,</span> <span class="cm">/* ... */</span><span class="p">,</span> <span class="n">handler</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">return_code</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">close</span><span class="p">(</span> <span class="n">handler</span><span class="o">-&gt;</span><span class="n">fifofd</span> <span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="n">free</span><span class="p">(</span> <span class="n">handler</span> <span class="p">);</span> <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">handler</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Evitar la <strong>fuga de memoria</strong> si <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a> o <a href="https://man7.org/linux/man-pages/man3/pthread_create.3.html">pthread_create()</a> fallan.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Evitar la fuga del <em>socket</em> si <a href="https://man7.org/linux/man-pages/man3/pthread_create.3.html">pthread_create()</a> falla.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Este código y la forma en que maneja los errores funciones bien en programas monohilo, porque estamos seguro de que al salir de la función o se completaron todas las etapas o ninguna.
Es decir, si alguna de las peticiones al sistema falla, las hechas anteriormente se «deshacen» para evitar la fuga de recursos.</p>
</div>
<div class="paragraph">
<p>Pero no es correcto en programas multihilo porque <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a> y <a href="https://man7.org/linux/man-pages/man2/close.2.html">close()</a> son <strong>puntos de cancelación</strong>.
Si <code>conn_open()</code> es llamada desde un hilo y ese hilo es cancelado, el hilo podría terminar a mitad de la función, sin liberar <code>handler</code>, creando un <strong>fuga de memoria</strong> que no se liberará hasta que el proceso termine.
Si <code>conn_open()</code> es llamada en múltiples ocasiones, cada una es una oportunidad para perder memoria.</p>
</div>
<div class="paragraph">
<p>El código anterior se puede mejorar usando <strong>manejadores de limpieza</strong>.
Esos manejadores se organizan en una pila de la que se pueden insertar o extraer llamando a <a href="https://man7.org/linux/man-pages/man3/pthread_cleanup_push.3.html">pthread_cleanup_push()</a> y <a href="https://man7.org/linux/man-pages/man3/pthread_cleanup_pop.3.html">pthread_cleanup_pop()</a>, respectivamente.
Cuando el hilo es cancelado, la librería extrae los manejadores de la pila y los va ejecutando en orden, antes de terminar.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">CONN</span><span class="o">*</span> <span class="nf">conn_open</span><span class="p">(</span> <span class="cm">/* ... */</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">CONN</span><span class="o">*</span> <span class="n">handler</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CONN</span><span class="p">)</span> <span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">handler</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">pthread_cleanup_push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span> <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="n">handler</span><span class="o">-&gt;</span><span class="n">fifofd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span> <span class="cm">/* ... */</span> <span class="p">);</span>  <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="k">if</span> <span class="p">(</span><span class="n">fifofd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">pthread_cleanup_pop</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>     <span class="c1">// free(handler) </span><i class="conum" data-value="3"></i><b>(3)</b>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">pthread_cleanup_push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cleanup_fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">fifofd</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">return_code</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handler</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">,</span> <span class="cm">/* ... */</span><span class="p">,</span> <span class="n">handler</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">return_code</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">close</span><span class="p">(</span> <span class="n">handler</span><span class="o">-&gt;</span><span class="n">fifofd</span> <span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="n">pthread_cleanup_pop</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>     <span class="c1">// free(handler) </span><i class="conum" data-value="3"></i><b>(3)</b>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">pthread_cleanup_pop</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <i class="conum" data-value="4"></i><b>(4)</b>

    <span class="k">return</span> <span class="n">handler</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Nada más reservar la memoria de <code>CONN</code> se añade un <strong>manejador de limpieza</strong> que llamará a <code>free(handler)</code> si el hilo va a ser cancelado.
Así nos aseguramos que <code>handler</code> será liberado si el hilo es cancelado.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>La cancelación solo puede ocurrir en los <strong>puntos de cancelación</strong> que son las llamadas a <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a> y <a href="https://man7.org/linux/man-pages/man2/close.2.html">close()</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>En caso de error, el <strong>manejador de limpieza</strong> ya no hace falta, así que se extrae antes de salir de la función.
Se llama a <a href="https://man7.org/linux/man-pages/man3/pthread_cleanup_pop.3.html">pthread_cleanup_pop()</a> con valor distinto de 0 porque así la función extrae el manejador y lo invoca.
A fin de cuentas se sale a causa de un error, por lo que sigue siendo necesario ejecutar <code>free(handler)</code> para evitar una <strong>fuga de memoria</strong>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Al termina la función se extraen todos los manejadores de señal, puesto que ya no hacen falta.
El argumento 0 hace que <a href="https://man7.org/linux/man-pages/man3/pthread_cleanup_pop.3.html">pthread_cleanup_pop()</a> no ejecute el manejador de limpieza extraido.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Ahora <code>conn_open()</code> maneja correctamente la cancelación del hilo donde se ejecuta, por lo que puede usarse sin problemas en aplicaciones multihilo.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_cancelación_de_hilos_en_lenguajes_de_alto_nivel">12.5.4. Cancelación de hilos en lenguajes de alto nivel</h4>
<div class="paragraph">
<p>El mecanismo de cancelación de hilos descrito funciona razonablemente bien en C, pero no con lenguajes de más alto nivel, como C&#43;&#43;, Java o C#.
Las librerías de hilos suelen ser librerías en C, que no conocen nada de objetos ni de otras particularidades de esos lenguajes.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, en C&#43;&#43;, antes de terminar un hilo, deberían ser llamados todos los destructores de los objetos locales, para evitar <strong>fugas de memoria</strong> y de otros recursos, datos sin escribir y otro problemas derivados de tener objetos que no se destruyen adecuadamente.
Lamentablemente, el mecanismo de cancelación de <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a> —y el de otras librerías de hilos, como la de Windows API— no sabe hacer nada de eso.
Cada lenguaje debe implementar su propia solución.</p>
</div>
<div class="paragraph">
<p>En Java y C#, por ejemplo, cuando un punto de cancelación detecta una petición de cancelación emite la excepción <code>Thread.Interrupt</code>, que retrocede por la pila de llamadas, liberando las variables locales hasta salir por el método principal del hilo.
A este mecanismo se lo denomina <strong>cancelación coordinada</strong>.</p>
</div>
<div class="paragraph">
<p>En C&#43;&#43; no se ha incluido un mecanismo de cancelación en el estándar hasta C&#43;&#43;20.
Antes de C&#43;&#43;20, la forma recomendada de implementar la cancelación es pasando a los hilos una variable de tipo <code>bool</code> con la que señalarles cuándo deben terminar.
El código de los hilos debe comprobar frecuentemente el valor de dicha variable y, llegado el momento, terminar retornando ordenadamente por la función principal del hilo.</p>
</div>
<div class="paragraph">
<p>En C&#43;&#43;20 esta estrategia de <strong>cancelación cooperativa</strong> se ha formalizado e incluido en el estándar al introducir la clase <a href="https://en.cppreference.com/w/cpp/thread/jthread">std::jthread</a>.
Esta nueva clase de hilo puede pasar a la función principal lo que se llama un <strong><em>token</em> de cancelación</strong> —en lugar de una variable tipo <code>bool</code>— que se debe comprobar regularmente para saber si hay que terminar el hilo prematuramente.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, la función del factorial podría hacer uso de esa funcionalidad para terminar cuando se lo indiquen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="kt">void</span> <span class="nf">compute_factorial</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">stop_token</span> <span class="n">stoken</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">factorial</span><span class="p">,</span> <span class="kt">int</span> <span class="n">number</span><span class="p">)</span> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">{</span>
    <span class="n">factorial</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">number</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">stoken</span><span class="p">.</span><span class="n">stop_requested</span><span class="p">())</span> <span class="k">return</span><span class="p">;</span> <i class="conum" data-value="4"></i><b>(4)</b>
        <span class="n">factorial</span> <span class="o">=</span> <span class="n">factorial</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="kt">int</span> <span class="n">factorial</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">jthread</span> <span class="kr">thread</span><span class="p">(</span><span class="n">compute_factorial</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">factorial</span><span class="p">),</span> <span class="mi">122</span><span class="p">);</span>  <i class="conum" data-value="1"></i><b>(1)</b> <i class="conum" data-value="2"></i><b>(2)</b>

    <span class="c1">// ...</span>

    <span class="kr">thread</span><span class="p">.</span><span class="n">request_stop</span><span class="p">();</span> <i class="conum" data-value="3"></i><b>(3)</b>

    <span class="c1">// ...</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Crear e iniciar el hilo con <a href="https://en.cppreference.com/w/cpp/thread/jthread">std::jthread</a> para calcular el factorial de 122.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Al crear el hilo se pasa a la función el <strong><em>token</em> de cancelación</strong> <code>stoken</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>En algún momento de la ejecución del programa pedimos al hilo que se detenga antes de terminar los cálculos.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>El código del hilo debe comprobar el <strong><em>token</em> de cancelación</strong> regularmente.
Si se ha pedido la cancelación, se termina el hilo retornando desde la función principal.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Java y C# han terminado incluyendo también este tipo de <strong>cancelación cooperativa</strong> usando un <strong><em>token</em> de cancelación</strong>, debido a los problemas que tienen los desarrolladores para recordar usar correctamente la excepción de la <strong>cancelación coordinada</strong>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_otras_consideraciones_sobre_los_hilos">12.6. Otras consideraciones sobre los hilos</h3>
<div class="sect3">
<h4 id="_las_llamadas_al_sistema_fork_y_exec_en_procesos_multihilo">12.6.1. Las llamadas al sistema fork() y exec() en procesos multihilo</h4>
<div class="paragraph">
<p>La llamada al sistema <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> de los sistemas POSIX es anterior a la existencia del concepto de <strong>hilo</strong>.
Así que cuando estos aparecieron surgió el problema de si al llamar a <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> en un proceso multihilo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>El nuevo proceso debía tener un duplicado de todos los hilos.</p>
</li>
<li>
<p>O el nuevo proceso debía tener un único hilo copia del que invocó a <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Como hemos comentado anteriormente, la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> sustituye el programa en ejecución con un nuevo programa e inicia su ejecución en <a href="https://en.cppreference.com/w/c/language/main_function">main()</a>.
Esto incluye liberar toda la memoria reservada y la destrucción de todos los hilos del programa original, por lo que duplicar los hilos en el proceso hijo creado por <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>, si luego se va a llamar a <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> parece algo innecesario.</p>
</div>
<div class="paragraph">
<p>El estándar POSIX establece que si se utiliza <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> en un programa multihilo, el nuevo proceso debe ser creado con un sólo hilo, que será una réplica del que hizo la llamada, así como un duplicado completo del espacio de direcciones del proceso.</p>
</div>
<div class="paragraph">
<p>Sin embargo, algunos sistemas UNIX tienen una segunda llamada no estándar denominada <code>forkall()</code>, capaz de duplicar todos los hilos del proceso padre.
Obviamente solo resulta conveniente emplearla si no se va a utilizar la llamada <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> a continuación.
La inclusión de <code>forkall()</code> en el estándar POSIX fue considerada y rechazada.</p>
</div>
</div>
<div class="sect3">
<h4 id="_manejo_de_señales_en_procesos_multihilo">12.6.2. Manejo de señales en procesos multihilo</h4>
<div class="paragraph">
<p>En el <a href="#_señales_en_sistemas_operativos_posix">Apartado 10.5.2</a> hablamos del uso de las señales como mecanismo de comunicación, pero en general sirven para informar a un proceso del suceso de ciertos eventos.</p>
</div>
<div class="paragraph">
<p>Existen dos tipos de señales:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Las <strong>señales síncronas</strong> se deben a alguna acción del propio proceso.
Ejemplos de señales de este tipo son <code>SIGSEV</code> y <code>SIGFE</code>, originadas por accesos ilegales a memoria o divisiones por 0, respectivamente.</p>
<div class="paragraph">
<p>Las señales síncronas son enviadas al mismo proceso que las origina.</p>
</div>
</li>
<li>
<p>Las <strong>señales asíncronas</strong> son debidas a acciones externas.
Un ejemplo de este tipo de señales es la terminación de procesos con teclas especiales como <span class="keyseq"><kbd>CTRL</kbd>+<kbd>C</kbd></span> o <kbd>CTRL-D</kbd>, que envían al proceso las señales <code>SIGINT</code> y <code>SIGHUP</code> respectivamente.
También lo son las señales enviadas desde otro proceso, como cuando el proceso <strong>init</strong> envía <code>SIGTERM</code> al resto de procesos para informales que deben terminar porque el sistema se va a apagar.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Como hemos visto, las señales que llegan a un proceso pueden ser interceptadas por una función definida por el programador llamada <strong>manejador de señal</strong>.</p>
</div>
<div class="paragraph">
<p>Las señales también son anteriores a los hilos, por lo que cuando aparecieron los hilos se tuvieron que tomar decisiones sobre como iban a encajar ambos conceptos.
Por ejemplo, decidir cuál de los hilos del proceso, será interrumpido cuando llegue una señal, para ejecutar el manejador de señales.</p>
</div>
<div class="sect4">
<h5 id="_señales_enviadas_por_otros_hilos">Señales enviadas por otros hilos</h5>
<div class="paragraph">
<p>En los sistemas POSIX multihilo se pueden enviar señales a un proceso:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">kill</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">SIGTERM</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>En ese caso uno cualquiera de los hilos podrá ser interrumpido para ejecutar el manejador de señal.</p>
</div>
<div class="paragraph">
<p>Cada hilo puede enmascarar las señales que considere llamando a <a href="https://man7.org/linux/man-pages/man3/pthread_sigmask.3.html">pthread_sigmask()</a>
Es decir, cada hilo puede elegir que señales quiere bloquear para no tener que atenderlas:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">sigset_t</span> <span class="n">set</span><span class="p">;</span>               <i class="conum" data-value="1"></i><b>(1)</b>

<span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="p">);</span>          <i class="conum" data-value="2"></i><b>(2)</b>
<span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="p">,</span> <span class="n">SIGINT</span><span class="p">);</span>    <i class="conum" data-value="3"></i><b>(3)</b>
<span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="p">,</span> <span class="n">SIGUSR1</span><span class="p">);</span>   <i class="conum" data-value="4"></i><b>(4)</b>

<span class="n">pthread_sigmask</span><span class="p">(</span><span class="n">SIG_BLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">set</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Las máscaras de señales se definen mediante <em>sets</em> de señales.
El tipo de los <em>sets</em> de señales es <code>sigset_t</code>, de cuyo tipo real no deberíamos preocuparnos, por portabilidad.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Para manipular los <em>sets</em> se proporcionan una serie de funciones.
<a href="https://man7.org/linux/man-pages/man3/sigemptyset.3.html">sigemptyset()</a> es para asegurar que el <em>set</em> está vacío.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Añadimos al <em>set</em> la señal <code>SIGINT</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Añadimos al <em>set</em> la señal <code>SIGINT</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Bloqueamos en el hilo actual las señales en el <em>set</em> <code>set</code>,es decir, <code>SIGINT</code> y <code>SIGUSR1</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Así una señal enviada a un proceso interrumpirá a uno de los hilos que no la haya bloqueado.</p>
</div>
<div class="paragraph">
<p>También se puede enviar una señal a un hilo en concreto usando <a href="https://man7.org/linux/man-pages/man3/pthread_kill.3.html">pthread_kill()</a>.
El hilo será interrumpido si no la ha bloqueado.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">pthread_kill</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span> <span class="n">SIGTERM</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Sin embargo, hay que tener en cuenta que el manejo de señales es un recurso del proceso, compartido por todos sus hilos.
Esto quiere decir que si señal está configurada para ser manejada usando la acción por defecto y dicha acción es terminar, terminará todo el proceso, aunque la señal haya sido dirigida a un hilo en concreto.</p>
</div>
</div>
<div class="sect4">
<h5 id="_señales_enviadas_por_el_sistema">Señales enviadas por el sistema</h5>
<div class="paragraph">
<p>Lo que queda por ver es a quién va dirigida una señal, cuando es el sistema quién la envía para notificar un evento:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Las señales síncronas son causadas por un error en la ejecución, que en un proceso multihilo es debido a la fallida ejecución de un hilo en particular.
Por eso estas señales se dirigen al hilo que las causa.</p>
</li>
<li>
<p>Las señales asíncronas llegan por causas externas, así que se dirigen al proceso, pudiendo ser entregada a uno de los hilos que no la tenga bloqueada.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>La recomendación es elegir un hilo para el manejo de señales asíncronas, de tal forma que sea el único que no las tenga bloqueadas.
El resto de hilos deberían bloquear estas señales nada más iniciar su ejecución.</p>
</div>
<div class="paragraph">
<p>Si el hilo que debe manejar las señales no tiene otras responsabilidades, puede utilizar <a href="https://man7.org/linux/man-pages/man3/sigwait.3.html">sigwait()</a> para bloquearse hasta que llegue una señal.
Cuando eso ocurra, la función <a href="https://man7.org/linux/man-pages/man3/sigwait.3.html">sigwait()</a> retornará, indicando el número de señal recibida —sin necesitar <strong>manejadores de señal</strong>—.
Así, por ejemplo, el hilo puede solicitar la cancelación de los otros hilos.
Esta estrategia facilita el diseño del programa para que manejen las señales adecuadamente.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sincronización">13. Sincronización</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>30 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>En el <a href="#_memoria_compartida">Capítulo 11</a> vimos que varios procesos pueden compartir regiones de la memoria con el objeto de cooperar en las tareas que deben desempeñar.
Además, en el <a href="#_hilos">Capítulo 12</a> vimos que en los procesos multihilo todos los hilos comparten el espacio de direcciones del proceso al que pertenecen, lo que significa que pueden acceder al mismo tiempo a las variables globales y a la memoria reservada dinámicamente.</p>
</div>
<div class="paragraph">
<p>Ambas posibilidades introducen algunos riesgos, puesto que el acceso simultáneo a los datos compartidos puede ocasionar inconsistencias.
Así que ha llegado el momento de discutir cómo se puede asegurar la ejecución ordenada de hilos o procesos cooperativos que comparten regiones de la memoria, con el fin de mantener la consistencia de los datos.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En este capítulo hablaremos de hilos y de procesos que comparten memoria indistintamente.
En ambos casos el problema es el mismo y las soluciones similares.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_el_problema_de_las_secciones_críticas">13.1. El problema de las secciones críticas</h3>
<div class="paragraph">
<p>Llamamos <strong>condición de carrera</strong> a la situación en la que varios procesos o hilos pueden acceder y manipular los mismos datos al mismo tiempo —es decir, de forma <strong>concurrente</strong>— y donde el resultado de la ejecución depende del orden particular en el que tienen lugar dichos accesos.
Estas situaciones ocurren frecuentemente en los sistemas operativos, puesto que diferentes componentes del mismo manipulan los mismos recursos interfiriendo unos con otros.</p>
</div>
<div class="sect3">
<h4 id="_problema_del_productor_consumidor">13.1.1. Problema del productor-consumidor</h4>
<div class="paragraph">
<p>Para ilustrarlo, veamos un problema clásico de concurrencia: el <strong>problema del productor-consumidor</strong>.</p>
</div>
<div class="paragraph">
<p>Supongamos que dos hilos o procesos comparten una región de la memoria que contiene un vector de elementos y un contador con el número de elementos del vector.</p>
</div>
<div class="paragraph">
<p>El primer hilo realiza varias tareas, que no entraremos a describir.
Lo importante es que, como resultado de esas tareas, en ocasiones añade un elemento al vector e incrementa el contador que indica el número de elementos en el vector.
Es decir, el primer hilo actúa como un <strong>productor</strong> de elementos del vector.</p>
</div>
<div class="paragraph">
<p>A continuación mostramos una porción de la función del productor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">while</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">item</span> <span class="o">=</span> <span class="n">produce_item</span><span class="p">();</span>

    <span class="c1">// Si el vector está lleno, esperar</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">VECTOR_SIZE</span><span class="p">);</span>

    <span class="c1">// Añadir el elemento al vector</span>
    <span class="n">vector</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
    <span class="o">++</span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>El segundo hilo también realiza varias tareas que no describiremos.
Pero para realizar esas tareas en ocasiones debe tomar un elemento del vector compartido, decrementando el contador para indicar que ahora hay un elemento menos en el vector.
Es decir, el segundo hilo actúa como un <strong>consumidor</strong> de elementos del vector.</p>
</div>
<div class="paragraph">
<p>A continuación mostramos una porción de la función del consumidor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">while</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Si el vector está vacio, esperar</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// Extraer un elemento del vector</span>
    <span class="o">--</span><span class="n">count</span><span class="p">;</span>
    <span class="n">item</span> <span class="o">=</span> <span class="n">vector</span><span class="p">[</span><span class="n">count</span><span class="p">];</span>

    <span class="n">consume_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Aunque el <strong>problema del productor-consumidor</strong> parezca artificial, lo cierto es que es muy común.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, en una herramienta de grabación de audio, el <strong>productor</strong> es un hilo dedicado a obtener bloques de muestras grabadas a través de la API multimedia del sistema operativo.
Mientras tanto, otro hilo puede dedicarse a tomar las muestras y realizar diversas transformaciones, como: reducir el ruido, mezclar con otras fuentes de sonido o aplicar algún tipo de efecto digital.
Este segundo hilo es el <strong>consumidor</strong>.
La manera de conectar ambos es tener un vector compartido, donde se depositan los bloques de muestras cuando llegan y de dónde se extraen para su tratamiento.
Así, ambos hilos pueden trabajar a su propio ritmo, de forma casi independiente.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Aunque el código anterior del productor y del consumidor es correcto cuando no coinciden en el tiempo al ejecutarse, no funciona adecuadamente cuando sí lo hacen.
El motivo es que los dos hilos comparten la variable <code>count</code> y tanto las sentencias <code>++count</code> y como <code>--count</code> pueden interrumpirse a medias para dejar paso a la ejecución del otro hilo.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, <code>++count</code> podría dividirse por el compilador en las siguiente operaciones, al generar las instrucciones del procesador:</p>
</div>
<div class="listingblock">
<div class="title">++count</div>
<div class="content">
<pre>registro1 = count;
registro1 = registro1 + 1;
count = registro1;</pre>
</div>
</div>
<div class="paragraph">
<p>Donde <code>registro1</code> representa un registro de la CPU.
De forma parecida la sentencia <code>--count</code> podría ser implementada de la siguiente manera:</p>
</div>
<div class="listingblock">
<div class="title">--count</div>
<div class="content">
<pre>registro2 = count;
registro2 = registro2 - 1;
count = registro2;</pre>
</div>
</div>
<div class="paragraph">
<p>Donde nuevamente <code>registro2</code> representa un registro de la CPU.
Realmente, aunque <code>registro1</code> y <code>registro2</code> pueden ser el mismo registro físico, el contenido de los registros se guarda y se recupera durante los cambios de contexto de un hilo al otro, por lo que cada uno ve sus propios valores y no los del otro.</p>
</div>
<div class="paragraph">
<p>El que las sentencias <code>++count</code> y <code>--count</code> se ejecute de forma concurrente, es similar a que las instrucciones de lenguaje máquina de ambas sentencias en ambos hilos o procesos se entrelacen en algún orden aleatorio.</p>
</div>
<div class="paragraph">
<p>Un posible entrelazado de las instrucciones en lenguaje máquina entre hilos, suponiendo que inicialmente <code>count = 5</code>, podría ser el siguiente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="c1">// Entra ++count</span>
<span class="n">registro1</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>          <span class="c1">// registro1 = 5</span>
<span class="n">registro1</span> <span class="o">=</span> <span class="n">registro1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// registro1 = 6</span>
<span class="c1">// Sale ++count y entra --count</span>
<span class="n">registro2</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>          <span class="c1">// registro2 = 5</span>
<span class="n">registro2</span> <span class="o">=</span> <span class="n">registro2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// registro2 = 4</span>
<span class="c1">// Sale --count y entra ++count</span>
<span class="n">count</span> <span class="o">=</span> <span class="n">registro1</span><span class="p">;</span>          <span class="c1">// count = 6 </span><i class="conum" data-value="2"></i><b>(2)</b>
<span class="c1">// Entra --count</span>
<span class="n">count</span> <span class="o">=</span> <span class="n">registro2</span><span class="p">;</span>          <span class="c1">// count = 4 </span><i class="conum" data-value="1"></i><b>(1)</b> <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Así llegamos al resultado incorrecto <code>count = 4</code>, indicando que hay 4 elementos en el vector cuando realmente hay 5.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Si invertimos el orden de las sentencias obtendríamos el resultado, también incorrecto, <code>count = 6</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Como se puede apreciar, hemos llegado a estos valores incorrectos porque hemos permitido la manipulación concurrente de la variable <code>count</code>.
Según como se entrelacen las instrucciones de <code>++count</code> y <code>--count</code> en la CPU, el resultado final podría ser: 4, 5 o 6.
Pero el único resultado correcto es 5, que es el que obtendríamos si ejecutamos las sentencias secuencialmente, sin mezclar las operaciones en las que se dividen.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Ambos hilos se ejecutan de forma concurrente porque o bien, tenemos un sistema multiprocesador o multinúcleo, donde ambos hilos se ejecutan a la vez en procesadores diferentes, o bien, porque tenemos un sistema operativo donde uno de los hilos puede ver interrumpida su ejecución en cualquier momento para asignar la CPU a otro (véase el <a href="#_planificación_expropiativa">Apartado 14.1</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_manipular_estructuras_de_datos">13.1.2. Manipular estructuras de datos</h4>
<div class="paragraph">
<p>Obviamente, el problema comentado no aparece solo en sentencias simples, sino también en bloques de código destinados a hacer tareas complejas, como manipular estructuras de datos.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, supongamos que <code>vector</code> no es un simple <em>array</em> de elementos, sino un lista enlazada, de tal forma que ahora extraer un elemento sería así:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="o">--</span><span class="n">count</span><span class="p">;</span>
<span class="n">item</span> <span class="o">=</span> <span class="n">vector</span><span class="p">.</span><span class="n">extract</span><span class="p">(</span><span class="n">count</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>y el método <code>extract()</code> tendría que dar los siguientes pasos:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Iterar sobre la lista para buscar el nodo en la posición <code>count</code>.</p>
</li>
<li>
<p>Al encontrarlo, preservar en variables locales el puntero a ese nodo y al previo.</p>
</li>
<li>
<p>Cambiar en el nodo previo el puntero al siguiente nodo, para que apunte al nodo tras el que queremos extraer.
En este momento el nodo a extraer ya no pertenece a la lista enlazada.</p>
</li>
<li>
<p>Extrae el <code>item</code> del campo que lo contiene en el nodo.</p>
</li>
<li>
<p>Destruir el nodo.</p>
</li>
<li>
<p>Salir del método retornando el elemento.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Esto genera varios momentos cruciales entorno al paso 3, que puedan dar lugar a <strong>condiciones de carrera</strong>.
Por ejemplo, si el hilo es interrumpido tras guardar el puntero al nodo en una variable local y llega otro hilo que extrae —y destruye— antes ese mismo nodo, el puntero ya no es válido —es un <em>dangling pointer</em> o referencia colgante— al continuar la ejecución del primer hilo.
Y lo mismo ocurre con el puntero al nodo previo o al siguiente, si el hilo es interrumpido y otro hilo destruye antes alguno de ellos.</p>
</div>
<div class="paragraph">
<p>Los problemas que ésto puede causar son diversos, según el momento exacto en el que ocurra.
Puede haberlos al intentar leer el elemento guardado en el nodo en el paso 4, porque este último ya no exista.
También, al intentar actualizar, en el paso 3, el puntero al siguiente nodo en el nodo previo, porque el nodo previo no exista.
Incluso puede que la función termine con aparente normalidad pero dejando que el nodo previo apunte a un nodo siguiente que no existe.
En este último supuesto, la lista quedaría en estado inconsistente y así el problema se lo encontraría el próximo hilo que intente usarla.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exclusión_mutua">13.1.3. Exclusión mutua</h4>
<div class="paragraph">
<p>Para evitar que estas situaciones lleven a la corrupción de datos y a caídas de servicios y sistemas, debemos asegurarnos que sólo un hilo en cada momento puede manipular recursos y variables compartidas.
Por tanto, necesitamos algún tipo de mecanismo de sincronización para que mientras se ejecuta <code>++count</code> no se pueda ejecutar <code>--count</code> en otro hilo, ni viceversa.
O para que mientras un hilo haga un <code>insert()</code> o un <code>extract()</code> en una lista, otro no pueda utilizar ni estas ni otras funciones de las misma clase.</p>
</div>
<div class="paragraph">
<p>Para resolver ésto, debemos empezar buscando las <strong>secciones críticas</strong> de nuestro código.
Una <strong>sección crítica</strong> es una porción del código dónde se accede a variables, tablas, listas, archivos y otros recursos compartidos.</p>
</div>
<div class="paragraph">
<p>Para evitar <strong>condiciones de carrera</strong>, el acceso a las <strong>secciones críticas</strong> debe ser controlado, de manera que cuando un hilo se esté ejecutando en una sección de este tipo ningún otro pueda hacerlo en la suya correspondiente para manipular los mismos recursos.
En estos casos se dice que existe <strong>exclusión mutua</strong> entre las <strong>secciones críticas</strong>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_eventos">13.1.4. Eventos</h4>
<div class="paragraph">
<p>Las <strong>condiciones de carrera</strong> son el principal problema del código anterior del productor y el consumidor, pero no el único.
En ambos ejemplos se usan bucles para que el hilo espere si el vector está lleno o vacío, antes de continuar.
A esta técnica se la denomina <strong>espera ocupada</strong> o <strong>espera activa</strong> y está completamente desaconsejada usarla en código del espacio de usuario, porque contribuye a gastar tiempo de CPU inútilmente.</p>
</div>
<div class="paragraph">
<p>En su lugar, se recomienda usar mecanismos de sincronización ofrecidos por el sistema operativo; diseñados para que un hilo o proceso notifique eventos a otro, de tal forma que hasta que eso ocurre, el que espera permanezca en estado <strong>esperando</strong>, dejando la CPU para los hilos que la necesitan.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sincronización_por_hardware">13.2. Sincronización por hardware</h3>
<div class="paragraph">
<p>Las soluciones ofrecidas por el sistema operativo, para resolver los problemas anteriores, suelen tener que apoyarse en características del hardware.
A continuación veremos algunas de esas características, antes de profundizar en los mecanismos ofrecidos por el sistema operativo.</p>
</div>
<div class="sect3">
<h4 id="_bloque_de_las_interrupciones">13.2.1. Bloque de las interrupciones</h4>
<div class="paragraph">
<p>El problema de la sección crítica puede ser resuelto de forma sencilla en un sistema monoprocesador.</p>
</div>
<div class="paragraph">
<p>Como el núcleo del sistema operativo es un software controlado mediante interrupciones, basta con que los hilos bloqueen las interrupciones mientras se está dentro de la sección crítica.
Así, el sistema operativo no puede tomar el control y asignar otro hilo a la CPU, lo que impide que se ejecute otra secuencia de instrucciones que podría modificar los datos compartidos.</p>
</div>
<div class="paragraph">
<p>Indudablemente esta solución no es práctica en sistema multiprocesador, donde hay varios procesadores ejecutándose a la vez.</p>
</div>
</div>
<div class="sect3">
<h4 id="_instrucciones_atómicas">13.2.2. Instrucciones atómicas</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Todas las CPU modernas disponen de instrucciones para comparar y modificar el
contenido de una variable o intercambiar el contenido de dos variables, de forma <strong>atómica</strong>.
El término <strong>atómico</strong> hace referencia a que las operaciones se ejecutan como una unidad
ininterrumpible.
No importa que varias CPU ejecuten estas instrucciones simultáneamente, puesto el hardware se encargará de que sean ejecutadas secuencialmente en algún orden arbitrario.</p>
</div>
<div class="paragraph">
<p>Estas instrucciones están disponibles para los programadores de C y C&#43;&#43; a través de tipos especiales.
Por ejemplo, en C11 <a href="https://en.cppreference.com/w/c/atomic">&lt;stdatomic.h&gt;</a> define tipos como: <code>atomic_bool</code>, <code>atomic_uint</code> o <code>atomic_char</code> para declarar variables atómicas de los tipos <code>bool</code>, <code>unsigned int</code> y <code>char</code>, respectivamente.
También declara funciones para inicializar, leer, guardar, intercambiar, sumar, restar y realizar operaciones lógicas, de forma atómica sobre estas variables:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">atomic_int</span> <span class="n">count</span><span class="p">;</span>
<span class="n">atomic_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="kt">int</span> <span class="n">old_count</span> <span class="o">=</span> <span class="n">atomic_fetch_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Inicializar el valor de la variable atómica.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Como un <code>count++</code> atómico: incrementa la variable devolviendo el valor previo.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>En C&#43;&#43;11, <a href="https://en.cppreference.com/w/cpp/header/atomic">&lt;atomic&gt;</a> declara la plantilla <a href="https://en.cppreference.com/w/cpp/atomic/atomic">std::atomic</a> que ofrece una funcionada similar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">count</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>  <i class="conum" data-value="1"></i><b>(1)</b> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="kt">int</span> <span class="n">old_count</span> <span class="o">=</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>    <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>También hay un tipo <code>std::atomic_int</code> que es equivalente.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Se usa el constructor para inicializar la variable atómica.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Además de soportar los operadores '++' y '--', soporta los métodos <a href="https://en.cppreference.com/w/cpp/atomic/atomic/fetch_add">std::atomic::fetch_add()</a> y <a href="https://en.cppreference.com/w/cpp/atomic/atomic/fetch_sub">std::atomic::fetch_sub()</a> para sumar y restar devolviendo el valor previo.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>La importancia de estas instrucciones está en que pueden ser utilizadas por el sistema operativo para ofrecer soluciones sencillas al problema de la sección critica.
Por ejemplo, <strong>semáforos</strong> o <strong><em>mutex</em></strong>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_semáforos">13.3. Semáforos</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>La exclusión mutua en las secciones críticas se asegura utilizando adecuadamente una serie de recursos que para ese fin proporciona el sistema operativo.
Estos recursos utilizan internamente instrucciones y otras características de la CPU, incluidas por los diseñadores para resolver este tipo de problemas, que hemos comentado anteriormente.
Ese es el caso de los <strong>semáforos</strong>.</p>
</div>
<div class="paragraph">
<p>Los <strong>semáforos</strong> son un tipo de objetos del sistema operativo que nos permiten controlar el acceso a una sección crítica, por medio de dos primitivas: <strong>acquire</strong> y <strong>release</strong> —o <strong>wait</strong> y <strong>signal</strong>, según el libro de texto que consultemos—.
A continuación describimos el mecanismo de funcionamiento:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">semaphore</span> <span class="nf">S</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>    <i class="conum" data-value="1"></i><b>(1)</b>

<span class="n">S</span><span class="p">.</span><span class="n">acquire</span><span class="p">()</span>         <i class="conum" data-value="2"></i><b>(2)</b>

<span class="c1">// Código de la sección crítica... </span><i class="conum" data-value="3"></i><b>(3)</b>

<span class="n">S</span><span class="p">.</span><span class="n">signal</span><span class="p">();</span>         <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Crear el <strong>semáforo</strong> <code>S</code> inicializado a 10.
Un <strong>semáforo</strong> contiene fundamentalmente un contador con el número máximo de hilos que pueden estar ejecutando el código de la sección crítica al mismo tiempo.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Intentar entrar en la sección crítica:
<div class="ulist">
<ul>
<li>
<p>Si el contador interno del <strong>semáforo</strong> es mayor que 0, <code>acquire()</code> lo decrementa y retorna para que la ejecución continúe.</p>
</li>
<li>
<p>Si el contador interno del <strong>semáforo</strong> es igual a 0, <code>acquire()</code> saca al hilo de la CPU y lo pone en una cola de espera, suspendiendo así su ejecución.
Básicamente, es que hay demasiados hilos dentro de la sección crítica.</p>
</li>
</ul>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Aquí iría el código protegido con el <strong>semáforo</strong>.
Es decir, el código de la sección crítica en sí.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Salir de la sección crítica:
<div class="ulist">
<ul>
<li>
<p>Si el contador interno del <strong>semáforo</strong> es mayor que 0, <code>release()</code> lo incrementa y retorna para que la ejecución continúe.</p>
</li>
<li>
<p>Si el contador interno del <strong>semáforo</strong> es igual a 0, <code>release()</code> lo incrementa y saca a uno de los hilos en la cola de espera —donde los puso su <code>acquire()</code>— para meterlo en la cola de preparados, dejándolo listo para entrar en la CPU.
Cuando eso ocurra, ese hilo decrementará el contador interno del <strong>semáforo</strong> y saldrá de su <code>acquire()</code>, donde hasta a hora estaba atrapado.
Mientras tanto <code>release()</code> retorna y la ejecución del hilo que sale del sección crítica continúa.</p>
</li>
</ul>
</div></td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Para que funcione correctamente, el <strong>semáforo</strong> <code>S</code> debe ser el mismo para todos los hilos que tengan secciones críticas en cuya ejecución deber haber <strong>exclusión mutua</strong>.
Es decir, el <strong>semáforo</strong> <code>S</code> debe estar compartido entre los hilos de la misma manera que las estructuras de datos, variables y otros recursos que protege.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_tipos_de_semáforos">13.3.1. Tipos de semáforos</h4>
<div class="paragraph">
<p>Tanto el estándar POSIX como Windows API soportan semáforos y ambos admiten dos tipos de semáforos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Los <strong>semáforos anónimos</strong> que sólo existen en el espacio de direcciones del proceso que los crea, de tal forma que están disponibles para sincronizar hilos del mismo proceso.</p>
<div class="paragraph">
<p>La forma de usarlos para sincronizar procesos diferentes o hilos en procesos diferentes depende del sistema operativo.
Con Windows API se pueden heredar de padres a hijos.
Mientras que en sistemas POSIX es necesario crear el <strong>semáforo</strong> en una región de <strong>memoria compartida</strong>, que hayamos creado previamente, e indicar un valor distinto de 0 en el argumento <code>pshared</code> de <a href="https://man7.org/linux/man-pages/man3/sem_init.3.html">sem_init()</a>.</p>
</div>
</li>
<li>
<p>Las <strong>semáforos con nombre</strong> son públicos al resto del sistema, por lo que teóricamente cualquier proceso con permisos puede abrirlos para utilizarlos.</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 4. Funciones de la API para manipular semáforos.</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">POSIX API</th>
<th class="tableblock halign-left valign-top">Windows API</th>
</tr>
</thead>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Crear semáforo anónimo</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/sem_init.3.html">sem_init()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsemaphorea">CreateSemaphore()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Crear semáforo con nombre</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/sem_open.3.html">sem_open()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsemaphorea">CreateSemaphore()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Abrir semáforo con nombre</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/sem_open.3.html">sem_open()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-opensemaphorew">OpenSemaphore()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Operación acquire</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/sem_wait.3.html">sem_wait()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject">WaitForSingleObject()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Operación release</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/sem_post.3.html">sem_post()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-releasesemaphore">ReleaseSemaphore()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Cerrar semáforo con nombre</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/sem_close.3.html">sem_close()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle">CloseHandle()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Destruir semáforo anónimo</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/sem_destroy.3.html">sem_destroy()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="lightcell">[Automático]</span></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Destruir semáforo con nombre</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/sem_unlink.3.html">sem_unlink()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="lightcell">[Automático]</span></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_ejemplos_del_uso_de_semáforos">13.3.2. Ejemplos del uso de semáforos</h4>
<div class="paragraph">
<p>En el ejemplo <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap11/anom-shared-memory.cpp">anom-shared-memory.cpp</a> de comunicación mediante memoria compartida, se usa un <strong>semáforo</strong> para que el proceso hijo indique al proceso padre que ha terminado de calcular el factorial y el resultado ya está en la memoria.</p>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap11/shared-memory-server.c">shared-memory-server.c</a> está el ejemplo completo de un programa que muestra periódicamente la hora del sistema y que puede ser controlado remotamente, mediante memoria compartida, con un cliente como el de <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap11/shared-memory-client.cpp">shared-memory-client.cpp</a>.</p>
</div>
<div class="paragraph">
<p>Para enviar los mensajes entre el cliente y el servidor, en la memoria compartida se reserva hueco para un búfer en el que el cliente copia el comando que quiere enviar y para dos <strong>semáforos</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="k">struct</span> <span class="n">memory_content</span>
<span class="p">{</span>
    <span class="n">sem_t</span> <span class="n">empty</span><span class="p">;</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">sem_t</span> <span class="n">ready</span><span class="p">;</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="kt">char</span> <span class="n">command_buffer</span><span class="p">[</span><span class="n">MAX_COMMAND_SIZE</span><span class="p">];</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Indica cuándo <code>command_buffer</code> está vacío, así que se inicializa a 1.
El cliente usa <a href="https://man7.org/linux/man-pages/man3/sem_wait.3.html">sem_wait()</a> en este <strong>semáforo</strong> antes de escribir un nuevo comando en <code>command_buffer</code>:
<div class="ulist">
<ul>
<li>
<p>Si el <strong>semáforo</strong> está a 0, el cliente pasa y escribe el comando.
Después llama a <a href="https://man7.org/linux/man-pages/man3/sem_post.3.html">sem_post()</a> en <code>ready</code>.</p>
</li>
<li>
<p>Si el <strong>semáforo</strong> está a 1, el cliente queda bloqueado y tiene que espera a que el servidor use <a href="https://man7.org/linux/man-pages/man3/sem_post.3.html">sem_post()</a> sobre el mismo <strong>semáforo</strong>.
El servidor lo hace después de leer el comando para interpretarlo.</p>
</li>
</ul>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Indica cuándo <code>command_buffer</code> tiene un comando, así que se inicializa a 0.
El servidor usa <a href="https://man7.org/linux/man-pages/man3/sem_wait.3.html">sem_wait()</a> en este <strong>semaforo</strong> antes de leer el comando en <code>command_buffer</code> para interpretarlo:
<div class="ulist">
<ul>
<li>
<p>Si el <strong>semáforo</strong> está a 0, el cliente pasa y lee el comando.
Después llama a <a href="https://man7.org/linux/man-pages/man3/sem_post.3.html">sem_post()</a> en <code>empty</code>.</p>
</li>
<li>
<p>Si el <strong>semáforo</strong> está a 1, el servidor queda bloqueado y tiene que esperar a que el cliente use <a href="https://man7.org/linux/man-pages/man3/sem_post.3.html">sem_post()</a> sobre el mismo <strong>semáforo</strong>.
El cliente lo hace después de escribir un nuevo comando en <code>command_buffer</code>.</p>
</li>
</ul>
</div></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>El detalle de cómo cliente y servidor usan ambos semáforos, se puede ver en el código de <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap11/shared-memory-client.cpp">shared-memory-client.cpp</a> y <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap11/shared-memory-server.c">shared-memory-server.c</a>, respectivamente.</p>
</div>
<div class="paragraph">
<p>Finalmente, para resolver el <strong>problema del productor-consumidor</strong> tenemos que considerar que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Necesitamos un semáforo para haya <strong>exclusión mutua</strong> entre ambos al insertar y extraer elementos del vector.</p>
</li>
<li>
<p>Necesitamos una forma de que el productor espere cuando el vector esté lleno y que el consumidor haga lo mismo cuando el vector esté vacío.
Una solución es usar dos semáforos, uno para que cuente el número de elementos en el vector y otro para contar el número de huecos libres:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">sem_t</span> <span class="n">mutex</span><span class="p">;</span>       <i class="conum" data-value="1"></i><b>(1)</b>
<span class="n">sem_t</span> <span class="n">fill_count</span><span class="p">;</span>  <i class="conum" data-value="2"></i><b>(2)</b>
<span class="n">sem_t</span> <span class="n">empty_count</span><span class="p">;</span> <i class="conum" data-value="3"></i><b>(3)</b>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">item_t</span><span class="o">&gt;</span> <span class="n">buffer</span><span class="p">(</span> <span class="n">VECTOR_SIZE</span> <span class="p">);</span>

<span class="kt">void</span> <span class="nf">initialize</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">sem_init</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>  <i class="conum" data-value="1"></i><b>(1)</b> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="n">sem_init</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>  <i class="conum" data-value="2"></i><b>(2)</b> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="n">sem_init</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">VECTOR_SIZE</span> <span class="p">);</span>  <i class="conum" data-value="3"></i><b>(3)</b> <i class="conum" data-value="4"></i><b>(4)</b>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">productor</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="k">while</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">item_t</span> <span class="n">item</span> <span class="o">=</span> <span class="n">produce_item</span><span class="p">();</span>

        <span class="n">sem_wait</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">empty_count</span> <span class="p">);</span> <i class="conum" data-value="5"></i><b>(5)</b>
        <span class="n">sem_wait</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">mutex</span> <span class="p">);</span>       <i class="conum" data-value="7"></i><b>(7)</b>

        <span class="n">vector</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>

        <span class="n">sem_post</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">mutex</span> <span class="p">);</span>       <i class="conum" data-value="7"></i><b>(7)</b>
        <span class="n">sem_post</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">fill_count</span> <span class="p">);</span>  <i class="conum" data-value="6"></i><b>(6)</b>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">consumer</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="k">while</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">sem_wait</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">fill_count</span> <span class="p">);</span>  <i class="conum" data-value="6"></i><b>(6)</b>
        <span class="n">sem_wait</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">mutex</span> <span class="p">);</span>       <i class="conum" data-value="7"></i><b>(7)</b>

        <span class="n">item_t</span> <span class="n">item</span> <span class="o">=</span> <span class="n">vector</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
        <span class="n">vector</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>

        <span class="n">sem_post</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">mutex</span> <span class="p">);</span>       <i class="conum" data-value="7"></i><b>(7)</b>
        <span class="n">sem_post</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">empty_count</span> <span class="p">);</span> <i class="conum" data-value="5"></i><b>(5)</b>

        <span class="n">consume_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><strong>Semáforo</strong> que se encarga de la exclusión mutua.
Se inicializa a 1, para que el primer hilo que use <a href="https://man7.org/linux/man-pages/man3/sem_wait.3.html">sem_wait()</a> pueda entrar.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><strong>Semáforo</strong> que se encarga de contar huecos ocupados en el vector.
Se inicializa a 0, porque al principio no hay ningún elemento.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><strong>Semáforo</strong> que se encarga de contar los huecos libres en el vector.
Se inicializa a VECTOR_SIZE, porque están todos vacíos.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>El segundo argumento de <a href="https://man7.org/linux/man-pages/man3/sem_init.3.html">sem_init()</a> es <code>pshared</code>.
Se pone a 0 para indicar que este <strong>semaforo</strong> no se va a compartir entre procesos diferentes.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Antes de insertar un elemento se decrementa <code>empty_count</code>.
Así, si vale 0, es que el vector está lleno y el productor se bloquea.
El consumidor incrementa <code>empty_count</code> tras extraer un elemento y dejar hueco, despertando al productor.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Antes de extraer un elemento se decrementa <code>fill_count</code>.
Así, si vale 0, es que el vector está vacío y el consumidor se bloquea.
El productor incrementa <code>fill_count</code> tras insertar un elemento nuevo, despertando al consumidor.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>El acceso al vector con los elementos es en <strong>exclusión mutua</strong>, así que tanto productor como consumidor deben usar <a href="https://man7.org/linux/man-pages/man3/sem_wait.3.html">sem_wait()</a> sobre <code>mutex</code> antes de acceder a él.
Esto decrementa el semáforo, así que solo uno de los dos pasa y ejecuta las líneas siguientes, mientras el otro queda bloqueado.
Cuando el que haya pasado termine, debe usar <a href="https://man7.org/linux/man-pages/man3/sem_post.3.html">sem_post()</a> sobre <code>mutex</code> para incrementar el semáforo y permitir que el otro hilo entre en su <strong>sección crítica</strong>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mutex">13.4. Mutex</h3>
<div class="paragraph">
<p>Los semáforos inicializados a 1 se denominan <strong><em>mutex</em></strong> o <strong>semáforos binarios</strong>.
Por tanto, aunque un sistema o lenguaje solo soporte <strong>semáforos</strong>, es directo implementar <strong><em>mutex</em></strong>.
A la inversa ocurre igual.
Si un sistema o lenguaje soporta <strong><em>mutex</em></strong>, es muy sencillo hacer una implementación <strong>semáforos</strong>, si nos hiciera falta.</p>
</div>
<div class="paragraph">
<p>El estándar POSIX soporta <strong><em>mutex</em></strong> a través de <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a>.
Por defecto solo se pueden utilizar para sincronizar hilos del mismo proceso; pero tienen un atributo para permitir la sincronización entre procesos diferentes, aunque para eso deben ser creados en una región de memoria compartida por dichos procesos.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>La API de <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a> no soporta <strong>semáforos</strong> porque, como vimos antes, ya eran parte del estándar POSIX.</p>
</div>
</td>
</tr>
</table>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 5. Funciones de la API para manipular <em>mutex</em>.</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">C&#43;&#43;</th>
<th class="tableblock halign-left valign-top">POSIX API</th>
<th class="tableblock halign-left valign-top" colspan="2">Windows API</th>
</tr>
</thead>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Crear</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.cppreference.com/w/cpp/thread/mutex">std::mutex</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/pthread_mutex_init.3p.html">pthread_mutex_init()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-initializecriticalsection">InitializeCriticalSection()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createmutexa">CreateMutex()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Abrir</p></th>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-openmutexw">OpenMutex()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Operación acquire</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.cppreference.com/w/cpp/thread/mutex/lock">std::mutex:::lock()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/pthread_mutex_lock.3p.html">pthread_mutex_lock()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-entercriticalsection">EnterCriticalSection()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject">WaitForSingleObject()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Operación release</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.cppreference.com/w/cpp/thread/mutex/unlock">std::mutex::unlock()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/pthread_mutex_unlock.3p.html">pthread_mutex_unlock()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-leavecriticalsection">LeaveCriticalSection()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-releasemutex">ReleaseMutex()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Destruir</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="lightcell">[Destructor]</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/pthread_mutex_destroy.3p.html">pthread_mutex_destroy()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-deletecriticalsection">DeleteCriticalSection()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle">CloseHandle()</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>En Windows API hay dos tipo de objetos equiparables a los <strong><em>mutex</em></strong>: los <strong><em>mutex</em></strong> y las <strong>secciones críticas</strong>.
Las <strong>secciones críticas</strong> son más ligeras, pero solo se pueden utilizar para sincronizar hilos del mismo proceso.
Mientras que los <strong><em>mutex</em></strong> de Windows API son objetos más costosos, pero se pueden compartir entre procesos sin utilizar memoria compartida; ya sea mediante herencia al crear un proceso hijo o asignando un nombre al <strong><em>mutex</em></strong>, como ocurre con los <strong>semáforos</strong>.</p>
</div>
<div class="sect3">
<h4 id="_ejemplos_del_uso_de_mutex">13.4.1. Ejemplos del uso de mutex</h4>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap13/pthreads-sync.cpp">pthreads-sync.cpp</a> se puede estudiar el código completo de un ejemplo similar a <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap12/pthreads.cpp">pthreads.cpp</a>, donde se calculaba el factorial de un número, repartiendo la tarea entre dos hilos, usando el API de <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a>.
La diferencia es que ahora los hilos no retornan el resultado, sino que cada uno lo mete en un vector compartido.
Al terminar, el hilo principal recorre el vector multiplicando los resultados parciales.</p>
</div>
<div class="paragraph">
<p>Como ahora ambos hilos acceden a una estructura de datos compartida, esta debe ir protegida por un <strong><em>mutex</em></strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">pthread_mutex_t</span> <span class="n">mutex</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BigInt</span><span class="o">&gt;</span> <span class="n">partials</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Antes de meter un nuevo valor, cada hilo debe adquirir el <code>mutex</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// Bloquear el mutex y guardar el resultado</span>
<span class="n">pthread_mutex_lock</span><span class="p">(</span> <span class="n">mutex</span> <span class="p">);</span>   <i class="conum" data-value="1"></i><b>(1)</b>
<span class="n">partials</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">result</span> <span class="p">);</span>
<span class="n">pthread_mutex_unlock</span><span class="p">(</span> <span class="n">mutex</span> <span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Adquirir <code>mutex</code> antes de entrar en la <strong>sección crítica</strong>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Liberar <code>mutex</code> para salir de la <strong>sección crítica</strong>.
Es importante no olvidarnos de liberar el <strong><em>mutex</em></strong> al terminar o de lo contrario uno de los hilos quedará dormido indefinidamente, al no poder entrar en la <strong>sección crítica</strong>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap13/threads-sync.cpp">threads-sync.cpp</a> se puede ver un ejemplo equivalente pero usando <a href="https://en.cppreference.com/w/cpp/thread/thread">std::thread</a> y <a href="https://en.cppreference.com/w/cpp/thread/mutex">std::mutex</a>, de la librería estándar de C&#43;&#43;.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_variables_de_condición">13.5. Variables de condición</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>En la solución que dimos al <strong>problema del productor-consumidor</strong> usando <strong>semáforos</strong> (véase el <a href="#_ejemplos_del_uso_de_semáforos">Apartado 13.3.2</a>) empleamos <strong>semáforos</strong> para implementar las esperas del productor y el consumidor cuando el vector está lleno o vacío, respectivamente.
Lamentablemente, los <em>mutex</em> no se pueden usar de la misma manera para señalar eventos.
En su lugar necesitamos otro tipo de objeto llamado <strong>variable de condición</strong>.</p>
</div>
<div class="paragraph">
<p>Las <strong>variables de condición</strong> soportan tres primitivas principales:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">wait( mutex )</dt>
<dd>
<p>Es llamada por un hilo que desea esperar a que ocurra el evento que representa la variable de condición.
El hilo debe haber adquirido antes el <strong><em>mutex</em></strong>, es liberado en el momento de poner al hilo en estado <strong>esperando</strong>.
Varios hilos pueden llamar a <strong>wait</strong> sobre la misma variable de condición, a la espera de que alguno use <strong>notify</strong>.</p>
</dd>
<dt class="hdlist1">notify</dt>
<dd>
<p>Es llamada por un hilo que quiere notificar el suceso de un evento a los hilos que esperan en la variable de condición.
Uno de esos hilos es despertado, adquiere el <strong><em>mutex</em></strong> que liberó al llamar a <strong>wait</strong> y, finalmente, retorna de <strong>wait</strong> para seguir ejecutándose.</p>
</dd>
<dt class="hdlist1">notifyAll</dt>
<dd>
<p>Es llamada por un hilo que quiere notificar el suceso de un evento a los hilos que esperan en la variable de condición.
Todos los hilos son despertados e intentan adquirir el <strong><em>mutex</em></strong> que liberaron al llamar a <strong>wait</strong>.
Cuando lo consiguen, retornan de <strong>wait</strong> para seguir ejecutándose.
Obviamente, si todos hicieron <strong>wait</strong> sobre el mismo <strong><em>mutex</em></strong>, irán retornando de <strong>wait</strong> de uno en uno, porque solo un hilo puede tener el <strong><em>mutex</em></strong> al mismo tiempo.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Tanto Windows API como el estándar POSIX, a través de <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a>, soportan <strong>variables de condición</strong>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 6. Funciones de la API para manipular variables de condición.</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">C&#43;&#43;</th>
<th class="tableblock halign-left valign-top">POSIX API</th>
<th class="tableblock halign-left valign-top">Windows API</th>
</tr>
</thead>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Crear</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.cppreference.com/w/cpp/thread/condition_variable">std::condition_variable</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/pthread_cond_init.3p.html">pthread_cond_init()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-initializeconditionvariable">InitializeConditionVariable()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Operación wait</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.cppreference.com/w/cpp/thread/condition_variable/wait">std::condition_variable::wait()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/pthread_cond_wait.3p.html">pthread_cond_wait()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleepconditionvariablecs">SleepConditionVariableCS()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Operación notify</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.cppreference.com/w/cpp/thread/condition_variable/notify_one">std::condition_variable::notify_one()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/pthread_cond_signal.3p.html">pthread_cond_signal()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-wakeconditionvariable">WakeConditionVariable()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Operación notifyAll</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.cppreference.com/w/cpp/thread/condition_variable/notify_all">std::condition_variable::notify_all()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/pthread_cond_broadcast.3p.html">pthread_cond_broadcast()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-wakeallconditionvariable">WakeAllConditionVariable()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Destruir</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="lightcell">[Destructor]</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/pthread_cond_destroy.3p.html">pthread_cond_destroy()</a></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Por defecto, las <strong>variables de condición</strong> de <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a> solo se pueden utilizar para sincronizar hilos del mismo proceso; pero tienen un atributo para permitir la sincronización entre procesos diferentes.
Obviamente, para eso deben ser creadas en una región de memoria compartida por dichos procesos.</p>
</div>
<div class="paragraph">
<p>Las <strong>variables de condición</strong> de Windows API solo se pueden utilizar en hilos del mismo procesos.
Como alternativa, Windows API soporta <strong>eventos</strong>, que son un tipo de objeto similar a las <strong>variables de condición</strong> pero que sí se puede utilizar entre hilos de procesos diferentes (véase <a href="https://docs.microsoft.com/en-us/windows/win32/sync/using-event-objects">«Using Event Objects&#8201;&#8212;&#8201;Microsoft Docs»</a>).</p>
</div>
<div class="paragraph">
<p>A los <strong>eventos</strong> se les puede asignar un nombre, para que sean accesibles por otros procesos, o heredarse de padres a hijos.
Además son más pesados que las <strong>variables de condición</strong> de Windows API, no exigen un <strong><em>mutex</em></strong> para liberar al invocar su operación <strong>wait</strong>, ni admiten la operación <strong>notifyAll</strong>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 7. Funciones de la API para manipular eventos de Windows API.</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">Windows API</th>
</tr>
</thead>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Crear</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createeventa">CreateEvent()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Abrir</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-openeventa">OpenEvent()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Operación wait</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject">WaitForSingleObject()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Operación notify</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-setevent">SetEvent()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Resetear evento</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-resetevent">ResetEvent()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Destruir</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle">CloseHandle()</a></p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="_ejemplos_del_uso_de_variables_de_condición">13.5.1. Ejemplos del uso de variables de condición</h4>
<div class="paragraph">
<p>Vamos a intentar resolver el <strong>problema del productor-consumidor</strong> sin usar <strong>semáforos</strong>.
Para lo que, nuevamente, tenemos que considerar que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Necesitamos <strong>exclusión mutua</strong> entre ambos hilos al insertar y extraer elementos del vector para evitar <strong>condiciones de carrera</strong>, por tanto usamos un <strong><em>mutex</em></strong> para proteger la <strong>sección crítica</strong>.</p>
</li>
<li>
<p>Necesitamos una forma de que el productor espere cuando el vector está lleno y que el consumidor haga lo mismo cuando el vector está vacío.
Para señalar estos eventos necesitamos dos <strong>variables de condición</strong>:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">mutext</span> <span class="n">mutex</span><span class="p">;</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">no_full</span><span class="p">;</span>  <i class="conum" data-value="2"></i><b>(2)</b>
<span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">no_empty</span><span class="p">;</span> <i class="conum" data-value="3"></i><b>(3)</b>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">item_t</span><span class="o">&gt;</span> <span class="n">buffer</span><span class="p">(</span> <span class="n">VECTOR_SIZE</span> <span class="p">);</span>

<span class="kt">void</span> <span class="nf">productor</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="k">while</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">item_t</span> <span class="n">item</span> <span class="o">=</span> <span class="n">produce_item</span><span class="p">();</span>

        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span> <span class="n">lock</span><span class="p">{</span> <span class="n">mutex</span> <span class="p">};</span>  <i class="conum" data-value="4"></i><b>(4)</b> <i class="conum" data-value="5"></i><b>(5)</b>

        <span class="k">while</span><span class="p">(</span> <span class="n">buffer</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">VECTOR_SIZE</span> <span class="p">)</span>  <i class="conum" data-value="6"></i><b>(6)</b> <i class="conum" data-value="10"></i><b>(10)</b>
        <span class="p">{</span>
            <span class="n">no_full</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span> <span class="n">mutex</span> <span class="p">);</span> <i class="conum" data-value="11"></i><b>(11)</b>
        <span class="p">}</span>

        <span class="n">vector</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">item</span> <span class="p">);</span>  <i class="conum" data-value="11"></i><b>(11)</b>

        <span class="n">no_empty</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span> <i class="conum" data-value="7"></i><b>(7)</b>
    <span class="p">}</span> <i class="conum" data-value="6"></i><b>(6)</b>

    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">consumer</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="k">while</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span> <span class="n">lock</span><span class="p">{</span> <span class="n">mutex</span> <span class="p">};</span>  <i class="conum" data-value="4"></i><b>(4)</b> <i class="conum" data-value="5"></i><b>(5)</b>

        <span class="k">while</span><span class="p">(</span> <span class="n">buffer</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>  <i class="conum" data-value="8"></i><b>(8)</b> <i class="conum" data-value="10"></i><b>(10)</b>
        <span class="p">{</span>
            <span class="n">no_empty</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span> <span class="n">mutex</span> <span class="p">);</span>  <i class="conum" data-value="11"></i><b>(11)</b>
        <span class="p">}</span>

        <span class="n">item_t</span> <span class="n">item</span> <span class="o">=</span> <span class="n">vector</span><span class="p">.</span><span class="n">back</span><span class="p">();</span> <i class="conum" data-value="11"></i><b>(11)</b>
        <span class="n">vector</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>

        <span class="n">no_full</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span> <i class="conum" data-value="9"></i><b>(9)</b>

        <span class="n">consume_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
    <span class="p">}</span> <i class="conum" data-value="6"></i><b>(6)</b>

    <span class="c1">// ...</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><strong><em>Mutex</em></strong> que se encarga de la exclusión mutua.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><strong>Variable de condición</strong> que se encarga de indicar cuando el vector no está lleno.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><strong>Variable de condición</strong> que se encarga de indicar cuando el vector no está vacío.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Antes de acceder al vector es necesario bloquear <code>mutex</code>.
Ni si quiera es seguro preguntar por el número de elementos guardados en <code>vector</code> sin antes adquirir el <strong><em>mutex</em></strong>, puesto que el otro hilo puede estar modificando <code>vector</code> al mismo tiempo.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Los <strong><em>mutex</em></strong> se pueden adquirir y liberar con <a href="https://en.cppreference.com/w/cpp/thread/mutex/lock">std::mutex:::lock()</a> y  cpp_mutex_unlock} pero esa no es la forma recomendada.
Lo recomendando es crear alguno de los objetos <em>lock</em> incluidos en la librería estándar.
Estos objetos bloquean el <strong><em>mutex</em></strong> al crearse y lo desbloquean automáticamente al destruirse.
Así es complicado que nos olvidemos de desbloquearlo al salir de la función.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Antes de insertar un elemento se comprueba si hay algún hueco disponible.
Si no lo hay, se pone el hilo a la espera en la <strong>variable de condición</strong> <code>no_full</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>El consumidor despierta al productor de esa espera tras extraer un elemento, porque es seguro que al hacerlo habrá dejado un hueco.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Antes de extraer un elemento se comprueba si hay alguno en el vector.
Si no lo hay, se pone el hilo a la espera en la <strong>variable de condición</strong> <code>no_empty</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>El productor despierta al consumidor de esta espera tras insertar un nuevo elemento.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>El estándar de C&#43;&#43; indica que las esperas en las <strong>variables de condición</strong> son susceptibles de despertar de forma espuria.
Es decir, que el hilo puede salir de <a href="https://en.cppreference.com/w/cpp/thread/condition_variable/wait">std::condition_variable::wait()</a> sin que haya habido notificación.
Por eso hay que volver a comprobar la condición antes de continuar ejecutando sentencias en la <strong>sección crítica</strong>.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>Cuando los hilos se bloquean en <a href="https://en.cppreference.com/w/cpp/thread/condition_variable/wait">std::condition_variable::wait()</a>, <code>mutex</code> es liberado para que el otro hilo pueda entrar y extraer o insertar un elemento.
De lo contrario, no podría hacerlo y ambos se quedarían bloqueados indefinidamente —en una situación que se denomina <strong>interbloqueo</strong> o <strong><em>deadlock</em></strong>—.
Pero antes de salir de <a href="https://en.cppreference.com/w/cpp/thread/condition_variable/wait">std::condition_variable::wait()</a>, el hilo adquiere de nuevo el <code>mutex</code>.
Así que el código que inserta y extrae elementos se ejecuta en <strong>exclusión mutua</strong>, tal y como nos interesa.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_esperas">13.6. Esperas</h3>
<div class="paragraph">
<p>Muchos de los objetos de sincronización que hemos visto necesitan algún mecanismo para poner en espera a los hilos que los usan.
Existen dos alternativas desde el punto de vista de como implementar esta espera:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>El sistema operativo puede cambiar el estado del hilo o proceso a <strong>esperado</strong> y moverlo a una cola de espera asociada al objeto de sincronización, tal y como hemos comentado en varias ocasiones.
Entonces el planificador de la CPU escogerá a otro proceso para ser ejecutado.</p>
</li>
<li>
<p>El hilo puede iterar comprobando constantemente la condición hasta que se cumple.
A esa técnica se la denomina <strong>espera ocupada</strong>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Este tipo de <strong>espera ocupada</strong> desperdicia tiempo de CPU que otro hilo podría utilizar de forma más productiva, por lo que sólo se utiliza en el caso de esperas previsiblemente cortas.
Para evitar que las esperas ocupadas sean demasiado largas, los sistema operativos nunca expulsan de la CPU a hilos que se estén ejecutando dentro de secciones críticas controladas por objetos de sincronización con este tipo de espera, con la idea de que salgan de la sección crítica los antes posible.</p>
</div>
<div class="paragraph">
<p>En Windows API, por ejemplo, se puede utilizar <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-initializecriticalsectionandspincount">InitializeCriticalSectionAndSpinCount()</a> para inicializar un objeto de <strong>sección crítica</strong> donde el hilo que la intenta adquirir itera el número especificado de veces en una <strong>espera ocupada</strong>, comprobando si la sección es liberada, antes de bloquearse en el estado <strong>esperando</strong> si eso no ocurre.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>La <strong>espera ocupada</strong> de estos objetos <strong>sección crítica</strong> de Windows API solo ocurre en sistemas multiprocesador, donde el hilo que tiene adquirida la sección puede estar ejecutándose en otro hilo y terminar rápidamente.
En sistemas monoprocesador nunca hay <strong>espera ocupada</strong>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A los <strong><em>mutex</em></strong> con <strong>espera ocupada</strong> también se los denomina <strong><em>(spinlock)</em></strong>.
Los <strong><em>spinlocks</em></strong> son utilizados frecuentemente para proteger las estructuras del núcleo en los sistemas multiprocesador, cuando la tarea a realizar dentro de la sección crítica en el núcleo requiere poco tiempo y los diseñadores calculan que se desperdicia más tiempo sacando de la CPU al hilo en espera para ejecutar otro en su lugar.</p>
</div>
</div>
<div class="sect2">
<h3 id="_funciones_reentrantes_y_seguras_en_hilos">13.7. Funciones reentrantes y seguras en hilos</h3>
<div class="paragraph">
<p>Todas estas cuestiones sobre la sincronización no solo afectan al código que escribimos sino también a las librerías que podemos utilizar.
A la hora de decidir utilizar una librería en un programa multihilo es necesario que tengamos en cuenta los conceptos de <strong>reentrante</strong> y <strong>seguridad de hilos</strong>.</p>
</div>
<div class="sect3">
<h4 id="_funciones_reentrantes">13.7.1. Funciones reentrantes</h4>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>Una función es <strong>reentrante</strong> puede ser interrumpida en medio de su ejecución y, mientras espera, volver a ser llamada con total seguridad.
Obviamente las funciones recursivas deben ser reentrantes para poder llamarse a sí mismas una y otra vez con seguridad.</p>
</div>
<div class="paragraph">
<p>En el contexto de la programación multihilo, ocurre una reentrada cuando durante la ejecución de una función por parte de un hilo, este es interrumpido por el sistema operativo para planificar posteriormente a otro del mismo proceso que invoca la misma función.</p>
</div>
<div class="paragraph">
<p>En general una función es reentrante, si:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>No modifica variables estáticas o globales.
Si lo hiciera sólo puede hacerlo mediante operaciones <strong>leer-modificar-escribir</strong> que sean ininterrumpibles —es decir, atómicas—.</p>
</li>
<li>
<p>No modifica su propio código y no llama a otras funciones que no sean reentrantes.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_seguridad_en_hilos">13.7.2. Seguridad en hilos</h4>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>Una función es <strong>segura en hilos</strong> o <strong>thread-safe</strong> si al manipular estructuras compartidas de datos lo hace de tal manera que se garantiza la ejecución segura de la misma por múltiples hilos al mismo tiempo.
Obviamente estamos hablando de un problema de secciones críticas, por lo que las funciones lo  resuelven sincronizando el acceso a estos datos mediante el uso de <strong>semáforos</strong>, <strong><em>mutex</em></strong> u otros recursos similares ofrecidos por el sistema operativo.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En ocasiones, ambos conceptos se confunden porque es bastante común que el código reentrante también sea seguro en hilos.
Sin embargo es posible crear código reentrante que no sea seguro en hilos y viceversa.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A la hora de usar una función o librería que va a ser llamada desde múltiples hilos, primero debemos consultar la documentación para averiguar si es <strong>segura en hilos</strong>.
Si no lo fuera, tendríamos que buscar funciones alternativas o recordar proteger las llamadas a las funciones no seguras con mecanismos de sincronización, para asegurar que solo son invocadas desde un hilo al mismo tiempo.</p>
</div>
<div class="paragraph">
<p>Esto se aplica tanto a librerías de otros desarrolladores como a la librería estándar del lenguaje que estemos usando y a la librería del sistema.</p>
</div>
<div class="sect4">
<h5 id="_seguridad_en_hilos_en_c">Seguridad en hilos en C++</h5>
<div class="paragraph">
<p>La norma general es que las clases de la librería estándar de C&#43;&#43; son seguras frente a múltiples accesos de lectura desde diferentes hilos.
Pero si un hilo modifica un objeto, todas las lecturas y escrituras en el mismo objeto por ese y otros hilos deben estar protegidas.</p>
</div>
<div class="paragraph">
<p>Obviamente, las clases de mecanismos de sincronización y gestión de hilos generalmente ofrecen mayores garantías, para lo que hay que consultar la documentación.</p>
</div>
</div>
<div class="sect4">
<h5 id="_seguridad_en_hilos_en_c_2">Seguridad en hilos en C</h5>
<div class="paragraph">
<p>El estándar de C no menciona nada sobre <strong>seguridad en hilos</strong>, por lo que se debe suponer que las funciones de la librería estándar no lo son o consultar la documentación ofrecida por el proveedor de la librería.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, todas las versiones de la librería estándar de C en Windows actualmente son <strong>seguras en hilos</strong> (véase <a href="https://docs.microsoft.com/en-us/cpp/parallel/multithreading-with-c-and-win32?view=vs-2019">«Multithreading with C and Win32&#8201;&#8212;&#8201;Microsoft Docs»</a>).
Pero hasta hace uno años Microsoft ofrecía varias versiones de la librería, algunas <strong>seguras en hilos</strong>, para usar en aplicaciones multihilo, y otras no seguras para usar en aplicaciones monohilo.</p>
</div>
</div>
<div class="sect4">
<h5 id="_seguridad_en_hilos_en_posix">Seguridad en hilos en POSIX</h5>
<div class="paragraph">
<p>La API POSIX es un superconjunto de la API de la librería estándar de C.
Por lo que en esos sistemas el estándar POSIX es el que marca qué funciones de la librería estándar de C y del resto del API POSIX son <strong>seguras en hilos</strong>.</p>
</div>
<div class="paragraph">
<p>En los sistemas POSIX, el estándar establece que todas las funciones son seguras excepto algunas muy concretas, que se pueden consultar en el apartado <a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_09_01_">«2.9.1 Thread-Safety»</a> de la especificación.
Muchas de esas funciones no se especifican como <strong>seguras en hilos</strong> porque existe alguna alternativa que sí lo es.
Por ejemplo, <a href="https://man7.org/linux/man-pages/man3/strerror.3.html">strerror()</a> no es <strong>segura en hilos</strong>, pero <a href="https://man7.org/linux/man-pages/man3/strerror.3.html">strerror_r()</a> tiene una funcionalidad equivalente y sí lo es.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_planificación_de_la_cpu">14. Planificación de la CPU</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>30 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>El <strong>planificador de la CPU</strong> o <strong>planificador de corto plazo</strong> tiene la misión de seleccionar de la <strong>cola de preparados</strong> el siguiente proceso o hilo de núcleo a ejecutar.
En dicha cola suelen estar los PCB —o TCB— de todos los procesos —o hilos de núcleo— que esperan una oportunidad para usar la CPU.
Aunque se suele pensar en la <strong>cola de preparados</strong> como una cola FIFO, no tiene por qué ser así, como veremos más adelante, ya que existen mejores estrategias para seleccionar la próxima tarea a ejecutar.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En este capítulo hablaremos de procesos y de cómo son seleccionados por el planificador de la CPU.
Sin embargo, debemos tener en cuenta que en los sistemas operativos multihilo con la librería de hilos implementada en el núcleo —categoría a la que pertenecen todos los sistemas modernos— la unidad de trabajo de la CPU es el hilo.
Así que todo lo que comentemos a partir de ahora sobre la planificación de procesos en la CPU, realmente se aplica a los hilos y no a los procesos en los sistemas operativos modernos.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>En cualquier caso, sea cual sea el algoritmo de planificación utilizado, éste debe ser muy rápido, ya que es ejecutado con mucha frecuencia —aproximadamente una vez cada 100 milisegundos—.</p>
</div>
<div class="sect2">
<h3 id="_planificación_expropiativa">14.1. Planificación expropiativa</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El planificador deben ser invocado necesariamente en los siguientes casos, dado que en ellos la CPU queda libre y es conveniente aprovecharla planificando otro proceso, en lugar de dejarla desocupada:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Cuando un proceso pasa de <strong>ejecutando</strong> a <strong>esperando</strong>.
Por ejemplo, por solicitar una operación de E/S, esperar a que un hijo termine, esperar en un semáforo, etc.</p>
</li>
<li>
<p>Cuando un proceso termina.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Cuando el planificador de la CPU es invocado solo en los casos anteriores, decimos que tenemos un sistema operativo con <strong>planificación cooperativa</strong> o <strong>no expropiativa</strong>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>En la <strong>planificación cooperativa</strong> cuando la CPU es asignada a un proceso, éste la acapara hasta terminar o hasta pasar al estado de <strong>esperando</strong>.</p>
</div>
<div class="paragraph">
<p>La <strong>planificación cooperativa</strong> no requiere de ningún hardware especial, por lo que en algunas plataformas puede ser la única opción.
Por ello estaba presente en los sistemas operativos más antiguos, como <a href="https://es.wikipedia.org/wiki/Windows_3.1x">Windows 3.x</a> y <a href="https://es.wikipedia.org/wiki/Mac_OS">Mac OS</a> —que no debemos confundir con el actual <a href="https://es.wikipedia.org/wiki/MacOS">macOS</a>—.</p>
</div>
<div class="paragraph">
<p>Sin embargo, las decisiones de planificación también pueden ser tomadas en otros dos casos:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Cuando ocurre una interrupción del temporizador, lo que permite detectar si un proceso lleva demasiado tiempo ejecutándose.</p>
</li>
<li>
<p>Cuando un proceso pasa de <strong>esperando</strong> a <strong>preparado</strong>.
Por ejemplo, porque para un proceso ha terminado la operación de E/S por la que estaba esperando.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Cuando el planificador es invocado en los cuatro casos decimos que tenemos <strong>planificación expropiativa</strong> o <strong>apropiativa</strong>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>La <strong>planificación expropiativa</strong> sí requiere de un soporte adecuado por parte del hardware, por lo que se utiliza en los sistemas operativos modernos.
Ejemplos de estos sistemas son Microsoft Windows —desde Windows 95—, Linux, macOS, y todos los UNIX modernos.</p>
</div>
<div class="paragraph">
<p>La utilización de un <strong>planificador expropiativo</strong> introduce algunas dificultades adicionales:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Puesto que un proceso puede ser expropiado en cualquier momento —sin que pueda hacer nada para evitarlo— el sistema operativo debe proporcionar <em>mecanismos de sincronización</em> (véase el <a href="#_sincronización">Capítulo 13</a>) para coordinar el acceso a datos compartidos que podrían estar siendo modificados por el proceso que abandona la CPU y que puede necesitar el que entra en ella.</p>
</li>
<li>
<p>¿Qué ocurre si un proceso va a ser expropiado en el preciso momento en el que se está ejecutando una llamada al sistema? No debemos olvidar que
dentro del núcleo se manipulan datos importantes, compartidos por todo el sistema, que deben permanecer consistentes en todo momento.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Para resolver esta cuestión la solución más sencilla es impedir la expropiación dentro del núcleo.
Es decir, el cambio de contexto —que sacaría al proceso actual de la CPU y metería al siguiente— no ocurre inmediatamente, sino que se retrasa hasta que la llamada al sistema se completa o se bloquea poniendo al proceso en el estado de <em>esperando</em>.
Esto permite núcleos simples y garantiza que las estructuras del mismo permanezcan consistentes, pero es una estrategia muy pobre para sistemas de tiempo real o multiprocesador.
Exploraremos otras soluciones más adelante (véase el <a href="#_planificación_de_tiempo_real">Apartado 14.6</a>).</p>
</div>
</div>
<div class="sect2">
<h3 id="_el_asignador">14.2. El asignador</h3>
<div class="paragraph">
<p>El <strong>asignador</strong> es el componente que da el control de la CPU al proceso seleccionado por el planificador de corto plazo.
Esta tarea implica realizar las siguientes funciones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cambiar el contexto.</p>
</li>
<li>
<p>Cambiar al modo usuario.</p>
</li>
<li>
<p>Saltar al punto adecuado del programa para continuar la ejecución del proceso.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Puesto que el <strong>asignador</strong> es invocado para cada intercambio de procesos en la CPU, es necesario que el tiempo que tarda en detener un proceso e iniciar otro sea lo más corto posible.
Al tiempo que transcurre desde que un proceso es escogido para ser planificado en la CPU hasta que es asignado a la misma se lo denomina <strong>latencia de asignación</strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_criterios_de_planificación">14.3. Criterios de planificación</h3>
<div class="paragraph">
<p>Los diferentes algoritmos de planificación de la CPU tienen diversas propiedades que pueden favorecer a una clase de procesos respecto a otra.
Por ello es interesante disponer de algún criterio para poder comparar los algoritmos y determinar cual es el mejor.</p>
</div>
<div class="paragraph">
<p>Se han sugerido muchos criterios para comparar los algoritmos de planificación de CPU.
La elección de uno u otro puede suponer una diferencia sustancial a la hora de juzgar qué algoritmo es el mejor.</p>
</div>
<div class="paragraph">
<p>A continuación presentamos los criterios más comunes.</p>
</div>
<div class="sect3">
<h4 id="_criterios_a_maximizar">14.3.1. Criterios a maximizar</h4>
<div class="paragraph">
<p>Los algoritmos de planificación son mejores cuanto mayor es su valor para los siguientes criterios.</p>
</div>
<div class="sect4">
<h5 id="_uso_de_cpu">Uso de CPU</h5>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Un buen planificador debería mantener la CPU lo más ocupada posible.
El <strong>uso de CPU</strong> es la proporción de tiempo que se usa la CPU en un periodo de tiempo determinado.
Se suele indicar en tanto por ciento.</p>
</div>
<div class="stemblock">
<div class="content">
\$"Uso de CPU" = 100 "Tiempo que la CPU permanece ocupada" / "Tiempo durante el que se toma la medida" "%"\$
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tasa_de_procesamiento">Tasa de procesamiento</h5>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Cuando la CPU está ocupada es porque el trabajo se está haciendo.
Por tanto, una buena medida del volumen de trabajo realizado puede ser el número de tareas o procesos terminados por unidad de tiempo.
A dicha magnitud es a la que denominamos como <strong>tasa de procesamiento</strong>.</p>
</div>
<div class="stemblock">
<div class="content">
\$"Tasa de procesamiento" = "Numero de procesos terminados" / "Tiempo durante el que se toma la medida" "procesos/s"\$
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_criterios_a_minimizar">14.3.2. Criterios a minimizar</h4>
<div class="paragraph">
<p>Los algoritmos de planificación son mejores cuanto menor es su valor para los siguientes criterios.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Tiempo de ejecución</dt>
<dd>
<p>Es el intervalo de tiempo que transcurre desde que el proceso es cargado hasta que termina.</p>
</dd>
<dt class="hdlist1">Tiempo de espera</dt>
<dd>
<p>Es la suma de tiempos que el proceso permanece a la espera en la <strong>cola de preparados</strong>.
Esta medida de tiempo no incluye el tiempo de espera debido a las operaciones de E/S.</p>
</dd>
<dt class="hdlist1">Tiempo de respuesta</dt>
<dd>
<p>Es el intervalo de tiempo que transcurre desde que se le lanza un evento —se pulsa una tecla, se hace clic con el ratón o llega un paquete por la interfaz de red— hasta que se produce la primera respuesta del proceso.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>El <strong>tiempo de respuesta</strong> mide el tiempo que se tarda en responder y no el tiempo de E/S.
Mientras que el <strong>tiempo de ejecución</strong> sí incluye el tiempo que consumen las operaciones de E/S, por lo que suele estar limitado por la velocidad de los dispositivos E/S.</p>
</div>
</div>
<div class="sect3">
<h4 id="_elección_del_criterio_adecuado">14.3.3. Elección del criterio adecuado</h4>
<div class="paragraph">
<p>En función del tipo de sistema o de la clase de trabajos que se van a ejecutar puede ser conveniente medir la eficiencia del sistema usando un criterio u otro.
Esto a su vez beneficiará a unos algoritmos de planificación frente a otros, indicándonos cuáles son los más eficientes para nuestra clase de trabajos en particular.</p>
</div>
<div class="paragraph">
<p>En general podemos encontrar dos clases de trabajos para los que puede ser necesario evaluar la eficiencia del sistema de manera diferente: los trabajos interactivos y los que no lo son.</p>
</div>
<div class="sect4">
<h5 id="_sistemas_interactivos">Sistemas interactivos</h5>
<div class="paragraph">
<p>En los sistemas interactivos —ya sean sistemas de escritorio o <em>mainframes</em> de tiempo compartido— los procesos pasan la mayor parte del tiempo esperando algún tipo de entrada por parte de los usuarios.</p>
</div>
<div class="paragraph">
<p>En este tipo de sistemas, el <strong>tiempo de ejecución</strong> no suele ser el mejor criterio para determinar la bondad de un algoritmo de planificación, ya que viene determinado en gran medida por la velocidad de la entrada de los usuarios.
Por el contrario, se espera que el sistema reaccione lo antes posible a las órdenes recibidas, lo que hace que el <strong>tiempo de respuesta</strong> sea un criterio más adecuado para evaluar al planificador de la CPU.</p>
</div>
<div class="paragraph">
<p>Generalmente, el <strong>tiempo de respuesta</strong> se reduce  cuando el tiempo que pasan los procesos interactivos en la <strong>cola de preparados</strong> también lo hace —tras haber sido puestos ahí por la ocurrencia de algún evento— por lo que también puede ser una buena idea utilizar como criterio el <strong>tiempo de espera</strong>.</p>
</div>
<div class="paragraph">
<p>Esta selección de criterios no sólo es adecuada para los sistemas interactivos, ya que existen muchos otros casos donde es interesante seleccionar un planificador de la CPU que minimice el tiempo de respuesta.
Esto, por ejemplo, ocurre con algunos servicios en red, como: sistemas de mensajería instantánea, videoconferencia, servidores de videojuegos, etc.</p>
</div>
</div>
<div class="sect4">
<h5 id="_sistemas_no_interactivos">Sistemas no interactivos</h5>
<div class="paragraph">
<p>Por el contrario, en los antiguos <em>mainframes</em> de procesamiento por lotes y multiprogramados, en los superordenadores que realizan complejas simulaciones físicas y en los grandes centros de datos de proveedores de Internet como Google, lo de menos es el tiempo de respuesta y lo realmente importante es completar cada tarea en el menor tiempo posible.
Por eso en ese tipo de sistemas es aconsejable utilizar criterios tales como el <strong>tiempo de ejecución</strong> o la <strong>tasa de procesamiento</strong>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_promedio_o_varianza_del_criterio">Promedio o varianza del criterio</h5>
<div class="paragraph">
<p>Obviamente estos criterios varían de un proceso a otro, por lo que normalmente lo que se busca es optimizar los valores promedios en el sistema.</p>
</div>
<div class="paragraph">
<p>Sin embargo no debemos olvidar que en muchos casos puede ser más conveniente optimizar el máximo y mínimo de dichos valores antes que el promedio.
Por ejemplo, en los sistemas interactivos es más importante minimizar la <strong>varianza en el tiempo de respuesta</strong> que el <strong>tiempo de respuesta promedio</strong>, puesto que para los usuarios un sistema con un tiempo de respuesta predecible es más deseable que uno muy rápido en promedio pero con una varianza muy alta.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ciclo_de_ráfagas_de_cpu_y_de_es">14.4. Ciclo de ráfagas de CPU y de E/S</h3>
<div class="paragraph">
<p>El éxito de la planificación de CPU depende en gran medida de la siguiente propiedad que podemos observar en hilos o procesos:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><em>La ejecución de un hilo o proceso consiste en ciclos de CPU y esperas de E/S, de forma que alternan entre estos dos estados.</em></p>
</div>
<div class="paragraph">
<p><em>La ejecución empieza con una ráfaga de CPU, seguida por una ráfaga de E/S, que a su vez es seguida por otra de CPU y así sucesivamente.</em>
<em>Finalmente, la última ráfaga de CPU finaliza con una llamada al sistema —generalmente <a href="https://www.man7.org/linux/man-pages/man3/exit.3.html">exit()</a>— para terminar la ejecución del proceso.</em></p>
</div>
</div>
</div>
<div id="ráfagas_de_cpu" class="imageblock">
<div class="content">
<img src="C14-planificación_de_CPU/media/histogramas_tiempo_de_ráfagas.svg" alt="histogramas tiempo de ráfagas">
</div>
<div class="title">Figura 36. Histograma de los tiempos de las ráfagas de CPU..</div>
</div>
<div class="paragraph">
<p>La curva que relaciona la frecuencia de las ráfagas de CPU con la duración de las mismas tiende a ser exponencial o hiper-exponencial (véase la <a href="#ráfagas_de_cpu">Figura 36</a>) aunque varía enormemente entre tipos de tareas y sistemas informáticos distintos.
Esto significa que los procesos se pueden clasificar entre aquellos que presentan un gran número de ráfagas de CPU cortas o aquellos con un pequeño número de ráfagas de CPU largas.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Concretamente:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Decimos que un proceso es <strong>limitado por la E/S</strong> cuando presenta muchas ráfagas de CPU cortas, debido a que si es así, es porque pasa la mayor parte del tiempo esperando por la E/S.</p>
</li>
<li>
<p>Decimos que un proceso está <strong>limitado por la CPU</strong> cuando presenta pocas ráfagas de CPU largas, debido a que si es así, es porque hace un uso intensivo de la misma y a penas pasa tiempo esperando por la E/S.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Esta distinción entre tipos de procesos puede ser importante en la selección de un algoritmo de planificación de CPU adecuado, puesto que, por lo general el algoritmo escogido debe planificar antes a los procesos limitados por la E/S, evitando así que los procesos limitados por la CPU —que son los que tienden a usarla más tiempo— la acaparen.</p>
</div>
<div class="paragraph">
<p>Si esto último ocurriera, los procesos limitados por la E/S se acumularían en la <strong>cola de preparados</strong>, dejando vacías las colas de dispositivos.
Este fenómeno, que provoca una infrautilización de los dispositivos de E/S, se denomina <strong>efecto convoy</strong>.</p>
</div>
<div class="paragraph">
<p>Planificar primero a los procesos limitados por la E/S tiene además dos efectos muy positivos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Los procesos interactivos son generalmente procesos limitados por la E/S, por lo que planificarlos primero hace que mejore el tiempo de respuesta.</p>
</li>
<li>
<p>Generalmente el tiempo de espera promedio se reduce cuando se planifican primero los procesos con ráfagas de CPU cortas.
Según las definiciones anteriores, estos procesos son precisamente los limitados por la E/S.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_algoritmos_de_planificación_de_la_cpu">14.5. Algoritmos de planificación de la CPU</h3>
<div class="paragraph">
<p>A continuación ilustraremos algunos de los algoritmos de planificación de CPU más comunes.
Lo haremos considerando que cada proceso tiene una única ráfaga de CPU.
Sin embargo, no debemos olvidar que para ser precisos necesitaríamos utilizar muchos más procesos, donde cada uno estuviera compuesto de una secuencia de miles de ráfagas alternativas de CPU y de E/S.</p>
</div>
<div class="sect3">
<h4 id="_planificación_fcfs">14.5.1. Planificación FCFS</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>En la planificación <strong>FCFS</strong> (<em>First Come, First Served</em>) o <strong>primero que llega, primero servido</strong> la cola es FIFO:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Los procesos que llegan se colocan al final de la cola que les corresponde.</p>
</li>
<li>
<p>El proceso asignado a la CPU se coge siempre del principio de la cola seleccionada.</p>
</li>
<li>
<p>Es un algoritmo <strong>cooperativo</strong>, puesto que un proceso mantiene la CPU hasta que decide liberarla voluntariamente —recordemos que la ráfaga de CPU llega a su fin porque el proceso termina o solicita alguna operación que lo lleva el estado <strong>esperando</strong>—.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ilustremos el algoritmo con un ejemplo.
Supongamos que 4 procesos llegan a la <strong>cola de preparados</strong> en los tiempos indicados en la <a href="#tabla_problema_fcfs">Tabla 8</a>.
Además, aunque es difícil tener un conocimiento a priori del tiempo de la ráfaga de CPU de cada proceso, vamos a suponer que también son conocidos.</p>
</div>
<table id="tabla_problema_fcfs" class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 8. Problema de planificación de la CPU mediante algoritmo FCFS.</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Proceso</th>
<th class="tableblock halign-center valign-top">Tiempo de llegada (ms.)</th>
<th class="tableblock halign-center valign-top">Tiempo de ráfaga de CPU (ms.)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">24</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>En la siguiente figura podemos ver el <a href="https://es.wikipedia.org/wiki/Diagrama_de_Gantt">diagrama de Gantt</a> de la planificación considerando que se utiliza el algoritmo <strong>FCFS</strong>:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="C14-planificación_de_CPU/media/fcfs1.svg" alt="fcfs1">
</div>
</div>
<div class="paragraph">
<p>Utilizando el diagrama anterior, podemos calcular fácilmente los <strong>tiempos de espera y de ejecución promedio</strong>:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2858%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Proceso</th>
<th class="tableblock halign-center valign-top">Instante de finalización (ms.)</th>
<th class="tableblock halign-center valign-top" colspan="2">Tiempo de espera (ms.)</th>
<th class="tableblock halign-center valign-top" colspan="2">Tiempo de ejecución (ms.)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">24</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(0-0)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(24-0)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">24</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">27</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(24-1)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">23</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(27-1)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">26</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">30</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(27-2)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">25</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(30-2)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">28</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">32</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(30-3)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">27</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(32-3)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">29</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Tiempos promedio (ms.)</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">18,75</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">26,75</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph">
<p>Lo interesante es que el resultado cambia si los procesos llegan en otro orden.
Por ejemplo, P1 podría llegar el último:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Proceso</th>
<th class="tableblock halign-center valign-top">Tiempo de llegada (ms.)</th>
<th class="tableblock halign-center valign-top">Tiempo de ráfaga de CPU (ms.)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">24</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Entonces el resultado de la planificación sería el que se muestra en la siguiente figura:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="C14-planificación_de_CPU/media/fcfs2.svg" alt="fcfs2">
</div>
</div>
<div class="paragraph">
<p>Y los <strong>tiempos de espera y ejecución promedio</strong> correspondientes serían:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2858%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Proceso</th>
<th class="tableblock halign-center valign-top">Instante de finalización (ms.)</th>
<th class="tableblock halign-center valign-top" colspan="2">Tiempo de espera (ms.)</th>
<th class="tableblock halign-center valign-top" colspan="2">Tiempo de ejecución (ms.)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(0-0)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(3-0)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(3-1)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(6-1)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(6-2)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(8-2)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">32</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(8-3)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(32-3)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">29</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Tiempos promedio (ms.)</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2,75</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10,75</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph">
<p>Aunque el tiempo total necesario para ejecutar los ráfagas de los 4 procesos, los criterios utilizados reflejan que el algoritmo se comporta mucho mejor en el segundo caso.
Por tanto, el algoritmo <strong>FCFS</strong> no garantiza ni <strong>tiempos de espera</strong> ni de <strong>ejecución</strong> mínimos, ya que pueden cambiar variar considerablemente con el orden en el que llegan los procesos.</p>
</div>
<div class="paragraph">
<p>Además, el algoritmo <strong>FCFS</strong> sufre el llamado <strong>efecto convoy</strong>.
Para entenderlo, analicemos lo que está pasando en el ejemplo de la <a href="#tabla_problema_fcfs">Tabla 8</a>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Al proceso P1 se la asigne la CPU.
Durante el tiempo que P1 utiliza la CPU todos los otros procesos terminan sus operaciones de E/S y pasan a la <strong>cola de preparados</strong>.
Por tanto, mientras los procesos esperan para utilizar la CPU, los dispositivos de E/S permanecen
desocupados.</p>
</li>
<li>
<p>El proceso P1 termina de usar la CPU y pasa a una cola de dispositivos.</p>
</li>
<li>
<p>El resto de procesos P, que tienen ráfagas de CPU cortas, se ejecutan rápidamente y pasan a las colas de dispositivos.
Por tanto, la CPU permanecerá vacía hasta que algún proceso termine la operación de E/S solicitada.</p>
</li>
<li>
<p>El proceso P1 pasa a la <strong>cola de preparados</strong> y se le asigna la CPU.
Con el tiempo el resto de procesos terminaran sus operaciones y, nuevamente, tienen que esperar en la <strong>cola de preparados</strong> a que el proceso P1 termine de utilizarla.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Esto nos permite llegar a la conclusión de que en cierto orden de llegada la mayor parte
de los procesos esperan constantemente detrás de uno para poder realizar su trabajo.
Esto reduce la utilización de la CPU y de los dispositivos de E/S por debajo de lo que sería posible, si los
procesos mas cortos se ejecutasen primero.</p>
</div>
</div>
<div class="sect3">
<h4 id="_planificación_sjf">14.5.2. Planificación SJF</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>La planificación <strong>SJF</strong> (<em>Shortest-Job First</em>) o <strong>primero el más corto</strong>, consiste en:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Se asocia con cada proceso la longitud de tiempo de su siguiente ráfaga de CPU.</p>
</li>
<li>
<p>Cuando la CPU está disponible, se pone <strong>ejecutando</strong> el proceso de menor ráfaga de CPU.</p>
</li>
<li>
<p>Si dos procesos tienen ráfagas de una misma longitud, se utiliza el algoritmo <strong>FCFS</strong> —entre ellos, el que lleva más tiempo en la <strong>cola de preparados</strong>—.</p>
</li>
<li>
<p>Es un algoritmo <strong>cooperativo</strong>, puesto que un proceso mantiene la CPU hasta que decide liberarla voluntariamente.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Ilustremos el algoritmo con un ejemplo:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Proceso</th>
<th class="tableblock halign-center valign-top">Tiempo de llegada (ms.)</th>
<th class="tableblock halign-center valign-top">Tiempo de ráfaga de CPU (ms.)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Considerando que se utiliza el algoritmo <strong>SJF</strong> obtendremos el siguiente diagrama de Gantt:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="C14-planificación_de_CPU/media/sjf.svg" alt="sjf">
</div>
</div>
<div class="paragraph">
<p>Con los <strong>tiempos de espera y ejecución promedio</strong> correspondientes:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2858%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Proceso</th>
<th class="tableblock halign-center valign-top">Instante de finalización (ms.)</th>
<th class="tableblock halign-center valign-top" colspan="2">Tiempo de espera (ms.)</th>
<th class="tableblock halign-center valign-top" colspan="2">Tiempo de ejecución (ms.)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(0-0)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(6-0)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">24</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(16-1)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">15</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(24-1)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">23</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">16</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(9-2)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(16-2)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">14</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(6-3)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(9-3)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Tiempos promedio (ms.)</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6,25</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">12,25</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph">
<p>Sin embargo, si hubiéramos utilizado el algoritmo <strong>FCFS</strong> los tiempos hubieran sido mucho peores:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2858%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Proceso</th>
<th class="tableblock halign-center valign-top">Instante de finalización (ms.)</th>
<th class="tableblock halign-center valign-top" colspan="2">Tiempo de espera (ms.)</th>
<th class="tableblock halign-center valign-top" colspan="2">Tiempo de ejecución (ms.)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(0-0)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(6-0)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">14</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(6-1)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(14-1)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">13</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">21</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(14-2)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">12</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(21-2)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">19</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">24</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(21-3)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">18</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(24-3)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">21</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Tiempos promedio (ms.)</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8,75</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">14,75</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph">
<p>El algoritmo <strong>SJF</strong> es óptimo en el sentido de que el <strong>tiempo de espera promedio</strong> es mínimo, porque reduce más el tiempo de espera de los procesos cortos y aumenta el de los procesos largos.
Además, así se evita el <strong>efecto convoy</strong>.</p>
</div>
<div class="paragraph">
<p>Sin embargo, la pregunta que debemos hacernos es cómo podemos conocer de antemano la longitud de las ráfagas de CPU de un proceso, para usar esa información durante la planificación.
Sin analizar el código, el sistema operativo no puede conocer el tiempo de una ráfaga hasta que esta no termina de ejecutarse.</p>
</div>
<div class="paragraph">
<p>Por eso el algoritmo SJF se utiliza frecuente como planificador de la <strong>cola de trabajos</strong>, donde se puede obligar al usuario a especificar un tiempo de ejecución máximo, al enviar el trabajo a dicha cola.
En este caso, los usuarios tenderán a ajustar la estimación de tiempo de ejecución, puesto que los que tengan tiempos más cortos serán priorizados para ser ejecutados antes, frente a los de tiempos más largos.</p>
</div>
<div class="paragraph">
<p>Para evitar que los usuarios hagan trampas indicando un tiempo de ejecución más corto que el real, con el fin de que se planifique antes su trabajo, se puede utilizar un temporizador para abortar los trabajos que excedan el tiempo de ejecución indicado por el usuario.
El error puede ser notificado al usuario para que vuelva a enviar el trabajo con una estimación más realista.</p>
</div>
<div class="paragraph">
<p>Para utilizar el algoritmo <strong>SJF</strong> en el planificador de la CPU, lo único que se puede hacer es intentar predecir el tiempo de la siguiente ráfaga de CPU.
Por ejemplo, se puede utilizar un promedio ponderado exponencial de los tiempos de las de ráfagas de CPU pasadas:</p>
</div>
<div class="stemblock">
<div class="content">
\[\tau_{n+1} = \alpha{}t_n + (1 - \alpha)\tau_n,\; 0 \leq \alpha \leq 1\]
</div>
</div>
<div class="paragraph">
<p>donde:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\$\tau_{n+1}\$ es la estimación de tiempo de la siguiente ráfaga de CPU</p>
</li>
<li>
<p>\$t_{n}\$ es el tiempo real de la última ráfaga</p>
</li>
<li>
<p>\$\alpha\$ es el peso relativo del tiempo real de la última ráfaga.</p>
</li>
<li>
<p>\$\tau_{n}\$ es la estimación de tiempo de la última ráfaga.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>La expresión es recursiva, dado que \$\tau_{n}\$ se calcula usando la ecuación con \$t_{n-1}\$ y \$\tau_{n-1}\$; que a su vez depende de \$t_{n-2}\$ y \$\tau_{n-2}\$, y así sucesivamente.</p>
</div>
<div class="paragraph">
<p>Si desarrollamos la formula sustituyendo los valores, veremos que \$t_{n}\$ se pondera con \$\alpha\$, \$t_{n-1}\$ con \$(1 - \alpha)\alpha\$, \$t_{n-2}\$ con \$(1 - \alpha)^2\alpha\$, y así sucesivamente:</p>
</div>
<div class="stemblock">
<div class="content">
\[\tau_{n+1}=\alpha{}t_n + (1 - \alpha)\alpha{}t_{n-1} + (1 - \alpha)^2\alpha{}t_{n-2} + \ldots\]
</div>
</div>
<div class="paragraph">
<p>Si \$\alpha = 1\$, \$\tau_{n+1} = \alpha\t_n\$, ignorando el resto del histórico.
En otro caso, dado que tanto \$\alpha\$ como \$1 -\alpha\$ son menores de 1, cada término sucesivo tiene menor peso que su predecesor, haciendo que los \$t_{n}\$ contribuyan menos cuanto más alejados del tiempo actual.</p>
</div>
<div class="paragraph">
<p>El problema es que todos estos cálculos consumen tiempo de CPU, cuando el planificador debe ser lo más rápido posible, dado que se ejecuta con mucha frecuencia.</p>
</div>
</div>
<div class="sect3">
<h4 id="_planificación_srtf">14.5.3. Planificación SRTF</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El algoritmo <strong>SJF</strong> es <strong>cooperativo</strong>, pero se puede implementar de forma <strong>expropiativa</strong>, en cuyo caso se llama <strong>SRTF</strong> (Shortest-Remaing-Time First).
La diferencia está en lo que ocurre cuando un nuevo proceso llega a la <strong>cola de preparados</strong>.</p>
</div>
<div class="paragraph">
<p>En <strong>SRTF</strong> se compara el tiempo de la siguiente ráfaga de CPU del nuevo
proceso, con el tiempo de ráfaga que le queda al proceso en ejecución.
Si la primera magnitud es inferior, el proceso que tiene la CPU es expropiado y sustituido por el nuevo proceso.
Mientras que en <strong>SJF</strong> no se hace nada.
Se espera a que el proceso que actualmente se está ejecutando termine su ráfaga de CPU voluntariamente.</p>
</div>
<div class="paragraph">
<p>Ilustremos el algoritmo con un ejemplo:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Proceso</th>
<th class="tableblock halign-center valign-top">Tiempo de llegada (ms.)</th>
<th class="tableblock halign-center valign-top">Tiempo de ráfaga de CPU (ms.)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">9</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>El resultado es el que se muestra en el siguiente diagrama de Gantt:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="C14-planificación_de_CPU/media/srtf.svg" alt="srtf">
</div>
</div>
<div class="paragraph">
<p>Y los tiempos de espera y ejecución promedio correspondientes serían:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2858%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Proceso</th>
<th class="tableblock halign-center valign-top">Instante de finalización (ms.)</th>
<th class="tableblock halign-center valign-top" colspan="2">Tiempo de espera (ms.)</th>
<th class="tableblock halign-center valign-top" colspan="2">Tiempo de ejecución (ms.)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">17</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(0-0) + (10-1)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(17-0)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">17</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(1-1)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(5-1)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">26</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(17-2)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">15</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(26-2)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">24</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(5-3)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(10-3)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Tiempos promedio (ms.)</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6,50</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">13,00</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph">
<p>Es muy complicado predecir cuál de los dos algoritmos será mejor para un conjunto concreto de procesos.
Sin embargo, debemos tener en cuenta que —aunque no lo estemos considerando en estos problemas— un algoritmo expropitativo, por lo general, provocará más cambios de contexto en los que se perderá tiempo de CPU.</p>
</div>
<div class="paragraph">
<p>Los algoritmos expropiativos también suelen ofrecer mejores tiempos de respuesta, puesto que un proceso que llega a la <strong>cola de preparados</strong> puede ser asignado a la CPU sin esperar a que el proceso que se ejecuta en ella actualmente termine su ráfaga de CPU.</p>
</div>
</div>
<div class="sect3">
<h4 id="_planificación_con_prioridades">14.5.4. Planificación con prioridades</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>En la <strong>planificación con prioridades</strong> se asocia una prioridad a cada proceso, de tal forma que el de prioridad más alta es asignado a la CPU.
En caso de igual prioridad, se utiliza <strong>FCFS</strong>.</p>
</div>
<div class="paragraph">
<p>Las prioridades se suelen indicar con números enteros en un rango fijo. Por ejemplo [0-7], [0-31],
[0-139] o [0-4095].
En algunos sistemas operativos los números más grandes representan mayor prioridad, mientras que en otros son los procesos con números más pequeños los que se planifican primero.
En éste curso utilizaremos la convención de que a menor valor, mayor prioridad.</p>
</div>
<div class="paragraph">
<p>Si las prioridades se asignan en base al tiempo de la próxima ráfaga de CPU, su comportamiento es el mismo que el del <strong>SJF</strong>; por lo que se considera a este último un caso particular de algoritmo de <strong>planificación con prioridades</strong>.</p>
</div>
<div class="paragraph">
<p>El algoritmo de planificación con prioridades puede ser <strong>expropiativo</strong> o <strong>cooperativo</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En el caso <strong>expropiativo</strong>, cuando un proceso llega a la <strong>cola de preparados</strong> su prioridad es comparada con la
del proceso en ejecución.
Se expropia la CPU si la prioridad del nuevo proceso es superior a la prioridad del proceso que se ejecuta.</p>
</li>
<li>
<p>En el caso <strong>cooperativo</strong>, no se toma ninguna decisión cuando llega un proceso a la <strong>cola de preparados</strong>, solo cuando el que tiene asignada la CPU la abandona.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Supongamos que 5 procesos llegan a la cola de preparados en los tiempos indicados en la <a href="#tabla_problema_prioridad">Tabla 9</a>.
Como en los ejemplos anteriores, aunque es difícil tener un conocimiento a priori del tiempo
de las ráfagas de CPU, vamos a suponer que son conocidos.
Y también que a cada proceso se le asigna, de alguna forma, una prioridad cuando llega a la <strong>cola de preparados</strong>.</p>
</div>
<table id="tabla_problema_prioridad" class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 9. Problema de planificación de la CPU mediante algoritmo de planificación con prioridades.</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Proceso</th>
<th class="tableblock halign-center valign-top">Tiempo de llegada (ms.)</th>
<th class="tableblock halign-center valign-top">Tiempo de ráfaga de CPU (ms.)</th>
<th class="tableblock halign-center valign-top">Prioridad</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P5</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>En las condiciones anteriores, si utilizamos el algoritmo de planificación por prioridades expropiativo, obtendremos el diagrama de Gantt de la siguiente figura:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="C14-planificación_de_CPU/media/prioridad.svg" alt="prioridad">
</div>
</div>
<div class="paragraph">
<p>Con los <strong>tiempos de espera y ejecución promedio</strong> correspondientes:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2858%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Proceso</th>
<th class="tableblock halign-center valign-top">Instante de finalización (ms.)</th>
<th class="tableblock halign-center valign-top" colspan="2">Tiempo de espera (ms.)</th>
<th class="tableblock halign-center valign-top" colspan="2">Tiempo de ejecución (ms.)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(0-0) + (3-1) + (9-4)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(17-0)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">17</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(1-1)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(3-1)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">20</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(17-2)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">15</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(20-2)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">18</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">22</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(20-3)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">17</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(22-3)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">19</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P5</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(4-4)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(9-4)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Tiempos promedio (ms.)</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7,80</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">12,20</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph">
<p>Que estos algoritmos ofrezcan mejores o peores resultados que otros, obviamente depende de los criterios utilizados para asignar las prioridades.</p>
</div>
<div class="sect4">
<h5 id="_prioridades_definidas_internamente_o_externamente">Prioridades definidas internamente o externamente</h5>
<div class="paragraph">
<p>Hay dos maneras de asignar las prioridades:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Internamente</strong>.
Se utiliza una cualidad medible del proceso para calcular su prioridad.
Por ejemplo, límites de tiempo, necesidades de memoria, número de archivos abiertos, tiempo estimado de ráfaga de CPU —como en <strong>SJF</strong>— o la proporción entre esta y el tiempo estimado de ráfaga de E/S.</p>
</li>
<li>
<p><strong>Externamente</strong>.
Las prioridades son fijadas por criterios externos al sistema operativo.
Por ejemplo, la importancia del proceso para los usuarios, la cantidad de dinero pagada para el uso del sistema u otros factores políticos.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Algunas de estas formas de asignar las prioridades pueden ser fijas, mientras que otras pueden ser variables.
Es decir, un criterio externo como es la importancia del proceso para los usuarios, puede dar lugar a una prioridad que se asigna al crear el proceso y que no cambia durante toda su ejecución.
Por el contrario, un criterio como el tiempo de ráfaga de CPU pueda dar lugar un una prioridad variable, que se ajusta cada vez que se tiene una estimación mejor.</p>
</div>
</div>
<div class="sect4">
<h5 id="_muerte_por_inanición">Muerte por inanición</h5>
<div class="paragraph">
<p>El mayor problema de éste tipo de planificación es el <strong>bloqueo indefinido</strong> o <strong>muerte por inanición</strong>.
Si hay un conjunto de procesos de alta prioridad demandando CPU continuamente, el algoritmo puede dejar a algunos procesos de menor prioridad esperando indefinidamente.</p>
</div>
<div class="paragraph">
<p>Una solución a este problema es aplicar mecanismos de <strong>envejecimiento</strong>.
Consisten en aumentar gradualmente la prioridad de los procesos que esperan —por ejemplo, 1 unidad cada 15
minutos—.
De esta manera los proceso de baja prioridad tarde o temprano tendrán una oportunidad para ejecutarse.
Una vez se les asigna la CPU, se restablece su prioridad al valor original.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_planificación_rr">14.5.5. Planificación RR</h4>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>El algoritmo <strong>RR</strong> (<em>Round-Robin</em>) es similar al <strong>FCFS</strong> pero añadiendo la expropiación para conmutar
entre procesos cuando llevan cierta cantidad de tiempo ejecutándose en la CPU.</p>
</div>
<div class="paragraph">
<p>Este algoritmo requiere los siguientes elementos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Definir una <strong>ventana de tiempo</strong> o <strong>cuanto</strong>, generalmente entre 10 y 100 ms.</p>
</li>
<li>
<p>Definir la <strong>cola de preparados</strong> como una cola circular, dónde el planificador asigna la CPU a cada proceso en intervalos de tiempo de hasta un <strong>cuanto</strong>, como máximo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Cuando un proceso está en la CPU pueden darse diversos casos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Que la ráfaga de CPU sea menor que un cuanto.
Entonces el proceso liberará la CPU voluntariamente, al terminar la ráfaga.</p>
</li>
<li>
<p>Que la ráfaga de CPU sea mayor que un cuanto.
El temporizador interrumpirá el proceso al terminar el cuanto e informará al sistema operativo.
Éste hará el cambio de contexto para asignar la CPU al siguiente proceso y el que abandona la CPU es insertado al final de la <strong>cola de preparados</strong>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Este algoritmo es <strong>expropiativo</strong> puesto que los procesos son expropiados por la interrupción del temporizador.
Como se puede intuir, originalmente fue diseñado para los <strong>sistemas de tiempo compartido</strong>, para repartir la CPU por igual entre los procesos de los usuarios del sistema.</p>
</div>
<div class="paragraph">
<p>Ilustremos el algoritmo con un ejemplo con cuanto de 4 ms.:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Proceso</th>
<th class="tableblock halign-center valign-top">Tiempo de llegada (ms.)</th>
<th class="tableblock halign-center valign-top">Tiempo de ráfaga de CPU (ms.)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">24</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>El resultado es el que se muestra en el siguiente diagrama de Gantt:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="C14-planificación_de_CPU/media/rr.svg" alt="rr">
</div>
</div>
<div class="paragraph">
<p>Y los <strong>tiempos de espera y ejecución promedio</strong> correspondientes serían:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2858%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Proceso</th>
<th class="tableblock halign-center valign-top">Instante de finalización (ms.)</th>
<th class="tableblock halign-center valign-top" colspan="2">Tiempo de espera (ms.)</th>
<th class="tableblock halign-center valign-top" colspan="2">Tiempo de ejecución (ms.)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">30</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(0-0) + (10-4)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(30-0)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">24</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(4-1)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(7-1)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(7-2)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(10-2)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Tiempos promedio (ms.)</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4,67</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">12,67</p></td>
</tr>
</tfoot>
</table>
<div class="sect4">
<h5 id="_rendimiento_2">Rendimiento</h5>
<div class="paragraph">
<p>Cuando se utilizar la planificación <strong>RR</strong> el tamaño del cuanto es un factor clave en la eficiencia del planificador:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cuando se reduce el <strong>cuanto</strong>, el <strong>tiempo de respuesta</strong> y el <strong>tiempo de espera promedio</strong> tienden a mejorar.
Sin embargo el número de cambios de contexto será mayor, por lo que la ejecución de los procesos será mas lenta.</p>
<div class="paragraph">
<p>Es importante tener en cuenta que interesa que el <strong>cuanto</strong> sea mucho mayor que el tiempo del cambio de contexto.
Si, por ejemplo, el tiempo de cambio de contexto es un 10% del <strong>cuanto</strong>, entonces alrededor del 10% del tiempo de CPU se pierde en cambios de contexto.</p>
</div>
</li>
<li>
<p>Cuando se incrementa el <strong>cuanto</strong>, el <strong>tiempo de espera promedio</strong> también se incrementa.
En el caso extremo en el que el <strong>cuanto</strong> es tan grande que ningún proceso lo agota, el <strong>RR</strong> se convierte en <strong>FCFS</strong>, que suele tener grandes <strong>tiempos de espera promedio</strong>.</p>
<div class="paragraph">
<p>Por otro lado, puede observarse experimentalmente que el <strong>tiempo de ejecución promedio</strong> generalmente mejora cuantos más procesos terminan su próxima ráfaga de CPU dentro de su <strong>cuanto</strong>.
Por lo tanto, nos interesa un cuanto grande para que más procesos terminen su siguiente ráfaga dentro del mismo.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Dados tres procesos con una duración cada uno de ellos de 10 unidades de tiempo y cuanto igual a 1, el tiempo de ejecución promedio será de 29 unidades.
Sin embargo, si el cuanto de tiempo fuera 10, el tiempo de ejecución promedio caería a 20 unidades de tiempo.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>La regla general que siguen los diseñadores es intentar que el 80% de las ráfagas de CPU sean menores que el tiempo de <strong>cuanto</strong>.
Se busca así equilibrar los criterios anteriores, evitando que el tiempo de cuanto sea demasiado grande o demasiado corto.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Actualmente se utilizan tiempos de cuanto de entre 10 y 100 ms.
Estos tiempos son mucho mayores que los tiempos de cambios de contexto, que generalmente son inferiores a 10µs.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_reparto_equitativo_del_tiempo_de_cpu">Reparto equitativo del tiempo de CPU</h5>
<div class="paragraph">
<p>Uno de los inconvenientes del algoritmo <strong>RR</strong> es que no garantiza el reparto equitativo del tiempo de
CPU entre los procesos limitados por la E/S y los limitados por la CPU —aunque es mejor que <strong>FCFS</strong>—.</p>
</div>
<div class="paragraph">
<p>Esto es debido a que los primeros utilizan el procesador durante periodos cortos de tiempo, para bloquearse posteriormente a la espera de que se realice la operación de E/S que han solicitado.
Cuando la espera termina, vuelven a la <strong>cola de preparados</strong> donde aguardan a que se les asigne la CPU.
Sin embargo, eso no va a ocurrir rápidamente si en el sistema hay procesos limitados por la CPU, pues estos generalmente agotan el <strong>cuanto</strong> antes de ser forzados a volver a la <strong>cola de preparados</strong>.</p>
</div>
<div class="paragraph">
<p>Así, los procesos limitados por la CPU hacen un mayor uso de la misma, mientras que los limitados por la E/S pueden tener que esperar durante bastante tiempo —aunque menos que si el algoritmo fuera <strong>FCFS</strong>, donde no hay <strong>cuanto</strong>— en la <strong>cola de preparados</strong> antes entrar en la CPU para solicitar una nueva operación de E/S.
Esto hace que se desaprovechen los dispositivos de E/S y genera un incremento de la varianza del tiempo de respuesta.
Para evitarlo se puede optar por un <strong>planificador de colas multinivel</strong> —para resolver el problema combinando el algoritmo <strong>RR</strong> con otro que priorice adecuadamente los procesos limitados por la E/S (véase el <a href="#_planificación_con_colas_multinivel">Apartado 14.5.7</a>)— o por la <strong>planificación equitativa</strong> que veremos a continuación.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_planificación_equitativa">14.5.6. Planificación equitativa</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Hasta el momento hemos hablado de planificadores que se centran en cuál es el proceso más importante para ejecutarlo a continuación.
Sin embargo otra opción, desde el punto de vista de la planificación, es dividir directamente el tiempo de CPU entre los procesos.
Esto es precisamente lo que hace la <strong>planificación equitativa</strong> (<em>Fair Scheduling</em>) que intenta repartir por igual el tiempo de CPU entre los procesos de la cola de preparados.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, si 4 procesos compitieran por el uso de la CPU, el planificador asignaría un 25% del tiempo de la misma a cada uno.
Si a continuación un usuario iniciase un nuevo proceso, el planificador tendría que ajustar el reparto asignando un 20% del tiempo a cada uno, ya que ahora habrían 5 procesos compitiendo por el tiempo de CPU.</p>
</div>
<div class="paragraph">
<p>El algoritmo de planificación equitativa es muy similar al algoritmo <strong>RR</strong>. Pero, mientras que en este último se utiliza un cuanto de tamaño fijo, en la planificación equitativa la ventana de tiempo se calcula de dinámicamente para garantizar el reparto equitativo de la CPU.</p>
</div>
<div class="paragraph">
<p>Al igual que en los algoritmos anteriores, en ocasiones puede ser interesante priorizar unos procesos frente a otros, tanto por motivos ajenos al sistema operativo como por motivos internos.
Por ejemplo, se puede querer favorecer a los procesos limitados por la E/S para mejorar la eficiencia del sistema, tal y como comentamos en el apartado <a href="#_ciclo_de_ráfagas_de_cpu_y_de_es">Apartado 14.4</a>.
La <strong>planificación equitativa</strong> resuelve este problema permitiendo que a los procesos se les asignen pesos y repartiendo proporcionalmente más tiempo de CPU a los procesos con mayor peso.
A esta generalización del planificador equitativo se la conoce como <strong>planificador equitativo ponderado</strong>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Desde la versión 2.6.23 de Linux se utiliza un tipo de <strong>planificador equitativo ponderado</strong> denominado <strong>CFS</strong> (<em>Completely Fair Scheduler</em>) o <strong>planificador completamente equitativo</strong>.
Otro ejemplo es Zircon, el <em>microkernel</em> de <a href="https://es.wikipedia.org/wiki/Google_Fuchsia">Google Fuchsia</a>, que está inmerso en migrar a una implementación de  <strong>planificador equitativo ponderado</strong>.</p>
</div>
<div class="paragraph">
<p>Para más información véase <a href="https://developer.ibm.com/technologies/linux/tutorials/l-completely-fair-scheduler/">«Inside the Linux 2.6 Completely Fair Schedule&#8201;&#8212;&#8201;IBM Developer»</a> y <a href="https://fuchsia.dev/fuchsia-src/concepts/kernel/fair_scheduler">«Zircon Fair Scheduler&#8201;&#8212;&#8201;Fuchsia Project»</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Si durante un periodo de tiempo \$T\$, un proceso \$P_i\$ tiene peso \$w_i\$, a ese proceso le corresponde un tiempo de CPU \$t_i\$:</p>
</div>
<div class="stemblock">
<div class="content">
\$t_i = w_i/W T\$
</div>
</div>
<div class="paragraph">
<p>donde \$W\$ es la suma de los pesos de todos los procesos en la <strong>cola de preparados</strong> durante \$T\$.</p>
</div>
</div>
<div class="sect3">
<h4 id="_planificación_con_colas_multinivel">14.5.7. Planificación con colas multinivel</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Los diseñadores recurren a la <strong>planificación de colas multinivel</strong> cuando quieren combinar las características de varios algoritmos.</p>
</div>
<div class="paragraph">
<p>En la planificación con colas multinivel se divide la cola de preparados en colas separadas.
Los procesos son asignados permanentemente a alguna de dichas colas, cada una de las cuales puede
tener un algoritmo de planificación distinto.</p>
</div>
<div class="paragraph">
<p>La asignación de un proceso a una cola se hace en base a alguna una característica del proceso.
Por ejemplo, si es interactivo o no, su prioridad o su tamaño en memoria.
Se hace de esta manera porque se supone que los procesos se pueden clasificar, y que cada clase tiene diferentes requerimientos.
Por ejemplo, si los procesos se clasifican en interactivos o no interactivos, los primeros puede ir a una cola con planificación <strong>RR</strong> mientras los segundos van a una con <strong>FCFS</strong>.</p>
</div>
<div id="esquema_colas_multinivel" class="imageblock">
<div class="content">
<img src="C14-planificación_de_CPU/media/planificación_colas_multinivel.svg" alt="planificación colas multinivel">
</div>
<div class="title">Figura 37. Ejemplo de planificación con colas multinivel.</div>
</div>
<div class="paragraph">
<p>Una cuestión interesante es como seleccionar la cola que debe escoger al siguiente proceso a ejecutar:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Un opción común en los sistemas actuales es utilizar un <strong>planificador con prioridades</strong>.
Es decir, que cada cola tenga una prioridad y así el planificador solo tiene que escoger la cola de prioridad más alta que no esté vacía.</p>
<div class="paragraph">
<p>Por ejemplo, en la <a href="#esquema_colas_multinivel">Figura 37</a>, mientras un proceso de prioridad 1 esté preparado, no se escoge ningún otro de prioridad inferior.
Si este planificador se implementa de forma expropiativa, el proceso que tiene asignada la CPU es expulsado si un proceso entra en una de las colas que tiene mayor prioridad que la suya.</p>
</div>
</li>
<li>
<p>Otra opción es usar cuantos sobre las colas.
Es decir, que a cada cola se le asigne una porción del tiempo de la CPU que debe repartirse entre los distintos procesos en la misma.</p>
<div class="paragraph">
<p>Por ejemplo, un 80% de CPU para la cola de procesos interactivos, con planificación <strong>RR</strong>, y el 20% de CPU restante para la cola de procesos no interactivos, con planificador <strong>FCFS</strong>.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>La <strong>planificación de colas multinivel</strong> con una <strong>planificador con prioridades</strong> para escoger la cola adecuada, es con diferencia la opción más común en lo sistemas operativos modernos.
Sin embargo, en este tipo de <strong>colas multinivel</strong> la asignación de los procesos a las colas es permanente —si la asignación se hace por prioridad, significa que la prioridad es fija—.
Mientras que hoy en día es común que los procesos se muevan entre colas según las características del proceso.</p>
</div>
</div>
<div class="sect3">
<h4 id="_planificación_con_colas_multinivel_realimentadas">14.5.8. Planificación con colas multinivel realimentadas</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Para aumentar la flexibilidad de la planificación con colas multinivel se puede permitir a los procesos pasar de una cola a otra.
Así se pueden clasificar en colas distintas procesos con diferente tiempos de ráfaga de CPU.
Por ejemplo, para situar los procesos interactivos o limitados por la E/S en las colas de más alta prioridad, lo que ya hemos discutido que mejora los tiempos de espera y de respuesta y evita el <strong>efecto convoy</strong>.</p>
</div>
<div id="esquema_planificación_colas_multinivel_realimentadas" class="imageblock">
<div class="content">
<img src="C14-planificación_de_CPU/media/planificación_colas_multinivel_realimentadas.svg" alt="planificación colas multinivel realimentadas">
</div>
<div class="title">Figura 38. Ejemplo de planificación con colas multinivel realimentadas.</div>
</div>
<div class="paragraph">
<p>Por ejemplo, supongamos un <strong>planificador de colas multinivel</strong> donde cada cola tiene una prioridad, así que se usa la <strong>planificación con prioridades</strong> para seleccionar la cola.
En las colas se usa el algoritmo <strong>RR</strong> para seleccionar el siguiente proceso, siendo el <strong>cuanto</strong> de la cola mayor cuanto menos prioritaria es la cola (véase la <a href="#esquema_planificación_colas_multinivel_realimentadas">Figura 38</a>).
Los procesos que llegan nuevos o desde el estado <strong>esperando</strong> lo hacen con la prioridad más alta —que por convención hemos decidido que sea 0— así que se insertan en la cola correspondiente.
Mientras que los procesos expropiados por vencimiento del <strong>cuanto</strong> pierde un punto de prioridad, siendo insertados en una cola de prioridad menor.</p>
</div>
<div class="paragraph">
<p>Con ese algoritmo los procesos limitados por E/S suelen ejecutarse la mayor parte del tiempo con prioridades más altas que los limitados por CPU.
Por ejemplo, usando los valores del esquema de la <a href="#esquema_planificación_colas_multinivel_realimentadas">Figura 38</a>, los procesos de ráfagas de CPU entre 20 y 80 ms. acaban cayendo a la cola de prioridad 1 tras 20 ms. de ejecución.
Así dejan paso a los procesos con ráfagas menores de 20 ms., que siempre se ejecutan con prioridad 0.
Finalmente, los procesos de ráfagas mayores de 80 ms. van a la cola FCFS, desde donde sólo tendrán acceso a la CPU cuando no haya ningún proceso de los otros tipos en la <strong>cola de preparados</strong></p>
</div>
<div class="paragraph">
<p>La <strong>planificador de colas multinivel realimentadas</strong> también se puede utilizar para pasar a colas superiores los procesos que han esperado mucho tiempo en colas inferiores, evitando la <strong>muerte por inanición</strong>, que puede afecta a los sistemas de <strong>planificación de colas multinivel</strong> con <strong>prioridad fija</strong>.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, el algoritmo <strong>RR virtual</strong> es un caso de <strong>planificador de colas multinivel realimentadas</strong> que resuelve los problemas del <strong>RR</strong>, en cuanto al reparto de la CPU entre procesos limitados por la E/S y limitados por la CPU (véase el <a href="#_reparto_equitativo_del_tiempo_de_cpu">Apartado 14.5.5.2</a>).</p>
</div>
<div id="esquema_planificación_rr_virtual" class="imageblock">
<div class="content">
<img src="C14-planificación_de_CPU/media/vrr.svg" alt="vrr">
</div>
<div class="title">Figura 39. Ejemplo de planificación con RR virtual.</div>
</div>
<div class="paragraph">
<p>Tal y como se ilustra en la <a href="#esquema_planificación_rr_virtual">Figura 39</a>, en el <strong>RR virtual</strong> los procesos por lo general tienen prioridad 1.
Sin embargo, aquellos que vuelven al estado <strong>preparado</strong> desde <strong>esperando</strong> después de una operación de E/S, obtienen una bonificación en la propiedad que los lleva a tener prioridad 0.
Por tanto, los procesos que usan con más frecuencia la E/S, usan más la cola de prioridad más alta, por lo que se les asigna antes la CPU mayor frecuencia.</p>
</div>
<div class="paragraph">
<p>Esta solución puede llevar a que si hay muchos procesos limitados por la E/S, éstos acaparen la CPU y no den oportunidad de ejecutarse a los procesos en la cola de prioridad 1.
Para evitarlo, el algoritmo <strong>RR</strong> de la cola de prioridad 0 tiene un <strong>cuanto</strong> variable, de tal forma que cada proceso recibe lo que le queda del <strong>cuanto</strong> de la cola de prioridad 1 tras haber consumido parte en la CPU en la ráfaga anterior.
Esto hace que incluso los procesos con ráfagas de CPU más cortas acaben consumiendo su <strong>cuanto</strong> en la cola de prioridad 0 y terminen cayendo a la cola de prioridad 1, dando oportunidad de ejecutarse a otros procesos.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Planificación en Microsoft Windows</div>
<div class="paragraph">
<p>Para ilustrar los visto hasta el momento sobre la planificación de la CPU en sistemas operativos modernos, vamos a comentar las principales características de las últimas versiones de Microsoft Windows a este respecto.</p>
</div>
<div class="paragraph">
<p>Las actuales versiones de sistemas operativos Windows pertenecen a la familia de Microsoft Windows NT; que nació con el sistema operativo Windows NT 3.1 en 1993 y que llega hasta hoy en día con Microsoft Windows 10 y Windows Server 2019 —que se corresponden con la versión 10.0 de dicha familia Windows NT—</p>
</div>
<div class="paragraph">
<p>El núcleo de la familia Windows NT es multihilo e internamente implementa un algoritmo de planificación expropiativa con colas multinivel realimentadas basado en prioridades.</p>
</div>
<div class="paragraph">
<p>En Windows las prioridades de los hilos se pueden ver desde dos perspectivas: la de Windows API y la del núcleo.
Ambas tienen una organización muy diferente pero, en última instancia, las primeras deben traducirse en las segundas.</p>
</div>
<table id="win32_clases_prioridad" class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 10. Clases de prioridad en Windows API.</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Clase</th>
<th class="tableblock halign-center valign-top">Valor</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">REALTIME_PRIORITY_CLASS</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0x00000100</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">HIGH_PRIORITY_CLASS</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0x00000080</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">ABOVE_NORMAL_PRIORITY_CLASS</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0x00008000</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">NORMAL_PRIORITY_CLASS</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0x00000020</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">BELOW_NORMAL_PRIORITY_CLASS</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0x00004000</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">IDLE_PRIORITY_CLASS</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0x00000040</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Desde el punto de vista de Windows API, todo proceso pertenece a alguna de las 6 clases de prioridad de la <a href="#win32_clases_prioridad">Tabla 10</a>.
La clase de prioridad de un proceso se puede indicar durante la creación del proceso, a través del argumento <code>dwCreationFlags</code> de la función <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a>, o sea puede obtener y cambiar con las funciones <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getpriorityclass">GetPriorityClass()</a> y <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setpriorityclass">SetPriorityClass()</a>, respectivamente.
Por lo general, la clase de prioridad <code>NORMAL_PRIORITY_CLASS</code> es la clase por defecto de cualquier proceso nuevo, excepto que se indique otra cosa durante su creación.</p>
</div>
<div id="windows_task_manager" class="imageblock">
<div class="content">
<img src="C14-planificación_de_CPU/media/administrador_de_tareas.jpg" alt="administrador de tareas">
</div>
<div class="title">Figura 40. Cambiar la prioridad de un proceso en el <strong>Administrador de tareas</strong>.</div>
</div>
<div class="paragraph">
<p>Con el <strong>Administrador de tareas</strong> de Windows podemos alterar fácilmente la clase de prioridad de un proceso durante su ejecución (véase la <a href="#windows_task_manager">Figura 40</a>).</p>
</div>
<table id="win32_prioridad_hilos" class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 11. Clases de prioridad en Windows API.</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Prioridad</th>
<th class="tableblock halign-center valign-top">Valor</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">THREAD_PRIORITY_TIME_CRITICAL</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">15</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">THREAD_PRIORITY_HIGHEST</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">THREAD_PRIORITY_ABOVE_NORMAL</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">THREAD_PRIORITY_NORMAL</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">THREAD_PRIORITY_BELOW_NORMAL</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">THREAD_PRIORITY_LOWEST</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-2</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">THREAD_PRIORITY_IDLE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">15</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Al mismo tiempo, cada hilo del sistema tiene alguno de las prioridades de la <a href="#win32_prioridad_hilos">Tabla 11</a>.
La prioridad de un hilo recién creado es <code>THREAD_PRIORITY_NORMAL</code>, pero se puede cambiar
usando la función <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadpriority">SetThreadPriority()</a>.</p>
</div>
<div class="paragraph">
<p>El núcleo de Windows tiene 32 prioridades, siendo 31 la prioridad más alta y 0 la más baja.
Estos valores se dividen en dos rangos.
El rango de prioridades de tiempo real va de 16 a 31 y solo está disponible para hilos en procesos en la clase de prioridad <code>REALTIME_PRIORITY_CLASS</code>.
Mientras que el rango de prioridades dinámicas va de 1 a 15.
El nivel 0 está reservado para el sistema y se usa para una rutina especializada en limpiar zonas de memoria liberada por los procesos, poniéndolas a 0.</p>
</div>
<div class="paragraph">
<p>La prioridad base —o prioridad estática— de cada hilo que ve el núcleo se calcula combinando la prioridad del hilo y la clase de prioridad del proceso al que pertenece.</p>
</div>
<table id="win32_prioridad_estática" class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 12. Clases de prioridad base en Windows API.</caption>
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2858%;">
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-center valign-top"></th>
<th class="tableblock halign-center valign-top" colspan="6"><p class="tableblock">Clase de prioridad del proceso</p></th>
</tr>
<tr>
<th class="tableblock halign-center valign-top"></th>
<th class="tableblock halign-center valign-top"><p class="tableblock">REALTIME</p></th>
<th class="tableblock halign-center valign-top"><p class="tableblock">HIGH</p></th>
<th class="tableblock halign-center valign-top"><p class="tableblock">ABOVE NORMAL</p></th>
<th class="tableblock halign-center valign-top"><p class="tableblock">NORMAL</p></th>
<th class="tableblock halign-center valign-top"><p class="tableblock">BELOW NORMAL</p></th>
<th class="tableblock halign-center valign-top"><p class="tableblock">IDLE</p></th>
</tr>
<tr>
<th class="tableblock halign-center valign-top"><p class="tableblock">TIME CRITICAL</p></th>
<td class="tableblock halign-center valign-top"><p class="tableblock">31</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">15</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">15</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">15</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">15</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">15</p></td>
</tr>
<tr>
<th class="tableblock halign-center valign-top"><p class="tableblock">HIGHEST</p></th>
<td class="tableblock halign-center valign-top"><p class="tableblock">26</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">15</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">12</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
</tr>
<tr>
<th class="tableblock halign-center valign-top"><p class="tableblock">ABOVE NORMAL</p></th>
<td class="tableblock halign-center valign-top"><p class="tableblock">25</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">15</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">11</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
</tr>
<tr>
<th class="tableblock halign-center valign-top"><p class="tableblock">NORMAL</p></th>
<td class="tableblock halign-center valign-top"><p class="tableblock">24</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
</tr>
<tr>
<th class="tableblock halign-center valign-top"><p class="tableblock">BELOW NORMAL</p></th>
<td class="tableblock halign-center valign-top"><p class="tableblock">23</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">12</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
</tr>
<tr>
<th class="tableblock halign-center valign-top"><p class="tableblock">LOWEST</p></th>
<td class="tableblock halign-center valign-top"><p class="tableblock">22</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">11</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
</tr>
<tr>
<th class="tableblock halign-center valign-top"><p class="tableblock">IDLE</p></th>
<td class="tableblock halign-center valign-top"><p class="tableblock">16</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Esta prioridad base es la prioridad real del hilo, si éste tiene una prioridad en el rango de tiempo real —es decir, si el proceso al que pertenece está en la clase de prioridad <code>REALTIME_PRIORITY_CLASS</code>—.
Mientras que para el resto de hilos, el sistema suma ciertas bonificaciones a la prioridad base para calcular la prioridad dinámica, que es con la que realmente será planificado el hilo.
Estas bonificaciones se truncan para que nuncan puedan hacer que el hilo se meta en el rango de tiempo real.</p>
</div>
<div class="paragraph">
<p>La prioridad real la usa el sistema para determinar a qué cola va el hilo cuando va a ser insertado en la <strong>cola de preparados</strong>.
Para cada nivel de prioridad hay una cola con algoritmo <strong>RR</strong>, de tal forma que el planificador escoge primero a los hilos con prioridad más alta. Dentro de la misma prioridad la CPU se asigna en turno, dándoles un <strong>cuanto</strong> de tiempo de CPU.</p>
</div>
<div class="paragraph">
<p>Cuando llega un hilo a la cola de preparados, expropia la CPU al hilo que la tiene asignada si éste tiene menor prioridad.
Esto puede ocurrir incluso si el hilo a expropiar está en medio de una llamada al sistema ya que, como cualquier sistema operativo moderno, el núcleo de Windows es expropiable —lo que veremos en el <a href="#_núcleo_expropiable">Apartado 14.6.4.2</a> que ofrece latencias de asignación más bajas que si no lo fuera—.</p>
</div>
<div class="paragraph">
<p>Respecto al <strong>cuanto</strong>, desde Windows Vista –NT 6.0– no se usa el temporizador para controlarlo sino el contador de ciclos de reloj de la CPU.
Así el sistema puede determinar con precisión el tiempo que se ha estado ejecutando un hilo, excluyendo los tiempos dedicados a otras cuestiones, como por ejemplo a manejar interrupciones.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Desde el Intel Pentium las CPU de la familia x86 incorporan un contador de marca de tiempo (<em>Time Stamp Counter</em> o TSC) de 64 bits que indica el número de ciclos transcurridos desde el último reinicio del procesador.</p>
</div>
<div class="paragraph">
<p>Para más información véase <a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">«Time Stamp Counter&#8201;&#8212;&#8201;Wikipedia»</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Una característica curiosa, es que los hilos expropiados se insertan en la cabeza de su cola —no en el final— y conservan lo que les queda de <strong>cuanto</strong>.
Mientras que se insertan por el final con el valor de <strong>cuanto</strong> reiniciado cuando abandonan la CPU por haber agotado el cuanto anterior.
Estos últimos, además, pierden un nivel de prioridad si se ejecutaban con una prioridad superior a su prioridad base, a causa de alguna modificación.</p>
</div>
<div class="paragraph">
<p>Los bonificaciones a los hilos en el rango de prioridades dinámicas vienen determinadas por distintos criterios, escogidos para mejorar el <strong>tiempo respuesta</strong> y el <strong>tiempo de espera</strong> —priorizando los procesos limitados por E/S—, evitar la <strong>muerte por inanición</strong> y la <strong>inversión de prioridad</strong>.</p>
</div>
<div class="paragraph">
<p>Se bonifican los hilos que despiertan tras completar operaciones de E/S con una cantidad que depende del tipo de dispositivo.
Por ejemplo, la bonificación es mejor para hilos que han esperado por el teclado o el ratón que para los que esperaron por dispositivos del almacenamiento.
También son bonificados los hilos que despierta de eventos, semáforos y de otros objetos de sincronización.
En este último caso, incluso se les ofrece más tiempo de <strong>cuanto</strong> si es el hilo asociado a la ventana de primer plano, con el objetivo de mejorar la respuesta de las aplicaciones interactivas.
También se bonifica cualquier hilo que gestione elementos de la interfaz grafica cuando despierta para responder a eventos del sistema de ventanas.</p>
</div>
<div class="paragraph">
<p>Para evitar la <strong>muerte por inanición</strong>, el planificador escoge cada segundo unos pocos hilos que lleven esperando aproximadamente 4 segundos, les triplica el <strong>cuanto</strong> y les aumenta la prioridad a 15.
Estos hilos recuperan su prioridad base y el cuanto anterior cuando agotan el tiempo de cuanto actual o son expropiados de la CPU</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_planificación_de_tiempo_real">14.6. Planificación de tiempo real</h3>
<div class="paragraph">
<p>En el <a href="#_sistemas_de_tiempo_real">Apartado 2.7</a> discutimos la importancia de los sistemas de tiempo real.
A continuación, describiremos las funcionalidades necesarias para soportar la ejecución de procesos en tiempo real dentro de un sistema operativo de propósito general.</p>
</div>
<div class="sect3">
<h4 id="_tiempo_real_estricto">14.6.1. Tiempo real estricto</h4>
<div class="paragraph">
<p>

</p>
</div>
<div class="paragraph">
<p>Los sistemas de <strong>tiempo real estricto</strong> son necesarios para realizar tareas críticas que deben ser completadas dentro de unos márgenes de tiempo preestablecidos.</p>
</div>
<div class="paragraph">
<p>Generalmente las tareas son entregas al sistema operativo junto con una declaración de las restricciones de tiempo —periodicidad y límite de tiempo— y la cantidad de tiempo que necesitan para ejecutarse.
El planificador sólo admitirá las tareas si puede garantizar el cumplimiento de las restricciones de tiempo, rechazándolas en caso contrario.</p>
</div>
<div class="paragraph">
<p>El ofrecer estas garantías requiere que el planificador conozca exactamente el tiempo máximo que se tarda en realizar todas y cada una de las funciones del sistema operativo.
Esto es imposible en sistemas con almacenamiento secundario o memoria virtual, ya que introducen variaciones no controladas en la cantidad de tiempo necesario para ejecutar una tarea.
Por tanto, el <strong>tiempo real estricto</strong> no es compatible con los sistemas operativos de propósito general, como los sistemas operativos de escritorio modernos.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tiempo_real_flexible">14.6.2. Tiempo real flexible</h4>
<div class="paragraph">
<p>

</p>
</div>
<div class="paragraph">
<p>La ejecución de procesos de <strong>tiempo real flexible</strong> es menos restrictiva.
Tan sólo requiere que los procesos críticos reciban mayor prioridad que los que no lo son.
Esto puede generar excesos en la cantidad de recursos asignados a los procesos de tiempo real, así como inanición y grandes retardos en la ejecución del resto de los procesos, pero es compatible con los sistemas de propósito general.</p>
</div>
<div class="paragraph">
<p>Además nos permite conseguir sistemas de propósito general que soporten multimedia, videojuegos y otras tareas que no funcionarían de manera aceptable en un entorno que no implementara tiempo real flexible.
Por ello, la mayor parte de los sistemas operativos modernos soportan este tipo de tiempo real.</p>
</div>
</div>
<div class="sect3">
<h4 id="_implementación_del_soporte_de_tiempo_real">14.6.3. Implementación del soporte de tiempo real</h4>
<div class="paragraph">
<p>Implementar el soporte de tiempo real flexible en un sistema operativo de propósito general requiere:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Sistema operativo con planificación con prioridades</strong>.
Los procesos de tiempo real deben tener la mayor prioridad y ser fija.
Es decir, no deben ser afectados por ningún mecanismo de envejecimiento o bonificación, que pueda usarse con los procesos de tiempo no real.</p>
</li>
<li>
<p><strong>Baja latencia de asignación</strong>.
Cuanto menor es la latencia, más rápido comenzará a ejecutarse el proceso de tiempo real después de ser seleccionado por el planificador de la CPU.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Mientras que el primer requerimiento es bastante sencillo de conseguir, el segundo es mucho más complejo.</p>
</div>
</div>
<div class="sect3">
<h4 id="_reducir_la_latencia_de_asignación">14.6.4. Reducir la latencia de asignación</h4>
<div class="paragraph">
<p>Muchos sistemas operativos tienen un núcleo no expropiable.
Estos núcleos no pueden realizar un cambio de contexto mientras se está ejecutando código del núcleo —por ejemplo, debido a una llamada al sistema— por lo que se ven obligados a esperar hasta que la operación que se esté realizando termine, antes de asignar la CPU a otro proceso.
Esto aumenta la <strong>latencia de asignación</strong>, dado que algunas llamadas al sistema pueden ser muy
complejas y requerir mucho tiempo para completarse.</p>
</div>
<div class="paragraph">
<p>Con el objetivo de resolver este problema se han desarrollado diversas alternativas para que el código del núcleo sea expropiable.</p>
</div>
<div class="sect4">
<h5 id="_puntos_de_expropiación">Puntos de expropiación</h5>
<div class="paragraph">
<p>Una posibilidad es introduciendo <strong>puntos de expropiación</strong> en diversos lugares «seguros» dentro del código.
En dichos puntos se comprueba si algún proceso de prioridad más alta está en la cola de preparados.
En caso de que sea así, se expropia la CPU al proceso actual y se le asigna al proceso de más alta prioridad.</p>
</div>
<div class="paragraph">
<p>Debido a la función que realizan los puntos de expropiación, sólo pueden ser colocados en lugares seguros del código del núcleo.
Es decir, lugares donde no se interrumpe la modificación de estructuras de datos.
Sin embargo, esto limita el número de puntos que pueden ser colocados, por lo que la latencia de asignación puede seguir siendo muy alta para algunas operaciones muy complejas del núcleo.</p>
</div>
</div>
<div class="sect4">
<h5 id="_núcleo_expropiable">Núcleo expropiable</h5>
<div class="paragraph">
<p>Otra posibilidad es diseñar un <strong>núcleo completamente expropiable</strong>.</p>
</div>
<div class="paragraph">
<p>Puesto que en este caso la ejecución de cualquier operación en el núcleo puede ser interrumpida en cualquier momento por procesos de mayor prioridad que el que actualmente tiene asignada la CPU, es necesario proteger las estructuras de datos del núcleo con mecanismos de sincronización.
Esto hace que el diseño de un núcleo de estas características sea mucho más complejo.</p>
</div>
<div class="paragraph">
<p>Microsoft Windows —desde Windows NT—, Linux —desde la versión 2.6—, <a href="https://es.wikipedia.org/wiki/Solaris_(sistema_operativo)">Solaris</a> y <a href="https://es.wikipedia.org/wiki/NetBSD">NetBSD</a> son algunos ejemplos de sistemas operativos con núcleos expropiables.
En el caso concreto de Solaris la latencia de asignación es inferior a 1 ms., mientras que con la expropiación del núcleo desactivada ésta puede superar los 100 ms.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Expropiación en el núcleo de Linux</div>
<div class="paragraph">
<p>Lamentablemente, conseguir baja latencia de asignación no tiene coste cero.
El hecho de que el núcleo sea expropiable aumenta el número de cambios de contexto, lo que reduce el rendimiento del sistema a cambio de un menor tiempo de respuesta.
Esto resulta muy interesante para aplicaciones de tiempo real, multimedia y sistemas de escritorio, pero es poco adecuado para servidores y computación de altas prestaciones.</p>
</div>
<div class="paragraph">
<p>Por eso desde Linux 2.6 se puede compilar el núcleo con diferentes niveles, de lo expropiable que es el núcleo.</p>
</div>
<div class="paragraph">
<p>En la configuración por defecto <code>PREEMPT_NONE</code>, el núcleo tiene algunos <strong>puntos de expropiación</strong>, de tal forma que es ideal para servidores y sistemas cómputo de altas prestaciones.
Con <code>PREEMPT_VOLUNTARY</code> —el siguiente nivel— se añaden muchos más <strong>puntos de expropiación</strong> con el objeto de reducir la latencia, mejorando el tiempo de respuesta en sistemas de escritorio.</p>
</div>
<div class="paragraph">
<p>Finalmente, activando <code>PREEMPT</code> el núcleo se vuelve <strong>completamente expropiable</strong> —excepto en algunas secciones críticas—.
Esto es ideal para sistemas de escritorio o sistemas empotrados con requisitos de latencia en el rango de los milisegundos.</p>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_inversión_de_prioridad">Inversión de prioridad</h6>
<div class="paragraph">
<p>Supongamos que en un núcleo completamente expropiable, un proceso de baja prioridad es interrumpido porque hay un proceso de alta prioridad en la cola de preparados.
Y que esto ocurre mientras el primero accede a una importante estructura de datos del núcleo.</p>
</div>
<div class="paragraph">
<p>Durante su ejecución, el proceso de alta prioridad podría intentar acceder a la misma estructura que trataba de manipular el proceso de baja prioridad cuando fue interrumpido.
Debido al uso de mecanismos de sincronización, el proceso de alta prioridad se quedaría bloqueado y tendría que abandonar la CPU a la espera de que el de baja, libere el acceso al recurso.
Sin embargo, este último tardará en ser asignado a la CPU mientras haya algún otro proceso de alta prioridad en la cola de preparados.</p>
</div>
<div class="paragraph">
<p>Al hecho de que un proceso de alta prioridad tenga que esperar por uno de baja se le conoce como <strong>inversión de la prioridad</strong>.
Para resolverlo se utiliza un <strong>protocolo de herencia de la prioridad</strong>, dónde un proceso de baja prioridad hereda la prioridad del proceso de más alta prioridad que espera por un recurso al que el primero está accediendo.
En el momento en que el proceso de baja prioridad libere el acceso a dicho recurso, su prioridad retornará a su valor original.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_planificación_en_sistemas_multiprocesador">14.7. Planificación en sistemas multiprocesador</h3>
<div class="paragraph">
<p>Para tratar el problema de la planificación en los sistemas multiprocesador nos limitaremos al caso de los <strong>sistemas homogéneos</strong>.
En dichos sistemas los procesadores son idénticos, por lo que, en cualquiera de ellos, puede ejecutar cualquier proceso.
Esto es bastante común y simplifica el problema de la planificación.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Un ejemplo de lo contrario a un sistema homogéneo —un sistema heterogéneo— se puede observar en los PC modernos, donde muchos disponen tanto de una CPU como de una GPU, especializada en el procesamiento de gráficos y en las operaciones vectoriales con números enteros y de coma flotante.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Aun así, no debemos olvidar que incluso en el caso de los sistemas homogéneos pueden aparecer limitaciones en la planificación.
Por ejemplo, los procesadores SMT (<em>Simultaneous Multithreading</em>) permiten la ejecución concurrente de varios hilos de ejecución como si de varias CPU se tratara.
Sin embargo, al no disponer cada hilo de una CPU completa, es posible que algunos deban esperar a que algún otro libere unidades de ejecución de la CPU que le son necesarias.
Eso debe ser tenido en cuenta por el planificador con el fin de optimizar el rendimiento del sistema.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>La tecnología <em>Hyper-threading</em> disponible en algunos procesadores de Intel es una implementación de la tecnología <em>Simultaneous Multithreading</em>.
Permite que cada núcleo de procesador que está presente físicamente, el sistema operativo lo gestione como dos núcleos virtuales —o lógicos— y repartir entre ellos las tareas cuando es posible.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Al margen de estas cuestiones, según el tipo de procesamiento, existen diversas posibilidades a la hora de enfrentar el problema de la planificación en un sistema multiprocesador (véase el <a href="#_sistemas_multiprocesador">Apartado 2.4</a>).</p>
</div>
<div class="sect3">
<h4 id="_multiprocesamiento_asimétrico">14.7.1. Multiprocesamiento asimétrico</h4>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>Cuando utilizamos <strong>multiprocesamiento asimétrico</strong> todas las decisiones de planificación, procesamiento de E/S y otras actividades son gestionadas por el núcleo del sistema ejecutándose en un único procesador: el <strong>servidor</strong> o <strong>maestro</strong>.
El resto de procesadores se limitan a ejecutar código de usuario, que les es asignado por ese procesador <strong>maestro</strong>.</p>
</div>
<div class="paragraph">
<p>Este esquema es sencillo, puesto que evita la necesidad de compartir estructuras de datos entre el código que se ejecuta en los diferentes procesadores.</p>
</div>
</div>
<div class="sect3">
<h4 id="_multiprocesamiento_simétrico">14.7.2. Multiprocesamiento simétrico</h4>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>Cuando utilizamos <strong>multiprocesamiento simétrico</strong> o <strong>SMP</strong>, cada procesador ejecuta su propia copia del núcleo del sistema operativo y se auto-planifica mediante su propio planificador de CPU.
En estos sistemas nos podemos encontrar con varias alternativas.</p>
</div>
<div class="sect4">
<h5 id="_con_una_cola_de_preparados_común">Con una cola de preparados común</h5>
<div class="paragraph">
<p>Algunos sistemas disponen de una cola de preparados común para todos los procesadores.
Puesto que se mira en una única cola, todos los procesos pueden ser planificados en cualquier procesador.</p>
</div>
<div class="paragraph">
<p>Este esquema requiere el uso mecanismos de sincronización para controlar el acceso concurrente de los núcleos a las colas.
En caso contrario, varios procesadores podrían escoger y ejecutar el mismo proceso a la vez.</p>
</div>
<div class="paragraph">
<p>Muchos sistemas operativos modernos implementan el esquema SMP con una cola de preparados común.
Esto incluye Microsoft Windows NT/2000/XP, Solaris, macOS y versiones anteriores a Linux 2.6.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Es importante recordar que en esos sistemas operativos, lo que se planifica en las distintas CPU usando alguna de estas estrategias, son los hilos y no los procesos.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Sin embargo, esta solución presenta algunos inconvenientes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La posibilidad de que un proceso se pueda ejecutar en cualquier CPU —aunque parezca beneficiosa— es negativa desde el punto de vista de que dejan de ser útiles las cachés de los procesadores, penalizando notablemente el rendimiento del sistema.
Por eso, la mayoría de los sistemas operativos de este tipo evitan, en lo posible, la migración de procesos de un procesador a otro.
A esto se lo conoce como asignar al proceso <strong>afinidad al procesador</strong>.</p>
</li>
<li>
<p>Los mecanismos de sincronización requeridos para controlar el acceso a la cola de preparados pueden mantener a los procesadores mucho tiempo desocupados —mientras esperan— en sistemas con un gran número de procesadores y con muchos procesos en la cola de preparados.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_con_una_cola_para_cada_procesador">Con una cola para cada procesador</h5>
<div class="paragraph">
<p>Cada vez más sistemas modernos están optando por utilizar el esquema SMP con una cola de preparados por procesador.
De esta manera, al no utilizar mecanismos de sincronización, se eliminan los tiempos de espera para acceder a la cola de preparados y escoger un nuevo proceso.</p>
</div>
<div class="paragraph">
<p>El mayor inconveniente de esta solución es que puede generar desequilibrios entre los procesadores, ya que un procesador puede acabar desocupado —con su cola de preparados vacía— mientras otro está muy ocupado.
Con el fin de que esto no suceda, es necesario que el sistema disponga de algunos mecanismos de <strong>balanceo de carga</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En la <strong>migración comandada</strong> o <em>push migration</em>, una tarea específica —que se ejecuta con menor frecuencia que el planificador de la CPU— estima la carga de trabajo de cada CPU y en caso de encontrar algún desequilibrio mueve algunos procesos de la cola de preparados de unos procesadores a la de los otros.</p>
</li>
<li>
<p>En la <strong>migración solicitada</strong> o <em>pull migration</em>, un procesador inactivo extrae de la cola de preparados de un procesador ocupado alguna tarea que esté esperando.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Tanto el planificador de Linux 2.6 y posteriores, como el planificador ULE de FreeBSD, implementan ambas técnicas.
Mientras que en Microsoft Windows, a partir de Windows Vista también se utiliza una cola de preparados por procesador, pero solo implementa la <strong>migración solicitada</strong>.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<h1 id="_gestión_de_la_memoria" class="sect0">Parte IV: Gestión de la memoria</h1>
<div class="sect1">
<h2 id="_memoria_principal">15. Memoria principal</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>22 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>La memoria es un recurso central para el funcionamiento de un sistema operativo moderno, puesto que es el único medio de almacenamiento al que la CPU puede acceder directamente.
Por ello, para que un programa pueda ser ejecutado, debe ser cargado en la memoria desde el disco y creadas o modificadas las estructuras internas del sistema operativo necesarias para convertirlo en un proceso.
Además, dependiendo de la forma en la que se gestiona la memoria, los procesos —o partes de los mismos— pueden moverse de la memoria al disco —y viceversa— durante su ejecución, con el objetivo de ajustar las necesidades de memoria para mantener el la <strong>uso de la CPU</strong> lo más alto posible.</p>
</div>
<div class="paragraph">
<p>Como comentamos en el <a href="#_sistemas_multiprogramados">Apartado 2.1.2</a>, en los <strong>sistemas multiprogramados</strong> existe una <strong>cola de entrada</strong>, que se define como aquella formada por el conjunto de procesos en disco que esperan para ser cargados en la memoria para su ejecución.</p>
</div>
<div class="paragraph">
<p>Por tanto, el procedimiento normal de ejecución de un programa en dichos sistemas es:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Seleccionar un proceso de la cola de entrada y cargarlo en la memoria.</p>
</li>
<li>
<p>Mientras el proceso se ejecuta, éste accede a instrucciones y datos de la memoria.</p>
</li>
<li>
<p>Finalmente, el proceso termina y su espacio en memoria es marcado como disponible.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>En los sistemas de propósito general modernos —desde los <strong>sistemas de tiempo compartido</strong> y los primeros <strong>sistemas de escritorio</strong>— no existe <strong>cola de entrada</strong>, por lo que los programas se cargan inmediatamente en memoria cuando los usuarios solicitan su ejecución.
Excepto por eso, el procedimiento normal de ejecución de un programa es similar al de los <strong>sistemas multiprogramados</strong>.</p>
</div>
<div class="sect2">
<h3 id="_etapas_de_un_programa_de_usuario">15.1. Etapas de un programa de usuario</h3>
<div class="paragraph">
<p>En la mayor parte de los casos, un programa de usuario debe pasar por diferentes etapas —algunas de las cuales son opcionales— antes de ser ejecutado (véase la <a href="#etapas_programas_de_usuario">Figura 41</a>).</p>
</div>
<div id="etapas_programas_de_usuario" class="imageblock">
<div class="content">
<img src="C15-memoria_principal/media/etapas_de_un_programa_de_usuario.svg" alt="etapas de un programa de usuario">
</div>
<div class="title">Figura 41. Etapas de procesamiento de un programa de usuario.</div>
</div>
<div class="paragraph">
<p>Los archivos de <strong>código fuente</strong> del programa son compilados por el compilador, generando un archivo de <a href="https://es.wikipedia.org/wiki/C%C3%B3digo_objeto"><strong>código objeto</strong></a> —con extensiones <code>.o</code> u <code>.obj</code>— para cada uno.</p>
</div>
<div class="paragraph">
<p>Todos los archivos de <strong>código objeto</strong> son unidos por el enlazador para crear el archivo <strong>ejecutable</strong>, en una fase que se denomina <strong>enlazado estático</strong>.
En esta fase también se pueden incorporar al ejecutable <strong>librerías de enlace estático</strong> —con extensiones <code>.a</code> o <code>.lib</code>— con <strong>código objeto</strong> que ha sido empaquetado para ser reutilizado en múltiples ejecutables.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>El compilador y el enlazador suelen ser dos programas independientes, aunque en ocasiones el compilador se haga cargo de ambas fases por comodidad.
Por ejemplo, en los sistemas GNU el compilador <a href="https://es.wikipedia.org/wiki/GNU_Compiler_Collection">gcc</a> por defecto genera el <strong>código objeto</strong> en archivos temporales, luego invoca al enlazador <a href="https://en.wikipedia.org/wiki/Linker_(computing)">ld</a> para crear el <strong>ejecutable</strong> y finalmente elimina los archivos temporales.</p>
</div>
<div class="paragraph">
<p>En proyectos grandes suele ser más interesante usar ambas herramientas por separado para reducir el tiempo de compilación.
El compilador genera los archivos de <strong>código objeto</strong>, que se conservan entre compilaciones.
Así, cada vez que se quiere generar una nueva versión del ejecutable, solo es necesario compilar los archivos de <strong>código fuente</strong> que hayan cambiado y luego enlazar juntos todos los archivos de <strong>código objeto</strong>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Al crear el <strong>ejecutable</strong> se pueden guardar en él dependencias respecto a librerías que se enlazarán posteriormente, durante la carga o ejecución del programa, en una fase denominada <strong>enlazado dinámico</strong>.</p>
</div>
<div class="paragraph">
<p>En el momento en el que se va a ejecutar el programa, cuando está construyendo la imagen binaria del proceso en la memoria; el sistema operativo examina estas dependencias, carga las <strong>librerías de enlace dinámico</strong> indicadas —con extensiones <code>.so</code>, <code>dylib</code> o <code>.dll</code>— y resuelve las referencias del programa sus variables y funciones.
Las <strong>librerías de enlace dinámico</strong> contienen <strong>código objeto</strong>, enlazado en un formato especial de <strong>ejecutable</strong> diseñado para contener partes compartidas entre archivos ejecutables.</p>
</div>
<div class="paragraph">
<p>Este proceso puede ocurrir mientras se carga el <strong>ejecutable</strong> —como se ha descrito— o cuando el programa usa por primera vez un elemento de las <strong>librerías de enlace dinámico</strong>.
También es común que el sistema ofrezca funciones para que los programas puedan cargar manualmente e invocar funciones de <strong>librerías de enlace dinámico</strong>.
Esto es muy útil para crear programas que se puedan mejorar por medio de extensiones o <em>plugins</em>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 13. Extensiones de archivos de programas.</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">UNIX, Linux y otros sistemas estilo UNIX</th>
<th class="tableblock halign-left valign-top">macOS</th>
<th class="tableblock halign-left valign-top">Microsoft Windows</th>
</tr>
</thead>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Código objeto</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>.o</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>.o</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>.obj</code></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Librería de enlace estático</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>.a</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>.a</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>.lib</code></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Ejecutable</p></th>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>.exe</code></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Librería de enlace dinámico</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>.so</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>.so</code>, <code>.dylib</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>.dll</code></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Formato de ejecutables y librerías de enlace dinámico</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://es.wikipedia.org/wiki/Executable_and_Linkable_Format">Executable and Linkable Format</a> (ELF)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.wikipedia.org/wiki/Mach-O">Mach-O</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://es.wikipedia.org/wiki/Portable_Executable">Portable Executable</a> (PE)</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_reubicación_de_las_direcciones">15.2. Reubicación de las direcciones</h3>
<div class="paragraph">
<p>La mayor parte de los sistemas permiten que un proceso de usuario resida en cualquier parte de la memoria física.
Así, aunque el espacio de direcciones del sistema comience en <code>0x00000000</code>, la primera dirección del proceso de usuario no tiene porque ser esa.</p>
</div>
<div class="paragraph">
<p>En cada una de las etapas vistas en el <a href="#_etapas_de_un_programa_de_usuario">Apartado 15.1</a> las direcciones pueden representarse de formas distintas, por lo que en cada paso es necesario reasignar las direcciones usadas en una etapa en direcciones de la siguiente.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, en el código fuente de un programa las direcciones son generalmente simbólicas, como los nombres de las variables y las funciones.
A continuación, un compilador suele reasignar esas direcciones simbólicas en <strong>direcciones reubicables</strong> del estilo de «120 bytes desde el comienzo del módulo».
Finalmente —el enlazador— que genera el ejecutable— o el cargador —que carga el programa en la memoria— convierte esas <strong>direcciones reubicables</strong> en <strong>direcciones absolutas</strong>, como <code>0x00210243</code>.</p>
</div>
<div class="paragraph">
<p>Por tanto, en cada etapa se traducen las direcciones de un espacio de direcciones en el siguiente.
Sin embargo, para que al final el programa pueda ser ejecutado, es necesario que tanto a los datos como a las instrucciones se les reasignen en algún momento a <strong>direcciones absolutas</strong> de la memoria.
Esto puede ocurrir en <strong>tiempo de compilación</strong>, <strong>tiempo de carga</strong> o <strong>tiempo de ejecución</strong></p>
</div>
<div class="sect3">
<h4 id="_reubicación_en_tiempo_de_compilación">15.2.1. Reubicación en tiempo de compilación</h4>
<div class="paragraph">
<p>Si durante la compilación o el enlazado se conoce el lugar de la memoria donde va a ser ejecutado el proceso, se puede generar directamente código con <strong>direcciones absolutas</strong> o <strong>código absoluto</strong>.</p>
</div>
<div class="paragraph">
<p>Eso significa que si en algún momento la dirección de inicio donde es cargado el programa cambia, es necesario recompilar el código fuente del programa para poder ejecutarlo en la nueva ubicación.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Un ejemplo son los ejecutables con formato <a href="https://es.wikipedia.org/wiki/Archivo_COM">COM</a> del sistema operativo MS-DOS.
Estos ejecutables no eran reubicables, aunque podían ponerse en distintas ubicaciones de la memoria gracias a la <a href="https://es.wikipedia.org/wiki/Segmentaci%C3%B3n_de_memoria_del_x86">segmentación de memoria de la familia Intel x86</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_reubicación_en_tiempo_de_carga">15.2.2. Reubicación en tiempo de carga</h4>
<div class="paragraph">
<p>Si no se conoce durante la compilación el lugar donde va a residir un programa cuando sea ejecutado, el compilador y el enlazador deben generar ejecutables con <strong>código reubicable</strong>.</p>
</div>
<div class="paragraph">
<p>En este tipo de código se utilizan <strong>direcciones reubicables</strong>, de manera que se retrasa su asignación a <strong>direcciones absolutas</strong> hasta el momento de la carga del programa.
Esto permite que un programa pueda residir en cualquier parte de la memoria física, cargando los procesos donde más convenga para maximizar el aprovechamiento de la misma.</p>
</div>
<div class="paragraph">
<p>Para generar <strong>código reubicable</strong>, por lo general, el compilador genera
<strong>código independiente de la posición</strong> o <strong>PIC</strong> (<em>Position-Independent Code</em>).
Este tipo de código se puede ejecutar adecuadamente y sin modificaciones independientemente del lugar de la memoria donde esté ubicado, porque utiliza direcciones relativas.</p>
</div>
<div class="paragraph">
<p>Lamentablemente, esto puede limitar las características de la CPU que puede utilizar el compilador o, a veces, las instrucciones que usan direcciones absolutas son más rápidas que las que usan direcciones relativas, aunque en los procesadores modernos la diferencia apenas es perceptible.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, las CPU x86-64 soportan un modo de direccionamiento en el que las direcciones son relativas a la dirección en el contador de programa.
Esto simplifica generar código reubicable eficiente.
Sin embargo, en las CPU x86 anteriores, las instrucciones de salto podían ser relativas al contador de programa, pero no ocurría así con aquellas destinadas a acceder a los datos del programa.</p>
</div>
<div class="paragraph">
<p>Cuando no se puede o no es eficiente generar <strong>código independiente de la posición</strong> se puede recurrir al uso de <strong>tablas de reubicación</strong> en tiempo de carga.
En este caso el compilador y el enlazador generan:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Código con direcciones relativas a cierta dirección fija del ejecutable —como el comienzo de la sección de código— o direcciones absolutas calculadas bajo la suposición de que el ejecutable se va a poder cargar en cierta dirección concreta de la memoria, que suele guardarse en la cabecera del ejecutable.</p>
</li>
<li>
<p>Una <strong>tabla de reubicaciones</strong> que se almacena en el mismo ejecutable.
Esta tabla contiene punteros a las ubicaciones en el código del ejecutable de las direcciones que deben reubicarse al cargarlo.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Durante la carga, el cargador del sistema operativo, una vez ha copiado a la memoria el contenido del ejecutable y conoce la ubicación definitiva del programa, recorre la <strong>tabla de reubicaciones</strong> para buscar las <strong>direcciones reubicables</strong> y actualizarlas.</p>
</div>
</div>
<div class="sect3">
<h4 id="_reubicación_en_tiempo_de_ejecución">15.2.3. Reubicación en tiempo de ejecución</h4>
<div class="paragraph">
<p>Si un proceso puede ser movido durante su ejecución de un lugar de la memoria a otro, la reubicación de direcciones debe ser retrasada hasta el momento de la ejecución de cada instrucción del programa.</p>
</div>
<div class="paragraph">
<p>Para que esto sea posible, necesitamos disponer de hardware especial que suele estar presente en la mayor parte de las CPU modernas, por lo que la inmensa mayoría de los sistemas operativos de propósito general modernos utilizan este método.
De él hablaremos en el <a href="#_espacio_de_direcciones_virtual_frente_a_físico">Apartado 15.3</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_espacio_de_direcciones_virtual_frente_a_físico">15.3. Espacio de direcciones virtual frente a físico</h3>
<div class="paragraph">
<p>En el <a href="#_protección_de_la_memoria">Apartado 7.3</a> vimos en los sistemas operativos modernos, como medida de protección, los procesos no tienen acceso libre a la memoria física.</p>
</div>
<div id="espacio_direcciones_virtual_frente_físico" class="imageblock">
<div class="content">
<img src="C15-memoria_principal/media/protección_memoria.svg" alt="protección memoria">
</div>
<div class="title">Figura 42. Mapeo de la memoria física en el espacio de direcciones virtual de un proceso.</div>
</div>
<div class="paragraph">
<p>En lugar de eso el sistema operativo —asistido por la <strong>MMU</strong> (<em>Memory-Management Unit</em>)— proporciona a cada proceso un <strong>espacio de direcciones virtual</strong> que ofrece una «vista» privada de la memoria, similar a la que tendrían si cada uno de los procesos estuviera siendo ejecutando en solitario (véase la <a href="#espacio_direcciones_virtual_frente_físico">Figura 42</a>).
Es durante los accesos a la memoria principal en tiempo de ejecución, cuando estas <strong>direcciones virtuales</strong> son convertidas por la <strong>MMU</strong> en las <strong>direcciones físicas</strong>, con las que realmente se accede a la memoria.
El <strong>espacio de direcciones físico</strong> es el conjunto de direcciones físicas que corresponden a todas las direcciones virtuales de un <strong>espacio de direcciones virtual</strong> dado.</p>
</div>
<div class="paragraph">
<p>El mecanismo de protección descrito es una forma muy común de <strong>reubicación de las direcciones en tiempo de ejecución</strong>, que está presente en la mayor parte de los sistemas operativos de propósito general modernos.
Pero, a parte de la protección de la memoria, algunas otras características de dicho mecanismo son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Los procesos pueden ser cargados en cualquier zona libre de la memoria física e incluso movidos de una región a otra durante la ejecución de los procesos, puesto que la transformación de las <strong>direcciones virtuales</strong> en <strong>direcciones físicas</strong> se realiza durante la ejecución de cada instrucción.</p>
</li>
<li>
<p>El código generado por el compilador puede ser <strong>código absoluto</strong>, puesto que de antemano se sabe que todas las ubicaciones del espacio de direcciones virtual van a estar disponibles.</p>
<div class="paragraph">
<p>Lo común es que los programas se ubiquen en una dirección fija en la parte baja del espacio de direcciones virtual.
Por ejemplo, empezando en la dirección <code>0x00400000</code>, dejando libres los primeros 4 MiB del <strong>espacio de direcciones virtual</strong>.</p>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Los programas pueden ubicarse en cualquier lugar del <strong>especio de direcciones virtual</strong> pero no ocurre lo mismo con las <strong>librerías de enlace dinámico</strong>, cuya posible ubicación va a depender del espacio ocupado por el programa y por otras <strong>librerías de enlace dinámico</strong>.
Por tanto, como veremos en detalle más adelante, estas librerías deben ser reubicables en tiempo de carga.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>Se puede reducir el consumo de memoria principal compartiendo las regiones de memoria física asignadas al código y los datos de sólo lectura de los procesos de un mismo programa.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El código de un programa suele contener direcciones tanto para los saltos como para el acceso a los datos.
Al ubicar los programas en las mismas regiones de los espacios de direcciones virtuales de sus procesos, nos estamos asegurando de que el código en memoria de los procesos de un mismo programa es el mismo —pues todos usan las mismas direcciones virtuales absolutas— por lo que se puede compartir la memoria física que ocupan.</p>
</div>
</div>
<div class="sect2">
<h3 id="_enlazado_dinámico_y_librerías_compartidas">15.4. Enlazado dinámico y librerías compartidas</h3>
<div class="paragraph">
<p>Como hemos comentado anteriormente, fundamentalmente existen dos tipos de enlazado:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En el <strong>enlazado estático</strong>, las librerías del sistema y otros módulos son combinados por el enlazador para formar la imagen binaria del programa que es almacenada en disco.
Algunos sistemas operativos —como MS-DOS— sólo soportan este tipo de enlazado.</p>
</li>
<li>
<p>En el <strong>enlazado dinámico</strong>, éste se pospone hasta la carga o la ejecución_ (véase la <a href="#etapas_programas_de_usuario">Figura 41</a>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Generalmente el enlazado dinámico ocurre durante la carga del programa:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Durante la carga del ejecutable se comprueban las dependencias del mismo.
Éstas se almacenan en el mismo archivo en disco que dicho ejecutable.</p>
</li>
<li>
<p>Las librerías a enlazar se cargar y ubican en el espacio de direcciones virtual creado para el nuevo proceso.</p>
</li>
<li>
<p>Finalmente, las referencias del programa a las funciones de cada una de las librerías cargadas se actualizan con la dirección en memoria de las mismas.
Así la invocación de las funciones por parte del programa se puede realizar de forma transparente, como si siempre hubieran formado parte del mismo.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Cuando el enlazado se va a realizar en tiempo de ejecución se habla de <strong>enlazado dinámico con carga diferida</strong>.
En ese caso el procedimiento es el siguiente:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Durante el enlazado estático del ejecutable se pone un <em>stub</em> a cada referencia a alguna función de la librería que va a ser enlazada dinámicamente.</p>
</li>
<li>
<p>Si durante la ejecución del programa alguna de dichas funciones es invocada, se ejecuta el <em>stub</em>.
El <em>stub</em> es una pequeña pieza de código que sabe como cargar la librería, si no ha sido cargada previamente, y como localizar la función adecuada en la misma.</p>
</li>
<li>
<p>Finalmente, el <em>stub</em> se sustituye a sí mismo con la dirección de la función y la invoca.
Esto permite que la siguiente ejecución de la función no incurra en ningún coste adicional.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Sin esta habilidad, cada programa en el sistema debería tener, por ejemplo, una copia de la librería del sistema incluida en su ejecutable.
Esto significaría un desperdicio de espacio libre en disco y de memoria principal.
Además, este esquema facilita la actualización de las librerías, puesto que los programas pueden utilizar directamente las versiones actualizadas sin necesidad de volver a ser enlazados.</p>
</div>
<div class="sect3">
<h4 id="_reubicación_de_las_direcciones_2">15.4.1. Reubicación de las direcciones</h4>
<div class="paragraph">
<p>Durante la compilación de una <strong>librería dinámica</strong> no se conoce la región que va a ocupar, dentro de los espacios de direcciones virtuales de los distintos procesos que la van a utilizar, por lo que es necesario generar <strong>código reubicable</strong>.</p>
</div>
<div class="paragraph">
<p>Atendiendo a lo visto en <a href="#_reubicación_en_tiempo_de_carga">Apartado 15.2.2</a> existen fundamentalmente dos estrategias:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>El compilador puede generar <strong>código independiente de la posición</strong> (PIC).
Esto permite reducir el consumo de memoria principal compartiendo las regiones de memoria física asignadas al código de una misma librería en los distintos procesos que la utilizan, pues en todas el código será exactamente el mismo.</p>
</li>
<li>
<p>En los sistemas operativos donde no se usa código PIC, el compilador debe generar código reubicable con <strong>tablas de reubicación</strong>, para que la reubicación de las direcciones virtuales se haga en tiempo de carga.
Esto aumenta el tiempo de carga de las librerías y sólo permite que compartan memoria física partes de la librería que sigan siendo iguales tras la reubicación de las direcciones.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_librerías_compartidas">15.4.2. Librerías compartidas</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Habitualmente las librerías incluyen información acerca de su versión.
Esta información puede ser utilizada para evitar que los programas se ejecuten con versiones incompatibles de las mismas, o para permitir que haya más de una versión de cada librería en el sistema.
Así los viejos programas se pueden ejecutar con las viejas versiones de las las librerías —o con versiones actualizadas pero compatibles— mientras los nuevos programas se ejecutan con las versiones más recientes e incompatibles con los viejos programas.</p>
</div>
<div class="paragraph">
<p>A este sistema se lo conoce como <strong>librerías compartidas</strong>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_asignación_contigua_de_memoria">15.5. Asignación contigua de memoria</h3>
<div class="paragraph">
<p>Como vimos en el <a href="#_protección_de_la_memoria">Apartado 7.3</a>, la memoria principal debe acomodar tanto el sistema operativo como a los diferentes procesos de los usuarios.</p>
</div>
<div class="paragraph">
<p>Normalmente queremos tener varios procesos en la memoria al mismo tiempo.
Por tanto, necesitamos considerar de que formas debemos asignar la memoria disponible a los procesos para que puedan ser cargados en ella.
En este apartado estudiaremos la técnica más simple, denominada <strong>asignación contigua de memoria</strong>.
Mientras que en capítulos posteriores vemos técnicas más avanzadas de hacer esta asignación.</p>
</div>
<div class="paragraph">
<p>En la <strong>asignación contigua de memoria</strong> a cada proceso se le asigna una única sección de memoria contigua.
Esto se puede hacer mediante <strong>particionado fijo</strong> o <strong>particionado dinámico</strong></p>
</div>
<div class="sect3">
<h4 id="_particionado_fijo">15.5.1. Particionado fijo</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El <strong>particionado fijo</strong> la memoria se divide en varias secciones de tamaño fijo, cada una de las cuales contiene un proceso.
Cuando un proceso termina, se carga uno nuevo de la cola de entrada en la partición libre.</p>
</div>
<div class="paragraph">
<p>Este método fue utilizado originalmente por el <a href="https://en.wikipedia.org/wiki/OS/360_and_successors">IBM OS/360</a>, pero ya no se utiliza</p>
</div>
</div>
<div class="sect3">
<h4 id="_particionado_dinámico">15.5.2. Particionado dinámico</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El <strong>particionado dinámico</strong> es una generalización del anterior:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>El sistema operativo mantiene una tabla indicando que partes de la memoria están libres y cuales ocupadas.
Inicialmente toda la memoria está libre por lo que es considerada como un gran hueco de memoria disponible.</p>
</li>
<li>
<p>Cuando un proceso llega y necesita memoria, se le busca un hueco lo suficientemente grande para alojarlo.
Si se encuentra, sólo se le asigna el espacio necesario, que es
marcado como ocupado.
El resto sigue siendo un hueco libre, aunque de menor tamaño.</p>
</li>
<li>
<p>Si un proceso termina y se crean dos huecos adyacentes, se funden en uno solo.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>El <strong>particionado dinámico</strong> se utilizaba fundamentalmente en <strong>sistemas de procesamiento por lotes</strong> y <strong>multiprogramados</strong>.
En este último caso, el sistema operativo tenía una <strong>cola de entrada</strong> ordenada por el <strong>planificador de largo plazo</strong> y la recorría asignando memoria a los procesos, hasta que no quedara
ningún hueco libre con tamaño suficiente para alojar al siguiente en la cola.
Entonces el sistema operativo podía esperar hasta que algunos procesos terminarán y hubiera un hueco lo suficientemente grande en la memoria, para el siguiente proceso, o podía seguir buscando en la cola de entrada procesos de menores requerimientos, aunque para ello tuviera que saltarse algunos procesos.</p>
</div>
<div class="paragraph">
<p>En general, en un momento dado el sistema operativo, debe satisfacer una petición de tamaño <em>N</em> con una lista de huecos libres de tamaño variable.
Esto no es más que un caso particular del problema clásico de la
asignación dinámica de almacenamiento, para el cual hay diversas soluciones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En el <strong>primer ajuste</strong> se escoge el primer hueco lo suficientemente grande como para satisfacer la petición.
La búsqueda puede ser desde el principio de la lista o desde donde ha terminado la búsqueda anterior.</p>
</li>
<li>
<p>En el <strong>mejor ajuste</strong> se escoge el hueco más pequeño que sea lo suficientemente grande para satisfacer la petición.
Indudablemente esto obliga a recorrer la lista de huecos completa o a tenerla ordenada por tamaño.</p>
</li>
<li>
<p>En el <strong>peor ajuste</strong> se escoge el hueco más grande.
Igualmente obliga a buscar en toda la lista de huecos o a tenerla ordenada por tamaño.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Para evaluar que estrategia es la mejor, se han realizado algunas simulaciones con los siguientes resultados:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>El <strong>primer y el mejor ajuste</strong> son mejores que el peor ajuste en términos de menor tiempo y mayor aprovechamiento del espacio de almacenamiento.</p>
</li>
<li>
<p>Si comparamos el <strong>primer y el mejor ajuste</strong> ninguno de ellos destaca sobre el otro en lo que a mejor aprovechamiento del espacio se refiere.</p>
</li>
<li>
<p>El <strong>primer ajuste</strong> es normalmente más rápido que el <strong>mejor ajuste</strong>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_fragmentación">15.6. Fragmentación</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Las estrategias de asignación de espacio de almacenamiento generalmente sufren de problemas de <strong>fragmentación</strong>.
Vamos a comentar brevemente como afecta la <strong>fragmentación</strong> a la <strong>asignación contigua de memoria</strong>.</p>
</div>
<div class="sect3">
<h4 id="_fragmentación_externa">15.6.1. Fragmentación externa</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>La <strong>fragmentación externa</strong> ocurre cuando hay suficiente espacio libre para satisfacer una petición, pero el espacio no es contiguo.
Es decir, el espacio de almacenamiento está fraccionado en un gran número de huecos de pequeño tamaño:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Afecta tanto a la estrategia del <strong>primer</strong> como del <strong>mejor ajuste</strong>. Siendo el primero mejor en algunos sistemas y el segundo mejor en otros.</p>
</li>
<li>
<p>Algunos análisis estadísticos realizados con el <strong>primer ajuste</strong> revelan que incluso con algunas optimizaciones, con \$N\$ bloques asignados se pierden \$0,5N\$ por <strong>fragmentación externa</strong> —es decir, un tercio de toda la memoria no es utilizable—.
A esto se lo conoce como la regla del 50%.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Existen diversas soluciones a este problema:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Utilizar técnicas de <strong>compactación</strong>, lo que consiste en mover los procesos para que toda la memoria libre quede en un único hueco de gran tamaño.
Sin embargo, esto puede ser muy caro en términos de tiempo y sólo puede ser realizado cuando la <strong>asignación de direcciones absolutas se realiza en tiempo de ejecución</strong>.</p>
</li>
<li>
<p>La otra solución es permitir que el <strong>espacio de direcciones físico</strong> de un proceso no sea contiguo.
Es decir, que la memoria puede ser asignada a un proceso independientemente de
donde esté disponible.
Existen dos técnicas complementarias que utilizan ésta solución: la paginación
(véase el <a href="#_paginación">Capítulo 16</a>) y la <a href="https://es.wikipedia.org/wiki/Segmentaci%C3%B3n_de_memoria">segmentación</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_fragmentación_interna">15.6.2. Fragmentación interna</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>La <strong>fragmentación interna</strong> se origina por la diferencia entre el espacio solicitado y el espacio finalmente asignado.</p>
</div>
<div class="paragraph">
<p>Supongamos un hueco de espacio libre de 12987 bytes que se va a usar para satisfacer una petición de 12985 bytes.
Esto genera un hueco de 2 bytes, pero la cantidad de información que debemos
guardar en la lista de huecos para saber que dicho hueco está ahí, es mucho mayor que el tamaño del hueco en sí mismo.
Por lo tanto, no nos interesa tener huecos de tamaño arbitrario.</p>
</div>
<div class="paragraph">
<p>La solución más común es dividir la memoria física en unidades de tamaño fijo y asignarla en múltiplos del tamaño de dichos bloques.
Esto hace que, en general, se asigne más memoria de la que realmente se ha solicitado y, por tanto, de la que realmente los procesos van a utilizar.
A esto se lo denomina <strong>fragmentación interna</strong>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_intercambio">15.7. Intercambio</h3>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>Un proceso debe estar en la memoria para ser ejecutado, pero en algunos sistemas operativos un proceso puede ser sacado de la memoria y copiado a un almacenamiento de respaldo de forma temporal —generalmente un dispositivo de almacenamiento secundario, como un disco— y en algún momento volver a ser traído a la memoria para continuar su ejecución.
Al procedimiento descrito se lo denomina <strong>intercambio</strong> o <strong><em>swapping</em></strong>.</p>
</div>
<div class="sect3">
<h4 id="_implementación">15.7.1. Implementación</h4>
<div class="paragraph">
<p>El <strong>intercambio</strong> se puede implementar de la siguiente manera:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>La <strong>cola de preparados</strong> contiene todos los procesos que esperan para ser ejecutados en la CPU.</p>
</li>
<li>
<p>Cuando el <strong>planificador de la CPU</strong> decide ejecutar un proceso, llama al <strong>asignador</strong>.</p>
</li>
<li>
<p>El <strong>asignador</strong> comprueba si el siguiente proceso que debe ser ejecutado está en la memoria.
Si no lo está y no hay memoria libre, el <strong>asignador</strong> hace que el <strong>gestor de la memoria</strong> intercambie el proceso con alguno de los que si lo está.</p>
</li>
<li>
<p>Finalmente, el <strong>asignador</strong> ejecuta el resto del cambio de contexto (véase el <a href="#_cambio_de_contexto">Apartado 9.6</a>) para entregar la CPU al proceso seleccionado.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Por ejemplo, si a un sistema con <strong>planificación de CPU</strong> basado en prioridad llega a la <strong>cola de preparados</strong> un proceso de alta prioridad, el <strong>gestor de memoria</strong> intercambia algunos procesos de baja prioridad con el de alta prioridad y ejecuta este último.
Cuando el proceso de alta prioridad termina, los de baja prioridad pueden ser intercambiados para continuar su ejecución.</p>
</div>
</div>
<div class="sect3">
<h4 id="_limitaciones">15.7.2. Limitaciones</h4>
<div class="paragraph">
<p>Sin embargo el <strong>intercambio</strong> presenta algunas limitaciones importantes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Si un sistema <strong>reubica las direcciones en tiempo de compilación o carga</strong>, el
proceso sólo puede ser intercambiado en la misma región de la memoria.
Si embargo, si se utiliza <strong>reubicación en tiempo de ejecución</strong>, entonces el proceso puede ser intercambiado en cualquier región de la memoria, puesto que las <strong>direcciones físicas</strong> son calculadas durante la ejecución.</p>
</li>
<li>
<p>El <strong>tiempo de cambio de contexto</strong> en un sistema con <strong>intercambio</strong> puede ser mucho mayor, puesto que incluye el tiempo que se tarda en hacer el intercambio.
La mayor parte del tiempo de intercambio es el tiempo de transferencia con el disco, que puede ser de varios cientos de milisegundos, incluso utilizando los discos más rápidos.
Esto afecta al <strong>tiempo de cuanto</strong> que siempre debe ser mucho mayor que el tiempo de <strong>cambio de contexto</strong>.</p>
</li>
<li>
<p>Un proceso podría disponer de un espacio en memoria de 120 MiB pero estar utilizando sólo 2 MiB.
Por tanto, es interesante que el sistema operativo conozca con exactitud la memoria utilizada por el proceso —y no la que podría estar utilizando como máximo— para reducir el tiempo de transferencia de los datos al disco durante el intercambio.</p>
<div class="paragraph">
<p>Para eso, el sistema operativo proporciona llamadas al sistema con las que un proceso con requerimientos dinámicos de memoria puede informar del cambio en su necesidad de memoria.
Por ejemplo, los sistemas operativos modernos proporcionan llamadas al sistema para reservar y liberar memoria —como <a href="https://en.cppreference.com/w/c/memory/malloc">malloc()</a> y <a href="https://en.cppreference.com/w/c/memory/free">free()</a> en los sistemas POSIX— gracias a las que el sistema conoce las necesidades reales de los procesos.</p>
</div>
</li>
<li>
<p>El <strong>intercambio</strong> presenta dificultades cuando el proceso que va a ser sacado de la memoria está esperando por una operación de E/S que accede a la memoria del proceso para leer o escribir datos en ella.
La soluciones podrían ser:</p>
<div class="ulist">
<ul>
<li>
<p>No intercambiar procesos con operaciones de E/S síncronas o asíncronas pendientes.</p>
</li>
<li>
<p>Utilizar búferes del sistema operativo en las operaciones de E/S.
Por ejemplo, en una operación <strong>write</strong> a un archivo, el sistema operativo copiaría primero los datos a un búfer interno y luego ordenaría la escritura de esos datos.
Así el proceso podría ser intercambiado sin problemas.
Las transferencias entre los búferes del sistema y la memoria de los procesos serían realizadas, por el sistema operativo, solo cuando los procesos residen en la memoria.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Debido fundamentalmente a que el tiempo de intercambio es muy alto, no se utiliza el intercambio estándar en los sistemas operativos actuales.
Lo que si podemos encontrar en muchos sistemas son versiones modificadas de este mecanismo.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, en muchas versiones antiguas de UNIX y en los sistemas modernos, el intercambio permanece desactivado y solo se activa cuando la cantidad de memoria usada supera cierto límite.
Además, en los sistemas actuales no se intercambian procesos completos sino las porciones menos usadas de cada proceso, como veremos en el <a href="#_memoria_virtual">Capítulo 17</a>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_paginación">16. Paginación</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>22 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>La traducción entre direcciones virtuales y físicas puede realizarse de diversas maneras.
La forma más extendida es la <strong>paginación</strong>, que no es sino un esquema de gestión de la memoria que permite que el espacio de direcciones físico de un proceso no sea continuo, evitando el problema de la <strong>fragmentación externa</strong>.</p>
</div>
<div class="sect2">
<h3 id="_método_básico">16.1. Método básico</h3>
<div class="paragraph">
<p>En la paginación la memoria física se divide en bloques de tamaño fijo denominados <strong>marcos</strong>, mientras que el espacio de direcciones virtual se divide en bloques del mismo tamaño que los marcos, denominados <strong>páginas</strong>.
Cuando un proceso va a ser ejecutado, sus páginas son cargadas desde el almacenamiento secundario en marcos libres de la memoria física.</p>
</div>
<div id="paginación" class="imageblock">
<div class="content">
<img src="C16-paginación/media/paginación.svg" alt="paginación">
</div>
<div class="title">Figura 43. Soporte del hardware para la paginación.</div>
</div>
<div class="paragraph">
<p>La paginación es una forma de <strong>reubicación de las direcciones en tiempo de ejecución</strong> donde la transformación de las direcciones virtuales en direcciones físicas se realiza de la siguiente manera (véase la <a href="#paginación">Figura 43</a>):</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Cada dirección virtual generada por la CPU es divida en dos partes: un <strong>número de página</strong> \$p\$ y un <strong>desplazamiento</strong> \$d\$.</p>
</li>
<li>
<p>El <strong>número de página</strong> es utilizado por la MMU para indexar la <strong>tabla de páginas</strong>, que contiene el <strong>número de marco</strong> \$f\$ de cada <strong>página</strong> en la memoria física.</p>
</li>
<li>
<p>El <strong>número de marco</strong> \$f\$ es combinado con el <strong>desplazamiento</strong> \$d\$ para generar la dirección física que va a ser enviada por el bus de direcciones hacia la memoria.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>El tamaño de las <strong>páginas</strong> —y el de los <strong>marcos</strong>— viene definido por el hardware y normalmente es un número entero potencia de 2 que puede variar entre 512 bytes y 16 MiB, dependiendo de la arquitectura.
Es decir, si el espacio de direcciones es de \$2^m\$ y el tamaño de página es de \$2^n\$, los \$m - n\$ bits de mayor orden de las direcciones virtuales indican el <strong>número de página</strong>, mientras que los \$n\$ bits de menor orden indican el <strong>desplazamiento</strong> (véase la <a href="#dirección_virtual_paginación">Figura 44</a>).</p>
</div>
<div id="dirección_virtual_paginación" class="imageblock">
<div class="content">
<img src="C16-paginación/media/dirección_virtual_paginación.svg" alt="dirección virtual paginación">
</div>
<div class="title">Figura 44. Descomposición de las direcciones virtuales en paginación.</div>
</div>
<div class="paragraph">
<p>Por ejemplo, en muchos sistemas operativos el tamaño de página es de 4 KiB, por lo que el desplazamiento \$n\$ necesita:</p>
</div>
<div class="stemblock">
<div class="content">
\$n = log_2 4096 = 12\ text{bits}\$
</div>
</div>
<div class="paragraph">
<p>Si las direcciones virtuales son de 32 bits, eso deja para el número de página \$p\$:</p>
</div>
<div class="stemblock">
<div class="content">
\$p = 32 - 12 = 20\ text{bits}\$
</div>
</div>
<div class="paragraph">
<p>por lo que el espacio de direcciones virtual tiene \$2^20\$ páginas —es decir, 1.048.576 páginas—.</p>
</div>
<div class="sect3">
<h4 id="_desde_el_punto_de_vista_de_los_procesos">16.1.1. Desde el punto de vista de los procesos</h4>
<div class="paragraph">
<p>Cada <strong>página</strong> de un proceso requiere un <strong>marco</strong>.
Por tanto, cuando un proceso llega al sistema:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Si el proceso requiere \$n\$ <strong>páginas</strong>, el sistema operativo debe escoger \$n\$ <strong>marcos</strong>.
Estos <strong>marcos</strong> son tomados de la <strong>lista de marcos libres</strong> que debe mantener el sistema.
Puesto que son escogidos de allí donde los haya libres, el <strong>espacio de direcciones físico</strong> puede no ser contiguo, aunque los procesos vean un <strong>espacio de direcciones virtual</strong> contiguo.</p>
</li>
<li>
<p>Los <strong>marcos</strong> seleccionados son asignados al proceso y cada <strong>página</strong> del proceso es cargada en uno de dichos <strong>marcos</strong>.</p>
</li>
<li>
<p>La <strong>tabla de páginas</strong> es actualizada de manera que en la entrada de cada <strong>página</strong> del proceso se pone el número de <strong>marco</strong> correspondiente.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Un aspecto importante de la paginación es la diferencia entre como ven los procesos la memoria y como es realmente la memoria física.
Cada proceso ve la memoria como un espacio único que lo contiene sólo a él.
Sin embargo, la realidad es que el programa está disperso por la memoria física, que además puede almacenar a otros programas.
Esto es posible porque en cada momento la <strong>tabla de páginas</strong> sólo contiene las <strong>páginas</strong> del proceso en ejecución en la CPU.</p>
</div>
</div>
<div class="sect3">
<h4 id="_desde_el_punto_de_vista_del_sistema_operativo">16.1.2. Desde el punto de vista del sistema operativo</h4>
<div class="paragraph">
<p>Puesto que el sistema operativo es quién gestiona la memoria física, éste debe saber:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Que <strong>marcos</strong> están asignados y a que <strong>página</strong> de que proceso o procesos.</p>
</li>
<li>
<p>Que <strong>marcos</strong> están disponibles.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Toda esta información generalmente se guarda en una estructura denominada la <strong>tabla de marcos</strong>, que tiene una entrada por cada <strong>marco</strong> de la memoria física.</p>
</div>
<div class="paragraph">
<p>Además, el sistema operativo debe mantener una copia de la <strong>tabla de páginas</strong> para cada proceso en el <strong>PCB</strong>, igual que mantiene una copia del contador de programa y del contenido de los registros de la CPU.
Esta copia es utilizada:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Por el <strong>asignador</strong> para sustituir la <strong>tabla de páginas</strong> usada por la CPU cuando realiza un <strong>cambio de contexto</strong>.
Por lo tanto, el uso de la paginación incrementa el tiempo del cambio de contexto.</p>
</li>
<li>
<p>Para la traducción manual de direcciones virtuales en físicas.
Por ejemplo, cuando un proceso realiza una llamada al sistema para realizar una operación de E/S y proporciona una dirección como parámetro, dicha dirección debe ser traducida manualmente para producir la dirección física correspondiente, que será comunicada al hardware para realizar la operación.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_tamaño_de_las_páginas">16.1.3. Tamaño de las páginas</h4>
<div class="paragraph">
<p>Una decisión de diseño importante es escoger el tamaño de las <strong>páginas</strong> adecuado:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Con <strong>páginas</strong> más pequeñas esperamos tener menos <strong>fragmentación interna</strong>.</p>
</li>
<li>
<p>Con páginas más grande se pierde menos espacio en la <strong>tabla de páginas</strong>.
No olvidemos que cuanto más pequeñas son las <strong>páginas</strong>, más <strong>páginas</strong> son necesarias y, por tanto, más entradas en la <strong>tabla de páginas</strong> se necesitan.
Además, la E/S es más eficiente cuanto más datos son transferidos de cada vez.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Los tamaños de <strong>páginas</strong> típicos son 4 y 8 KiB.
En un sistema de 32 bits con páginas de 4 KiB —como del que hablamos antes— el espacio de direcciones virtual tiene 1.048.576 páginas.
Si se utilizan 4 bytes para cada entrada de la <strong>tabla de páginas</strong> —aunque esto también puede variar— eso significa que cada <strong>tabla de páginas</strong> ocupa 4 MiB de espacio.
Mientras que con <strong>páginas</strong> de 8 KiB, la <strong>tabla de páginas</strong> ocuparía 2 MiB de espacios.</p>
</div>
<div class="paragraph">
<p>También significa que si los 4 bytes de la <strong>tabla de páginas</strong> se utilizan para guardar únicamente el <strong>número de marco</strong>, cada entrada puede direccionar a uno de \$2^32\$ —o 4 GiB— <strong>marcos</strong> de la memoria física.
Si el tamaño de cada <strong>marco</strong> es de 4 KiB —dado que debe coincidir con el tamaño de las páginas— podemos determinar que el sistema es capaz de direccionar \$2^44\$ bytes —o 16 TiB— de memoria física, aunque el espacio de direcciones virtual de cada proceso solo le da acceso a un máximo de 4 GiB.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_soporte_hardware_de_la_tabla_de_páginas">16.2. Soporte hardware de la tabla de páginas</h3>
<div class="paragraph">
<p>La implementación en hardware de la <strong>tabla de páginas</strong> puede realizarse de diversas maneras.</p>
</div>
<div class="sect3">
<h4 id="_almacenada_en_registros_de_la_cpu">16.2.1. Almacenada en registros de la CPU</h4>
<div class="paragraph">
<p>La <strong>tabla de páginas</strong> del proceso actual en la CPU puede alojarse dentro de la propia CPU, en unos registros destinados a tal fin.</p>
</div>
<div class="paragraph">
<p>Debido a la velocidad de los registros de la CPU, la implementación en registros es la más eficiente.
Sin embargo, solo puede ser utilizado para <strong>tablas de páginas</strong> razonablemente pequeñas, ya que alojar tablas de más de 256 entradas en registros es muy costoso.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, el DEC <a href="https://es.wikipedia.org/wiki/PDP-11">PDP-11</a> —para el que se diseño el primer UNIX— es un ejemplo de sistema con esta implementación.
Utilizaba un espacio de direcciones de 16 bits y un tamaño de <strong>páginas</strong> de 8 KiB, por lo que sólo necesitaba 8 registros dedicados para alojar toda la <strong>tabla de páginas</strong>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_almacenada_en_memoria">16.2.2. Almacenada en memoria</h4>
<div class="paragraph">
<p>La otra opción es alojar la <strong>tabla de páginas</strong> del proceso actual en la memoria, normalmente en un formato definido por la CPU.</p>
</div>
<div class="paragraph">
<p>En los sistemas modernos se utilizan <strong>tablas de páginas</strong> de un millón de entradas o más, que difícilmente pueden alojarse en registros dentro de la CPU.
Por eso, los sistemas actuales almacenan la <strong>tabla de páginas</strong> del proceso actualmente en ejecución, en la memoria.
Eso permite disponer de <strong>tablas de páginas</strong> de gran tamaño, aunque a costa de necesitar dos accesos a la memoria física por cada acceso a una dirección virtual.</p>
</div>
<div class="paragraph">
<p>Para que la MMU pueda conocer la ubicación de la <strong>tabla de páginas</strong> durante la traducción de las direcciones, la CPU debe disponer de un registro —el <strong>PTBR</strong> (<em>Page-Table Base Register</em>)— donde se guarda la dirección de la <strong>tabla de páginas</strong> actual.</p>
</div>
<div class="paragraph">
<p>Además, esto tiene la ventaja de que el <strong>cambio de contexto</strong> es más rápido —respecto al uso de registros para almacenar la tabla de páginas— puesto que sólo es necesario cargar un único registro más —el <strong>PTBR</strong>— durante el mismo.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tlb">16.2.3. TLB</h4>
<div class="paragraph">
<p>La solución al retraso originado por el acceso a la tabla de páginas, cuando ésta está en la
memoria, pasa por que el sistema disponga de una pequeña caché de traducciones en hardware llamada <strong>TLB</strong> (<em>Translation Look-aside Buffer</em>).</p>
</div>
<div class="paragraph">
<p>La <strong>TLB</strong> es una memoria asociativa de alta velocidad.
Cada entrada de la <strong>TLB</strong> tiene dos partes: la <strong>clave</strong> —o etiqueta— y el valor.
Cuando a la <strong>TLB</strong> se le entrega un elemento, éste es comparado simultáneamente con todas las claves.
Si se produce alguna coincidencia, la memoria devuelve el valor de la entrada correspondiente.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Debido a la forma que tienen de operar, son rápidas pero muy caras de fabricar.
Por ello, el número de entradas es bajo, normalmente entre 64 y 1024.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_uso_básico_de_la_tlb">Uso básico de la TLB</h5>
<div class="paragraph">
<p>La <strong>TLB</strong> es utiliza con la <strong>tabla de páginas</strong> de la siguiente manera:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>La <strong>TLB</strong> contiene unas pocas entradas de la <strong>tabla de páginas</strong>.</p>
</li>
<li>
<p>Cuando la CPU genera una dirección virtual, el <strong>número de página</strong> es entregado a la <strong>TLB</strong>.
La <strong>TLB</strong> utiliza los números de páginas como <strong>clave</strong>, por lo que si hay alguna coincidencia, devolverá la entrada correspondiente de la <strong>tabla de páginas</strong>.</p>
</li>
<li>
<p>Si hay coincidencia, el <strong>número de marco</strong> es extraído de la entrada devuelta por la <strong>TLB</strong> y es utilizado para generar la dirección física.
Todo este proceso puede requerir un 10% más de tiempo que si no se hiciera la traducción de las direcciones.</p>
</li>
<li>
<p>Si no hay coincidencia, es necesario acceder a la <strong>tabla de páginas</strong> para obtener la entrada correspondiente directamente de ella.
Indudablemente, este acceso puede beneficiarse de la existencia de diferentes niveles de caché en el acceso a la memoria principal.</p>
</li>
<li>
<p>En este último caso, la entrada recuperada debe ser añadida a la <strong>TLB</strong>, por lo que si está llena, se debe seleccionar una para ser sustituida.
Los algoritmos de reemplazo utilizados van, desde elegir una aleatoriamente, hasta el <strong>LRU</strong> (<em>Least Recently Used</em>).</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_borrado_de_la_tlb_en_el_cambio_de_contexto">Borrado de la TLB en el cambio de contexto</h5>
<div class="paragraph">
<p>Una cuestión importante es qué ocurre con las <strong>TLB</strong> cuando el sistema operativo realiza un <strong>cambio de contexto</strong>.</p>
</div>
<div class="paragraph">
<p>En general, es necesario que el asignador realice un borrado de la <strong>TLB</strong>.
De lo contrario, el nuevo proceso podría utilizar las entradas de la <strong>tabla de páginas</strong> del viejo proceso, que estuvieran almacenadas en la <strong>TLB</strong>.
Sin embargo, un proceso no tiene porque utilizar todas las entradas de la <strong>TLB</strong>, por lo que sería mas interesante, no tener que borrar las entradas de procesos anteriores, mientras no sean necesarias, por si éstos vuelven a ser ejecutados en la CPU.</p>
</div>
<div class="paragraph">
<p>El borrado se puede evitar si cada entrada de la <strong>TLB</strong> tiene un <strong>ASID</strong> (<em>Address-Space Identification</em>), que no es más que un identificador único para cada proceso.
En este tipo de <strong>TLB</strong>, en la <strong>clave</strong> se buscan pares <strong>(número de página, ASID)</strong>, donde el primero proviene de la dirección virtual y el segundo es el <strong>ASID</strong> del proceso actual.
De esta forma, si el <strong>número de página</strong> coincide pero no el <strong>ASID</strong>, se produce un fallo de la <strong>TLB</strong>.
Ésto obliga a acceder a la <strong>tabla de páginas</strong> en memoria para recuperar la entrada, evitando que se lea por error la entrada de un proceso anterior.</p>
</div>
<div class="paragraph">
<p>Esta característica está presente en los procesadores <a href="https://es.wikipedia.org/wiki/DEC_Alpha">DEC Alpha</a>, <a href="https://es.wikipedia.org/wiki/MIPS_(procesador)">MIPS</a>  y <a href="https://es.wikipedia.org/wiki/UltraSPARC">Sun UltraSPARC</a>.
Entre 2005 y 2006 también comenzó a ser incluida en algunos procesadores de la familia x86, a través de las extensiones de virtualización Intel VT y AMD Pacifica.</p>
</div>
</div>
<div class="sect4">
<h5 id="_tiempos_de_acceso_a_la_memoria">Tiempos de acceso a la memoria</h5>
<div class="paragraph">
<p>El rendimiento de un sistema con paginación, está relacionado con el concepto de <strong>tiempo de acceso efectivo</strong> a la memoria \$T_(em)\$, que intenta estimar el tiempo que realmente se tarda en acceder a la memoria, teniendo en cuenta mecanismos del sistema operativo como el método de paginación o la existencia de <strong>TLB</strong>.</p>
</div>
<div class="paragraph">
<p>En muchos sistemas informáticos, el <strong>tiempo de acceso</strong> a la memoria física \$T_m\$ es de unos pocos nanosegundos.
Por lo tanto, en el método de básico de paginación el <strong>tiempo de acceso efectivo</strong> es el doble del <strong>tiempo de acceso</strong> a la memoria:</p>
</div>
<div class="stemblock">
<div class="content">
\$T_(em)=2T_m\$
</div>
</div>
<div class="paragraph">
<p>Obviamente, en métodos de paginación donde hagan falta más accesos para obtener finalmente el <strong>número de marco</strong>, el <strong>tiempo de acceso efectivo</strong> será mayor.</p>
</div>
<div class="paragraph">
<p>Supongamos que tenemos un sistema con <strong>TLB</strong> y que conocemos la probabilidad \$p\$ de que la entrada que consultamos esté en la <strong>TLB</strong>.
Entonces, el <strong>tiempo de acceso efectivo</strong> se podría calcular como la probabilidad \$(1-p)\$ de que la entrada no esté en la <strong>TLB</strong>, por el <strong>tiempo de acceso</strong> necesario, en ese caso \$2T_m\$, mas la probabilidad de que la entrada sí esté en la <strong>TLB</strong> \$p\$, por el <strong>tiempo de acceso</strong> \$T_m\$, porque solo hace falta acceder una vez a la memoria:</p>
</div>
<div class="stemblock">
<div class="content">
\$T_(em)=(1-p) 2T_m+pT_m=(2-p) T_m\$
</div>
</div>
<div class="paragraph">
<p>Como se puede observar, cuanto más se aproxima a 1 la probabilidad \$p\$ de que la entrada esté en la <strong>TLB</strong>, más cerca está \$T_(em)\$ de \$T_m\$.</p>
</div>
<div class="paragraph">
<p>Para mejorar esta probabilidad:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Las <strong>TLB</strong> permiten marcar algunas entradas como insustituibles.
Esto normalmente se hace con las entradas de las <strong>páginas</strong> del código y los datos del núcleo, ya que son páginas que se utilizan con muchísima frecuencia.</p>
</li>
<li>
<p>Si la MMU soporta páginas de mayor tamaño que el estándar, se utilizan para alojar el código y los datos del núcleo.
De esta forma se minimiza el número de entradas de la <strong>TLB</strong> que utilizan, con el fin de disponer de más entradas libres para los procesos en ejecución.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En la familia x86 el tamaño de página estándar es de 4 KiB, pero también se puede disponer de páginas de 4 MiB.
En x86-64 las páginas de gran tamaño son de 2 MiB, aunque algunos modelos también soportan páginas de 1 GiB.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_protección_de_la_memoria_2">16.3. Protección de la memoria</h3>
<div class="paragraph">
<p>La protección de las páginas se consigue mediante unos bits que indican las operaciones que se pueden realizar sobre ellas.
Normalmente, estos bits son almacenados en cada una de las entradas de la <strong>tabla de páginas</strong>.</p>
</div>
<div class="sect3">
<h4 id="_bits_de_protección">16.3.1. Bits de protección</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Los <strong>bits de protección</strong> pueden ser:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Solo lectura</strong>.</p>
</li>
<li>
<p><strong>Lectura&#8201;&#8212;&#8201;Escritura</strong>.
En algunos sistemas hay un bit específico para este permiso, mientras que en otros se utilizan bits separados, como: <strong>lectura</strong>, <strong>escritura</strong> y <strong>ejecución</strong>; que se pueden combinar libremente.</p>
</li>
<li>
<p><strong>Sólo ejecución</strong>.
Que no existen en todas las plataformas.
Por ejemplo, la familia x86 careció de esta característica hasta que AMD la incluyó en su arquitectura x86-64, lo que obligó a Intel a incluirla en las versiones más modernas de Pentium IV.
El bit —que para ser exacto indica <strong>no ejecución</strong>— fue introducido para evitar cierto tipo de ataques de seguridad.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Durante la traducción de las direcciones, la MMU comprueba que el tipo de acceso sea válido.
Si no lo es, se genera una excepción de violación de protección de memoria, dado que el acceso en un modo no autorizado se considera una instrucción privilegiada.
Normalmente, el sistema operativo responde a dicha excepción terminando el proceso que la generó.</p>
</div>
</div>
<div class="sect3">
<h4 id="_bit_de_válido">16.3.2. Bit de válido</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Además de los <strong>bits de protección</strong> comentados, se suele añadir a cada entrada un <strong>bit de válido</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cuando una <strong>página es válida</strong>, la pagina existe en el espacio de direcciones virtual del proceso.
Es decir, que la página se puede utilizar.
Otro término comúnmente utilizado, es que la página es <strong>legal</strong>.</p>
</li>
<li>
<p>Cuando la <strong>página es inválida</strong>, la página no existe en el espacio de direcciones virtual del proceso.
Es decir, que la página no se puede utilizar.
El término alternativo utilizado, es que la página es <strong>ilegal</strong>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Al igual que con los <strong>bit de protección</strong>, los intentos de acceso a una página ilegal generan una excepción.</p>
</div>
<div class="paragraph">
<p>El sistema operativo puede utilizar este bit para permitir o denegar cualquier tipo de acceso a una <strong>página</strong>.
Generalmente, porque no se le ha asignado un <strong>marco</strong> de memoria física, ya que esa página no está siendo utilizada por el proceso.</p>
</div>
<div id="bit_de_válido_en_la_tabla_de_páginas" class="imageblock">
<div class="content">
<img src="C16-paginación/media/bit_de_válido_en_la_tabla_de_páginas.svg" alt="bit de válido en la tabla de páginas">
</div>
<div class="title">Figura 45. Bit de válido en la tabla de páginas.</div>
</div>
<div class="paragraph">
<p>Por ejemplo, en la <a href="#bit_de_válido_en_la_tabla_de_páginas">Figura 45</a>, vemos el espacio de direcciones virtual y la <strong>tabla de páginas</strong> de un proceso de 5096 bytes en un sistema con <strong>páginas</strong> de 1 KiB.
Puesto que el proceso no ocupa todo el espacio de direcciones, sólo las direcciones de la 0 a la 5119 son válidas.
En dicho ejemplo, podemos apreciar varios fenómenos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Debido a la <strong>fragmentación interna</strong>, las direcciones de la 5097 a la 5119 son válidas, aunque el proceso solo ocupe hasta la 5096.
Es decir, se está asignando al proceso una porción de memoria que no necesita.</p>
</li>
<li>
<p>Solo las <strong>páginas</strong> con datos y código del proceso son válidas.
Mientras que todas las <strong>páginas</strong> con direcciones por encima de la 5119 están marcadas como ilegales.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>En general, los procesos sólo necesitan una porción muy pequeña de su espacio de direcciones virtual.
Por ejemplo, en un sistema de 32 bits, muy pocos procesos necesitan los 3 GiB disponibles como máximo para cada proceso —el 1 GiB restante suele estar ocupado por el núcleo del sistema—.
Utilizando el <strong>bit de válido</strong>, el sistema operativo no tiene que asignar <strong>marcos</strong> a <strong>páginas</strong> no utilizadas por el proceso, ahorrando mucha memoria.</p>
</div>
<div class="paragraph">
<p>En el <a href="#_tamaño_de_las_páginas">Apartado 16.1.3</a>, vimos que el tamaño de la <strong>tabla de páginas</strong> se puede calcular como el número máximo de páginas del espacio de direcciones virtual multiplicado por el tamaño de cada entrada de la tabla.
Así, en un sistema de 32 bits con páginas de 4 KiB y 4 bytes por entrada, se necesitan 4 MiB de memoria para almacenar la <strong>tabla de páginas</strong>.
Como un proceso suele ocupar muy poco de su espacio de direcciones virtual, suele ser un desperdicio de memoria crear y almacenar una <strong>tabla de páginas</strong> completa, con una entrada para cada <strong>página</strong> del espacio de direcciones.</p>
</div>
<div class="paragraph">
<p>Para evítarlo, en algunas CPU existe el registro <strong>PTLR</strong> (<em>Page-Table Length Register</em>) que se utiliza para indicar el tamaño actual de la <strong>tabla de páginas</strong>.
Este valor es comparado por la MMU, durante la traducción de las direcciones virtuales, con el <strong>número de página</strong> de cada dirección virtual, de manera que las <strong>páginas</strong> con entradas más allá de la última almacenada en la tabla son consideradas ilegales.</p>
</div>
<div id="proceso_en_memoria_disperso" class="imageblock">
<div class="content">
<img src="C16-paginación/media/proceso_en_memoria.svg" alt="proceso en memoria">
</div>
<div class="title">Figura 46. Anatomía de un proceso en memoria.</div>
</div>
<div class="paragraph">
<p>En realidad, el registro <strong>PTLR</strong> no es de mucha utilidad en los sistemas operativos modernos porque, tal y como vimos en el <a href="#_el_proceso">Apartado 9.1</a>, lo más común es que los procesos tengan un espacio de direcciones virtual disperso como el de la <a href="#proceso_en_memoria_disperso">Figura 46</a>.
En ella, podemos observar, como el sistema operativo ubica los diferentes componentes del proceso de una forma particular dentro del espacio de direcciones virtual.
Este esquema permite que tanto el <strong>montón</strong> —a través del mecanismo de asignación dinámica de memoria—, como la <strong>pila</strong> puedan extenderse —en base a las necesidades de memoria que tenga el proceso—, sobre la región de memoria no ocupada.
Esa región también puede ser parcialmente ocupada por <strong>librerías de enlace dinámico</strong> o regiones de <strong>memoria compartida</strong>, si son necesarias durante la ejecución del proceso.</p>
</div>
<div class="paragraph">
<p>En cualquier caso, las <strong>páginas</strong> de la región no ocupada, forman parte del espacio de direcciones virtual, pero no necesitan tener asignado ningún <strong>marco</strong> de memoria física, en tanto en cuanto el proceso no las vaya a utilizar.
La falta de <strong>marco</strong> es indicada por el sistema operativo utilizando el <strong>bit de válido</strong> para denegar el acceso.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_páginas_compartidas">16.4. Páginas compartidas</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Una de las ventajas importantes de la paginación, es la posibilidad de compartir <strong>páginas</strong> entre procesos.
Para conseguir esto, basta con que las <strong>páginas compartidas</strong> de los distintos procesos tengan asignadas un mismo <strong>marco</strong>.
Esto permite, por ejemplo, que los procesos de un mismo programa puedan compartir las <strong>páginas</strong> de código o los datos de sólo lectura con el fin de ahorrar memoria.
También permite compartir las <strong>páginas</strong> de código de una librería compartida enlazada en diferentes procesos.</p>
</div>
<div class="paragraph">
<p>Compartir <strong>páginas</strong> no sólo permite ahorrar memoria, pues en los sistemas operativos modernos, la comunicación entre procesos mediante memoria compartida (véase el <a href="#_memoria_compartida">Capítulo 11</a>), se implementa mediante <strong>páginas compartidas</strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_paginación_jerárquica">16.5. Paginación jerárquica</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Al método básico de paginación, se lo conoce como <strong>tabla de páginas lineal</strong>.
Sin embargo, las CPU comúnmente, utilizan otras técnicas a la hora de estructurar la <strong>tabla de páginas</strong>.
Una de las más comunes es la <strong>paginación jerárquica</strong>, utilizada en los procesadores de la familia x86 y en ARM, entre otros.</p>
</div>
<div class="paragraph">
<p>La mayor parte de los sistemas modernos soportan el uso de espacios de direcciones de gran tamaño.
Por ejemplo, supongamos un sistema con un espacio de direcciones virtual de 32 bits:</p>
</div>
<table class="tableblock frame-none grid-none stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>tamaño del espacio de direcciones</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">= \$2^32\$ = 4 GiB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>tamaño de página</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">= \$2^12\$ = 4 KiB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>número de páginas</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">= \$2^32 / 2^12\$ = \$2^{32-12}\$ = \$2^20\$ = 1.048.576 entradas</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Es decir, que si el tamaño de cada entrada fuera de 4 bytes, la <strong>tabla de páginas</strong> de un proceso podría ocupar hasta 4 MiB; que debe ser alojada en una región continúa del espacio de direcciones físico, por lo que podría darse el caso de que en algún momento no hubiera un hueco contiguo lo suficientemente grande.
Una forma de resolver este problema es partir la <strong>tabla de páginas</strong>, de manera que no sea necesario asignarle memoria de forma contigua.</p>
</div>
<div class="sect3">
<h4 id="_paginación_jerárquica_de_dos_niveles">16.5.1. Paginación jerárquica de dos niveles</h4>
<div class="paragraph">
<p>La <strong>paginación jerárquica</strong> se basa en la idea de que un vector de gran tamaño puede ser mapeado en uno más pequeño, que a su vez, puede ser mapeado en un vector de menor tamaño.</p>
</div>
<div id="paginación_jerárquica" class="imageblock">
<div class="content">
<img src="C16-paginación/media/paginación_jerárquica.svg" alt="paginación jerárquica">
</div>
<div class="title">Figura 47. Esquema de paginación jerárquica de dos niveles.</div>
</div>
<div class="paragraph">
<p>Por ejemplo, si asumimos el caso anterior de un sistema con un espacio de direcciones de 32 bits y un tamaño de
página de 4 KiB, entonces podemos dividir la tabla de páginas de 1.048.576 entradas —4 MiB si cada entrada necesita 4 bytes— en 1024 porciones, cada una de las cuales cabría en un <strong>marco</strong> de 4 KiB.</p>
</div>
<div class="paragraph">
<p>Estos <strong>marcos</strong>, a su vez, pueden ser mapeados por 1024 entradas con las direcciones físicas de cada <strong>marco</strong>.
Si organizamos estas 1024 entradas en un vector lineal, obtendríamos una <strong>tabla de páginas externa</strong> de 4 KiB (véase la <a href="#paginación_jerárquica">Figura 47</a>).</p>
</div>
<div class="paragraph">
<p>Dado que 4 KiB es una cantidad de memoria muy pequeña, muchos sistemas operativos mantienen la <strong>tabla de páginas externa</strong> en la memoria mientras el proceso se está ejecutando.
Sin embargo, ahora la <strong>tabla de páginas</strong> está dividida en <strong>marcos</strong>, que no tienen porqué ser asignados de forma contigua en la memoria.
Incluso podrían ser intercambiados al disco, en caso de necesitar memoria libre.</p>
</div>
<div class="paragraph">
<p>Para tener dos niveles de 1024 entradas, solo es necesario dividir el <strong>número de página</strong> \$p\$ de la dirección virtual —que tenía \$2^20\$ bits— en dos <strong>números de página</strong> de \$2^10\$ bits cada uno:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="C16-paginación/media/dirección_virtual_paginación_jerárquica.svg" alt="dirección virtual paginación jerárquica">
</div>
</div>
<div class="paragraph">
<p>Este es el método utilizado por la familia de procesadores x86.</p>
</div>
<div class="paragraph">
<p>Otra variación de la <strong>paginación jerárquica de dos niveles</strong> es la utilizada por VAX.
Estos sistemas utilizaban un arquitectura de 32 bits con un tamaño de página de 512 bytes.
Las direcciones virtuales eran divididas de la siguiente manera:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="C16-paginación/media/dirección_virtual_vax.svg" alt="dirección virtual vax">
</div>
</div>
<div class="paragraph">
<p>El espacio de direcciones de un proceso estaba dividido en 3 secciones.
Los 2 bits de orden más alto \$s\$ de las direcciones virtuales se utilizaban para indicar la <strong>sección</strong>.
Cada <strong>sección</strong> estaba dividida en <strong>páginas</strong> de 512 bytes, por lo que los siguientes 21 bits de las direcciones virtuales \$p\$ eran utilizadas para seleccionar la <strong>página</strong> concreta.</p>
</div>
<div class="paragraph">
<p>Dividiendo el espacio de direcciones de esta manera, el sistema operativo podía mantener secciones sin utilizar mientras no fueran necesarias.
Esto era importante, puesto que la <strong>tabla de páginas</strong> de una
<strong>sección</strong> tenía un tamaño de 8 MiB.</p>
</div>
</div>
<div class="sect3">
<h4 id="_paginación_jerárquica_de_n_niveles">16.5.2. Paginación jerárquica de N niveles</h4>
<div class="paragraph">
<p>En general, en la <strong>paginación jerárquica</strong> de \$N\$ niveles el <strong>número de página</strong> \$p\$ de cada dirección virtual es dividido en \$N\$ números: \${ p_1, p_2, p_3, \ldots, p_N}\$, donde:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>\$p_1\$ se utiliza para indexar la <strong>tabla de páginas externa</strong> —también llamada <strong>directorio de páginas</strong> o <strong>tabla de páginas de nivel 0</strong>— cuya dirección conoce la CPU mediante el <strong>PTBR</strong>.
La entrada obtenida de esta manera, contiene la dirección en la memoria física de una porción de la <strong>tabla de páginas</strong> en el siguiente nivel —el nivel 1—.</p>
</li>
<li>
<p>\$p_2\$ se utiliza para indexar la <strong>tabla de páginas de nivel 1</strong>.
E, igualmente, la entrada así obtenida contiene la dirección en la memoria física de una porción de la <strong>tabla de páginas</strong> en el siguiente nivel —el nivel 2—.</p>
</li>
<li>
<p>El proceso continúa hasta que \$p_N\$, se utiliza para indexar la <strong>tabla de páginas de nivel N-1</strong>, con la que se obtiene el <strong>número de marco</strong> que es utilizado, finalmente, para generar la dirección física al combinarlo con el desplazamiento \$d\$ de la dirección virtual.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Como se puede ver, resolver una dirección virtual necesita tantos accesos a la memoria como niveles hay en la jerarquía.</p>
</div>
<div class="paragraph">
<p>Debido a que la traducción funciona desde las <strong>tablas de páginas</strong> de nivel superior —nivel 0— hacia las de nivel inferior —nivel \$N-1\$—, a esta estructura también se la conoce como <strong>tabla de páginas directa</strong>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Los procesadores <a href="https://es.wikipedia.org/wiki/DEC_Alpha">DEC Alpha</a> y <a href="https://es.wikipedia.org/wiki/MIPS_(procesador)">MIPS</a> utilizan una variante denominada <strong>tabla de páginas virtualizada</strong>.
En este esquema, el último nivel de la <strong>paginación jerárquica</strong>, aunque esté en marcos separados en el espacio de direcciones físico, se mapea de manera continua en el espacio de direcciones virtual del proceso.</p>
</div>
<div class="paragraph">
<p>Así, si la consulta a la <strong>TLB</strong> falla, se indexa la <strong>tabla de páginas</strong> directamente con direcciones virtuales usando el <strong>número de página</strong> completo.
Esta consulta conlleva la traducción de la dirección virtual de la entrada indexada, que puede estar en la <strong>TLB</strong>.
Si no es así, se pasa a recorrer la <strong>tabla de páginas</strong> desde el nivel 0 y usando direcciones físicas.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Existen algunos procesadores que utilizan más de dos niveles.
Por ejemplo, los procesadores x86-64 utilizan un esquema de 4 niveles de paginación.
Cada <strong>página</strong> es de 4 KiB —como en el resto de la familia x86— pero como cada entrada en la <strong>tabla de páginas</strong> es de 8 bytes —con el fin de poder almacenar direcciones de 64 bits— en cada una caben 512 entradas, por lo que los <strong>números de página</strong> de cada nivel necesitan 9 bits.
Eso significa que de las direcciones virtuales se utilizan actualmente 48 bits —resultado de multiplicar 4 niveles por 9 bits cada uno más 12 bits de desplazamiento—, aunque el limite de la arquitectura para las direcciones virtuales sea de 64 bits.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_memoria_virtual">17. Memoria virtual</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>1 horas y 5 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>La <strong>memoria virtual</strong> es una técnica que permite la ejecución de procesos sin que éstos tengan que ser cargados completamente en la memoria.</p>
</div>
<div class="paragraph">
<p>Los programas suelen tener partes de código que rara vez son ejecutadas.
Por ejemplo, las funciones para manejar condiciones de error que, aunque útiles, generalmente nunca son invocadas.
También es frecuente que se reserve más memoria para datos de lo que realmente es necesario.
Por ejemplo, muchos programadores tienen la costumbre, de hacer cosas tales como declarar un <em>array</em> de 65536 elementos, cuando realmente sólo necesitan 255.
Teniendo todo esto en cuenta, y con el fin de mejorar el aprovechamiento de la memoria, parece que sería interesante no tener que cargar todas las porciones de los procesos y que, aun así, pudieran ejecutarse.
Eso es exactamente lo que proporciona la <strong>memoria virtual</strong>.</p>
</div>
<div class="paragraph">
<p>La habilidad de ejecutar un proceso cargado parcialmente en memoria proporciona algunos beneficios importantes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Un programa nunca más estaría limitado por la cantidad de memoria disponible.</p>
<div class="paragraph">
<p>Es decir, los desarrolladores pueden escribir programas considerando que disponen de un espacio de direcciones virtual extremadamente grande, sin considerar la cantidad de memoria realmente disponible.
No debemos olvidar que sin memoria virtual, para que un proceso pueda ser ejecutado, debe estar completamente cargado en la memoria.</p>
</div>
</li>
<li>
<p>Puesto que cada programa ocupa menos memoria, más programas se pueden ejecutar al mismo tiempo; con el correspondiente incremento en el uso de la CPU y en el rendimiento del sistema, pero sin efectos negativos en el tiempo de respuesta y en el de ejecución.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El concepto de <strong>memoria virtual</strong> no debe confundirse con el de <strong>espacio de direcciones virtual</strong>.
Sin embargo están relacionados, puesto que el que exista separación entre la memoria física y la manera en la que los procesos perciben la memoria es un requisito para poder implementar la memoria virtual.</p>
</div>
<div class="sect2">
<h3 id="_paginación_bajo_demanda">17.1. Paginación bajo demanda</h3>
<div class="paragraph">
<p>La <strong>paginación bajo demanda</strong> es la técnica con la que frecuentemente se implementa la <strong>memoria virtual</strong> en los sistemas con paginación.</p>
</div>
<div class="paragraph">
<p>En la <strong>paginación bajo demanda</strong> las páginas individuales, en las que se dividen los espacios de direcciones virtuales de los diferentes procesos, pueden ser sacadas de la memoria de manera temporal y copiadas a un almacenamiento de respaldo, para posteriormente volver a ser traídas a la memoria cuando son necesitadas por su proceso.
A este proceso de guardado y recuperación de las páginas sobre el almacenamiento de respaldo se lo denomina <strong>intercambio</strong> o <strong><em>swapping</em></strong> y es llevado a cabo por un componente del sistema operativo denominado el <strong>paginador</strong>.</p>
</div>
<div class="paragraph">
<p>Para que se puedan cargar las páginas cuando son necesitadas por su proceso, hace falta que el <strong>paginador</strong> sepa cuándo lo son.
Eso requiere que el hardware proporcione algún tipo de soporte, por ejemplo, incorporando un <strong>bit de válido</strong> a la entrada de cada página en la tabla de páginas, que se utiliza de la siguiente manera:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cuando el <strong>bit de válido</strong> está a 1 la página es legal y está en la memoria.
Es decir, la página existe en el espacio de direcciones virtual del proceso y tiene asignado un marco de memoria física.</p>
</li>
<li>
<p>Cuando el <strong>bit de válido</strong> está a 0, pueden ocurrir varias cosas:</p>
<div class="ulist">
<ul>
<li>
<p>La página es legal pero está almacenada en disco y no en la memoria.</p>
</li>
<li>
<p>La página no es legal.
Es decir, no existe en el espacio de direcciones virtual del proceso.</p>
<div class="paragraph">
<p>Esto puede ser debido a que la página esté en un hueco del espacio de direcciones —en una región que no está siendo utilizada— por lo que el sistema operativo no le ha asignado espacio de almacenamiento ni en disco ni en la memoria.</p>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Si un proceso accede a una página legal, no ocurre nada y la instrucción se ejecuta con normalidad.
Pero si accede a una página marcada como inválida:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Al intentar acceder a la página, la MMU comprueba el bit de válido y genera una excepción de <strong>fallo de página</strong> al estar marcada como inválida.
Dicha excepción es capturada por el sistema operativo.</p>
</li>
<li>
<p>El sistema operativo comprueba en una tabla interna si la página es legal o no.
Es decir, si la página realmente no pertenece al espacio de direcciones virtual del proceso o si pertenece pero está almacenada en el disco.
Esta tabla interna suele almacenarse en el PCB del proceso como parte de la información de gestión de la memoria.</p>
</li>
<li>
<p>Si la página es ilegal, el proceso ha cometido un error y debe ser terminado.
En sistemas POSIX, por ejemplo, el sistema envía al proceso una señal de <strong>violación de segmento</strong> que lo obliga a terminar.</p>
</li>
<li>
<p>Si la página es legal, se carga desde el disco:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>El núcleo busca un marco de memoria libre que, por ejemplo, se puede escoger de la lista de marcos libres del sistema.</p>
</li>
<li>
<p>Se solicita una operación de disco para leer la página deseada en el marco asignado.</p>
<div class="paragraph">
<p>Puesto que no resulta eficiente mantener la CPU ocupada mientras la página es recuperada desde el disco, el sistema debe solicitar la lectura de la página y poner al proceso en estado <strong>esperando</strong>.</p>
</div>
</li>
<li>
<p>Cuando la lectura del disco haya terminado, se modifica la tabla interna, antes mencionada, y la tabla de páginas para indicar que la página está en la memoria.</p>
</li>
<li>
<p>Reiniciar la instrucción que fue interrumpida por la excepción.
Generalmente esto se hace colocando el proceso nuevamente en la <strong>cola de preparados</strong> y dejando que el <strong>asignador</strong> lo reinicie cuando sea escogido por el <strong>planificador</strong> de la CPU.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Un caso extremo de la paginación bajo demanda es la <strong>paginación bajo demanda pura</strong>.
En ella la ejecución de un proceso se inicia sin cargar ninguna página en la memoria.
Cuando el sistema operativo sitúa el contador de programa en la primera instrucción del proceso —que es una página no residente en memoria— se genera inmediatamente un <strong>fallo de página</strong>.
La página es cargada en la memoria —tal y como hemos descrito anteriormente— y el proceso continua ejecutándose, fallando cuando sea necesario con cada página que necesite y no esté cargada.
Las principales ventajas de la <strong>paginación bajo demanda pura</strong> son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Nunca se trae desde el disco una página que no sea necesaria.</p>
</li>
<li>
<p>El inicio de la ejecución de un proceso es mucho más rápido que si se cargara todo el proceso desde el principio.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_requerimientos_de_la_paginación_bajo_demanda">17.1.1. Requerimientos de la paginación bajo demanda</h4>
<div class="paragraph">
<p>Los requerimientos hardware para que un sistema operativo pueda soportar la <strong>paginación bajo demanda</strong> son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Tabla de páginas con habilidad para marcar entradas inválidas, ya sea utilizando un bit específico o con valores especiales en los bits de protección.</p>
</li>
<li>
<p>Disponibilidad de un dispositivo de almacenamiento secundario.</p>
<div class="paragraph">
<p>En este dispositivos se guardan las páginas que no están presentes en la memoria principal.
Normalmente se trata de un disco conocido como <strong>dispositivo de intercambio</strong>, mientras que la sección de disco utilizada concretamente para dicho propósito se conoce como <strong>espacio de intercambio</strong> o <strong><em>swap</em></strong>.</p>
</div>
</li>
<li>
<p>Posibilidad de reiniciar cualquier instrucción después de un fallo de página.</p>
<div class="paragraph">
<p>En la mayor parte de los casos esta funcionalidad es sencilla de conseguir.
Sin embargo, la mayor dificultad proviene de las instrucciones que pueden modificar diferentes posiciones de la memoria, como aquellas pensadas para mover bloques de bytes o palabras.
En el caso de que el bloque de origen o de destino atraviese un borde de página, la instrucción sería interrumpida cuando la operación solo haya sido realizada parcialmente.
Si además ambos bloques se superpusieran, no se podría reiniciar la instrucción completa.
Las posibles soluciones a este problema deben ser implementadas en la CPU.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_rendimiento_de_la_paginación_bajo_demanda">17.1.2. Rendimiento de la paginación bajo demanda</h4>
<div class="paragraph">
<p>Indudablemente, el rendimiento de un sistema con <strong>paginación bajo demanda</strong> se ve afectado por el <strong>número de fallos de páginas</strong>.
En el peor de los casos, en cada instrucción un proceso puede intentar acceder a una página distinta, empeorando notablemente el rendimiento.
Sin embargo, esto no ocurre puesto que los programas tienden a tener localidad de referencia (véase el <a href="#_hiperpaginación">Apartado 17.6</a>).</p>
</div>
<div class="sect4">
<h5 id="_tiempo_de_acceso_efectivo">Tiempo de acceso efectivo</h5>
<div class="paragraph">
<p>Como con la <strong>paginación</strong>, el rendimiento de un sistema con <strong>paginación bajo demanda</strong> también está relacionado con el concepto de <strong>tiempo de acceso efectivo</strong> a la memoria, que intenta estimar el tiempo que realmente se tarda en acceder a la memoria teniendo en cuenta mecanismos del sistema operativo.</p>
</div>
<div class="paragraph">
<p>Supongamos que conocemos la probabilidad \$p_(fp)\$ de que ocurra un fallo de página.
El <strong>tiempo de acceso efectivo</strong> se podría calcular como la probabilidad de que no ocurra un fallo de página \$(1-p_(fp))\$ por el <strong>tiempo de acceso</strong> a la memoria \$T_m\$, mas la probabilidad de que ocurra un fallo de página \$p\$ por el tiempo necesario para gestionar cada fallo de página —o <strong>tiempo de fallo de página</strong>— \$T_(fp)\$:</p>
</div>
<div class="stemblock">
<div class="content">
\$T_(em)=(1-p_(fp)) T_m+p_(fp) T_(fp)\$
</div>
</div>
<div class="paragraph">
<p>Por tanto, para calcular el <strong>tiempo de acceso efectivo</strong> \$T_(em)\$ necesitamos estimar el <strong>tiempo de fallo de página</strong> \$T_(fp)\$, que se consume fundamentalmente en:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Servir la excepción de fallo de página.</p>
<div class="paragraph">
<p>Esto incluye capturar la interrupción, salvar los registros y el estado del proceso, determinar que la interrupción es debida a una excepción de <strong>fallo de página</strong>, comprobar si la página es legal y determinar la localización de la misma en el disco.
Aproximadamente, en realizar esta tarea el sistema puede tardar de 1 a 100μs.</p>
</div>
</li>
<li>
<p>Leer la página en un marco libre.
En esta tarea se puede tardar alrededor de 8ms, pero este tiempo puede ser mucho mayor si el dispositivo está ocupado y se debe esperar a que se realicen otras operaciones.</p>
</li>
<li>
<p>Reiniciar el proceso.
Si incluimos el tiempo de espera en la cola de preparados, se puede tardar entre 1 y 100μs.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Como se puede apreciar, la mayor parte del <strong>tiempo de fallo de página</strong> es debido al tiempo requerido para acceder al <strong>dispositivo de intercambio</strong>.</p>
</div>
<div class="paragraph">
<p>Para ilustrar el cálculo del <strong>tiempo de acceso efectivo</strong> a la memoria, solo vamos a considerar el tiempo requerido para acceder al <strong>dispositivo de intercambio</strong>, ignorando las otras tareas a realizar durante el <strong>fallo de página</strong> ya que comparativamente consumen mucho menos tiempo.
Vamos suponer que el <strong>tiempo de acceso</strong> a la memoria \$T_m\$ es de 200 ns. y que la probabilidad \$p_(fp)\$ es muy pequeña —es decir, \$p ≪ 1\$—:</p>
</div>
<div class="stemblock">
<div class="content">
\${:
(T_(em),=,     (1-p_(fp))*200\ text{ns.}+p_(fp) * 8\ text{ms.}),
(      ,=,     (1-p_(fp))*200\ text{ns.}+p_(fp) * 8000000\ text{ns.}),
(     ,approx, 200\ text{ns.} + 7999800\ text{ns.} * p )
:}\$
</div>
</div>
<div class="paragraph">
<p>Como se puede apreciar el <strong>tiempo de acceso efectivo</strong> es proporcional a la <strong>tasa de fallos de página</strong> \$tau_(fp)\$:</p>
</div>
<div class="stemblock">
<div class="content">
\$T_(em) approx T_(m) + tau_(fp)\$
</div>
</div>
<div class="paragraph">
<p>donde \$tau_(fp)=p_(fp) T_(fp)\$.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, si un proceso causa un fallo de página en uno de cada 1000 accesos —es decir, \$p_(fp) = 0,001\$— el <strong>tiempo de acceso efectivo</strong> es de 8,2 ms., por lo que el rendimiento del sistema es 40 veces inferior debido a la <strong>paginación bajo demanda</strong>.
Por tanto, es necesario mantener la <strong>tasa de fallos de página</strong> \$tau_(fp)\$ lo más baja posible para mantener un rendimiento adecuado.</p>
</div>
<div class="paragraph">
<p>Por simplicidad, por el momento hemos considerado \$T_m\$ como el tiempo de acceso a la memoria física.
Sin embargo, realmente estamos en un sistema que utiliza paginación —incluso con varios niveles— y que puede tener una TLB para mejorar su rendimiento.
Entonces, si queremos ser más precisos, podemos considerar \$T_m\$ como el <strong>tiempo de acceso efectivo</strong> que vimos en el <a href="#_tiempos_de_acceso_a_la_memoria">Apartado 16.2.3.3</a> para el método básico de paginación.
Por lo que sustituyendolo en la expresión anterior:</p>
</div>
<div class="stemblock">
<div class="content">
\$T_(em) approx (2-p_(tlb)) T_m + tau_(fp)\$
</div>
</div>
<div class="paragraph">
<p>donde \$p_(tlb)\$ es la probabilidad de que una entrada esté en la TLB y \$T_m\$ ahora sí es el <strong>tiempo de acceso</strong> a la memoria física.</p>
</div>
</div>
<div class="sect4">
<h5 id="_manejo_y_uso_del_espacio_de_intercambio">Manejo y uso del espacio de intercambio</h5>
<div class="paragraph">
<p>Otro aspecto fundamental que afecta al rendimiento de la <strong>paginación bajo demanda</strong> es el uso del espacio de intercambio.</p>
</div>
<div class="paragraph">
<p>Cuando un proceso genera un <strong>fallo de página</strong>, el sistema operativo debe recuperar la página de allí donde esté almacenada.
Si esto ocurre al principio de la ejecución, ese lugar seguramente será el archivo que contiene la imagen binara del programa, pues es donde se encuentran las páginas en su estado inicial.
Sin embargo, el acceso al espacio de intercambio es mucho más eficiente que el acceso a un sistema de archivos, incluso aunque el primero esté almacenado dentro de un archivo de gran tamaño.
Esto es debido a que los datos se organizan en bloques contiguos de gran tamaño, se evitan las búsquedas de archivos y las indirecciones en la asignación de espacio.
Por ello debemos plantearnos qué hacer con las imágenes de los programas que van a ser ejecutados.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se puede mejorar el rendimiento copiando en el espacio de intercambio la imagen completa de los programas durante el inicio del proceso, para después realizar la <strong>paginación bajo demanda</strong> sobre dicha copia.</p>
</li>
<li>
<p>Otra alternativa es cargar las páginas desde el archivo que contiene la imagen cuando son usadas por primera vez, pero siendo escritas en el espacio de intercambio cuando dichas páginas tiene que ser reemplazadas.
Esta aproximación garantiza que solo las páginas necesarias son leídas desde el sistema de archivos, reduciendo el uso de espacio de intercambio, mientras que las siguientes operaciones de intercambio se hacen sobre dicho espacio.</p>
</li>
<li>
<p>También se puede suponer que el código de los procesos no puede cambiar.
Esto permite utilizar el archivo de la imagen binaria para recargar las páginas de código, lo que también evita escribirlas cuando son sustituidas.
Sin embargo, el espacio de intercambio se sigue utilizando para las páginas que no están directamente asociadas a un archivo, como la pila o el montón de los procesos.</p>
<div class="paragraph">
<p>Este último método parece conseguir un buen compromiso entre el tamaño del espacio de intercambio y el rendimiento.
Por eso se utiliza en la mayor parte de los sistemas operativos modernos.</p>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_copy_on_write">17.2. Copy-on-write</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El <strong><em>copy-on-write</em></strong> o <strong>copia durante la escritura</strong> permite la creación rápida de nuevos procesos, minimizando la cantidad de páginas que deben ser asignadas a estos.</p>
</div>
<div class="paragraph">
<p>Para entenderlo, es importante recordar que la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> crear un proceso hijo cuyo espacio de direcciones es un duplicado del espacio de direcciones del padre.
Indudablemente, esto significa que durante la llamada es necesario asignar suficientes marcos de memoria física como para alojar las páginas del nuevo proceso hijo.
El <strong><em>copy-on-write</em></strong> minimiza de la siguiente manera el número de marcos que deben ser asignadas al nuevo proceso:</p>
</div>
<div id="copy_on_write_1" class="imageblock">
<div class="content">
<img src="C17-memoria_virtual/media/copy-on-write1.svg" alt="copy on write1">
</div>
<div class="title">Figura 48. Copy-on-write antes de que el proceso 1 modifique la página A.</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Cuando la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> crea el nuevo proceso lo hace de forma que éste comparta todas sus páginas con las del padre (véase la <a href="#copy_on_write_1">Figura 48</a>).</p>
<div class="paragraph">
<p>Sin el <strong><em>copy-on-write</em></strong> el <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> tendría que asignar marcos de memoria física al hijo, para a continuación copiar las páginas del padre en ellos.
Sin embargo, con el <strong><em>copy-on-write</em></strong> padre e hijo mapean sus páginas en los mismos marcos, evitando tener que asignar memoria libre.</p>
</div>
</li>
<li>
<p>Las páginas compartidas se marcan como <strong><em>copy-on-write</em></strong>.</p>
<div class="paragraph">
<p>Para ello se pueden marcar todas las páginas como de <strong>solo lectura</strong> en la tabla de páginas de ambos procesos y utilizar una tabla interna alojada en el PCB para indicar cuales son realmente de sólo lectura y cuales están en <strong><em>copy-on-write</em></strong>.
Es importante destacar que realmente sólo las páginas que pueden ser modificadas se marcan como <strong><em>copy-on-write</em></strong>. Las páginas que no puede ser modificadas —por ejemplo, las que contienen el código ejecutable del programa— simplemente pueden ser compartidas como de sólo lectura por los procesos, como hemos comentado anteriormente.</p>
</div>
</li>
<li>
<p>Si algún proceso intenta escribir en una página <strong><em>copy-on-write</em></strong>, la MMU genera una excepción para notificar el suceso al sistema operativo.
Siguiendo lo indicado en el punto anterior, la excepción se originaría porque la página está marcada como de solo lectura, por lo que el sistema operativo comprobará si se trata de un acceso a una página <strong><em>copy-on-write</em></strong> o a un intento real de escribir en una página de sólo lectura.
Para ello, el sistema solo tiene que mirar la tabla interna almacenada en el PCB.
Si se ha intentado escribir en una página de solo lectura, el proceso ha cometido un error y generalmente será terminado.</p>
</li>
</ol>
</div>
<div id="copy_on_write_2" class="imageblock">
<div class="content">
<img src="C17-memoria_virtual/media/copy-on-write2.svg" alt="copy on write2">
</div>
<div class="title">Figura 49. Copy-on-write después de que el proceso 1 modifique la página A.</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Si el sistema detecta una escritura a una página de <strong><em>copy-on-write</em></strong> solo tiene que copiarla en un marco libre y mapearlo en el espacio de direcciones del proceso (véase la <a href="#copy_on_write_2">Figura 49</a>).</p>
<div class="paragraph">
<p>Para esto se sustituye la página compartida por otra que contiene una copia pero que ya no está compartida.
Obviamente, la nueva página debe ser marcada como de escritura para que en el futuro pueda ser modificada por el proceso.</p>
</div>
</li>
<li>
<p>La página original marcada como <strong><em>copy-on-write</em></strong> puede ser marcada como de escritura y no como <strong><em>copy-on-write</em></strong>, pero solo si no va a seguir siendo compartida.
Esto es así porque una página marcada como <strong><em>copy-on-write</em></strong> puede estar siendo compartida con otros procesos.</p>
</li>
<li>
<p>El sistema operativo puede reiniciar el proceso.
A partir de ahora, éste puede escribir en la página sin afectar al resto de los procesos.
Sin embargo, puede seguir compartiendo otras páginas en <strong><em>copy-on-write</em></strong>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>El <strong><em>copy-on-write</em></strong> permite ahorrar memoria y tiempo en la creación de los procesos, puesto que sólo se copian las páginas que son modificadas por éstos.
Por eso se trata de una técnica común en múltiples sistemas operativos, como por ejemplo los sistemas POSIX modernos y Microsoft Windows.</p>
</div>
<div class="paragraph">
<p>El <strong><em>copy-on-write</em></strong> es especialmente interesante si a continuación se va a utilizar la llamada al sistema <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> puesto que si es así, copiar el espacio de direcciones completo es una pérdida de tiempo.</p>
</div>
</div>
<div class="sect2">
<h3 id="_archivos_mapeados_en_memoria">17.3. Archivos mapeados en memoria</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Los <strong>archivos mapeados en memoria</strong> permiten acceder a un archivo como parte del espacio de direcciones virtuales de un proceso.
Algunas de las características de esta técnica son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cuando una región del espacio de direcciones queda marcada para ser mapeada sobre una región de un archivo. se utiliza una estrategia similar a la comentada para el método básico de la paginación bajo demanda.
La diferencia es que las páginas son cargadas desde dicho archivo y no desde el espacio de intercambio.
Es decir, en un primer acceso a una página mapeada se produce un <strong>fallo de página</strong> que es resuelto por el sistema operativo leyendo una porción del archivo en el marco asignado a la página.</p>
</li>
<li>
<p>Esto significa que la lectura y escritura del archivo se realiza a través de lecturas y escrituras en la memoria, lo que simplifica el acceso y elimina el costo adicional de las llamadas al sistema: <a href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a>, <a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a>, etc.</p>
</li>
<li>
<p>Las escrituras en disco se suelen realizar de forma asíncrona.
Es decir, los datos no se escriben inmediatamente en disco cuando se modifica la página, sino que el sistema operativo comprueba periódicamente las páginas modificadas y las escribe en disco.</p>
</li>
<li>
<p>Los marcos utilizados en el mapeo pueden ser compartidos, lo que permite compartir los datos de los archivos.
Además, se puede incluir soporte de <strong><em>copy-on-write</em></strong>, lo que permite a los procesos compartir buena parte de un archivo en modo de sólo lectura, pero disponiendo de sus propias copias de aquellas páginas que modifiquen.</p>
<div class="paragraph">
<p>Indudablemente, para que los procesos puedan compartir datos es necesario que exista algún tipo de coordinación (véase el <a href="#_sincronización">Capítulo 13</a>).</p>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_mapeo_de_archivos">17.3.1. Ejemplo de mapeo de archivos</h4>
<div class="paragraph">
<p>Tanto en los sistemas POSIX como en Windows API el archivo a mapear hay que abrirlo con la llamada al sistema destinada a ello.
Por ejemplo, en sistemas POSIX:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span> <span class="s">"foo.txt"</span><span class="p">,</span> <span class="n">O_RDONLY</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>En el API POSIX con esto es suficiente para usar la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a> y mapear el archivo en memoria:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="n">lenght</span> <span class="o">=</span> <span class="n">lseek</span><span class="p">(</span> <span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_END</span> <span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="kt">void</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="n">length</span><span class="p">,</span>                 <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="n">PROT_READ</span><span class="p">,</span>              <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="n">MAP_SHARED</span><span class="p">,</span>
    <span class="n">fd</span><span class="p">,</span>                     <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="mi">0</span>                       <i class="conum" data-value="3"></i><b>(3)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Descriptor del archivo abierto con <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>La longitud de la región del archivo a mapear.
Si queremos mapear todo el archivo, podemos usar <a href="https://www.man7.org/linux/man-pages/man2/lseek.2.html">lseek()</a> para conocer su longitud.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Si no se mapea todo el archivo, se puede indicar la posición del archivo donde comenzar el mapeo.
Esta posición debe ser múltiplo del tamaño de página.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Permisos de la memoria mapeada.
Deben coincidir con el modo con el que se abrió el archivo.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Una vez mapeado el archivo, si no se van a crear más mapeos, se puede cerrar el descriptor de archivo con <a href="https://man7.org/linux/man-pages/man2/close.2.html">close()</a>.
Y la región de memoria mapeada se puede liberar, al terminar, con <a href="https://man7.org/linux/man-pages/man2/munmap.2.html">munmap()</a>.</p>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap17/mapped-files.cpp">mapped-files.cpp</a> se puede ver el ejemplo de un programa que cuenta el número de líneas, palabra y caracteres de un archivo.
Para acceder a él, primero lo mapea en memoria, evitando tener que usar <a href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a> para leer su contenido.
El programa usa la clase definida en <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap17/memory_map.hpp">memory_map.hpp</a> para gestionar el mapeo del archivo.
Sus métodos muestran de forma práctica cómo utilizar las llamadas al sistema comentadas.</p>
</div>
<div class="paragraph">
<p>Con Windows API el proceso requiere un paso más. Primero hay que usar el manejador del archivo abierto para crear un <strong>objeto de mapeo de archivo</strong> con <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga">CreateFileMapping()</a>.
Después, el manejador devuelto por <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga">CreateFileMapping()</a> es usado con <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile">MapViewOfFile()</a> para mapear el archivo en la memoria del proceso.</p>
</div>
<div class="paragraph">
<p>Para liberar la memoria mapeada, se utiliza <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-unmapviewoffile">UnmapViewOfFile()</a>.
Mientras que para cerrar el manejador del <strong>objeto de mapeo de archivo</strong> se usa <a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle">CloseHandle()</a>, como es habitual.</p>
</div>
</div>
<div class="sect3">
<h4 id="_mapeo_de_archivos_en_el_núcleo">17.3.2. Mapeo de archivos en el núcleo</h4>
<div class="paragraph">
<p>Algunos sistemas operativos ofrecen el servicio de mapeo de archivos en la memoria solo a través de una llamada al sistema concreta, permitiendo utilizar las llamadas estándar —<a href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a>, <a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a>, etc.— para hacer uso de la E/S tradicional.
Sin embargo, muchos sistemas modernos utilizan el mapeo en la memoria independientemente de que se pidan o no.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, en los sistemas POSIX, si un proceso utiliza llamada al sistema <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a> es porque explícitamente pide que el archivo sea mapeado en memoria.
Por tanto, el núcleo mapea el archivo en el espacio de direcciones del proceso.</p>
</div>
<div class="paragraph">
<p>Pero en Linux, Microsoft Windows y otros sistemas operativos modernos, adicionalmente, cuando un archivo es abierto con llamadas al sistemas estándar —como <strong>open</strong>— el archivo es mapeado en el espacio de direcciones del núcleo y las llamadas <strong>read</strong> y <strong>write</strong> son traducidas en accesos a la memoria en dicha región.
No importa como sea abierto el archivo.
Estos sistemas tratan toda la E/S a archivos como mapeada en memoria, permitiendo que el acceso a los mismos, tenga lugar a través del eficiente componente de gestión de la memoria.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_reemplazo_de_página">17.4. Reemplazo de página</h3>
<div class="paragraph">
<p>Hasta el momento hemos considerado que disponemos de memoria física suficiente para atender cualquier fallo de página pero ¿qué ocurre cuando no quedan marcos libres?.
En ese caso el código que da servicio a la excepción de <strong>fallo de página</strong> debe escoger alguna página, intercambiarla con el disco y utilizar el marco de la misma para cargar la nueva página.
Es decir, debemos modificar la función que ejecuta los pasos descritos en el <a href="#_paginación_bajo_demanda">Apartado 17.1</a> de la siguiente manera:</p>
</div>
<div class="olist arabic">
<ol class="arabic" start="4">
<li>
<p>Si la página es legal, debe ser cargada desde el disco.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Buscar la localización de la página en disco.</p>
</li>
<li>
<p>El núcleo debe buscar un marco de memoria libre que, por ejemplo, se puede escoger de la lista de marcos libres del sistema.</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>Si hay uno, usarlo.</p>
</li>
<li>
<p>Si no hay, usar un <strong>algoritmo de reemplazo de página</strong> para seleccionar una víctima.</p>
</li>
<li>
<p>Escribir la víctima en el disco y cambiar las <strong>tablas de páginas y de marcos libres</strong> de acuerdo a la nueva situación.
Para evitar mantener la CPU ocupada, el sistema debe solicitar la escritura de la página y poner al proceso en estado de <strong>esperando</strong>.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Se solicita una operación de disco para leer la página deseada en el marco asignado.
Para evitar mantener la CPU ocupada, el sistema debe solicitar la escritura de la página y poner al proceso en estado de <strong>esperando</strong>.</p>
</li>
<li>
<p>Cuando la lectura del disco haya terminado, se debe modificar la tabla interna de páginas válidas, y la tabla de páginas para indicar que la página está en la memoria.</p>
</li>
<li>
<p>Reiniciar la instrucción que fue interrumpida por la excepción.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Es importante destacar que en caso de <strong>reemplazo</strong> se necesita realizar dos accesos al disco.
Esto se puede evitar utilizando un <strong>bit de modificado</strong> asociado a cada entrada en la <strong>tabla de páginas</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Este bit es puesto a 1 por el hardware cuando se escribe en la página.</p>
</li>
<li>
<p>Se puede evitar escribir en disco aquellas páginas que tienen este bit a 0 cuando son seleccionada para reemplazo, siempre que el contenido de la página no haya sido sobrescrito por otra en el espacio de intercambio.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>En general, para implementar la paginación bajo demanda necesitamos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Un <strong>algoritmo de asignación de marcos</strong>, que se encarga de asignar los marcos a los procesos.</p>
</li>
<li>
<p>Un <strong>algoritmo de reemplazo de página</strong> para seleccionar que página reemplazamos cuando no hay marcos suficientes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Obviamente, estos algoritmos deben ser escogidos de forma que mantengan la <strong>tasa de fallos de página</strong> lo más baja posible para perjudicar en lo mínimo el rendimiento del sistema.</p>
</div>
<div class="sect3">
<h4 id="_algoritmos_de_reemplazo_de_páginas">17.4.1. Algoritmos de reemplazo de páginas</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Hay muchos <strong>algoritmos de reemplazo de página</strong>.
La cuestión es cómo seleccionar uno en particular, sabiendo que debe tener la menor tasa posible de <strong>fallos de página</strong>.</p>
</div>
<div class="sect4">
<h5 id="_trazas_de_referencias">Trazas de referencias</h5>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Podemos evaluar el algoritmo utilizando una secuencia de referencias a memoria y calculando el número de <strong>fallos de página</strong>.
A dicha secuencia de referencias se la denomina <strong>trazas de referencias</strong>.</p>
</div>
<div class="paragraph">
<p>Las trazas pueden ser obtenidas aleatoriamente u obteniéndolas a partir de las que hace un proceso en un sistema real.
Indudablemente, esta última alternativa puede proporcionar miles de millones de referencias.
Para reducir el número de datos podemos hacer dos cosas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>De cada referencia sólo necesitamos considerar el número de página.</p>
</li>
<li>
<p>Si tenemos una referencia a la página \$p\$, cualquier referencia inmediatamente posterior a dicha página \$p\$ nunca provocará un fallo de página, por lo que podemos ignorarlas.
Esto no tendría porque ser cierto y si consideramos que hay varios procesos en el sistema y unos pueden expropiar a los otros.
Pero por simplicidad, ese no es nuestro caso.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Por ejemplo, si obtenemos la siguiente traza de un proceso particular:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>0100, 0432, 0101, 0612, 0102, 0103, 0104, 0101, 0611, 0102, 0103, 0104, 0101, 0610, 0102, 0103, 0104, 0101, 0609, 0102, 0105</pre>
</div>
</div>
<div class="paragraph">
<p>con páginas de 100 bytes, podemos reducirla a:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>1, 4, 1, 6, 1, 6, 1, 6, 1, 6, 1</pre>
</div>
</div>
<div class="paragraph">
<p>Indudablemente, para determinar el número de <strong>fallos de página</strong> también debemos conocer el número de marcos disponibles para el proceso.</p>
</div>
</div>
<div class="sect4">
<h5 id="_reemplazo_fifo">Reemplazo FIFO</h5>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>El <strong>algoritmo de reemplazo de páginas FIFO</strong> es el más sencillo.
Funciona de la siguiente manera:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se asocia a cada página el instante de tiempo en que fue cargada por última vez.</p>
</li>
<li>
<p>Cuando hay que hacer reemplazo se selecciona como víctima a la página más antigua.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Realmente no es estrictamente necesario almacenar el instante de tiempo en que una página fue cargada.
En su lugar, las páginas en memoria pueden ser almacenadas en una cola FIFO, puesto que así se conserva su orden de llegada en el tiempo, que es lo que nos interesa.
Esta misma cola FIFO es utilizada en algunos algoritmos que veremos posteriormente.</p>
</div>
<div class="paragraph">
<p>Vamos a ilustrar este algoritmo con un ejemplo, donde supondremos que tenemos 3 marcos de memoria física:</p>
</div>
<table class="tableblock frame-all grid-all stretch small">
<colgroup>
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top" colspan="20"><p class="tableblock">13 fallos de página</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Como se puede observar, las primeras 3 referencias generan <strong>fallos de página</strong> porque se supone que los marcos no están asignados a ninguna página.
A partir de ahí se utiliza el <strong>algoritmo de reemplazo FIFO</strong> para seleccionar una página cuyo marco es utilizado para cargar la página requerida por el proceso.</p>
</div>
<div class="paragraph">
<p>El <strong>algoritmo FIFO</strong> no siempre tiene un buen rendimiento:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Puesto que utiliza el orden en el tiempo, puede reemplazar tanto páginas que no están siendo utilizadas como páginas usadas frecuentemente.
Sin embargo, aunque esto pase, todo seguirá funcionado correctamente, aunque aumentará la tasa de <strong>fallos de página</strong> enlenteciendo el sistema.</p>
</li>
<li>
<p>No siempre que aumenta la cantidad de memoria disponible mejora el rendimiento.</p>
</li>
</ul>
</div>
<div id="fallos_de_página_frente_a_marcos" class="imageblock">
<div class="content">
<img src="C17-memoria_virtual/media/fallos_de_página_frente_a_marcos.svg" alt="fallos de página frente a marcos">
</div>
<div class="title">Figura 50. Fallos de página frente a número de marcos.</div>
</div>
<div class="paragraph">
<p>Es de esperar que si el número de marcos disponibles aumenta, el número de <strong>fallos de página</strong> disminuya (véase la <a href="#fallos_de_página_frente_a_marcos">Figura 50</a>).
Sin embargo, con el <strong>algoritmo FIFO</strong> el número de <strong>fallos de página</strong> puede aumentar cuando el número de marcos disponibles se incrementa.
Es lo que se conoce como la <strong>anormalidad de Belady</strong>.</p>
</div>
<div id="anormalidad_de_belady" class="imageblock">
<div class="content">
<img src="C17-memoria_virtual/media/anormalidad_de_belady.svg" alt="anormalidad de belady">
</div>
<div class="title">Figura 51. Fallos de página con el algoritmo de reemplazo FIFO.</div>
</div>
<div class="paragraph">
<p>Para ilustrarlo consideraremos la siguiente traza de referencias:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5</pre>
</div>
</div>
<div class="paragraph">
<p>La <a href="#anormalidad_de_belady">Figura 51</a> muestra la curva de <strong>fallos de página</strong> frente el número de marcos.
Como se puede apreciar, el número de <strong>fallos de página</strong> con cuatro marcos es superior al número de fallos con tres marcos, aunque era de esperar que el número de fallos de páginas decrementara cuando aumenta el número de marcos.</p>
</div>
</div>
<div class="sect4">
<h5 id="_reemplazo_óptimo">Reemplazo óptimo</h5>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>Como resultado del descubrimiento de la <strong>anormalidad de Belady</strong> se comenzó a buscar un algoritmo de reemplazo de página óptimo.
Es decir:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Que tuviera la <strong>tasa de fallo de página</strong> más baja posible.</p>
</li>
<li>
<p>Que nunca sufra de la <strong>anormalidad de Belady</strong>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ese algoritmo existe y consiste en reemplazar la página que no va a ser utilizada en el mayor periodo de tiempo.</p>
</div>
<table class="tableblock frame-all grid-all stretch small">
<colgroup>
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top" colspan="20"><p class="tableblock">9 fallos de página</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Desafortunadamente, el <strong>algoritmo de reemplazo óptimo</strong> es difícil de implementar puesto que necesita saber las páginas que serán referenciadas en el futuro.
Por lo que sólo se usa en estudios comparativos, con el fin de saber cuánto se aproxima al óptimo un algoritmo de reemplazo determinado.</p>
</div>
</div>
<div class="sect4">
<h5 id="_reemplazo_lru">Reemplazo LRU</h5>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>El <strong>algoritmo de reemplazo de página LRU</strong> (<em>Least Recently Used</em>) es una aproximación del óptimo.
La hipótesis es que si una página no ha sido usada durante un gran periodo de tiempo, entonces
probablemente tampoco será utilizada en el futuro; por lo que reemplazando la página que hace más tiempo que no se usa, nos estaríamos aproximando al algoritmo óptimo.
Vamos a ilustrarlo con un ejemplo:</p>
</div>
<table class="tableblock frame-all grid-all stretch small">
<colgroup>
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top" colspan="20"><p class="tableblock">11 fallos de página</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Este algoritmo se considera bastante eficiente cuando se aplica al reemplazo de páginas, por lo que es utilizado con frecuencia.</p>
</div>
<div class="paragraph">
<p>Un detalle significativo es que necesita asociar cada página con el momento en que fue utilizada por última vez.
Aunque se pueden utilizar interrupciones para implementarlo por software —monitorizando cada acceso a la memoria— esta solución es muy ineficiente, puesto que se necesitaría actualizar algunos datos en la memoria en cada referencia a una página.
Por ello el reemplazo LRU es inconcebible sin apoyo del hardware.</p>
</div>
<div class="paragraph">
<p>Son posibles dos implementaciones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Utilizando contadores:</p>
<div class="openblock">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>La CPU debe tener un reloj lógico o contador que se incrementa con cada referencia
a la memoria.</p>
</li>
<li>
<p>A cada página se añade un campo de <strong>instante de uso</strong>, que se almacena en la entrada de la tabla de páginas correspondiente.</p>
</li>
<li>
<p>Cuando una página es referenciada, el valor del contador de la CPU se almacena en
el campo de <strong>instante de uso</strong> de dicha página.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>Esta implementación requiere que se haga una escritura en la memoria con cada referencia.
Además de una búsqueda por toda la tabla de páginas para localizar la página LRU.</p>
</div>
</li>
<li>
<p>Utilizando una pila:</p>
<div class="openblock">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Se utiliza una pila de números de página.</p>
</li>
<li>
<p>Si se referencia una página, se quita el número correspondiente de la mitad de la pila
y se inserta arriba.
Debido a esto, lo mejor es implementarla como una lista doblemente en lazada.</p>
</li>
</ol>
</div>
</div>
</div>
</li>
<li>
<p>La actualización de la pila —que debe realizarse en cada referencia— tiene mayor coste que
en la implementación anterior, pues puede ser necesario cambiar hasta 6 punteros.
Sin embargo, no es necesario realizar ninguna búsqueda para seleccionar la víctima del
reemplazo, puesto que esta se puede extraer directamente del final de la pila.</p>
</li>
<li>
<p>Es una estrategia ideal para ser implementada en software o microcódigo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El <strong>algoritmo reemplazo LRU</strong> pertenece a una clase denominada <strong>algoritmos de pila</strong>, que nunca se
ven afectados por la <strong>anormalidad de Belady</strong>.
En estos algoritmos, las páginas en memoria en un instante dado para \$N\$ marcos son un subconjunto de las que podrían haber con \$N+1\$ marcos.
Concretamente, en el <strong>algoritmo LRU</strong> las páginas en los marcos son las \$N\$ páginas más referenciadas recientemente.
Si el número de marcos aumentase, estas \$N\$ páginas seguirían estando en memoria, pues siguen siendo las referenciadas más recientemente.</p>
</div>
</div>
<div class="sect4">
<h5 id="_reemplazo_lru_aproximado">Reemplazo LRU aproximado</h5>
<div class="paragraph">
<p>Pocos sistemas tienen soporte para utilizar el <strong>algoritmo de reemplazo de página LRU</strong>.
Incluso en algunos casos no hay soporte de ningún tipo, por lo que no queda más remedio que utilizar el remplazo FIFO.</p>
</div>
<div class="paragraph">
<p>Sin embargo, muchos proporcionan algo de ayuda en la forma de un <strong>bit de referencia</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cada entrada de la tabla de páginas tiene un <strong>bit de referencia</strong>.</p>
</li>
<li>
<p>El hardware pone a 1 el <strong>bit de referencia</strong> cada vez que se referencia a una página.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Con el <strong>bit de referencia</strong> no podemos saber con exactitud el instante pero si que una página ha sido
referenciada recientemente.
Utilizándolo, podemos implementar diversas aproximaciones al algoritmo LRU.</p>
</div>
<div class="sect5">
<h6 id="_reemplazo_nru">Reemplazo NRU</h6>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>En el <strong>algoritmo de reemplazo de página NRU</strong> se utiliza el <strong>bit de referencia</strong> de la siguiente manera:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>En intervalos regulares de tiempo, todos los <strong>bits de referencia</strong> son puestos a cero por el sistema operativo.</p>
</li>
<li>
<p>Según los procesos se van ejecutando, el <strong>bit de referencia</strong> asociado a cada página se pone a 1
por el hardware, al ser referenciadas.</p>
</li>
<li>
<p>Cuando haya que escoger una página para ser reemplazada, se intenta seleccionar una que no haya sido referenciada —es decir, con el bit de referencia a 0—.</p>
</li>
<li>
<p>En caso de que hayan varias alternativas entre las que elegir se puede utilizar el <strong>algoritmo de reemplazo de página FIFO</strong> o escoger un aleatoriamente.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Vamos a ilustrarlo con un ejemplo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Utilizaremos 3 marcos de página.</p>
</li>
<li>
<p>Indicaremos el valor del bit de referencia con un superíndice junto al número de página.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>No debemos olvidar que en caso de que ocurra un fallo de página, después de la carga de la página se reinicia la instrucción que generó dicho fallo.
Por lo tanto, habrá un acceso que pondrá el <strong>bit de referencia a 1</strong>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>Marcaremos con una flecha el instante de tiempo en el que todos los bits de referencia se
ponen a cero.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En un sistema operativo real los bits son desplazados en intervalos fijos de tiempo.
Pero esto no tiene que coincidir con una cantidad fija de referencias en la traza, puesto que hemos eliminado las referencias consecutivas a una misma página.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>En caso de coincidencia, utilizaremos el <strong>reemplazo FIFO</strong> para seleccionar la víctima.</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch small">
<colgroup>
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">↓</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">↓</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">↓</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">↓</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">↓</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>0</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top" colspan="20"><p class="tableblock">11 fallos de página</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Se puede mejorar el algoritmo anterior considerando tanto el <strong>bit de referencia</strong> como el <strong>bit de modificado</strong>, para clasificar las páginas en distintas categorías y escoger una página en la mejor categoría.
Este es el tipo más común de <strong>algoritmo de reemplazo de página NRU</strong>, pero lo veremos en el <a href="#_algoritmo_de_la_segunda_oportunidad_mejorado">Apartado 17.4.1.5.4</a> bajo el nombre de <strong>Algoritmo de la segunda oportunidad mejorado</strong>.</p>
</div>
</div>
<div class="sect5">
<h6 id="_con_bits_de_referencia_adicionales">Con bits de referencia adicionales</h6>
<div class="paragraph">
<p>Podemos obtener información adicional sobre el orden en que se realizan las referencias, guardando los <strong>bits de referencia</strong> en intervalos periódicos de tiempo.
El <strong>reemplazo LRU aproximado con bits de referencia adicionales</strong>, o de <strong>envejecimiento</strong>, consiste en lo siguiente:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A parte del <strong>bit de referencia</strong>, cada página tiene un conjunto de <strong>bits de referencia adicionales</strong> —por ejemplo, 8 bits— que se guardan en alguna tabla interna que mantiene el sistema operativo.</p>
</li>
<li>
<p>A intervalos regulares —por ejemplo, cada 100 ms.— el sistema operativo desplaza los <strong>bits de referencia adicionales</strong> de cada página; insertando el <strong>bit de referencia</strong> de la página en el bit de orden más alto y descartando el bit de orden más bajo.</p>
</li>
<li>
<p>Cuando haya que escoger una página para ser reemplazada se escoge la que tenga el valor más pequeño en el conjunto de <strong>bits de referencia adicionales</strong>.
Esto es así, puesto que dicho conjunto contiene la historia de referencias de la página.
Por ejemplo, \${1 1 0 0 0 1 0 0}\$ es más reciente que \${0 1 1 1 0 1 1 1}\$.</p>
</li>
<li>
<p>Se puede utilizar el <strong>algoritmo de reemplazo de página FIFO</strong> o escoger un aleatoriamente, si dos páginas tienen el mismo valor.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Vamos a ilustrarlo con un ejemplo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Utilizaremos 3 marcos de página.</p>
</li>
<li>
<p>Utilizaremos 2 bits adicionales.</p>
</li>
<li>
<p>Indicaremos el valor del <strong>bit de referencia</strong> y de los <strong>bits adicionales</strong> con un superíndice junto al número de página.</p>
</li>
<li>
<p>Marcaremos con una flecha el instante de tiempo en el que los bits son desplazados por el sistema operativo.</p>
</li>
<li>
<p>En caso de coincidencia, utilizaremos el <strong>reemplazo FIFO</strong> para seleccionar la víctima.</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch small">
<colgroup>
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">↓</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">↓</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">↓</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">↓</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">↓</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>0|10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1|10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1|10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>0|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>0|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>0|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>0|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>0|11</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1|10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1|10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1|10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>0|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>0|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>0|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>0|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1|11</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>0|10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>0|10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>0|10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>0|01</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>0|10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>0|10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>0|10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1|00</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top" colspan="20"><p class="tableblock">10 fallos de página</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>El número de <strong>bits adicionales</strong> puede variar de una implementación a otra, pero en cualquier caso debe ser seleccionado para realizar la actualización lo más rápidamente posible, teniendo en cuenta las características del hardware.
En un caso extremo, el número de <strong>bits de referencia adicionales</strong> podría ser cero, dejando solo el <strong>bit de referencia</strong>.
A este algoritmo se lo conoce como el <strong>algoritmo de la segunda oportunidad</strong>.</p>
</div>
</div>
<div class="sect5">
<h6 id="_algoritmo_de_la_segunda_oportunidad">Algoritmo de la segunda oportunidad</h6>
<div class="paragraph">
<p>



</p>
</div>
<div class="paragraph">
<p>El <strong>algoritmo de reemplazo de la segunda oportunidad</strong> o del <strong>reloj</strong> es un <strong>algoritmo de reemplazo de página FIFO</strong>, pero donde una página es seleccionada considerando el <strong>bit de referencia</strong>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Cuando es necesario seleccionar una víctima para reemplazo se extrae una página de la cola FIFO.
Esta cola contiene todas las páginas con marcos asignados y en el orden en que fueron cargadas, como ocurre con el <strong>algoritmo FIFO de reemplazo</strong>.</p>
</li>
<li>
<p>Si el <strong>bit de referencia</strong> está a 0, se utiliza esta página para reemplazo.</p>
</li>
<li>
<p>Si el <strong>bit de referencia</strong> está a 1:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Se pone el <strong>bit de referencia</strong> a 0 y se vuelve a insertar la página en el final de la cola.</p>
</li>
<li>
<p>Se extrae la siguiente pagina del principio de la cola y se vuelve al punto 2.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>De este esquema podemos destacar algunos aspectos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Una página a la que se le da la segunda oportunidad, no será reemplazada hasta que no se le de la segunda oportunidad a todas las demás; siempre que no sea referenciada antes y el <strong>bit de referencia</strong> se vuelva a poner a 1.</p>
</li>
<li>
<p>En el peor de los casos, cuando todas las páginas tienen sus bits a uno, degenera en un reemplazo FIFO.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Vamos a ilustrarlo con un ejemplo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Utilizaremos 3 marcos de página.</p>
</li>
<li>
<p>Indicaremos el valor del <strong>bit de referencia</strong> con un superíndice junto al número de página en el marco.</p>
</li>
<li>
<p>Indicaremos el principio de la cola con una flecha junto al número de página.</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch small">
<colgroup>
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→2<sup>0</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">→</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→0<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→0<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→3<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>0</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→4<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top" colspan="20"><p class="tableblock">11 fallos de página</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect5">
<h6 id="_algoritmo_de_la_segunda_oportunidad_mejorado">Algoritmo de la segunda oportunidad mejorado</h6>
<div class="paragraph">
<p>Se puede mejorar el <strong>algoritmo de la segunda oportunidad</strong> considerando tanto el <strong>bit de referencia</strong> como el <strong>bit de modificado</strong>.
Algunos autores denominan a este algoritmo como <strong>algoritmo de la segunda oportunidad mejorado</strong>, mientras otro lo llaman <strong>NRU</strong>,
ya que es una versión mejorada del algoritmo del <a href="#_reemplazo_nru">Apartado 17.4.1.5.1</a>.</p>
</div>
<div class="paragraph">
<p>Con esos dos bits, el sistema operativo clasifica las páginas en una de las siguientes cuatro clases:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>(0,0) ni recientemente usado ni modificado. Las páginas de esta clase son las mejores para ser
reemplazadas.</p>
</li>
<li>
<p>(0,1) no usado recientemente pero modificado. No es una buena elección puesto que hay que
escribir primero la página al disco antes del reemplazo.</p>
</li>
<li>
<p>(1,0) recientemente usado pero no modificado.
Probablemente será usada de nuevo en un corto espacio de tiempo.</p>
</li>
<li>
<p>(1,1) usada y modificada.
Será utilizada pronto y la página tendría que ser escrita a disco para ser reemplazada.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Cuando el reemplazo de página es invocado:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se examina la clase a la que pertenece cada página y se reemplaza un página en la clase de menor importancia que no esté vacía.
Indudablemente, deberemos examinar la lista varias veces antes encontrar la página que debe ser reemplazada.</p>
</li>
<li>
<p>A intervalos regulares los <strong>bits de referencia</strong> de todas las páginas son puestos a cero por el sistema operativo.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En un sistema real, el sistema operativo escribe las páginas modificadas en el almacenamiento secundario cuando está desocupado y luego pone el <strong>bit de modificado</strong> a 0.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Vamos a ilustrarlo con un ejemplo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Utilizaremos 3 marcos de página.</p>
</li>
<li>
<p>El que la referencia a la memoria sea para lectura <strong>R</strong> o escritura <strong>W</strong> vendrá indicado junto al número de página en la traza.</p>
</li>
<li>
<p>Marcaremos con una flecha el instante de tiempo en el que todos los bits de referencia se ponen a cero.</p>
</li>
<li>
<p>Indicaremos el valor del <strong>bit de referencia</strong> y del <strong>bit de modificado</strong> con un superíndice junto al número de página en el marco.</p>
</li>
<li>
<p>Indicaremos el principio de la cola con una flecha junto al número de página.
Sirve para mantener un orden en las páginas, de tal forma que si hay varios candidatos de la misma categoría, se escoja el primero encontrado.
Si la elección en caso de varios candidatos es aleatoria, por ejemplo, no hace falta ese puntero.</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch small">
<colgroup>
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">↓</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">↓</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">↓</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">↓</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">↓</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7r</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0r</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1w</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2r</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0r</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2r</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0w</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2r</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4w</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0w</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2r</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0r</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1r</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3w</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0r</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1r</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2w</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7w</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0r</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1r</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→7<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→2<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→2<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→2<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>01</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>01</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>01</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>01</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>10</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">→</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→0<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→0<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→0<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→0<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→0<sup>01</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>01</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>01</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→1<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→1<sup>00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→1<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→1<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→7<sup>11</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>01</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>01</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>01</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>01</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→1<sup>01</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>01</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→0<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→0<sup>01</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">→0<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>11</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top" colspan="20"><p class="tableblock">11 fallos de página</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_reemplazo_basado_en_contador">Reemplazo basado en contador</h5>
<div class="paragraph">
<p>Otros algoritmos utilizan un contador del número de referencias que son realizadas a cada página.
En esos casos, la elección de la víctima se puede realizar utilizando dos esquemas: la que tiene el valor mayor o el menor.
Ninguno de los dos es muy común, ya que su implementación es costosa y no son una buena aproximación del óptimo.</p>
</div>
<div class="paragraph">
<p>Por lo general, la actualización del contador no la realiza la CPU, ya que leer la entrada de la página, incrementar el contador y volver a guardar la entrada, tiene un coste importante.
En su lugar:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>El contador de cada página se guarda en una tabla interna.</p>
</li>
<li>
<p>Periódicamente el sistema operativo examina el <strong>bit de referencia</strong> de cada página y si está a 1, incrementa el contador de la página correspondiente.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>El mayor problema es que permite hacer el seguimiento de la frecuencia con la que se usan las páginas pero no tiene en cuenta el periodo durante el que se usan.
Por ejemplo, los procesos durante su inicialización pueden usar intensamente ciertas páginas y después no necesitarlas más.
Debido a que esas páginas ha sido utilizadas intensamente, tiene un contador de referencias con un valor muy alto, por lo que son mantenidas en memoria aunque no vaya a ser utilizadas.</p>
</div>
<div class="paragraph">
<p>La solución es utilizar el <strong>algoritmo LRU aproximado con bits de referencia adicionales</strong> (véase <a href="#_con_bits_de_referencia_adicionales">Apartado 17.4.1.5.2</a>) ya que tiene un coste muy similar a este y prioriza las usadas más recientemente sobre las que fueron usadas con mucha frecuencia en el pasado.</p>
</div>
<div class="sect5">
<h6 id="_reemplazo_lfu">Reemplazo LFU</h6>
<div class="paragraph">
<p>


</p>
</div>
<div class="paragraph">
<p>En el <strong>algoritmo de reemplazo de página LFU</strong> (<em>Least Frequently Used</em>) o <strong>NFU</strong>  (<em>Not Frequently Used</em>) se escoge la página con el contador más bajo.
Esto es así puesto que suponemos que las páginas menos referenciadas son las que no se están utilizando de forma más activa.</p>
</div>
<div class="paragraph">
<p>Vamos a ilustrarlo con un ejemplo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Indicaremos el valor de los contadores con un superíndice junto al número de página.</p>
</li>
<li>
<p>En caso de coincidencia, utilizaremos el reemplazo <strong>FIFO</strong> para seleccionar la víctima.</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch small">
<colgroup>
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>2</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>2</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>3</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>3</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>3</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>4</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>4</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>4</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>4</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>4</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>4</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>5</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>5</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>5</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>5</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>2</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>2</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>3</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>3</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>3</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>4</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>4</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>5</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>5</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>5</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>6</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>6</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>6</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>6</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>7</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>7</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top" colspan="20"><p class="tableblock">12 fallos de página</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect5">
<h6 id="_reemplazo_mfu">Reemplazo MFU</h6>
<div class="paragraph">
<p>En el <strong>algoritmo de reemplazo de página MFU</strong> (<em>Most Frequently Used</em>), se escoge la página con el contador más alto.
Se basa en el argumento de que la página con el contador más pequeño probablemente acaba de ser traída, por lo que aún no ha sido utilizada.</p>
</div>
<div class="paragraph">
<p>Vamos a ilustrarlo con un ejemplo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Indicaremos el valor de los contadores con un superíndice junto al número de página.</p>
</li>
<li>
<p>En caso de coincidencia, utilizaremos el reemplazo <strong>FIFO</strong> para seleccionar la víctima.</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch small">
<colgroup>
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>2</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>2</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>3</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>3</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>2</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>2</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>2</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>2</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>3</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>3</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>2</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top" colspan="20"><p class="tableblock">13 fallos de página</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Por extraña que parezca esta política, suele ser más eficiente que el <strong>LRU</strong> cuando se utiliza en las aplicaciones de almacenamiento de datos, porque algunas las páginas se utilizan intensamente durante breves periodos de tiempo pero están un tiempo sin utilizarse.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_algoritmos_de_buffering_de_páginas">17.4.2. Algoritmos de buffering de páginas</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Existen otros procedimientos que pueden ser utilizados, junto con alguno de los <strong>algoritmos de reemplazo</strong> comentados, con el objetivo de mejorar su eficiencia.
Estos procedimientos se agrupan dentro de lo que se denomina <strong>algoritmos de <em>buffering</em> de páginas</strong>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se puede mantener una lista de marcos libres.
Cuando se produce un <strong>fallo de pagina</strong> se escoge un marco de la lista y se carga la página, al tiempo que se selecciona una página como víctima y se copia al disco.</p>
<div class="paragraph">
<p>Esto permite que el proceso se reinicie lo antes posible, sin esperar a que la página reemplazada sea escrita en el disco.
Posteriormente, cuando la escritura finalice, el marco es incluido en la lista de marcos libres.</p>
</div>
</li>
<li>
<p>Recordar qué página estuvo en cada marco antes de que éste pasara a la lista de marcos libres, sería una mejora de lo anterior.
De esta forma las páginas podrían ser recuperadas directamente desde la lista, si fallara alguna antes de que su marco sea utilizado por otra página.</p>
<div class="paragraph">
<p>Esto permite reducir los efectos de que el <strong>algoritmo de reemplazo</strong> escoja una víctima equivocada.</p>
</div>
</li>
<li>
<p>Se puede mantener una lista de páginas modificadas e ir escribiéndolas cuando el dispositivo del espacio de intercambio no esté ocupado.</p>
<div class="paragraph">
<p>Este esquema aumenta la probabilidad de que una página no esté marcada como modificada —con el <strong>bit de modificado</strong>— cuando sea seleccionada por el algoritmo de reemplazo, evitando tener que hacer en ese momento la escritura en disco.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_reemplazo_local_frente_a_global">17.4.3. Reemplazo local frente a global</h4>
<div class="paragraph">
<p>Cuando un proceso necesita un marco, el algoritmo de reemplazo puede, tanto extraerlo de cualquier proceso, como ser obligado a considerar sólo aquellas páginas que pertenecen al proceso que generó el fallo.
Eso permite clasificar los algoritmos de reemplazo en dos categorías:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En el <strong>reemplazo local</strong> sólo se pueden escoger marcos de entre los asignados al proceso.
Por tanto:</p>
<div class="ulist">
<ul>
<li>
<p>El número de marcos asignados a un proceso no cambia por que ocurran <strong>fallos de página</strong>.</p>
</li>
<li>
<p>El mayor inconveniente es que un proceso no puede hacer disponible a otros procesos los marcos de memoria que menos utiliza.</p>
</li>
</ul>
</div>
</li>
<li>
<p>En el <strong>reemplazo global</strong> se pueden escoger marcos de entre todos los del sistema, independientemente de que estén asignados a otro proceso o no.
Por tanto:</p>
<div class="ulist">
<ul>
<li>
<p>El número de marcos asignados a un proceso puede aumentar si durante los <strong>fallos de página</strong> se seleccionan marcos de otros procesos.</p>
</li>
<li>
<p>El mayor inconveniente es que los procesos no pueden controlar su <strong>tasa de fallos de página</strong>, puesto que esta depende del comportamiento de los otros procesos, pudiendo afectar a su tiempo de ejecución de forma significativa.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Generalmente, el <strong>reemplazo global</strong> proporciona mayor rendimiento, por lo que es el método más utilizado.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_asignación_de_marcos_de_página">17.5. Asignación de marcos de página</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>La cuestión que queda por resolver es cómo repartir los marcos de memoria física libre entre los diferentes procesos, con el fin de cubrir las necesidades de reemplazo de cada uno de ellos.
Posibles soluciones a esto serían: repartir la memoria por igual entre todos los procesos o hacerlo en proporción a la cantidad de memoria virtual que utilizan.</p>
</div>
<div class="paragraph">
<p>Sin embargo, intuitivamente parece interesante intentar estimar de alguna manera el <strong>mínimo número de marcos</strong> que realmente necesita cada proceso.
Así, si a cada proceso se le proporciona el número mínimo de marcos necesario, el sistema podría disponer de memoria libre para aumentar el número de procesos —aumentando el uso de la CPU— o para dedicarla a otras funciones —como es el caso de los búferes y las cachés de E/S—.</p>
</div>
<div class="paragraph">
<p>El <strong>mínimo número de marcos</strong> viene establecido por diversos factores:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cuando ocurre un fallo de página, la instrucción que la ha provocado, debe ser reiniciada después de cargar la página en un marco libre.
Por lo tanto, un proceso debe disponer de suficientes marcos como para guardar todas las páginas a las que una única instrucción pueda acceder pues, de lo contrario, el proceso nunca podría ser reiniciado al fallar permanentemente en alguno de los acceso a memoria de la instrucción.
Obviamente, este límite viene establecido por la arquitectura de la máquina.</p>
</li>
<li>
<p>Todo proceso tiene una cierta cantidad de páginas que en cada instante son utilizadas frecuentemente.
Si el proceso no dispone de suficientes marcos como para alojar dichas páginas, generará fallos de página con demasiada frecuencia.
Esto afecta negativamente al rendimiento del sistema, por lo que es conveniente que el sistema asigne al número de marcos necesario para que eso no ocurra.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>En general, si se va reduciendo el número de marcos asignados a un proceso, mucho antes de haber alcanzado el mínimo establecido por la arquitectura, el proceso dejará de ser útil debido a la elevada <strong>tasa de fallos de página</strong>, que será mayor cuantos menos marcos tenga asignados.
Cuando eso ocurre se dice que el proceso está <strong>hiperpaginando</strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_hiperpaginación">17.6. Hiperpaginación</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Se dice que un proceso sufre de <strong>hiperpaginación</strong> cuando gasta más tiempo paginando que ejecutándose.</p>
</div>
<div class="sect3">
<h4 id="_causas_de_la_hiperpaginación">17.6.1. Causas de la hiperpaginación</h4>
<div class="paragraph">
<p>En los primeros sistemas multiprogramados que implementaron la paginación bajo demanda, era posible que se diera el siguiente caso:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>El sistema operativo monitorizaba el uso de la CPU.
Si el uso de la misma era bajo, se cargaban nuevos procesos desde la <strong>cola de entrada</strong> para aumentar el número de procesos ejecutándose al mismo tiempo —también llamado <strong>grado de multiprogramación</strong> en esos sistemas—.</p>
</li>
<li>
<p>Si un proceso necesitaba demasiada memoria, le podía quitar los marcos a otro, puesto que se utilizaba un <strong>algoritmo de reemplazo global</strong>.
Esto podía ocasionar que aumentara la <strong>tasa de fallos de página</strong> del proceso que perdía los marcos.</p>
</li>
<li>
<p>Al aumentar los <strong>fallos de pagina</strong> el uso de la CPU decrecía, por lo que el sistema operativo cargaba más procesos para aumentar el <strong>grado de multiprogramación</strong> y con ello el uso de la CPU.</p>
</li>
<li>
<p>Esto reducía la cantidad de memoria disponible para cada proceso, lo que aumentaba la <strong>tasa de fallos de páginas</strong>, que nuevamente reducía el uso de la CPU.</p>
</li>
<li>
<p>Este mecanismo iteraba hasta reducir considerablemente el rendimiento del sistema.</p>
</li>
</ol>
</div>
<div id="hiperpaginación" class="imageblock">
<div class="content">
<img src="C17-memoria_virtual/media/hiperpaginación.svg" alt="hiperpaginación">
</div>
<div class="title">Figura 52. Hiperpaginación en sistemas multiprogramados.</div>
</div>
<div class="paragraph">
<p>El fenómeno comentado, se ilustra en la <a href="#hiperpaginación">Figura 52</a>, donde se muestra el uso de la CPU frente al número de procesos cargados en el sistema.
Cuando esto último aumenta, el uso de la CPU aumenta hasta alcanzar un máximo.
Si el <strong>grado de multiprogramación</strong> supera dicho punto, el sistema comienza a <strong>hiperpaginar</strong>, por lo que el uso de la CPU disminuye bruscamente.
Por lo tanto, si el sistema está <strong>hiperpaginando</strong>, es necesario reducir el <strong>grado de multiprogramación</strong> con el objetivo de liberar memoria.</p>
</div>
<div class="paragraph">
<p>En los sistemas operativos modernos ocurre algo parecido a lo descrito para los sistemas multiprogramados, aunque sin el efecto en cadena ocasionado por el intento del planificador de largo plazo de maximizar el uso de la CPU, ya que estos sistemas carecen de dicho planificador.
Sea como fuere, en ambos casos, los procesos <strong>hiperpaginan</strong> si no se les asigna un número suficiente de marcos, haciendo que sea imposible utilizarlos.</p>
</div>
</div>
<div class="sect3">
<h4 id="_soluciones_a_la_hiperpaginación">17.6.2. Soluciones a la hiperpaginación</h4>
<div class="paragraph">
<p>Para el problema de la <strong>hiperpaginación</strong> existen diversas soluciones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Utilizar un algoritmo de reemplazo local, pues de esta manera un proceso que <strong>hiperpagina</strong> no puede afectar a otro.</p>
<div class="paragraph">
<p>Sin embargo, esto no es cierto del todo.
El uso intensivo del <strong>dispositivo de intercambio</strong> podría afectar al rendimiento del sistema, al aumentar el <strong>tiempo de acceso efectivo</strong> al disco.</p>
</div>
</li>
<li>
<p>Proporcionar a un proceso tantos marcos como le hagan falta.
Como ya hemos comentados en diversas ocasiones, para evitar la <strong>hiperpaginación</strong> es necesario asignar al procesos al menos un número mínimos de marcos, que a priori no es conocido.
Una de las estrategias que pretenden estimar dicho número es el <strong>modelo de conjunto de trabajo</strong>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_modelo_del_conjunto_de_trabajo">17.6.3. Modelo del conjunto de trabajo</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Para entender el modelo de conjunto de trabajo es necesario comenzar definiendo el <strong>modelo de localidad</strong>.
El <strong>modelo de localidad</strong> establece que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Una <strong>localidad</strong> es un conjunto de páginas que se utilizan juntas.</p>
</li>
<li>
<p>Cuando un proceso se ejecuta, se va moviendo de una <strong>localidad</strong> a otra.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Por ejemplo, cuando se invoca una función se define una nueva <strong>localidad</strong>.
En esta <strong>localidad</strong> las referencias a la memoria se realizan: al código de la función, a las variables locales de la misma y a algunas variables globales del programa.</p>
</div>
<div class="paragraph">
<p>Supongamos que proporcionamos a un proceso suficientes marcos como para alojar toda su <strong>localidad</strong> en un momento dado.
Entonces, el proceso generará <strong>fallos de página</strong> hasta que todas las páginas de su <strong>localidad</strong> estén cargadas.
Después de eso no volverá a fallar hasta que no cambie a una nueva <strong>localidad</strong>.
Sin embargo, si damos al proceso menos marcos de los que necesita su <strong>localidad</strong>, éste <strong>hiperpaginará</strong>.</p>
</div>
<div class="paragraph">
<p>El <strong>modelo de conjunto de trabajo</strong> es una estrategia que permite obtener una aproximación de la <strong>localidad</strong> del programa y consiste en lo siguiente:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Definir el parámetro \$Delta\$ como el tamaño de la <strong>ventana del conjunto de trabajo</strong>.</p>
</li>
<li>
<p>En un instante dado, el conjunto de páginas presente en las \$Delta\$ últimas referencias a la memoria se consideran el <strong>conjunto de trabajo</strong>.</p>
</li>
<li>
<p>Por lo tanto, el <strong>conjunto de trabajo</strong> es una aproximación de <strong>localidad</strong> del programa.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Por ejemplo, dada la siguiente lista de referencias a páginas en la memoria:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="C17-memoria_virtual/media/modelo_de_conjunto_de_trabajo.svg" alt="modelo de conjunto de trabajo">
</div>
</div>
<div class="paragraph">
<p>si \$Delta = 10\$ referencias a la memoria, entonces el conjunto de trabajo en \$t_1\$ es \${1, 2, 5, 6, 7}\$.
Mientras que en \$t_2\$ el conjunto de trabajo es \${3, 4}\$.</p>
</div>
<div class="paragraph">
<p>Obviamente, la precisión del <strong>conjunto de trabajo</strong> como aproximación de la <strong>localidad</strong> del programa depende del parámetro \$Delta\$.
Por ejemplo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Si \$Delta\$ es muy pequeña, el <strong>conjunto de trabajo</strong> no cubriría toda la <strong>localidad</strong>.</p>
</li>
<li>
<p>Si \$Delta\$ es muy grande, el <strong>conjunto de trabajo</strong> se superpondría a varias <strong>localidades</strong>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_uso_del_conjunto_del_trabajo_para_evitar_la_hiperpaginación">17.6.4. Uso del conjunto del trabajo para evitar la hiperpaginación</h4>
<div class="paragraph">
<p>El uso del conjunto de trabajo es bastante sencillo:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Los diseñadores del sistema seleccionan \$Delta\$.</p>
</li>
<li>
<p>El sistema operativo monitoriza el <strong>conjunto de trabajo</strong> de cada proceso y le asigna tantos marcos como páginas haya en el <strong>conjunto de trabajo</strong>.</p>
</li>
<li>
<p>Si sobran suficientes marcos otro proceso puede ser iniciado —en el caso de los sistemas multiprogramados— o se puede destinar la memoria libre a otros usos.</p>
</li>
<li>
<p>Si el <strong>tamaño del conjunto de trabajo</strong> total \$WSS\$ crece y excede el número de marcos disponibles, el sistema podría seleccionar un proceso para ser suspendido.
Éste podrá volver a ser reiniciado más tarde.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Donde el <strong>tamaño del conjunto de trabajo</strong> \$WSS\$ es la suma del <strong>tamaño de los conjuntos de trabajo</strong> \$WSS_i\$ para cada proceso \$i\$:</p>
</div>
<div class="stemblock">
<div class="content">
\$WSS=sum WSS_i\$
</div>
</div>
<div class="paragraph">
<p>y representa la demanda total de marcos.
Por eso, si \$WSS\$ es mayor que el número de marcos disponibles, habrá <strong>hiperpaginación</strong>.</p>
</div>
<div class="paragraph">
<p>El sencillo algoritmo anterior permite evitar la <strong>hiperpaginación</strong>.
Sin embargo, el problema está en como mover la <strong>ventana del conjunto de trabajo</strong> en cada referencia, con el fin de volver a calcular el <strong>conjunto de trabajo</strong>.
Una posible aproximación sería utilizar un temporizador que periódicamente invocase a una función encargada de examinar el <strong>bit de referencia</strong> de las páginas en la ventana \$Delta\$.
Es de suponer que las páginas con el <strong>bit de referencia</strong> a 1 forman parte de la <strong>localidad</strong> del programa y por tanto serán el <strong>conjunto de trabajo</strong> a lo largo del siguiente periodo.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_otras_consideraciones">17.7. Otras consideraciones</h3>
<div class="paragraph">
<p>Ya hemos comentado que las principales decisiones que deben ser tomadas en el diseño de un sistema con <strong>paginación bajo demanda</strong> son la elección del <strong>algoritmo de reemplazo</strong> y la de la <strong>asignación de marcos de página</strong>.
Sin embargo, hay otras consideraciones que deben ser tenidas en cuenta.</p>
</div>
<div class="sect3">
<h4 id="_prepaginado">17.7.1. Prepaginado</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El <strong>prepaginado</strong> es una técnica que consiste en cargar múltiples páginas junto con la página demandada en cada <strong>fallo de página</strong>.</p>
</div>
<div class="paragraph">
<p>Esas otras páginas se escogen especulativamente bajo la hipótesis de que van a ser necesitadas por el proceso en un corto espacio de tiempo.
De manera que si la predicción es acertada, la <strong>tasa de fallos de página</strong> se reduce significativamente.
Esta técnica puede ser utiliza, por ejemplo, en las siguiente situaciones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En la <strong>paginación bajo demanda pura</strong>, el sistema sabe de antemano que cuando se inicia un proceso siempre fallan las primeras páginas de código, por lo que son buenas candidatas para el <strong>prepaginado</strong>.</p>
</li>
<li>
<p>En el acceso secuencial a <strong>archivos mapeados en memoria</strong>.</p>
<div class="paragraph">
<p>El sistema puede determinar que el acceso va ser de tipo secuencial, tanto mediante el uso de técnicas heurísticas como mediante las opciones indicadas por el proceso en la llamada al sistema con la que se abrió el archivo.</p>
</div>
<div class="paragraph">
<p>En cualquier caso, si el sistema determina que el acceso al archivo es secuencial, en cada <strong>fallo de página</strong> puede cargar tanto la página demanda como las siguientes, en previsión de que vayan a ser utilizas por el proceso.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>En general, el único inconveniente del <strong>prepaginado</strong> es que debe ser ajustado para que el coste del mismo sea inferior al de servir los <strong>fallos de página</strong>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_aplicaciones_en_modo_raw">17.7.2. Aplicaciones en modo RAW</h4>
<div class="paragraph">
<p>Algunas aplicaciones, cuando acceden sus datos a través de los mecanismos de memoria virtual del sistema operativo, ofrecen peor rendimiento del que conseguirían si este mecanismo no existiera.</p>
</div>
<div class="paragraph">
<p>El ejemplo típico, son los gestores de bases de datos, que conocen sus necesidades de memoria y disco mejor que cualquier sistema operativo de propósito general, por lo que salen beneficiadas si implementan sus propios algoritmos de gestión de la memoria y de <em>buffering</em> de E/S.</p>
</div>
<div class="paragraph">
<p>Por eso muchos sistemas operativos modernos permiten que los programas que lo soliciten puedan acceder a los discos en <strong>modo RAW</strong>.
En el <strong>modo RAW</strong> no hay sistema de archivos, ni paginación bajo demanda, ni bloqueo de archivos, ni prepaginación, ni muchos otros servicios del sistema operativo; por lo que dichas aplicaciones deben implementar sus propios algoritmos de almacenamiento y gestión de la memoria.</p>
</div>
<div class="paragraph">
<p>Sin embargo, hay que valorar muy bien las necesidades del programa antes de optar por este modo.
La mayor parte de las aplicaciones siempre funcionan mejor utilizando los servicios convencionales ofrecidos por el sistema operativo.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tamaño_de_las_páginas_2">17.7.3. Tamaño de las páginas</h4>
<div class="paragraph">
<p>Como ya comentamos al estudiar el método básico de paginación (véase el <a href="#_paginación">Capítulo 16</a>), una decisión de diseño importante es escoger el tamaño adecuado para las páginas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Con páginas grandes</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Se consiguen menos <strong>fallos de páginas</strong>.
Por ejemplo, en un caso extremo, un proceso de 100 KiB solo podría generar un <strong>fallo de página</strong> si cada página es de 100 KiB, pero puede generar 102400 fallos si cada pagina es de 1 byte.</p>
</li>
<li>
<p>Se consiguen tablas de páginas más pequeñas.</p>
</li>
<li>
<p>La E/S para acceder al contenido de cada página requiere menos tiempo.</p>
<div class="paragraph">
<p>En general el tiempo de transferencia es proporcional a la cantidad de información transferida, lo que debería beneficiar a los sistemas con páginas de pequeño tamaño.
Sin embargo, la latencia y el tiempo requerido para posicionar la cabeza lectora de los discos es muy superior al tiempo de transferencias de datos, por lo que es más eficiente tener menos transferencias de mayor tamaño —como cuando se usan páginas grandes— que más transferencias de menor tamaño —como cuando se usan páginas pequeñas—.</p>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Con páginas pequeñas</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Se consigue tener menos <strong>fragmentación interna</strong> y, por tanto, un mejor aprovechamiento de la memoria.</p>
</li>
<li>
<p>Teóricamente, se obtiene una mejor resolución para asignar y transferir al disco sólo la memoria que realmente necesitamos.
Esto a la larga debería redundar en menos memoria asignada y menos operaciones de E/S.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>En la actualidad, el tamaño de página más común es de 4 KiB en sistemas de 32 bits y 8 KiB en los de 64 bits, ya que son adecuados para la mayor parte de las aplicaciones.
Sin embargo, muchos sistemas modernos soportan el uso simultáneo de múltiples tamaños de página.
Esto permite que la mayor parte de las aplicaciones utilicen el tamaño estándar, mientras las que hacen un uso intensivo de la memoria —como es el caso de los gestores de bases de datos— puedan utilizar páginas de mayor tamaño.</p>
</div>
</div>
<div class="sect3">
<h4 id="_efecto_de_la_estructura_de_los_programas">17.7.4. Efecto de la estructura de los programas</h4>
<div class="paragraph">
<p>Los programas creados considerando la <strong>localidad de referencia</strong> pueden mejorar su rendimiento en los sistemas con <strong>paginación bajo demanda</strong>.</p>
</div>
<div class="paragraph">
<p>Vamos a ilustrarlo con el siguiente ejemplo de un programa que inicializa a 0 un <em>array</em> de 128 por 128 elementos.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="kt">char</span> <span class="n">data</span><span class="p">[][]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">128</span><span class="p">][</span><span class="mi">128</span><span class="p">];</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Un <em>array</em> como el indicado es almacenado en filas:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="p">...,</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">127</span><span class="p">]</span>
<span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="p">...,</span> <span class="n">data</span><span class="p">[</span><span class="mi">127</span><span class="p">][</span><span class="mi">127</span><span class="p">]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>De manera que si suponemos que el tamaño de cada página es de 128 bytes, en el mejor de los casos cada fila estará almacenada en una página.
Por lo tanto:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Si el sistema le asigna 128 marcos o más, el proceso solo generará 128 fallos de página.</p>
</li>
<li>
<p>Si el sistema operativo le asigna un solo marco, el proceso tendrá 16,384 fallos, aproximadamente.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Sin embargo, el ejemplo sería diferente si el bucle interno del programa recorriera las columnas del <em>array</em> y no las filas:</p>
</div>
<div class="paragraph">
<p>Pues se podrían a 0 primero todos los bytes de una misma página antes de empezar con la siguiente.
Esto reduciría el número de <strong>fallos de página</strong> a 128, aunque el sistema operativo sólo asigne un marco al proceso.</p>
</div>
<div class="paragraph">
<p>Por lo tanto se puede concluir que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La selección cuidadosa de las estructuras de datos y de programación pueden mejorar la <strong>localidad</strong>, reduciendo la <strong>tasa de fallos de páginas</strong> y el tamaño del <strong>conjunto de trabajo</strong>.
Por ejemplo, las estructuras de datos tipo pila tienen buena <strong>localidad</strong> puesto que el acceso siempre se realiza en lo alto de las mismas.
Sin embargo, las tablas de dispersión, obviamente, están diseñadas para dispersar las referencias, lo que produce una mala <strong>localidad</strong>.</p>
</li>
<li>
<p>La elección del lenguaje de programación también puede tener efecto.
En los lenguajes como C y C&#43;&#43; se utilizan punteros con frecuencia, lo que aleatoriza el acceso a la memoria, empeorando la <strong>localidad de referencia</strong>.
Además, algunos estudios indican que los lenguajes orientados a objetos tienden a tener peor <strong>localidad de referencia</strong> que los que no lo son.</p>
</li>
<li>
<p>El compilador y el cargador también pueden tener un efecto importante:</p>
<div class="ulist">
<ul>
<li>
<p>Separando el código de los datos para permitir que las páginas de código puedan ser de sólo lectura.
Esto es interesante porque las páginas no modificadas no tienen que ser escritas antes de ser reemplazadas.</p>
</li>
<li>
<p>El compilador puede colocar las funciones que se llaman entre sí en la misma página.</p>
</li>
<li>
<p>El cargador puede situar las funciones en la memoria de tal forma que en lo posible no crucen los bordes de las páginas.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_interbloqueo_de_es">17.7.5. Interbloqueo de E/S</h4>
<div class="paragraph">
<p>Supongamos que un proceso solicita una operación de E/S sobre el contenido de alguna de las páginas de su espacio de direcciones y que, antes de que la operación sea realizada, la página es reemplazada mientras el proceso está esperando.
En ese caso, la operación de E/S se podría acabar realizando sobre una página que pertenece a un proceso diferente.
Para evitarlo existen diversas soluciones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se puede utilizar la memoria del núcleo como búfer en las operaciones de E/S.</p>
<div class="paragraph">
<p>En una escritura, ésto obliga a la llamada al sistema a copiar los datos desde las páginas del proceso a la memoria del núcleo, antes de solicitar la operación de E/S.
Mientras que en las operaciones de lectura sería justo al contrario.</p>
</div>
</li>
<li>
<p>Cada página puede tener un <strong>bit de bloqueo</strong> que se utiliza para indicar qué páginas no pueden ser seleccionadas para reemplazo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Además los <strong>bits de bloqueo</strong> se pueden utilizar en otras muchas situaciones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Bloquear las páginas del núcleo para evitar que sean reemplazadas.</p>
</li>
<li>
<p>Bloquear las páginas que acaban de ser cargadas.</p>
<div class="paragraph">
<p>Ésto evita que un <strong>fallo de página</strong> en un proceso de mayor prioridad pueda reclamar el marco antes de que el proceso para el que se cargó la página originalmente sea reiniciado, desperdiciando el trabajo de cargarla y provocando un nuevo <strong>fallo de página</strong>.</p>
</div>
<div class="paragraph">
<p>Para implementarlo, se puede poner el <strong>bit de bloqueo</strong> a 1 cuando la página se carga, volviéndolo después a poner a 0 cuando el proceso es planificado por primera vez, tras el <strong>fallo de página</strong> que provocó la carga de la página.</p>
</div>
</li>
<li>
<p>En los sistemas con <strong>tiempo real flexible</strong>, se suele permitir que las tareas de tiempo real informen de cuáles son las páginas más importantes, con el fin de que sean bloqueadas para evitar que puedan ser reemplazadas.</p>
<div class="paragraph">
<p>Para evitar riesgos, el sistema suele considerar estas solicitudes como «consejos de bloqueo».
De esta manera el sistema es libre de descartar dichos consejos si el conjunto de marcos libres llega a ser demasiado pequeño o si un proceso pide bloquear demasiadas páginas.</p>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_interfaz_de_gestión_de_la_memoria">17.8. Interfaz de gestión de la memoria</h3>
<div class="paragraph">
<p>Gracias a la abstracción de las técnicas de memoria virtual —como la paginación bajo demanda—, desde el punto de vista de los procesos, en cualquier sistema moderno prácticamente sólo hace falta una llamada al sistema para gestionar su espacio de direcciones virtual.</p>
</div>
<div class="paragraph">
<p>En los sistemas POSIX esta llamada es <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a> y en Windows API es <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc()</a>, que se usan junto a sus opuestas <a href="https://man7.org/linux/man-pages/man2/munmap.2.html">munmap()</a> y <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualfree">VirtualFree()</a>, respectivamente.</p>
</div>
<div class="paragraph">
<p>Ambas funciones permiten:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Reservar una porción del espacio de direcciones virtual del proceso.</p>
<div class="paragraph">
<p>La llamada solo hace la reserva de un rango de direcciones para pueda ser utilizado por el proceso —es decir, que las páginas en ese rango sean válidas— siendo el componente de paginación bajo demanda, el responsable de asignar la memoria física que lo respalda, cuando el proceso acceda a esas direcciones.</p>
</div>
</li>
<li>
<p>Establecer permisos —lectura, escritura y ejecución—, opciones de compartición entre procesos, bloqueo de páginas en la memoria física, páginas de gran tamaño y otras opciones, en la región de memoria virtual a reservar.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Además, en los sistemas POSIX, <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a> se utiliza también para mapear archivos en regiones del espacio de direcciones virtual.
Mientras que en Windows API para esa función se utilizan llamadas diferentes, como hemos visto.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Ambas funciones ofrecen una buena cantidad de funcionalidades, pero operan a muy bajo nivel.
Por eso en ambas la página es la unidad mínima en la gestión de la memoria.
Es decir, las regiones reservadas del espacio de direcciones virtual, siempre deben comienzar en un borde de página y su tamaño debe ser múltiplo del tamaño de página.</p>
</div>
<div class="paragraph">
<p>El problema es cómo compatibilizar eso, con las necesidades reales de los programas, que durante su ejecución necesitan reservar y liberar constantemente memoria para pequeños elementos, como: <em>arrays</em>, cadenas de texto, estructuras u  objetos.
Para esos casos, utilizar directamente <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a> o <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc()</a> no es una solución, puesto que la fragmentación interna conllevaría un importante derroche de recursos.</p>
</div>
<div class="sect3">
<h4 id="_anatomía_del_espacio_de_direcciones_virtual_del_proceso">17.8.1. Anatomía del espacio de direcciones virtual del proceso</h4>
<div class="paragraph">
<p>Los procesos pueden utilizar diversas ubicaciones dentro de su espacio de direcciones virtual para almacenar los datos que necesitan para su ejecución (véase la <a href="#proceso_en_memoria_completo">Figura 53</a>):</p>
</div>
<div id="proceso_en_memoria_completo" class="imageblock">
<div class="content">
<img src="C17-memoria_virtual/media/proceso_en_memoria_completo.svg" alt="proceso en memoria completo">
</div>
<div class="title">Figura 53. Anatomía de un proceso en memoria.</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Las variables y constantes globales se almacenan en el <strong>segmento de datos</strong>, que tiene tamaño fijo, ya que las dimensiones de estas variables se conocen de antemano en tiempo de compilación, al igual que ocurre con el código del programa.</p>
</li>
<li>
<p>Las variables locales y los argumentos de las funciones se almacenan en la <strong>pila</strong>, junto con las direcciones de retorno para volver de las funciones.</p>
<div class="paragraph">
<p>Ésta es la ubicación ideal para ellos, puesto que al retornar de una función, la pila se restablece al estado previo al que tenía cuando se invocó dicha función, haciendo que las variables locales y argumentos desaparezcan automáticamente.</p>
</div>
</li>
<li>
<p>Las variables reservadas dinámicamente —por ejemplo, usando <a href="https://en.cppreference.com/w/c/memory/malloc">malloc()</a>/<a href="https://en.cppreference.com/w/c/memory/free">free()</a> en C o <a href="https://en.cppreference.com/w/cpp/language/new">new</a>/<a href="https://en.cppreference.com/w/cpp/language/delete">delete</a> en C&#43;&#43; o Java— se almacenan en el <strong>montón</strong>, que no es más una región continua de memoria ubicada inmediatamente después del <strong>segmento de datos</strong> del proceso.</p>
</li>
<li>
<p>En la región entre el <strong>montón</strong> y la <strong>pila</strong> se ubican los <strong>archivos mapeados en memoria</strong>, las regiones de <strong>memoria compartida</strong>, las <strong>librerías de enlace dinámico</strong>, las <strong>pilas</strong> de cada hilo —en procesos multihilo— y, en general, la memoria reservada con funciones como <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a> y <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc()</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Cada lenguaje de programación, debe proporcionar —a través de su <strong>librería estándar</strong>— un mecanismo en espacio de usuario, adecuado para la gestión en tiempo de ejecución de la memoria del <strong>montón</strong> del proceso.
Para eso, cada lenguaje puede utilizar su propia implementación de dicho mecanismo o bien recurrir a la proporcionada por la <strong>librería del sistema</strong>.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, en los sistemas POSIX, la <strong>librería del sistema</strong> proporciona su propia implementación, accesible a través de las funciones <a href="https://en.cppreference.com/w/c/memory/malloc">malloc()</a> y <a href="https://en.cppreference.com/w/c/memory/free">free()</a>, que es utilizada directamente por los programas escritos en C.
Esta implementación hace uso de <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a>, pero ofrece mayor control sobre la cantidad de memoria que podemos reservar, como veremos en el <a href="#_gestión_de_la_memoria_del_montón">Apartado 17.8.2</a>.</p>
</div>
<div class="paragraph">
<p>Otros lenguajes de programación tienen otras interfaces para gestionar la memoria, pero utilizan internamente las funciones <a href="https://en.cppreference.com/w/c/memory/malloc">malloc()</a> y <a href="https://en.cppreference.com/w/c/memory/free">free()</a> de la <strong>librería del sistema</strong>.
Sin embargo, este no es el caso ni de C&#43;&#43; ni de Java ni de algunos otros lenguajes.
En C&#43;&#43;, los operadores <a href="https://en.cppreference.com/w/cpp/language/new">new</a> y <a href="https://en.cppreference.com/w/cpp/language/delete">delete</a> utilizan sus propios algoritmos de gestión de la memoria del <strong>montón</strong>, más optimizados que <a href="https://en.cppreference.com/w/c/memory/malloc">malloc()</a> y <a href="https://en.cppreference.com/w/c/memory/free">free()</a> para la creación y destrucción de objetos de cualquier tamaño de manera eficiente.</p>
</div>
<div class="paragraph">
<p>En Windows API ocurre algo similar.
La <strong>librería del sistema</strong> proporciona su propia gestión de la memoria del <strong>montón</strong>, que es accesible para cualquier programa a través de las funciones <a href="https://docs.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heapalloc">HeapAlloc()</a> y <a href="https://docs.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heapfree">HeapFree()</a>, y que se implementa sobre <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc()</a>.
La <strong>librería estándar</strong> de C utiliza, a su vez, esas funciones para implementar <a href="https://en.cppreference.com/w/c/memory/malloc">malloc()</a> y <a href="https://en.cppreference.com/w/c/memory/free">free()</a>.
Lo mismo ocurre en otros lenguajes, aunque no en todos, ya que algunos optan por implementar algoritmos más eficientes para sus casos de uso directamente sobre <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc()</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_gestión_de_la_memoria_del_montón">17.8.2. Gestión de la memoria del montón</h4>
<div class="paragraph">
<p>Para ilustrar cómo se puede gestionar la memoria del <strong>montón</strong> utilizaremos como ejemplo el mecanismo empleado por la <strong>librería del sistema</strong> de los sistemas POSIX —accesible a través de las funciones <a href="https://en.cppreference.com/w/c/memory/malloc">malloc()</a> y <a href="https://en.cppreference.com/w/c/memory/free">free()</a>.
Sin embargo, es importante tener en cuenta que esta tarea se realiza de manera muy similar en las implementaciones de otros sistemas operativos y lenguajes de programación.</p>
</div>
<div class="paragraph">
<p>El funcionamiento básico de <a href="https://en.cppreference.com/w/c/memory/malloc">malloc()</a> sigue las siguiente reglas:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Cuando la memoria solicitada supera cierto umbral —128KB en sistemas GNU/Linux— es reservada directamente mediante la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a>.
Eso significa que las peticiones de gran tamaño realmente no consumen espacio del <strong>montón</strong>, si no que se reservan del hueco entre el <strong>montón</strong> y la <strong>pila</strong>.</p>
</li>
<li>
<p>Cuando un proceso hace una petición de memoria dinámica espera que el espacio ofrecido sea continuo en el espacio de direcciones virtual, por lo que la memoria del <strong>montón</strong> se gestiona usando un algoritmo de <strong>asignación contigua de memoria</strong> (véase <a href="#_asignación_contigua_de_memoria">Apartado 15.5</a>) y, puesto que las peticiones pueden ser de tamaño variable, se utiliza con un esquema de <strong>particionado dinámico</strong>.</p>
<div class="paragraph">
<p>Es decir, que para las peticiones que no entran en el caso anterior, se busca en la tabla de huecos libres y ocupados del <strong>montón</strong> uno lo suficientemente como grande para atender la petición.
Se asigna el espacio solicitado y el resto sigue marcado como hueco libre.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>La estrategia más común de búsqueda es el <strong>mejor ajuste</strong>, utilizando algún tipo de estructura de datos que mantenga los huecos libres ordenados por tamaño, para encontrar el de tamaño adecuado rápidamente.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Si no hay suficiente memoria libre contigua como para atender la petición, se utiliza la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a>, para extender el tamaño del <strong>montón</strong> reservando una nueva región separada —a veces llamada <strong>arena</strong>— y comenzar a repartirla.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En aplicaciones pequeñas, algunas implementaciones intentan ampliar primero el espacio libre utilizando la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/brk.2.html">brk()</a>, que sirve para extender el <strong>montón</strong> sobre la región adyacente no asignada del espacio de direcciones virtual del proceso.
Este es el caso de la implementación estándar de <a href="https://en.cppreference.com/w/c/memory/malloc">malloc()</a> en GNU/Linux.</p>
</div>
<div class="paragraph">
<p>La llamada al sistema <a href="https://man7.org/linux/man-pages/man2/brk.2.html">brk()</a> ha sido eliminada del estándar POSIX, pero algunos sistemas la mantienen por compatibilidad hacia atrás, dado que era la forma en la que tradicionalmente se ampliaba la memoria del <strong>montón</strong> en los primeros UNIX.
En macOS esta llamada se emula con una región de 4 MiB reservada con <strong>mmap</strong> la primer vez que se utiliza.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_fragmentación_2">17.8.3. Fragmentación</h4>
<div class="paragraph">
<p>Las estrategia comentada sufre de <strong>fragmentación interna</strong>.
En las peticiones grandes, <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a> reserva en múltiplos de tamaño de página, por lo que siempre se puede perder cierta cantidad, aunque pequeña en comparación al tamaño de la región reservada.
En las peticiones pequeñas, la memoria se asigna en múltiplos de una unidad mínima —por ejemplo, 16 o 32 bytes— por lo que también se puede perder cierta cantidad de memoria.</p>
</div>
<div class="paragraph">
<p>Además sufre de <strong>fragmentación externa</strong>, porque después de que el proceso lleva un tiempo en ejecución, liberando y reservando memoria, el espacio puede comenzar a quedar fraccionado en un gran número de pequeños huecos, obligando a la librería a buscar más espacio para el <strong>montón</strong>, aunque en suma haya suficiente espacio en los huecos libres.</p>
</div>
<div class="paragraph">
<p>Ésto, representa un reto para los desarrolladores de aplicaciones, que previsiblemente vayan a ejecutarse durante periodos muy largos de tiempo.
En esos casos, es común optar por librerías externas, que implementen gestores de memoria que fragmenten menos la memoria, o soluciones basadas en alguna forma de referencias indirectas y recolección de basura, para ocasionalmente poder compactar la memoria del <strong>montón</strong>.
Esto último, es lo que hace la máquina virtual de Java.</p>
</div>
</div>
</div>
</div>
</div>
<h1 id="_gestión_del_almacenamiento" class="sect0">Parte V: Gestión del almacenamiento</h1>
<div class="sect1">
<h2 id="_almacenamiento_secundario">18. Almacenamiento secundario</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>10 minutos</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_dispositivos_de_almacenamiento">18.1. Dispositivos de almacenamiento</h3>
<div class="paragraph">
<p>Los ordenadores pueden almacenar información en diferentes soportes de almacenamiento —por ejemplo, en discos magnéticos, DVD o memorias de estado sólido—.
Cada uno tiene propiedades físicas diferentes que pasamos a comentar brevemente a continuación.</p>
</div>
<div class="sect3">
<h4 id="_discos_magnéticos">18.1.1. Discos magnéticos</h4>
<div class="paragraph">
<p>Los discos magnéticos son el tipo principal de almacenamiento secundario, generalmente en la forma de lo que se denominan discos duros.</p>
</div>
<div id="disco_duro_físico" class="imageblock">
<div class="content">
<img src="C18-almacenamiento/media/disco_duro_físico.jpg" alt="disco duro físico">
</div>
<div class="title">Figura 54. Disco duro&#8201;&#8212;&#8201;Fuente: <a href="https://commons.wikimedia.org/wiki/File:Hard_Drive_(11644168395).jpg">Wikipedia</a></div>
</div>
<div class="paragraph">
<p>Tal y como se puede apreciar en la <a href="#disco_duro_físico">Figura 54</a> cada unidad está compuesta por una serie de platos de forma circular recubiertos de material magnético.
La información se almacena grabándola magnéticamente sobre los platos, para lo cual se utilizan unas cabezas de lectura que «flotan» tanto por encima como por debajo de cada plato.</p>
</div>
<div id="disco_duro_lógico" class="imageblock">
<div class="content">
<img src="C18-almacenamiento/media/disco_duro_lógico.svg" alt="disco duro lógico">
</div>
<div class="title">Figura 55. Estructura lógica de un disco magnético.</div>
</div>
<div class="paragraph">
<p>Desde el punto de vista lógico (véase la <a href="#disco_duro_lógico">Figura 55</a>) la superficie de cada plato está dividida en <strong>pista</strong> circulares, cada una de las cuales se subdivide en <strong>sectores</strong>.
El conjunto de pistas formado por todas aquellas que están situadas en la misma posición en los distintos platos se denomina <strong>cilindro</strong>.</p>
</div>
<div class="paragraph">
<p>En estos dispositivos consume mucho más tiempo mover la cabeza de lectura hasta el sector de interés, que la lectura y transferencia de los datos almacenados a la memoria RAM.
Por lo tanto, el tiempo de acceso aleatorio al disco es mucho mayor que el de acceso secuencial.</p>
</div>
</div>
<div class="sect3">
<h4 id="_discos_ópticos">18.1.2. Discos ópticos</h4>
<div class="paragraph">
<p>Los discos ópticos —CD, DVD, BluRay, o cualquier otro medio similar— consisten en un disco circular en el cual la información se almacena haciendo uso de surcos microscópicos, que se leen haciendo incidir un láser sobre una de las caras planas que lo componen.</p>
</div>
<div class="paragraph">
<p>En este tipo de discos la información se almacena siguiendo un recorrido continuo en espiral que cubre la superficie entera del disco, extendiéndose desde el interior hacia el exterior.
Dado que el láser siempre debe desplazarse sobre la espiral, el acceso aleatorio a los datos es más lento que con otras tecnologías de disco.</p>
</div>
</div>
<div class="sect3">
<h4 id="_memorias_de_estado_sólido">18.1.3. Memorias de estado sólido</h4>
<div class="paragraph">
<p>Una memoria de estado sólido —memoria USB o un SSD— es un dispositivo de almacenamiento que usa una memoria no volátil —como las <a href="https://es.wikipedia.org/wiki/Memoria_flash">memorias <em>flash</em></a>— para almacenar datos, en lugar de utilizar discos ópticos o magnéticos.</p>
</div>
<div class="paragraph">
<p>En este tipo de memorias la información se almacena como en un vector lineal de bytes, que se puede indexar aleatoriamente con la misma eficiencia con la que se accede secuencialmente —como ocurre con la memoria RAM—.
Sin embargo algunos dispositivos, de cara al resto del sistema informático, emulan una interfaz y un modo de direccionamiento similar al utilizado por los discos magnéticos —es decir, usando pistas, sectores y cilindros— por temas de compatibilidad.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_archivos_y_sistemas_de_archivos">18.2. Archivos y sistemas de archivos</h3>
<div class="paragraph">
<p>Teniendo en cuenta la gran diversidad de dispositivos de almacenamiento que existen, para que el sistema informático sea cómodo de utilizar, el sistema operativo proporciona una visión lógica uniforme de todos los sistemas de almacenamiento.
Es decir, abstrae las propiedades físicas de los dispositivos de almacenamiento para definir una unidad de almacenamiento lógico que sea útil para los usuarios.
Esta unidad es el <strong>archivo</strong>.</p>
</div>
<div class="paragraph">
<p>Un <strong>archivo</strong> o <strong>fichero</strong> es una colección de datos relacionados, identificados por un nombre, que es tratada por el sistema operativo como una unidad de información en el almacenamiento secundario.
Desde la perspectiva de los usuarios, un archivo es la unidad más pequeña de almacenamiento.
Es decir, los usuarios no pueden escribir datos en el almacenamiento secundario a menos que éstos se encuentren dentro de un archivo.</p>
</div>
<div class="paragraph">
<p>El sistema operativo puede ofrecer esta abstracción gracias al <strong>sistema de archivos</strong>.
Éste proporciona los mecanismos para el almacenamiento de los datos y programas en archivos, tanto del propio sistema operativo como los de todos los usuarios del sistema informático.</p>
</div>
<div class="paragraph">
<p>Los sistemas de archivos están compuestos de dos partes claramente diferenciadas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Una colección de archivos</strong>, cada una de las cuales almacena una serie de datos relacionados.</p>
</li>
<li>
<p><strong>Una colección de estructuras de metadatos</strong>, que contienen información relativa a los archivos almacenados —nombre, ubicación en el disco, permisos, entre otros— y que se encarga de organizarlos; generalmente haciendo uso de una estructura de directorios.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_volúmenes_de_datos">18.3. Volúmenes de datos</h3>
<div class="paragraph">
<p>Los dispositivos de almacenamiento comentados anteriormente pueden ser utilizados al 100% con un único sistema de archivos.
Sin embargo, en ocasiones es interesante hacer divisiones con el objeto de disponer de múltiples sistemas de archivos en el mismo dispositivo.
Cada una de esas divisiones es un <strong>volumen</strong>.</p>
</div>
<div class="paragraph">
<p>En otros casos interesa combinar divisiones o dispositivos de almacenamiento completos para crear espacios de mayor tamaño —también denominadas <strong>volúmenes</strong>— cada una de las cuales puede albergar un único sistema de archivos.
Así que en general, utilizaremos el término <strong>volumen</strong> para referirnos a un espacio de almacenamiento que alberga un sistema de archivos, tanto si ese espacio es una pequeña parte del espacio completo del dispositivo, como si se trata de una estructura de mayor tamaño compuesta a partir de varios dispositivos.</p>
</div>
<div class="paragraph">
<p>A continuación comentaremos brevemente las tecnologías utilizadas con mayor frecuencia para construir estos volúmenes.</p>
</div>
<div class="sect3">
<h4 id="_raid">18.3.1. RAID</h4>
<div class="paragraph">
<p>La tecnología <strong>RAID</strong> (<em>Redundant Array of Inexpensive Disks</em>) permite combinar varios discos duros para mejorar las prestaciones a través del paralelismo en el acceso o para mejorar la fiabilidad a través del almacenamiento de información redundante.
En concreto se definen diversos <strong>niveles RAID</strong>, de entre los cuales los más comunes son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En un <strong>conjunto RAID 0</strong> se distribuyen los datos equitativamente en bloques de tamaño fijo entrelazados entre dos o más discos, sin incluir ningún tipo de información redundante.
Esto permite leer y escribir más datos en el mismo tiempo, ya que se pueden enviar en paralelo peticiones a los distintos discos.
Sin embargo, la fiabilidad es inversamente proporcional al número de discos, ya que para que el conjunto falle basta con que lo haga cualquiera de ellos.</p>
</li>
<li>
<p>En un <strong>conjunto RAID 1</strong> se crea una copia exacta —en espejo— de los datos en dos o más discos.
El resultado es que, incluso con dos discos, se incrementa exponencialmente la fiabilidad respecto a tener uno solo, ya que para que el conjunto falle es necesario que lo hagan todos los discos.
Adicionalmente, el rendimiento en las operaciones de lectura se incrementa linealmente con el número de copias, ya que los datos están disponibles en todos los discos al mismo tiempo, por lo que se pueden balancear las operaciones de lectura entre todos ellos.</p>
</li>
<li>
<p>En un <strong>conjunto RAID 5</strong> se distribuyen los datos equitativamente en bloques de tamaño fijo entrelazados entre dos o más discos y se utiliza uno adicional para almacenar la información de paridad de los bloques de una misma división.
En RAID se denomina división o <em>stripe</em> a la serie de bloques consecutivos escogido cada uno de uno de los discos del conjunto.</p>
<div class="paragraph">
<p>El disco utilizado para almacenar el bloque de paridad cambia de forma escalonada de una división a la siguiente, de ahí que se diga que el bloque de paridad está distribuido.
Algunos aspectos adicionales a tener en cuenta son que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cada vez que se escribe un bloque de datos se debe actualizar el bloque de paridad.
Por lo tanto las escrituras en un conjunto RAID 5 son costosas en términos de operaciones de disco y tráfico.</p>
</li>
<li>
<p>Los bloques de paridad no se leen durante las lecturas de datos, ya que eso reduciría el rendimiento.
Sólo se hace en caso de que la lectura de un sector falle, puesto que el sector en la misma posición relativa dentro de cada uno de los otros bloques de datos de la división y en el bloque de paridad se pueden utilizar para reconstruir el sector erróneo.</p>
</li>
<li>
<p>En un conjunto RAID 5 el fallo de 2 discos provoca la pérdida completa de los datos.
Esto significa que aunque se pueden añadir discos de manera ilimitada, eso no suele ocurrir puesto que a más discos en el conjunto más probabilidad de que fallen dos de ellos.</p>
</li>
</ul>
</div>
</li>
<li>
<p>En un <strong>conjunto RAID 6</strong> se utiliza la misma estrategia que en RAID 5 pero en cada división hay dos bloques de paridad —en lugar de uno— en dos discos diferentes.
Esto permite que fallen hasta dos discos sin perder los datos.</p>
</li>
<li>
<p>En un conjunto con niveles anidados se combinan varios niveles RAID básicos como si fueran capas superpuestas.
Ejemplos típicos son:</p>
<div class="ulist">
<ul>
<li>
<p><strong>RAID 0+1</strong>, donde se hace un espejo de un conjunto RAID 0.</p>
</li>
<li>
<p><strong>RAID 1+0</strong> o <strong>RAID 10</strong>, donde diversos conjuntos en espejo se combina en un RAID 0, aumentando la capacidad total.</p>
</li>
<li>
<p><strong>RAID 50</strong>, donde diversos conjuntos RAID 5 se combinan en un RAID 0, aumentando también la capacidad total.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>La implementación de RAID es otra de las áreas donde existen diversas variantes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>RAID puede implementarse en el hardware de la controladora de disco, de tal forma que sólo los discos conectados a ésta pueden formar parte de un conjunto RAID determinado.
Esta solución es muy eficiente, especialmente cuando se utilizan niveles que requieren cálculo de la paridad, ya que se evita utilizar tiempo de CPU para ese trabajo.
Sin embargo, estas controladoras son notablemente más caras que las que carecen de soporte para RAID.</p>
</li>
<li>
<p>RAID puede implementarse dentro del sistema operativo en lo que se denomina el <strong>software de gestión de volúmenes</strong>.
En este caso las soluciones RAID con paridad son bastante lentas, por lo que normalmente sólo se soportan los niveles RAID 0, 1, 10 o 0+1.
Algunas controladoras de disco modernas que dicen venir con soporte RAID realmente implementan esta tecnología en software, a nivel del controlador de dispositivo, mientras que en el hardware sólo se implementan unas características de apoyo mínimas.
En algunos entornos se denomina a este tipo de implementaciones <em>fakeRAID</em> o <em>hostRAID</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Cada conjunto RAID se comporta como una unidad de almacenamiento independiente desde el punto de vista del resto del sistema, por lo que se puede utilizar entero para albergar un único sistema de archivos.
Sin embargo, lo más común es dividirlo en regiones con el objeto de utilizar múltiples sistemas de archivos o combinarlo en estructuras de mayor tamaño, para lo cuál se pueden utilizar alguna de las técnicas que veremos a continuación.</p>
</div>
</div>
<div class="sect3">
<h4 id="_particiones">18.3.2. Particiones</h4>
<div class="paragraph">
<p>Un disco, un conjunto RAID o cualquier otro dispositivo de almacenamiento se puede dividir en regiones para utilizar en cada una de ellas un sistema de archivos diferente.
A esas regiones se las conoce comúnmente como <strong>particiones</strong>, <strong>franjas</strong> o <strong>minidiscos</strong>.</p>
</div>
<div class="paragraph">
<p>Según la plataforma, existen diversas maneras de implementar el soporte de particiones.
Entre los sistemas de escritorio las tecnologías más difundidas y utilizadas son la <strong>MBR</strong> (<em>Master Boot Record</em>) y la <strong>GPT</strong> (<em>GUID Partition Table</em>).
En ambas se almacena, en los primeros sectores del dispositivo de almacenamiento, una tabla con una entrada por partición donde se guardan las direcciones del primer y último sector de cada una de ellas en el dispositivo, así como otra información.
Eso es todo lo que necesita el sistema operativo para determinar los límites de la región ocupada por cada sistema de archivos.</p>
</div>
</div>
<div class="sect3">
<h4 id="_volúmenes_dinámicos">18.3.3. Volúmenes dinámicos</h4>
<div class="paragraph">
<p>Según la tecnología que se utilice para particionar es posible encontrarse con una serie de restricciones comunes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Limitado número de particiones que puede contener un mismo dispositivo.</p>
</li>
<li>
<p>Limitaciones o imposibilidad de redimensionar las particiones.
Especialmente si el sistema operativo está en ejecución.</p>
</li>
<li>
<p>La imposibilidad de crear particiones que hagan uso de regiones libres en diferentes dispositivos de almacenamiento.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Para resolverlo, algunos sistemas operativos incluyen un <strong>software de gestión de volúmenes</strong> que hace uso de tecnología propia para superar estas limitaciones.
Estas herramientas generalmente permiten agrupar dispositivos completos, conjuntos RAID, particiones, etc. y sobre ellos construir los volúmenes que sean necesarios.
Estos volúmenes pueden ser redimensionados —en ocasiones sin tener que detener la ejecución del sistema operativo— y en caso de que haga falta se pueden incluir dinámicamente nuevos dispositivos para incrementar el espacio disponible.
Además, como ya hemos comentado, el software de gestión de volúmenes puede incluir alguna funcionalidad propia de conjuntos RAID, con el objeto de mejorar las prestaciones, a través del paralelismo en el acceso, o mejorar la fiabilidad, a través del almacenamiento de información redundante.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sistemas_de_archivos">19. Sistemas de archivos</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>54 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Como hemos comentado, cada volumen puede albergar un sistema de archivos.
A continuación estudiaremos los elementos más comunes a la mayor parte de los sistemas de archivos actuales.</p>
</div>
<div class="sect2">
<h3 id="_estructura_de_un_sistema_de_archivos">19.1. Estructura de un sistema de archivos</h3>
<div id="estructura_sistema_de_archivos" class="imageblock">
<div class="content">
<img src="C19-sistema_de_archivos/media/estructura_sistema_de_archivos.svg" alt="estructura sistema de archivos">
</div>
<div class="title">Figura 56. Estructura de un sistema de archivos.</div>
</div>
<div class="paragraph">
<p>Los sistema de archivos son un componente complejo, por lo que suelen estar compuesto de varios niveles diferentes.
En la <a href="#estructura_sistema_de_archivos">Figura 56</a> se muestra un ejemplo típico de la estructura de un sistema de archivos diseñado en niveles.
Cada nivel utiliza las funciones de los niveles inferiores y proporciona nuevas funciones a los niveles superiores.</p>
</div>
<div class="sect3">
<h4 id="_control_de_es">19.1.1. Control de E/S</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>En el nivel más bajo, accediendo directamente a los dispositivos de almacenamiento, se encuentra el <strong>control de E/S</strong>.</p>
</div>
<div class="paragraph">
<p>Contiene los controladores de dispositivo encargados de transferir la información entre la memoria principal y el disco.
Estos controladores, que generalmente son compartidos entre los distintos sistemas de archivos, transfieren los datos en unidades de <strong>bloques</strong> —en lugar de transferir un byte cada vez— para mejorar la eficiencia.
Cada _*bloque* está formado por uno o más sectores.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Dependiendo de la unidad de disco, los sectores pueden tener tamaños de entre 32 bytes y 4096 bytes.
Lo más común es que su tamaño sea de 512 bytes.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_sistema_básico_de_archivos">19.1.2. Sistema básico de archivos</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El <strong>sistema básico de archivos</strong> se encarga de enviar comandos genéricos al controlador de dispositivo apropiado, con el fin de leer y escribir bloques físicos en el disco.
Cada bloque físico se identifica mediante su dirección de disco numérica.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, en dispositivos que usan direccionamiento de tipo cabeza-cilindro-sector (CHS), la dirección de un sector podría ser: unidad 1, cilindro 73, cabeza 2, sector 10.
Mientras que en dispositivos que admiten direccionamiento LBA (<em>Logical Block Addressing</em>), la dirección de un sector podría ser: unidad 1, sector 4691123.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>El <strong>LBA</strong> es un método común para especificar la localización de los sectores de un disco.
Usa un esquema de direccionamiento lineal, donde cada sector es identificado con un número entero único.
Antes de este método, se usaba el de cabeza-cilindro-sector (CHS), pero tenía la desventaja de hacer públicos los detalles físicos del dispositivo de almacenamiento.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_módulo_de_organización_de_archivos">19.1.3. Módulo de organización de archivos</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El <strong>módulo de organización de archivos</strong> tiene conocimiento de los archivos y se encarga de traducir las direcciones lógicas de los bloques en los archivos —es decir, posición del bloque dentro del archivo, siendo 0 la dirección del primer bloque— en las direcciones físicas de bloque —por ejemplo, cilindro, cabeza y sector del bloque correspondiente en el dispositivo de almacenamiento— que serán enviadas al <strong>sistema básico de archivos</strong> para que realice las transferencias solicitadas.</p>
</div>
<div class="paragraph">
<p>Los bloques lógicos de cada archivo son numerados de 0 a <em>N</em>, pero los bloques físicos asignados a estos bloques lógicos no tienen porqué coincidir en los números de bloque.
Por eso, el <strong>módulo de organización de archivos</strong> debe utilizar la ubicación del contenido del archivo en el disco y la información sobre los bloques físicos asignados, para traducir las direcciones lógicas en direcciones físicas.</p>
</div>
<div class="paragraph">
<p>Además, el módulo de organización, incluye el gestor de espacio libre, que controla los bloques no asignados y proporciona dichos bloques cuando el <strong>módulo de organización de archivos</strong> lo necesita, ya sea para crear un archivo nuevo o para extender uno existente.</p>
</div>
</div>
<div class="sect3">
<h4 id="_sistema_lógico_de_archivos">19.1.4. Sistema lógico de archivos</h4>
<div class="paragraph">
<p>El <strong>sistema lógico de archivos</strong> gestiona los <strong>metadatos</strong>.
En los <strong>metadatos</strong> se incluye toda la estructura del sistema de archivos, excepto los propios datos de los archivos.</p>
</div>
<div class="paragraph">
<p>Entre dichos <strong>metadatos</strong> está la <strong>estructura de directorios</strong> y los <strong>bloques de control de archivo</strong>.
Un <strong>bloque de control de archivo</strong> o <strong>FCB</strong> (<em>File Control Block</em>) contiene información acerca del archivo, incluyendo su propietario, los permisos y la ubicación del contenido del mismo.</p>
</div>
<div class="paragraph">
<p>Además, el <strong>sistema lógico de archivos</strong> también es responsable de las tareas de protección y seguridad.</p>
</div>
<div class="paragraph">
<p>Cada sistema operativo puede soportar uno o más sistemas de archivos para dispositivos de disco.
Por ejemplo, en los sistemas UNIX se utiliza el  «sistema de archivos UNIX» o <a href="https://es.wikipedia.org/wiki/Unix_File_System">UFS</a> (<em>UNIX File System</em>), que está basado en el sistema <a href="https://es.wikipedia.org/wiki/Berkeley_Fast_File_System">FFS</a> (<em>Fast File System</em>) de la Universidad de Berkeley.
Microsoft Windows soporta los sistemas de archivo <a href="https://es.wikipedia.org/wiki/Tabla_de_asignaci%C3%B3n_de_archivos">FAT</a> (<em>File Allocation Table</em>), <a href="https://es.wikipedia.org/w/index.php?title=FAT32">FAT32</a> y <a href="https://es.wikipedia.org/wiki/NTFS">NTFS</a> (<em>NT File System</em>).
En Linux se soportan más de cuarenta sistemas de archivo, entre los que cabe destacar: la familia <em>extended filesystem</em> —
<a href="https://es.wikipedia.org/wiki/Ext2">ext2</a>, <a href="https://es.wikipedia.org/wiki/Ext3">ext3</a> y <a href="https://es.wikipedia.org/wiki/Ext4">ext4</a>— <a href="https://es.wikipedia.org/wiki/XFS">XFS</a> y <a href="https://es.wikipedia.org/wiki/Btrfs">Btrfs</a>.</p>
</div>
<div class="paragraph">
<p>Además, la mayoría de los sistemas operativos modernos soportan otros sistemas de archivo, como los utilizados en los soportes removibles.
Por ejemplo el <a href="https://es.wikipedia.org/wiki/ISO_9660">ISO 9660</a>, utilizado por la mayor parte de los CD-ROM, o el <a href="https://es.wikipedia.org/wiki/Universal_Disk_Format">UDF</a> (<em>Universal Disk Format</em>), utilizado por los DVD-ROM y Blu-ray.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_estructuras_de_metadatos_en_disco">19.2. Estructuras de metadatos en disco</h3>
<div class="paragraph">
<p>Para implementar un sistema de archivos se utilizan diversas estructuras de <strong>metadatos</strong> alojadas tanto en el disco como en la memoria.
Estas estructuras varían dependiendo del sistema operativo y del sistema de archivos.
Sin embargo, a continuación intentaremos describir brevemente las estructuras en disco más comunes.</p>
</div>
<div class="sect3">
<h4 id="_bloque_de_control_de_arranque">19.2.1. Bloque de control de arranque</h4>
<div class="paragraph">
<p>

</p>
</div>
<div class="paragraph">
<p>En todo sistema de archivos suele haber un <strong>bloque de control de arranque</strong> —también llamado <strong>bloque de inicio</strong> o <strong>sector de arranque</strong>— que suele ocupar el primer bloque de cada volumen y que contiene la información necesaria para iniciar un sistema operativo a partir de dicho volumen.</p>
</div>
<div class="paragraph">
<p>Este bloque puede estar vacío, si el volumen no contiene un sistema operativo.</p>
</div>
</div>
<div class="sect3">
<h4 id="_bloque_de_control_de_volumen">19.2.2. Bloque de control de volumen</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El <strong>bloque de control de volumen</strong> contiene todos los detalles acerca del volumen.
Por ejemplo, el número máximo de bloques, el tamaño de los bloques, el número de bloques libres y punteros a los mismos; así como un contador de bloques de información <strong>FCB</strong> ocupados y punteros a estos.</p>
</div>
<div class="paragraph">
<p>A esta estructura se la denomina <strong>superbloque</strong>, en los sistemas de archivos de sistemas UNIX y Linux.
Mientras que en <a href="https://es.wikipedia.org/wiki/NTFS">NTFS</a> esta información se almacena en la <strong>tabla maestra de archivos</strong> o <strong>MFT</strong> (<em>Master File Table</em>).</p>
</div>
</div>
<div class="sect3">
<h4 id="_bloque_de_control_de_archivo">19.2.3. Bloque de control de archivo</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Todo sistema de archivos tiene un <strong>bloque de control de archivo</strong> o <strong>FCB</strong> (<em>File Control Block</em>) por archivo, en que se almacenan numerosos detalles sobre cada uno de los archivos
Por ejemplo, los permisos, el propietario, el tamaño y la ubicación de los bloques de datos, entre otros.</p>
</div>
<div class="paragraph">
<p>En términos generales, todos los <strong>FCB</strong> del sistema de archivos se almacenan en una tabla denominada <strong>directorio de dispositivo</strong> o <strong>tabla de contenidos del volumen</strong>.</p>
</div>
<div class="paragraph">
<p>En los sistemas de archivos de sistemas UNIX y Linux cada FCB se denomina <strong>inodo</strong> y se almacenan a continuación del <strong>superbloque</strong>.
En <a href="https://es.wikipedia.org/wiki/NTFS">NTFS</a> esta información se almacena en la <strong>MFT</strong>, ya que cada entrada de dicha tabla es un <strong>FCB</strong>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_estructura_de_directorios">19.2.4. Estructura de directorios</h4>
<div class="paragraph">
<p>Finalmente, por lo general los sistemas de archivos tienen una estructura de directorios, para organizar los archivos.</p>
</div>
<div class="paragraph">
<p>En los sistemas de archivos de sistemas UNIX y Linux, cada directorio es como un archivo especial que almacena los nombres de los archivos que contiene y los índices de los <strong>inodos</strong> de cada uno de ellos.
En <a href="https://es.wikipedia.org/wiki/NTFS">NTFS</a> es similar, aunque la estructura de directorios completa se almacena en la propia <strong>MFT</strong>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_estructuras_de_metadatos_en_memoria">19.3. Estructuras de metadatos en memoria</h3>
<div class="paragraph">
<p>La información almacenada en memoria se utiliza tanto para la gestión del sistema de archivos como para mejorar el rendimiento del mismo mediante mecanismos de caché.</p>
</div>
<div class="paragraph">
<p>Los datos se cargan en el momento de comenzar a utilizar el sistema de archivos —proceso denominado montaje— y se descartan cuando se va a dejar de hacer uso del mismo —es decir, en el desmontaje—.</p>
</div>
<div class="paragraph">
<p>Las estructuras existentes en la memoria pueden incluir las que a continuación se describen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Una <strong>tabla de montaje</strong> en memoria que contiene información acerca de cada volumen montado en el sistema.</p>
</li>
<li>
<p>Una caché en memoria de la <strong>estructura de directorios</strong> que almacena la información relativa a los directorios a los que se ha accedido recientemente.
Los directorios que actúan como puntos de montaje pueden contener un puntero a la entrada, en la tabla de montaje, del volumen montado en el directorio.</p>
</li>
<li>
<p>La <strong>tabla global de archivos abiertos</strong> que contiene una copia del <strong>FCB</strong> de cada archivo abierto en el sistema, además de otras informaciones.</p>
</li>
<li>
<p>La <strong>tabla de archivos abiertos</strong> de cada proceso.
El <strong>PCB</strong> de cada proceso contiene una tabla donde se listan los archivos abiertos por el proceso.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>La <strong>tabla de archivos abiertos</strong> contiene, para cada archivo, un puntero a la entrada correspondiente del mismo archivo en la tabla global de archivos abiertos, pero también guarda otras informaciones adicionales que son particulares de cada proceso.
Por ejemplo, si el proceso lo ha abierto para lectura o escritura o la posición del puntero que indica la siguiente posición a leer o escribir.</p>
</div>
</div>
<div class="sect2">
<h3 id="_montaje_de_sistemas_de_archivos">19.4. Montaje de sistemas de archivos</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Un sistema de archivos debe <strong>montarse</strong> para que sus archivos sean accesibles a los procesos del sistema.
El proceso de montaje incluye los siguientes pasos:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Al sistema operativo se le debe proporcionar el nombre o identificador del dispositivo y el punto de montaje.
El <strong></strong> es la ubicación dentro de la estructura de directorios —la ruta al directorio concreto— a la que queremos conectar el sistema de archivos.
Después de que el proceso de montaje se haya completado, los archivos y directorios del sistema de archivos montado serán accesibles como descendientes del directorio del <strong>punto de montaje</strong>.</p>
</li>
<li>
<p>A continuación el sistema operativo verifica que el dispositivo contiene un sistema de archivos válido.
Para ello lee el <strong>bloque de control de volumen</strong> y comprueba que tiene un formato válido.</p>
</li>
<li>
<p>Finalmente el sistema operativo registra en la <strong>tabla de montaje</strong> el tipo de sistema de archivos y el identificador del dispositivo montado.
Después, almacena el índice de la entrada correspondiente en la <strong>tabla de montaje</strong> en la copia en memoria del <strong>FCB</strong> del directorio que hace de <strong>punto de montaje</strong>.</p>
<div class="paragraph">
<p>Esto permite que pueda ser recorrida la estructura de directorios de distintos sistemas de archivos, pasando de uno a otro de forma transparente, según sea necesario.</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>En muchos sistemas operativos modernos, el montaje se ejecuta automáticamente cuando los dispositivos son detectados durante el arranque del sistema o cuando se conectan durante el funcionamiento del mismo —por ejemplo, cuando se inserta un medio en la unidad CD-ROM o se pincha una memoria flash en un puerto USB—.
En algunos se permite, además, que el administrador del equipo ejecute operaciones de montaje manuales.</p>
</div>
</div>
<div class="sect2">
<h3 id="_archivos">19.5. Archivos</h3>
<div class="paragraph">
<p>Cada sistema de archivos almacena en disco una tabla donde cada entrada guarda un <strong>bloque de control de archivo</strong> o <strong>FCB</strong> (<em>File Control Block</em>) por archivo.
Concretamente, en cada <strong>FCB</strong> se almacena diversa información acerca del archivo al que representa.</p>
</div>
<div class="sect3">
<h4 id="_atributos_de_archivos">19.5.1. Atributos de archivos</h4>
<div class="paragraph">
<p>La colección de atributos asociada a un archivo varía de un sistema operativo a otro, pero típicamente son los siguientes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Nombre</strong>.
Nombre simbólico del archivo, que se mantiene en un formato legible por la conveniencia de los usuarios.</p>
</li>
<li>
<p><strong>Identificador</strong>.
Identifica de forma unívoca el archivo dentro del sistema de archivos.
Generalmente es el índice del <strong>FCB</strong> en la <strong>tabla de contenidos del volumen</strong>, donde se almacenan los <strong>FCB</strong>.</p>
</li>
<li>
<p><strong>Tipo</strong>.
Es un atributo necesario en los sistemas que soportan diferentes tipos de archivos.</p>
</li>
<li>
<p><strong>Ubicación</strong>.
Es un puntero a un dispositivo y a la ubicación de los bloques con los datos del archivo dentro del mismo.</p>
</li>
<li>
<p><strong>Tamaño</strong>.
Indica el tamaño actual de archivo —en bytes, palabras o bloques— y, posiblemente, el tamaño máximo permitido.</p>
</li>
<li>
<p><strong>Protección</strong>.
Información de control de acceso que determina quién puede leerlo, escribirlo, ejecutarlo, etc.</p>
</li>
<li>
<p><strong>Fecha, hora e identificación del usuario</strong>.
Esta información puede mantenerse para los sucesos de creación, de última modificación y último uso del archivo.
Puede resultar útil para la protección, seguridad y monitorización del uso del archivo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Los atributos de los archivos se almacenan en las estructuras de <strong>metadatos</strong>.</p>
</div>
<div class="paragraph">
<p>Normalmente el nombre se almacena en la estructura de directorios, de tal manera que una entrada de directorio está compuesta del nombre de un archivo y del identificador de su <strong>FCB</strong>.
Dicho identificador permite localizar el <strong>FCB</strong> en la <strong>tabla de contenidos del volumen</strong>, que contiene el resto de los atributos del archivo.</p>
</div>
</div>
<div class="sect3">
<h4 id="_operaciones_con_los_archivos">19.5.2. Operaciones con los archivos</h4>
<div class="paragraph">
<p>Un archivo es un tipo abstracto de datos sobre el que pueden realizarse diversas operaciones.
Concretamente el sistema operativo proporciona llamadas al sistema para: crear, abrir, escribir, leer, reposicionar el puntero de lectura/escritura, borrar y truncar o redimensionar archivos.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Generalmente el sistema mantiene un puntero de lectura/escritura que hace referencia a la ubicación dentro del archivo en la que debe tener lugar la siguiente operación.
Este puntero se actualiza, avanzando cada vez que se realiza un nueva lectura/escritura.</p>
</div>
<div class="paragraph">
<p>Para desplazarse aleatoriamente por el archivo, el sistema operativo debe ofrecer una llamada al sistema que permita reposicionar el puntero allí donde interese.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Muchos sistemas también disponen de operaciones para consultar y modificar diversos atributos de un archivo, como la longitud o el propietario del mismo.
Además, se suelen incluir llamadas para otras operaciones comunes, como añadir datos al final de un archivo o el renombrado de un archivo existente.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 14. Funciones de la API para manipular archivos.</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">POSIX API</th>
<th class="tableblock halign-left valign-top">Windows API</th>
</tr>
</thead>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Crear archivos</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a> / <a href="https://man7.org/linux/man-pages/man2/openat.2.html">openat()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Abrir archivos</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a> / <a href="https://man7.org/linux/man-pages/man2/openat.2.html">openat()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-openfile">OpenFile()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Cerrar archivos</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/close.2.html">close()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle">CloseHandle()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Borrar archivos</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/unlink.2.html">unlink()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-deletefilea">DeleteFile()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Leer contenidos</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile">ReadFile()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Escribir contenido</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile">WriteFile()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Reposicionar puntero de lectura/escritura</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.man7.org/linux/man-pages/man2/lseek.2.html">lseek()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfilepointer">SetFilePointer()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Redimensionar archivos</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://linux.die.net/man/2/ftruncate">ftruncate()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setendoffile">SetEndOfFile()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Consultar atributos</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/stat.2.html">stat()</a> / <a href="https://man7.org/linux/man-pages/man2/fstat.2.html">fstat()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfileattributesa">GetFileAttributes()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Renombrar archivos</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/rename.2.html">rename()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-movefile">MoveFile()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Copiar archivos</p></th>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-movefile">MoveFile()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Mover archivos</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/rename.2.html">rename()</a> <span class="lightcell">solo en el mismo sistema de archivos</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-copyfile">CopyFile()</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Estas operaciones primitivas puede combinarse, a su vez, para realizar otras operaciones más complejas —por ejemplo, crear una copia de un archivo o moverlo a otro lugar de la estructura de directorios—.</p>
</div>
</div>
<div class="sect3">
<h4 id="_abrir_archivos">19.5.3. Abrir archivos</h4>
<div class="paragraph">
<p>La mayor parte de las operaciones comentadas implican realizar una búsqueda en el directorio para encontrar la entrada asociada con el archivo cuyo nombre se ha indicado.
Para evitar realizar está búsqueda una yo otra vez, muchos sistemas requieren que el proceso haga una llamada al sistema <strong>open</strong>, antes de realizar cualquiera de estas operaciones por primera vez sobre un archivo.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En unos pocos sistemas, los archivos se abren automáticamente cuando un proceso solicita su primera operación sobre los mismos y se cierran cuando el proceso termina.
Sin embargo lo más común es que los procesos tengan que abrir los archivos explícitamente.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>En concreto la operación <strong>open</strong>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Busca en el directorio el nombre del archivo, hasta encontrar la entrada asociada y recupera el identificador del mismo.</p>
</li>
<li>
<p>Utiliza el identificador del archivo para recuperar el <strong>FCB</strong> correspondiente.</p>
</li>
<li>
<p>Crea una entrada para el archivo en la <strong>tabla de archivos abiertos</strong> donde se almacena la información del FCB.</p>
</li>
<li>
<p>Retorna al proceso devolviendo un identificador —en forma de puntero o de índice— a la nueva entrada en la tabla de archivos abiertos.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>El nombre con el que se designa a esas entradas en la tabla de archivos abiertos varía de unos sistemas operativos a otros.
En los sistemas POSIX se utiliza el término <strong>descriptor de archivo</strong> —o <em>file descriptor</em>— mientras que en los sistemas Microsoft Windows se prefiere el término <strong>manejador de archivo</strong> —o <em>file handler</em>—.</p>
</div>
<div class="paragraph">
<p>Después de utilizar la llamada al sistema <strong>open</strong>, cuando se desea solicitar una operación sobre un archivo, sólo es necesario proporcionar el identificador devuelto, evitando así que haga falta realizar nuevamente la exploración del directorio para buscar el archivo.</p>
</div>
<div class="paragraph">
<p>En los sistemas operativos donde varios procesos pueden abrir un mismo archivo, se suelen utilizar dos niveles de tablas de archivos abiertos:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Una <strong>tabla para cada proceso</strong> —almacenada en el <strong>PCB</strong>— donde se indican todos los archivos que el proceso tiene abiertos.</p>
<div class="paragraph">
<p>En dicha tabla se almacena toda la información referente al uso de cada archivo por parte de un proceso.
Por ejemplo, se puede almacenar la posición actual utilizada por las operaciones de lectura y escritura o los derechos de acceso.</p>
</div>
</li>
<li>
<p>Una <strong>tabla global para todo el sistema</strong> donde se almacena toda la información independiente de los procesos, como la ubicación del archivo en el disco, las fechas de acceso y el tamaño del archivo.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Cuando un proceso invoca la llamada <strong>open</strong>, se añade una entrada en la <strong>tabla de archivos abiertos del proceso</strong>, que a su vez apunta a la entrada correspondiente dentro de la <strong>tabla global del sistema</strong>.
Si el archivo no existe en esta última, también hay que crear una entrada en la tabla global del sistema haciendo uso de la información contenida en disco en el <strong>FCB</strong> correspondiente.</p>
</div>
<div class="paragraph">
<p>Es muy común, que la <strong>tabla global</strong> almacene un <strong>contador de aperturas</strong> para cada archivo, con el objetivo de indicar cuantos procesos lo mantienen abierto.</p>
</div>
<div class="paragraph">
<p>Cuando el archivo deja de ser utilizado activamente por el proceso, puede ser cerrado utilizado la llamada al sistema <strong>close</strong>.
Entonces el <strong>contador de aperturas</strong> se decrementa, de forma que cuando alcance cero querrá decir que la entrada puede ser eliminada de la <strong>tabla global de archivos abiertos</strong>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tipos_de_archivo">19.5.4. Tipos de archivo</h4>
<div class="paragraph">
<p>Cuando se diseña un sistema operativo es necesario considerar si debe reconocer y soportar el concepto de <strong>tipo de archivo</strong>.
Si el sistema operativo reconoce el <strong>tipo de un archivo</strong> puede operar con el mismo de formas razonables.
Por ejemplo, el sistema puede impedir que un usuario intente imprimir los archivos que contienen programas en formato binario, pues el documento impreso sería ininteligible.</p>
</div>
<div class="paragraph">
<p>En los sistemas operativos más comunes las técnicas utilizadas para implementar los tipos de archivo son las siguientes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En MS-DOS y Microsoft Windows el tipo de archivo se incluye como parte del nombre del archivo.
Es decir, el nombre se divide en dos partes: un nombre y una extensión, separadas por un punto.</p>
<div class="paragraph">
<p>El sistema puede utilizar la extensión para conocer el tipo de archivo y el tipo de operaciones que se pueden realizar con el mismo.</p>
</div>
</li>
<li>
<p>En macOS cada archivo tiene un atributo que almacena el tipo —por ejemplo, TEXT para los archivos de texto o APPL para las aplicaciones— y otro que contiene el nombre del programa que lo creó.
Cuando el usuario hace clic con el ratón sobre el icono de un archivo, el programa que lo creó se ejecuta automáticamente y éste abre el archivo.</p>
</li>
<li>
<p>En los sistemas estilo UNIX se utiliza un <strong>número mágico</strong>, almacenado al principio de algunos archivos, para indicar el tipo del mismo.
No todos los archivos tienen números mágicos, por lo que se permite hacer sugerencias en forma de extensiones del nombre del archivo.</p>
<div class="paragraph">
<p>Sin embargo, en estos sistemas estas extensiones ni son obligatorias ni el sistema depende de ellas.
Su objetivo, fundamentalmente, es ayudar a los usuarios a determinar el tipo de contenido de un archivo, por lo que pueden ser utilizadas o ignoradas por cada aplicación concreta, en función de las preferencias de sus desarrolladores.</p>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_estructura_de_directorios_2">19.6. Estructura de directorios</h3>
<div class="paragraph">
<p>Algunos sistemas de archivos pueden almacenar millones de archivos en terabytes de disco.
Para gestionar todos esos datos necesitamos organizarlos de alguna manera, lo que generalmente implica el uso de directorios.</p>
</div>
<div class="paragraph">
<p>Un <strong>directorio</strong> puede considerarse una tabla de símbolos que traduce los nombre de los archivos en los identificadores que permiten recuperar sus correspondientes entradas en la <strong>tabla de contenidos del volumen</strong>, donde se almacenan los <strong>FCB</strong>.</p>
</div>
<div class="paragraph">
<p>A continuación vamos a estudiar los diversos esquemas para definir la estructura lógica del sistema de directorios.</p>
</div>
<div class="sect3">
<h4 id="_directorios_de_un_nivel">19.6.1. Directorios de un nivel</h4>
<div class="paragraph">
<p>En la estructura de directorios de un nivel todos los archivos están contenidos en un único directorio.</p>
</div>
<div class="paragraph">
<p>Esto presenta algunas limitaciones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cuando el número de usuarios del sistema aumenta se hace más difícil que cada uno escoja nombres diferentes para sus archivos.
Esto es necesario, puesto que todos los archivos se encuentran en el mismo directorio.</p>
</li>
<li>
<p>Incluso en los sistemas operativos monousuario, puede ser difícil para un usuario mantener organizados sus datos a medida que se incrementa el número de archivos.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Este esquema fue utilizado por la primera versión del sistema operativo MS-DOS.</p>
</div>
</div>
<div class="sect3">
<h4 id="_directorio_de_dos_niveles">19.6.2. Directorio de dos niveles</h4>
<div class="paragraph">
<p>En la estructura de directorios de dos niveles cada usuario tiene su propio <strong>directorio de archivos de usuario</strong> o <strong>UFD</strong> (<em>User File Directory</em>) que cuelga del <strong>directorio maestro de archivos</strong> o <strong>MFD</strong> (<em>Master File Directory</em>).</p>
</div>
<div class="paragraph">
<p>Cuando un usuario se conecta al sistema o inicia un trabajo, se explora el <strong>MFD</strong>.
Ésta es una tabla indexada por el nombre de los usuarios o por los números de cuenta, donde cada una de sus entradas apunta al <strong>UFD</strong> de dicho usuario.
Puesto que cada <strong>UFD</strong> incluye sólo los archivos del usuario al que pertenece, el sistema operativo puede confinar todas las operaciones que puede realizar un usuario sobre los archivos a su <strong>UFD</strong>.</p>
</div>
<div class="paragraph">
<p>Aunque esto resuelve el problema de la colisión de nombres entre diferentes usuarios, también presenta algunas desventajas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La estructura descrita aísla a los usuarios, lo cual puede ser un problema cuando éstos quieren compartir datos para cooperar en alguna tarea.</p>
<div class="paragraph">
<p>La solución pasa por utilizar <strong>nombres de ruta</strong> para designar a un archivo de forma unívoca.
Por ejemplo, si el usuario <code>usera</code> quiere acceder a su archivo <code>test</code>, simplemente debe referirse a él como <code>test</code>.
Mientras que si quiere acceder al archivo <code>test</code> del usuario <code>userb</code>, debe utilizar un <strong>nombre de ruta</strong> como <code>/userb/test</code>, donde se indica el nombre del usuario y el nombre del archivo.</p>
</div>
<div class="paragraph">
<p>En general, cada sistema operativo utiliza su propia sintaxis par nombrar los archivos contenidos en los directorios de otros usuarios.</p>
</div>
</li>
<li>
<p>Puede ser difícil para un usuario mantener organizados sus datos a medida que se incrementa el número de archivos personales, incluso aunque tenga un directorio para él solo.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_directorios_con_estructura_de_árbol">19.6.3. Directorios con estructura de árbol</h4>
<div class="paragraph">
<p>La estructura de directorio de dos niveles puede generalizarse en la <strong>estructura de directorios en árbol</strong> de altura arbitraria.
Esto permite que los usuarios puedan crear sus propios subdirectorios para organizar sus archivos de la forma más conveniente.</p>
</div>
<div class="paragraph">
<p>Cada sistema de archivos tiene un <strong>directorio raíz</strong> que puede contener tanto archivos como otros directorios.
A su vez, cada directorio puede contener un conjunto de archivos y subdirectorios.</p>
</div>
<div class="paragraph">
<p>Normalmente, cada entrada de directorio incluye un bit donde se indica si dicha entrada apunta a un archivo o a un subdirectorio.
Esto se hace así porque, generalmente, los directorios no son más que archivos con un formato interno especial; por lo que el sistema debe saber si la entrada apunta a un directorio para interpretar correctamente los datos del directorio.</p>
</div>
<div class="sect4">
<h5 id="_directorio_de_trabajo_actual">Directorio de trabajo actual</h5>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Comúnmente, en el <strong>PCB</strong> de cada proceso se guarda cual es su <strong>directorio de trabajo</strong> actual.
De esta forma, cuando se hace referencia a un archivo en una llamada al sistema usando solo su nombre, se le busca en el <strong>directorio de trabajo</strong> del proceso.</p>
</div>
<div class="paragraph">
<p>Si se necesita un archivo que no se encuentra en el <strong>directorio de trabajo</strong> actual, entonces el usuario debe especificar un <strong>nombre de ruta</strong> desde el <strong>directorio de trabajo</strong>, o primero cambiar con una llamada al sistema el directorio de trabajo del proceso al directorio donde está almacenado el archivo.</p>
</div>
<div class="paragraph">
<p>Windows API permite indicar el <strong>directorio de trabajo</strong> de un nuevo proceso al crearlo, a través del argumento <code>lpCurrentDirectory</code> de <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a>.
Si este argumento vale NULL, el proceso hereda el <strong>directorio de trabajo</strong> del padre.
En todo caso, cualquier proceso puede cambiar su <strong>directorio de trabajo</strong> actual llamando a <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setcurrentdirectory">SetCurrentDirectory()</a>.</p>
</div>
<div class="paragraph">
<p>En los sistemas POSIX, el proceso hijo creado con <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> hereda automáticamente el <strong>directorio de trabajo</strong> actual del proceso padre.
Por lo que si necesitamos cambiar su <strong>directorio de trabajo</strong> —por ejemplo, antes de llamar a <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> para cambiar el <strong>directorio de trabajo</strong> para el nuevo programa— el proceso puede usar <a href="https://man7.org/linux/man-pages/man2/chdir.2.html">chdir()</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Gracias a la herencia del <strong>directorio de trabajo</strong> es como los <strong>interpretes de comandos</strong> indican a los comandos que ejecutan en qué directorio deben ejecutarse.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, en los sistemas POSIX el intérprete de comandos <strong>Bash</strong> se inicia usando el directorio personal del usuario como <strong>directorio de trabajo</strong>.
El usuario puede cambiar el <strong>directorio de trabajo</strong> del proceso de la <strong>Bash</strong> usando el comando interno <code>cd</code>.
Cuando se pide a la <strong>Bash</strong> que ejecute cualquier otro comando, ésta crea un nuevo proceso hijo donde ejecutar el programa de dicho comando.
Ese proceso hereda el <strong>directorio de trabajo</strong> actual de <strong>Bash</strong>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_nombre_de_ruta">Nombre de ruta</h5>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Los <strong>nombres de ruta</strong> es la forma en la que se indica la ubicación de un archivo o directorio en el árbol de directorios.</p>
</div>
<div class="paragraph">
<p>Los <strong>nombres de ruta</strong> pueden ser de dos tipos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Un <strong>nombre de ruta absoluto</strong> comienza en la raíz y va indicando los directorios que componen la ruta de forma descendente hasta llegar al archivo especificado.</p>
<div class="paragraph">
<p>Por ejemplo, <code>/usr/share/doc</code>, <code>C:\Programa Files\WindowsApps</code> o <code>\Windows\System32</code></p>
</div>
</li>
<li>
<p>Un <strong>nombre de ruta relativo</strong> define una ruta a partir del <strong>directorio de trabajo actual</strong>.</p>
<div class="paragraph">
<p>Por ejemplo, <code>Imágenes/Enero/000001.jpg</code>, <code>Downloads\horario.zip</code> o <code>C:Desktop\Proyectos</code>.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Con una <strong>estructura de directorios en árbol</strong>, unos usuarios pueden acceder a los archivos de otros.
Para eso, solo es necesario que se utilicen <strong>nombres de ruta</strong> para designar los archivos del otro usuario, o que se cambie el <strong>directorio de trabajo actual</strong>.</p>
</div>
<div class="paragraph">
<p>Este tipo de estructura de directorios es la utilizada por MS-DOS y por las distintas versiones de Microsoft Windows.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_directorios_en_grafo_acíclico">19.6.4. Directorios en grafo acíclico</h4>
<div class="paragraph">
<p>La <strong>estructura de directorio en grafo acíclico</strong> es una generalización natural del esquema con <strong>estructura en árbol</strong>.</p>
</div>
<div class="paragraph">
<p>A diferencia de este último, la <strong>estructura en grafo acíclico</strong> permite que los mismos archivos y subdirectorios existan simultáneamente en distintos lugares de la estructura de directorios.
Eso significa que para acceder a un archivo o directorio pueden existir diversos <strong>nombres de ruta</strong>.</p>
</div>
<div class="paragraph">
<p>Esto, por ejemplo, permite que los usuarios puedan compartir archivos de tal forma que los mismos archivos y directorios estén disponibles directamente desde el directorio personal de los diferentes usuarios.</p>
</div>
<div class="sect4">
<h5 id="_enlaces">Enlaces</h5>
<div class="paragraph">
<p>Los archivos y subdirectorios compartidos pueden implementarse de diversas formas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se pueden crear una entrada de directorio especial denominada <strong>enlace</strong>.
Un <strong>enlace</strong> es, generalmente, un archivo que contiene la ruta relativa o absoluta de otro archivo o subdirectorio.
En los sistemas POSIX a éstos se los conoce como <strong>enlaces simbólicos</strong>.</p>
</li>
<li>
<p>También se puede duplicar toda la información de la entrada de directorio del archivo compartido en todos los directorios que también contienen dicho archivo.</p>
<div class="paragraph">
<p>Así, mientras que los <strong>enlaces simbólicos</strong> son claramente diferentes de la entrada original de directorio, las entradas de directorio duplicadas hacen que la entrada original y la copia sean indistinguibles.
En los sistemas POSIX, a este tipo de entradas duplicadas se las conoce como <strong>enlaces duros</strong>.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Como <strong>enlaces simbólicos</strong> almacenan una ruta, pueden apuntar a archivos o directorios en otros sistemas de archivos.
Mientras que los <strong>enlaces duros</strong> solo pueden apuntar a archivos en el mismo sistema de archivos.</p>
</div>
<div class="paragraph">
<p>En en los sistemas POSIX los <strong>enlaces duros</strong> se crean llamando a <a href="https://man7.org/linux/man-pages/man2/link.2.html">link()</a> y los <strong>enlaces simbólicos</strong> con <a href="https://man7.org/linux/man-pages/man2/symlink.2.html">symlink()</a>.</p>
</div>
<div class="paragraph">
<p>En Microsoft Windows se soportan ambos tipos de enlaces desde la primera versión —Microsoft Windows NT 3.1— pero únicamente en el sistema de archivos <a href="https://es.wikipedia.org/wiki/NTFS">NTFS</a> y solo por compatibilidad con las aplicaciones POSIX.
Windows API no tuvo funciones para crear <strong>enlaces</strong> hasta mucho después.
Por eso su uso en Microsoft Windows no es tan común.</p>
</div>
<div class="paragraph">
<p>En Windows API los <strong>enlaces duros</strong> se crean con <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka">CreateHardLink()</a> desde Windows 2000.
Mientras que los <strong>enlaces simbólicos</strong> se crean con <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka">CreateSymbolicLink()</a> desde Windows Vista.</p>
</div>
</div>
<div class="sect4">
<h5 id="_inconvenientes">Inconvenientes</h5>
<div class="paragraph">
<p>Una estructura en grafo acíclico es más flexible que una estructura en árbol, pero no por eso está exenta de inconvenientes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Si estamos intentando recorrer el sistema de archivos completo —por ejemplo, para buscar un archivo o para copiarlos en un dispositivo para hacer copias de seguridad— debemos evitar acceder más de una vez a los archivos y subdirectorios enlazados.
No olvidemos que en los sistemas con estructura en grafo acíclico, cada archivo puede tener múltiples nombres de ruta absoluta.</p>
<div class="paragraph">
<p>Esto es más sencillo de resolver en el caso de los <strong>enlaces simbólicos</strong>, puesto que podemos evitar recorrerlos al ser claramente distinguibles de los archivos normales.</p>
</div>
</li>
<li>
<p>Los diseñadores deben enfrentarse a la cuestión de cuándo liberar el espacio asignado a un archivo enlazado.
Si lo hacemos cuando un usuario lo borra podríamos dejar <strong>enlaces</strong> que referencian a archivos que no existen.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Sobre esta última cuestión:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>El caso más sencillo de resolver es el de los <strong>enlaces simbólicos</strong>, ya que pueden ser borrados sin que el archivo original se vea afectado, puesto que lo que se elimina es el <strong>enlace</strong> y no el archivo original.</p>
</li>
<li>
<p>Si lo que se pretende borrar es la entrada de un archivo original que es apuntado desde un <strong>enlace simbólico</strong>, tampoco hay problema en hacerlo y liberar el espacio asignado al mismo, dejando que el enlace apunte a un archivo que no existe.
Cuando se produzca un intento de acceder al archivos a través del <strong>enlace</strong>, el sistema determinará que el archivo referenciado fue borrado y tratará el acceso al enlace de forma similar a cualquier otro acceso ilegal a un archivo que no existe.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Ciertamente, podríamos plantearnos la posibilidad de buscar todos los <strong>enlaces</strong> al archivo borrado y eliminarlos pero, a menos que el FCB de cada archivo guarde las rutas a los <strong>enlaces</strong> que le señalan, esta búsqueda podría ser muy costosa.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>Otra opción es almacenar en la entrada del archivo original un contador con el número de referencias al archivo.
Cada vez que se elimina una referencia se decrementa el contador.
Cuando el contador sea 0, sabremos que ha llegado el momento de liberar el espacio asignado.</p>
<div class="paragraph">
<p>En los sistemas UNIX se utiliza esta técnica para saber cuándo liberar el contenido de archivos con <strong>enlaces duros</strong>.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Por último, no debemos olvidar que la estructura de directorios en grafo se conserva acíclica si se prohíbe que hayan múltiples referencias a un mismo directorio.
Ese es el motivo por el que en muchos sistemas POSIX no se permite, por defecto, que los <strong>enlaces duros</strong> hagan referencia a directorios.
Sin embargo si se pueden utilizar <strong>enlaces simbólicos</strong> para este fin, puesto que al ser distinguibles del directorio original podemos evitar los ciclos, si mientras se explora se ignoran dichos enlaces.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_directorios_en_forma_de_grafo_general">19.6.5. Directorios en forma de grafo general</h4>
<div class="paragraph">
<p>Uno de los principales problemas de la <strong>estructura de directorios en grafo acíclico</strong> es garantizar que no exista ningún ciclo.
Esto es interesante puesto que mientras sea así los algoritmos diseñados para recorrer el grafo y para determinar cuándo no existen más referencias a un archivo, son relativamente simples.</p>
</div>
<div class="paragraph">
<p>No olvidemos que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Es importante evitar encontrar cualquier archivo dos o más veces, tanto por razones de corrección como de rendimiento.</p>
</li>
<li>
<p>En una <strong>estructura de directorios en forma de grafo general</strong> que use contadores de referencia para borrar archivos cuándo no hay más referencias, puede que dicho contador no sea 0, aunque no hayan más referencias al archivo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Esto significa que generalmente se necesita algún mecanismo de recolección de basura para determinar con seguridad cuándo se ha borrado la última referencia.
La recolección de basura implica recorrer todo el sistema de archivos y marcar todos aquellos elementos que sean accesibles.
Después, en una segunda pasada, se elimina todo lo que no esté marcado.
Por tanto, es evidente que la recolección de basura para un sistema de archivos basado en disco consume mucho tiempo, por lo que se utiliza en muy pocas ocasiones.</p>
</div>
<div class="paragraph">
<p>Es mucho más sencillo trabajar con <strong>estructuras de directorio en grafo acíclico</strong>.
Para evitar que en un grafo aparezca un ciclo al añadir un nuevo <strong>enlace</strong>, se pueden utilizar diversos algoritmos.
Sin embargo, puesto que también suelen ser muy costosos, lo más simple es ignorar todos los <strong>enlaces simbólicos</strong> en los casos en los que se recorre el árbol de directorios para realizar una tarea en la que es importante no entrar en un bucle —por ejemplo, al hacer una búsqueda—.</p>
</div>
<div class="paragraph">
<p>En el caso de los <strong>enlaces duros</strong> —donde se duplica entradas de directorio que no se pueden distinguir de la del archivo original y, por tanto, no se pueden ignorar— lo más sencillo es que el sistema operativo no permita crear múltiples referencias a un mismo directorio.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compartición_de_archivos">19.7. Compartición de archivos</h3>
<div class="paragraph">
<p>Como ya hemos comentado, el que los usuarios puedan compartir archivos es algo muy deseable, pues permite que éstos puedan colaborar en la realización de una tarea determinada.
Sin embargo, al añadir esta característica, hay que tener en cuenta algunos aspectos que deben ser resueltos en el diseño del sistema operativo.</p>
</div>
<div class="sect3">
<h4 id="_múltiples_usuarios_y_protección">19.7.1. Múltiples usuarios y protección</h4>
<div class="paragraph">
<p>Cuando un sistema operativo admite múltiples usuarios y utiliza una estructura de directorio que permite que éstos compartan archivos, cobra gran importancia la protección de los datos.
En este sentido, el sistema operativo debe adoptar un papel de mediador en lo que respecta a la compartición de los archivos.</p>
</div>
<div class="paragraph">
<p>Para implementar la compartición y los mecanismos de protección, el sistema debe soportar más atributos para cada archivo y directorio que los que necesita en un sistema monousuario.
Aunque a lo largo de la historia se han adoptado diversos enfoques, la mayoría han evolucionado hasta utilizar los conceptos de <strong>propietario</strong> —o <strong>usuario</strong>— y <strong>grupo</strong> de un archivo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>El propietario de un archivo es el usuario que puede cambiar los atributos y conceder el acceso.
Se trata del usuario que dispone del mayor grado de control sobre el archivo.</p>
</li>
<li>
<p>El grupo es un conjunto de usuarios que pueden compartir el acceso al archivo.
El propietario del archivo es quien define que operaciones pueden ser ejecutadas por los miembros del grupo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Los identificadores del propietario y el grupo de un archivo se almacenan junto con los otros atributos en el FCB.</p>
</div>
<div class="paragraph">
<p>Cuando un usuario solicita realiza una operación sobre un archivo, se compara el identificador del usuario con el atributo del propietario para determinar si el solicitante es el propietario.
Exactamente de la misma manera se puede proceder con los identificadores de grupo.
El resultado de la comparación indica que permisos son aplicables.
A continuación, el sistema aplica dichos permisos a la operación solicitada y la autoriza o deniega según sea el caso.</p>
</div>
<div class="paragraph">
<p>Existen diversas implementaciones del esquema utilizado para determinar los permisos aplicables a un usuario que pretende operar sobre un archivo concreto.</p>
</div>
<div class="sect4">
<h5 id="_lista_de_control_de_acceso">Lista de control de acceso</h5>
<div class="paragraph">
<p>El esquema más general consiste en asociar a cada archivo o directorio una <strong>lista de control de acceso</strong> o <strong>ACL</strong> (<em>Access-control list</em>) que especifique los nombres de usuario o grupos y los tipos de acceso para cada uno.</p>
</div>
<div class="paragraph">
<p>Cuando un usuario solicita acceder a un archivo concreto, el sistema operativo comprueba la <strong>ACL</strong> asociada a dicho archivo.
Si el usuario, o alguno de sus grupos, está incluido en la lista para el tipo de acceso solicitado, se permite el acceso.</p>
</div>
<div class="paragraph">
<p>Esta técnica presenta diversas ventajas e inconvenientes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se trata de la técnica más general, permitiendo la implementación de políticas de acceso muy complejas.</p>
</li>
<li>
<p>Construir la lista puede ser una tarea tediosa.
Por ejemplo, si queremos que varios usuarios puedan leer unos archivos determinados, es necesario enumerar todos los usuarios que disponen de ese acceso en las <strong>ACL</strong> de dichos archivos.</p>
</li>
<li>
<p>El <strong>FCB</strong>, que hasta el momento tenía un tamaño fijo, ahora tendrá que ser de tamaño variable para almacenar la <strong>ACL</strong>, lo que requiere mecanismos más complejos de gestión del espacio.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>La familia de sistemas operativos Microsoft Windows utiliza este tipo de <strong>ACL</strong>.
Al crear un archivo nuevo, se puede indicar la <strong>ACL</strong> deseada a través del argumento <code>lpSecurityAttributes</code> de <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile()</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>También se puede consultar la <strong>ACL</strong> de cualquier objeto con permisos —incluidos los archivos— usando <a href="https://docs.microsoft.com/en-us/windows/win32/api/aclapi/nf-aclapi-getsecurityinfo">GetSecurityInfo()</a> o <a href="https://docs.microsoft.com/en-us/windows/win32/api/aclapi/nf-aclapi-getnamedsecurityinfoa">GetNamedSecurityInfo()</a> y modificarla usando <a href="https://docs.microsoft.com/en-us/windows/win32/api/aclapi/nf-aclapi-setsecurityinfo">SetSecurityInfo()</a> o <a href="https://docs.microsoft.com/en-us/windows/win32/api/aclapi/nf-aclapi-setnamedsecurityinfoa">SetNamedSecurityInfo()</a>.</p>
</div>
<div class="paragraph">
<p>Las <strong>ACL</strong> y los <strong>descriptores de seguridad</strong> de Windows API son un tema complejo.
Antes de manipularlos, es conveniente consultar <a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/security-descriptors">«Security Descriptors»</a> en Microsoft Docs.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_lista_de_control_de_acceso_condensada">Lista de control de acceso condensada</h5>
<div class="paragraph">
<p>Para solucionar algunos de los problemas de las <strong>ACL</strong> muchos sistemas utilizan <strong>listas de control de acceso condensadas</strong>.</p>
</div>
<div class="paragraph">
<p>Para condensar la longitud de la lista de control de acceso, generalmente los sistemas clasifican a los usuarios en tres grupos: <strong>propietario</strong>, <strong>grupo</strong> y <strong>otros</strong>.
Así sólo es necesario un campo para cada clase de usuario, siendo cada campo una colección de bits, donde cada uno permite o deniega el tipo de acceso asociado al mismo.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, en los sistemas POSIX se definen 3 campos —<strong>propietario</strong>, <strong>grupo</strong> y <strong>otros</strong>) de 3 bits cada uno: <code>rwx</code>, donde <code>r</code> controla el acceso de lectura, <code>w</code> controla el acceso de escritura y <code>x</code> controla la ejecución.</p>
</div>
<div class="paragraph">
<p>Las ACL condensadas son más sencillas de construir.
Al mismo tiempo, por tener una longitud fija, es mucho más simple gestionar el espacio para el <strong>FCB</strong> donde se almacenan.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Permisos de archivo en sistemas POSIX</div>
<div class="paragraph">
<p>Los sistemas POSIX usan, por defecto, <strong>listas de control de acceso condensadas</strong>.</p>
</div>
<div class="paragraph">
<p>Al crear un archivo nuevo, se pueden indicar los permisos de forma numérica a través del argumento <code>mode</code> de <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span>
    <span class="s">"foo.txt"</span><span class="p">,</span>
    <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_RDWR</span><span class="p">,</span>
    <span class="mo">0666</span>  <i class="conum" data-value="1"></i><b>(1)</b> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Indica los permisos del archivo en caso de crearlo.
Se ignora si el archivo ya existe.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Los bits a 1 del número especificado indican los permisos autorizados.
Es muy común hacerlo en base octal, como en el ejemplo.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Otra llamada al sistema que permite indicar permisos es <a href="https://man7.org/linux/man-pages/man2/mkdir.2.html">mkdir()</a>, que se utiliza para crear directorios</p>
</div>
<div class="paragraph">
<p>En ambos casos, los permisos finalmente usados vienen determinados por la <strong><em>umask</em></strong> del proceso.
Esta es una propiedad numérica de los procesos —heredada de padres a hijos— que indica qué permisos del argumento <code>mode</code> de <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a> y <a href="https://man7.org/linux/man-pages/man2/mkdir.2.html">mkdir()</a> se desactivan al crear un archivo o directorio.
Por ejemplo, si el argumento <code>mode</code> es 0666 y <strong><em>umask</em></strong> es 0022, los permisos efectivos al crear el archivo serán 0644.</p>
</div>
<div class="paragraph">
<p>Un proceso puede cambiar su <strong><em>umask</em></strong> mediante la función <a href="https://man7.org/linux/man-pages/man2/umask.2.html">umask()</a> y los usuarios de <strong>Bash</strong>, las de su <em>shell</em> usando el comando del mismo nombre.</p>
</div>
<div class="paragraph">
<p>Los procesos pueden consultar fácilmente los permisos que tienen sobre un archivo usando <a href="https://man7.org/linux/man-pages/man2/access.2.html">access()</a>.
Y pueden cambiar su propietario y el grupo llamando a la función <a href="https://man7.org/linux/man-pages/man2/chown.2.html">chown()</a>.
Si necesitan leer los permisos, el propietario y el resto de <strong>metadatos</strong> del archivo, pueden usar <a href="https://man7.org/linux/man-pages/man2/stat.2.html">stat()</a> o <a href="https://man7.org/linux/man-pages/man2/fstat.2.html">fstat()</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_combinar_ambos_tipos_de_listas_de_control_de_acceso">Combinar ambos tipos de listas de control de acceso</h5>
<div class="paragraph">
<p>Muchos sistemas POSIX también soportan un borrador de especificación llamado POSIX ACL, que describe una interfaz para usar las <strong>ACL</strong> más genéricas.
Sistemas operativos como Linux, macOS o FreeBSD implementan ambos tipos de ACL.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Para más información sobre las listas de control de acceso POSIX, véase <a href="https://www.man7.org/linux/man-pages/man5/acl.5.html">«acl(5)&#8201;&#8212;&#8201;Linux Manual»</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Combinar ambos tipos de <strong>ACL</strong> ofrece lo mejor de ambos mundos, pero no es una solución que esté exenta de dificultades:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Uno de los problemas es que los usuarios deben poder determinar cuando están activados los permisos <strong>ACL</strong> más generales.
En Linux, por ejemplo, se utiliza el símbolo <code>+</code> al listar los permisos de la ACL condensada para indicar dicha circunstancia.
Esos permisos pueden ser gestionados utilizando los comandos <a href="https://man7.org/linux/man-pages/man1/setfacl.1.html">setfacl</a> y <a href="https://man7.org/linux/man-pages/man1/getfacl.1.html">getfacl</a>.</p>
</li>
<li>
<p>Otra dificultad es la relativa a la asignación de precedencias cuando ambas <strong>ACL</strong> entran en conflicto.
En general, se suele asignar a la <strong>ACL</strong> más prioridad que a la <strong>ACL condensada</strong>, pues la primera tiene una granularidad más fina y no se crea de forma predeterminada.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_semántica_de_coherencia">19.7.2. Semántica de coherencia</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>La <strong>semántica de coherencia</strong> especifica cuándo las modificaciones que un proceso realiza en los archivos serán observables por los otros procesos.
Por tanto, es importante tenerla en cuenta cuando esperamos que varios procesos utilicen los mismos archivos al mismo tiempo.</p>
</div>
<div class="paragraph">
<p>A continuación vamos comentar algunos ejemplos de tipos <strong>semántica de coherencia</strong>.</p>
</div>
<div class="sect4">
<h5 id="_semántica_posix">Semántica POSIX</h5>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Los sistemas de archivos de los sistemas operativos POSIX utilizan la siguiente <strong>semántica de coherencia</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Las escrituras en un archivo abierto por parte de un proceso son visibles inmediatamente para los procesos que tengan abierto el mismo archivo.</p>
</li>
<li>
<p>Existe un modo de compartición que permite a los procesos compartir el puntero de ubicación actual dentro del archivo.
Así, el incremento de ese puntero por parte de un proceso afecta a todos los procesos que estén compartiendo el archivo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>En la semántica POSIX, cada archivo está asociado con una única imagen física con el contenido del archivo, a la que se accede en forma de recurso en <strong>exclusión mutua</strong>.
Por ejemplo, un proceso que haga <strong>read</strong> sobre un archivo podría quedar en espera si al mismo tiempo otro proceso está ejecutando un <strong>write</strong>, hasta que este último termine.</p>
</div>
<div class="paragraph">
<p>La competición por acceder a esta imagen única provoca retardos en los procesos debido a estos bloqueos.</p>
</div>
</div>
<div class="sect4">
<h5 id="_semántica_de_sesión">Semántica de sesión</h5>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El <a href="https://es.wikipedia.org/wiki/Andrew_File_System">sistema de archivos Andrew</a> (AFS) es un sistema de archivos en red —o sistema de archivos distribuido— es decir, sirve para compartir archivos en una red de ordenadores y usarlos como si estuvieran almacenados localmente.</p>
</div>
<div class="paragraph">
<p>AFS es altamente escalable, existiendo despliegues con más de 25000 clientes.
Para conseguirlo, cada equipo mantiene una copia local de los archivos abiertos.
Las operaciones de lectura y escritura se realizan en esa copia.
Cuando se cierra el archivo modificado, los cambios son enviados al servidor de archivos, para actualizar el archivo original.</p>
</div>
<div class="paragraph">
<p>Aunque es posible implementar la <strong>semántica POSIX</strong> —como hacen otros sistemas de archivos en red— ésta no escala adecuadamente, porque implica mantener sincronizadas las copias locales de cada archivo.
Es decir, asegurar que los nodos no pueden modificar sus copias locales simultáneamente y que los cambios se propaguen adecuadamente entre las
copias, antes de responder a cualquier operación de lectura solicitada por un proceso.
Por eso el sistema de archivo AFS usa una semántica de coherencia diferente, denominada <strong>semántica de sesión</strong>.</p>
</div>
<div class="paragraph">
<p>Suponiendo que una <strong>sesión de archivo</strong> es el conjunto de operaciones entre las llamadas <strong>open</strong> y <strong>close</strong>, la <strong>semántica de sesión</strong> consisten en que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Las escrituras en un archivo abierto por parte de un proceso no son visibles inmediatamente para los otros usuarios que hayan abierto ese mismo archivo.</p>
</li>
<li>
<p>Una vez que se cierra un archivo, los cambios realizados en él son visibles únicamente en las sesiones que comiencen posteriormente.
Las sesiones ya abiertas sobre el archivo no reflejarán dichos cambios.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Esto significa que un archivo puede permanecer temporalmente asociado a distintas imágenes físicas de su contenido al mismo tiempo.
Esto ocurre en el sistema de archivos AFS porque un mismo archivo tiene distintas copias locales temporales  en los nodos que lo tienen abierto.
Así se permite que múltiples nodos realicen accesos concurrentes, tanto de lectura como de escritura, en sus propias imágenes del archivo, evitando los retardos.</p>
</div>
<div class="paragraph">
<p>A cambio hay que tener cuidado con el hecho de que un proceso puede estar leyendo datos obsoletos, sin saberlo.
Si un proceso necesita acceder a los datos que escribe otro proceso, ambos deben sincronizarse explícitamente abriendo y cerrando el archivo.</p>
</div>
</div>
<div class="sect4">
<h5 id="_semántica_de_archivos_compartidos_inmutables">Semántica de archivos compartidos inmutables</h5>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>En esta semántica, cuando un archivo es declarado como compartido por su creador, ya no puede ser ser modificado.</p>
</div>
<div class="paragraph">
<p>Estos archivos inmutables cumplen dos propiedades clave: su nombre no puede reutilizarse y su contenido no puede ser modificado.
Así podemos estar seguros de que el contenido de un archivo inmutable es fijo.
Para escribir algo en uno de estos archivos, es necesario crear una copia con un nuevo nombre y hacer en ella los cambios.</p>
</div>
<div class="paragraph">
<p>Para optimizar la implementación de esta semántica se suele usar una técnica similar al <strong>copy-on-write</strong>.
Con esta técnica, cuando se va a modificar un archivo inmutable, se genera una copia que tiene la misma asignación de bloques que el archivo original.
Cada vez que se va modificar la información de un bloque, se crear una copia de ese bloque, se aplican los cambios y se sustituye el identificador del bloque anterior por el del nuevo bloque en la asignación de bloques del archivo en el <strong>FCB</strong>.
Así, las copias de archivos inmutables se hacen más rápido y se ahorra espacio, dado que de cada archivo solo se guardan los bloques modificados.</p>
</div>
<div class="paragraph">
<p>Además, cuando los sistemas operativos usan esta semántica, suelen tener una forma de crear automáticamente los nombres de las nuevas versiones de un archivo —por ejemplo, añadiendo un entero al nombre e incrementándolo en cada versión—.</p>
</div>
<div class="paragraph">
<p>La implementación de esta semántica en un sistema de archivos distribuido es muy simple, puesto que es muy sencillo hacer copias locales de los archivos.
Al ser inmutables, no hace falta disponer de un mecanismo para sincronizar los cambios entre los nodos.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_bloqueos_de_archivo">19.7.3. Bloqueos de archivo</h4>
<div class="paragraph">
<p>Algunos sistemas operativos proporcionan funciones para bloquear un archivo abierto —o partes del mismo—.
Esto permite que un proceso impida que otros procesos puedan acceder al archivo bloqueado.</p>
</div>
<div class="paragraph">
<p>Los bloqueos de archivo resultan útiles para encadenar varias operaciones de E/S sobre un archivo, teniendo la seguridad de que otros procesos no podrán hacer modificaciones en el mismo mientras tanto.</p>
</div>
<div class="paragraph">
<p>Los sistemas operativos pueden proporcionar diferentes tipos de bloqueos de archivo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Un <strong>bloqueo compartido</strong> es un tipo de bloqueo que puede ser adquirido —es decir, bloquear el archivo— al mismo tiempo por varios procesos.</p>
</li>
<li>
<p>Un <strong>bloqueo exclusivo</strong> solo puede ser adquirido por un proceso cada vez.
Si otro proceso intenta adquirir un <strong>bloqueo exclusivo</strong> sobre un archivo ya bloqueado, por cualquiera de los dos tipos de bloqueos, se suspende a la espera de que el bloqueo anterior sea liberado.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Algunos sistemas operativos sólo proporcionan el <strong>bloqueo exclusivo</strong>.
Sin embargo, en los que implementan ambos tipos de bloqueo, lo normal es que los procesos que pretenden acceder a un archivo compartido para sólo lectura utilicen el <strong>bloqueo compartido</strong>, mientras que los que acceden para modificar el contenido utilicen el <strong>bloqueo exclusivo</strong>.
Así, varios procesos puedan leer el archivo al mismo tiempo, pero si un proceso accede para escribir, ningún otro podrá acceder ni para leer ni para escribir.</p>
</div>
<div class="sect4">
<h5 id="_bloqueo_obligatorio_o_sugerido">Bloqueo obligatorio o sugerido</h5>
<div class="paragraph">
<p>Además, los sistemas operativos pueden proporcionar dos tipos de mecanismos de bloqueo de archivos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Si el <strong>bloqueo es obligatorio</strong>, después de que un proceso adquiera un bloqueo exclusivo, el sistema operativo impedirá a todos los demás procesos que hagan cualquier operación sobre el archivo bloqueado.</p>
<div class="paragraph">
<p>Esto ocurrirá incluso si los otros procesos no han sido programados para intentar adquirir el bloqueo.
Por tanto, el sistema operativo es el encargado de garantizar que los bloqueos se cumplen, haciendo las comprobaciones pertinentes en las llamadas al sistema.</p>
</div>
</li>
<li>
<p>Si el <strong>bloqueo es sugerido</strong>, el sistema operativo sólo impedirá que accedan al archivo bloqueado aquellos procesos programados para adquirir el bloqueo explícitamente.</p>
<div class="paragraph">
<p>Para eso los programas deben invocar ciertas llamadas al sistema para adquirir el bloqueo y liberarlo,
Pero el sistema operativo no impedirá el acceso al archivo a un proceso que lo abre y lo lee o escribe sin más.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Los sistemas operativos Microsoft Windows implementan un mecanismo de <strong>bloqueo obligatorio</strong>.
En Windows API se puede indicar el modo de bloqueo al abrir el archivo con <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile()</a> o se puede usar <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-lockfile">LockFile()</a> para adquirir un bloqueo sobre una parte del contenido</p>
</div>
<div class="paragraph">
<p>En los sistemas UNIX y estilo UNIX, como regla general, no se bloquea un archivo al abrirlo.
Existen diferentes mecanismos de bloqueo, algunos de los cuales pueden ser <strong>bloqueos obligatorio</strong>, pero por defecto son <strong>bloqueos sugeridos</strong>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Bloqueo de archivos en sistemas POSIX</div>
<div class="paragraph">
<p>En los sistemas POSIX el mecanismo más usado es <a href="https://man7.org/linux/man-pages/man2/fcntl.2.html">fcntl()</a>, que permite bloquear porciones del contenido de un archivo, tanto con <strong>bloqueo exclusivo</strong> como con <strong>bloqueo compartido</strong>.
El bloqueo se asocia al <strong>inodo</strong> y al <strong>PID</strong> del proceso, por lo que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Si el archivo tiene varios nombres —por el uso de <strong>enlaces duros</strong>— el bloqueo sobre el archivo tiene efecto sin importar el nombre usado para abrirlo.</p>
</li>
<li>
<p>Diferentes descriptores sobre el mismo archivo obtenidos llamando a <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a> varias veces en el mismo proceso, comparten los bloqueos adquiridos.
Así que, usando este tipo de bloqueos es posible sincronizar distintos procesos pero no distintos hilos, ya que todos los hilos de un mismo proceso comparten la adquisición del bloqueo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El estándar POSIX también soporta <a href="https://man7.org/linux/man-pages/man3/lockf.3.html">lockf()</a>, que es como una versión simplificada de <a href="https://man7.org/linux/man-pages/man2/fcntl.2.html">fcntl()</a>.
Aunque el estándar deja sin especificar como deben interactuar ambas llamadas, lo cierto es que es común que <a href="https://man7.org/linux/man-pages/man3/lockf.3.html">lockf()</a> se implemente usando <a href="https://man7.org/linux/man-pages/man2/fcntl.2.html">fcntl()</a>.
Esta función también crea bloqueos de porciones del contenido, asociados al <strong>inodo</strong> del archivo y el <strong>PID</strong>, pero solo soporta crear y liberar <strong>bloqueos exclusivos</strong>.</p>
</div>
<div class="paragraph">
<p>Finalmente, muchos sistemas UNIX y estilo UNIX soportan <a href="https://man7.org/linux/man-pages/man2/flock.2.html">flock()</a>.
Esta función fue introducida en 4.2BSD pero nunca fue incorporada al estándar POSIX.
Admite tanto <strong>bloqueos exclusivos</strong> como <strong>bloqueos compartidos</strong> pero, a diferencia de las llamadas anteriores, el bloqueo afecta siempre al archivo completo y se asocia al descriptor de archivo.</p>
</div>
<div class="paragraph">
<p>Esto último significa que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Diferentes descriptores sobre el mismo archivo obtenidos llamando a <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a> varias veces, no comparten los bloqueos adquiridos.
Así que pueden usarse para sincronizar incluso hilos de un mismo proceso.</p>
</li>
<li>
<p>Diferentes descriptores de archivo obtenidos llamando a <a href="https://man7.org/linux/man-pages/man2/dup.2.html">dup2()</a> o a <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>, comparten los bloqueos adquiridos.
Por lo que no pueden usarse para sincronizar hilos de un mismo proceso, pero permite que un proceso padre transfiera la adquisición del bloqueo a sus hijos.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Aparte de estos mecanismos, cada sistema operativo puede implementar algunas funcionalidades adicionales, no incluidas en el estándar POSIX.
Por ejemplo, la llamada <a href="https://man7.org/linux/man-pages/man2/fcntl.2.html">fcntl()</a> de Linux permite un tipo de bloqueo con las ventajas de los bloqueos originales de <a href="https://man7.org/linux/man-pages/man2/fcntl.2.html">fcntl()</a> pero asociados a descriptores de archivo.
Esto permite usarlos para sincronizar hilos de un mismo proceso y para que un proceso pueda transferir la adquisición del bloqueo a sus hijos, como ocurre con los bloqueos BSD de <a href="https://man7.org/linux/man-pages/man2/flock.2.html">flock()</a>.</p>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap19/filelock-server.c">filelock-server.c</a> y <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap19/filelock-client.cpp">filelock-client.cpp</a> se puede ver un ejemplo similar al de capítulos anteriores, pero usando en esta ocasión bloqueo de archivos.
El servidor <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap19/filelock-server.c">filelock-server.c</a> es un programa que muestra periódicamente la hora del sistema.
Mientras que el cliente <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap19/filelock-client.cpp">filelock-client.cpp</a>, simplemente envía una señal <code>SIGTERM</code> al servidor cuando queremos que termine.
Para que el cliente conozca el PID del servidor —de entre todos los procesos en ejecución en el sistema— el servidor escribe su PID en un archivo en un ubicación conocida por ambos.</p>
</div>
<div class="paragraph">
<p>Como el cliente lee el archivo con una única operación <a href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a> y el servidor lo escribe con una única operación <a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a>, no hace falta el uso de bloqueo de archivos para sincronizarlos.
Gracias a la semántica de coherencia POSIX, el cliente no puede leer el archivo en medio de la escritura.
Es decir, o ve el PID completo escrito por el servidor o no ve ninguno.</p>
</div>
<div class="paragraph">
<p>Pero si puede darse el caso de que se ejecuten varios servidores al mismo tiempo.
Cada uno debe comprobar si archivo existe y, si es así, leer el PID que contiene y comprobar si hay un proceso con ese mismo PID.
Si el archivo no existe o no encuentra un proceso con ese PID, debe entender que es el nuevo servidor y escribir su PID en el archivo, para que lo encuentre el cliente.
En caso contrario, debe terminar.</p>
</div>
<div class="paragraph">
<p>Para evitar que varios servidores den todos esos pasos al mismo tiempo, acaben creyendo que son los únicos y sobrescriban el archivo varias veces, el acceso al archivo debe hacerse en <strong>exclusión mutua</strong>.
Así lo van bloqueando de uno en uno y mientras no hace sus comprobaciones los demás esperan.
Por eso <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap19/filelock-server.c">filelock-server.c</a> utiliza <a href="https://man7.org/linux/man-pages/man3/lockf.3.html">lockf()</a> para bloquear el archivo, sincronizando el acceso de los servidores.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_coherencia">19.8. Coherencia</h3>
<div class="paragraph">
<p>Como hemos comentado anteriormente, parte de los <strong>metadatos</strong> se almacena en la memoria principal para acelerar el acceso.
Dicha información generalmente está más actualizada que la correspondiente en el disco, puesto que la información almacenada en la memoria no tiene porque ser escrita inmediatamente después de una actualización.</p>
</div>
<div class="paragraph">
<p>Entonces ¿qué ocurriría si fallase el sistema? Pues que el contenido de la caché y de los búferes se perdería, y con ellos los cambios realizados en los directorios y archivos abiertos.
Esto puede dejar el sistema de archivos en un estado incoherente, pues el estado real de algunos archivos no sería el que se describe en la estructura de <strong>metadatos</strong>.</p>
</div>
<div class="sect3">
<h4 id="_comprobación_de_coherencia">19.8.1. Comprobación de coherencia</h4>
<div class="paragraph">
<p>El <strong>comprobador de coherencia</strong> comprueba la estructura de <strong>metadatos</strong> y tratar de corregir todas las incoherencias que detecte.</p>
</div>
<div class="paragraph">
<p>Los algoritmos de asignación y de gestión del espacio de almacenamiento dictan los tipos de problemas que el comprobador puede tratar de detectar y también el grado de éxito que puede tener en esa tarea.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, la pérdida de un <strong>FCB</strong>, cuando es éste el que almacena la lista de bloques que contienen los datos del archivo, es desastrosa porque no hay forma de saber qué datos le pertenecen de entre todos los que hay en el disco.
Por esta razón, UNIX almacena en caché las entradas de directorio para acelerar las lecturas, pero todas las escrituras de datos que provoquen algún cambio en la asignación de espacio o en algún otro tipo de metadato, se realizan síncronamente —antes de continuar ejecutando el proceso desde la llamada al sistema—.</p>
</div>
<div class="paragraph">
<p>Es decir, si se hace una escritura de datos que extiende el tamaño de un archivo; el cambio del <strong>FCB</strong> correspondiente, con el nuevo tamaño de archivo y la lista actualizada de las direcciones de los bloques que contienen —o van a contener— los datos del archivo, se escribe en disco antes de terminar la llamada al sistema y devolver el control al proceso que la invocó.</p>
</div>
<div class="paragraph">
<p>Sin embargo, no ocurre lo mismo con los datos que el proceso quería escribir en el archivo.
El sistema operativo suele copiarlos a búferes internos en la memoria para escribirlos en disco más adelante, evitando interrumpir el proceso durante demasiado tiempo.
Esto significa que en caso de fallo del sistema, el sistema de archivos puede estar en estado consistente pero haberse perdido los nuevos datos del archivo, porque no dio tiempo de escribirlos en el disco.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En Microsoft Windows el programa <strong>comprobador de coherencia</strong> se llama <a href="https://es.wikipedia.org/wiki/CHKDSK">CHKDSK</a>.
Mientras que en sistemas POSIX se llama <a href="https://es.wikipedia.org/wiki/Fsck">fsck</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_soft_updates">19.8.2. Soft Updates</h4>
<div class="paragraph">
<p>Para mejorar la eficiencia del sistema de archivos, sin comprometer la coherencia en caso de fallo, los distintos sabores de los sistemas UNIX BSD utilizan una técnica denominada <strong>soft updates</strong> en su implementación del sistema de archivos <a href="https://es.wikipedia.org/wiki/Unix_File_System">UFS</a>.</p>
</div>
<div class="paragraph">
<p>Cuando se monta un sistema de archivos con la opción <strong>soft updates</strong>, el sistema operativo desactiva la escritura síncrona de los <strong>metadatos</strong>, que comentamos anteriormente, permitiendo que éstos sean escritos cuando los algoritmos de gestión de la caché lo consideren necesario, pero se impone cierto orden en el que dichas operaciones de escritura deben ser realizadas.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, cuando se van a escribir en el disco las modificaciones debidas a la creación de un nuevo archivo, el sistema se asegura de que primero se escribe el nuevo <strong>FCB</strong> —un <em>inodo</em>, en los sistemas UNIX BSD— y posteriormente se escribe el directorio con la nueva entrada de archivo con el identificador a dicho <strong>FCB</strong>.</p>
</div>
<div class="paragraph">
<p>Es sencillo darse cuenta de que haciéndolo al revés, si el sistema fallase antes de crear el <strong>FCB</strong>, acabaríamos con una entrada de directorio que apuntaría a un <strong>FCB</strong> inválido.
Mientras que de esta manera el sistema de archivos permanecerá consistente aunque el sistema falle entre ambas operaciones.</p>
</div>
</div>
<div class="sect3">
<h4 id="_sistemas_de_archivos_basados_en_registro">19.8.3. Sistemas de archivos basados en registro</h4>
<div class="paragraph">
<p>Otra solución al problema de la coherencia del sistema de archivos, consiste en aplicar técnicas de recuperación basadas en <strong>registro</strong>  —o <strong>journaling</strong>— durante las actualizaciones de los <strong>metadatos</strong> del sistema de archivos.</p>
</div>
<div class="paragraph">
<p>Fundamentalmente, en los <strong>sistemas de archivos basados en registro</strong> cada conjunto de operaciones sobre los <strong>metadatos</strong>, necesario para realizar una tarea específica sobre el sistema de archivos, es una <strong>transacción</strong>.
Por ejemplo, crear un archivo nuevo es una <strong>transacción</strong>, formada por el conjunto de operaciones sobre los <strong>metadatos</strong> necesarias para crearlo.
También lo es añadir datos al final de un archivo existente, aunque en este caso la <strong>transacción</strong> está formada por las operaciones sobre los <strong>metadatos</strong> necesarias para extender el tamaño del archivo.</p>
</div>
<div class="paragraph">
<p>Las operaciones sobre los <strong>metadatos</strong> de una <strong>transacción</strong> se escriben secuencialmente en un <strong>registro</strong> de operaciones que se usa de la siguiente manera:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Durante la llamada al sistema, la lista de operaciones sobre los <strong>metadatos</strong> necesarias para completar una <strong>transacción</strong> se escribe secuencial y síncronamente en el <strong>registro</strong>, antes de terminar la llamada al sistema.
Cuando la lista de operaciones pendientes termina de ser escrita en el registro, se considera que las operaciones han sido <strong>confirmadas</strong> y la llamada al sistema puede volver al proceso, permitiendo que continúe con su ejecución.</p>
</li>
<li>
<p>Mientras tanto, el sistema operativo va ejecutando las operaciones indicadas en el <strong>registro</strong> sobre las estructuras reales del sistema de archivos.
A medida que se realizan los cambios, se actualiza el <strong>registro</strong> para indicar las operaciones completadas.</p>
</li>
<li>
<p>Cuando todas las operaciones de una <strong>transacción</strong> se han ejecutado con éxito, dicha <strong>transacción</strong> se considera completada y se elimina del <strong>registro</strong>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>En el supuesto de que el sistema falle:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se comprueba el <strong>registro</strong> durante el montaje del sistema de archivos, antes de que pueda ser utilizado de nuevo.</p>
</li>
<li>
<p>Todas las <strong>transacciones confirmadas</strong> que contenga el <strong>registro</strong> estarán a medias, por lo que se terminan de aplicar las <strong>operaciones pendientes</strong> antes de finalizar el proceso de montaje.</p>
</li>
<li>
<p>Todos los cambios correspondientes a las <strong>transacciones no confirmadas</strong> que hubieran sido aplicados al sistema de archivos, son deshechos para preservar la coherencia.
Las <strong>transacciones no confirmadas</strong> son aquellas no terminaron de ser escritas en el <strong>registro</strong> antes del fallo y, por tanto, cuya lista de operaciones no está completa.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Esta técnica es muy común en muchos sistemas operativos modernos.
Por ejemplo, es utilizada en sistemas de archivos tales como: <a href="https://es.wikipedia.org/wiki/Ext3">ext3</a>, <a href="https://es.wikipedia.org/wiki/Ext4">ext4</a>, <a href="https://es.wikipedia.org/wiki/NTFS">NTFS</a>, <a href="https://es.wikipedia.org/wiki/XFS">XFS</a>, <a href="https://es.wikipedia.org/wiki/HFS%2B">HFS+</a>, etc.</p>
</div>
<div class="sect4">
<h5 id="_operaciones_sobre_datos">Operaciones sobre datos</h5>
<div class="paragraph">
<p>Es importante recordar que lo se guarda en el <strong>registro</strong> son las operaciones sobre los <strong>metadatos</strong>, porque se trata de preservar la coherencia del sistema de archivos en caso de fallo del sistema.
Sin embargo, ésto quiere decir que se pueden perder lo que no son operaciones sobre los <strong>metadatos</strong>, como por ejemplo, las operaciones que modifican los datos de los archivos, con lo que lo éstos pueden acabar almacenando datos corruptos o antiguos.</p>
</div>
<div class="paragraph">
<p>Para evitar en parte este problema, algunos sistemas de archivos fuerzan la escritura de los datos en el disco antes de <strong>confirmar</strong> la transacción en el <strong>registro</strong>.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, al añadir datos al final de un archivo existente, se guardan en el registro las operaciones sobre los <strong>metadatos</strong> necesarias para extender el archivo sobre bloques nuevos.
Pero esta <strong>transacción</strong> no se marca <strong>confirmada</strong>, hasta que los nuevos datos no se escriban en los nuevos bloques del archivo.
Así, sí el sistema falla antes de que se escriban los datos, como la operación no está <strong>confirmada</strong>, la extensión del archivo se deshace, quedando en su estado anterior, en lugar de extenderse sobre bloques que no se han terminado de escribir.
Si el sistema falla después, como la operación está <strong>confirmada</strong>, el archivo termina de extenderse sobre los bloques actualizados con los datos.</p>
</div>
<div class="paragraph">
<p>El sistema de archivos <a href="https://es.wikipedia.org/wiki/Ext4">ext4</a> tiene por defecto ese comportamiento.
Sin embargo, si la fiabilidad de los datos es muy importante, se le puede indicar que considere las operaciones sobre los datos dentro de la <strong>transacción</strong>.
De esta forma, las incluye en la lista de operaciones guardadas en el <strong>registro</strong>, las aplica posteriormente junto al resto de operaciones sobre los <strong>metadatos</strong> de la <strong>transacción</strong> y, en caso de fallo del sistema, puede decidir si deshacerlas o terminar de aplicarlas, para asegurar la consistencia de los datos en los archivos.</p>
</div>
</div>
<div class="sect4">
<h5 id="_rendimiento_en_el_acceso_a_disco">Rendimiento en el acceso a disco</h5>
<div class="paragraph">
<p>Un efecto colateral de la utilización de un <strong>registro</strong> es la mejora del rendimiento en el acceso al sistema de archivo.</p>
</div>
<div class="paragraph">
<p>La razón de esta mejora, es que las costosas escrituras síncronas —es decir, antes de devolver el control al proceso— de los <strong>metadatos</strong> en lugares aleatorios del volumen se transforman en escrituras síncronas secuenciales —que son mucho más eficientes— en el <strong>registro</strong>.
Mientras que todas las operaciones indicadas en el <strong>registro</strong> se aplican asíncronamente mediante escrituras aleatorias en las estructuras apropiadas, por lo que pueden ser reordenadas a conveniencia para maximizar el rendimiento.</p>
</div>
<div class="paragraph">
<p>Recordemos que en el registro pueden haber operaciones de distintos procesos que afecten a regiones próximas del disco.
Por lo que el resultado global es una significativa ganancia en la velocidad de las operaciones relativas a los <strong>metadatos</strong>, como por ejemplo la creación y borrado de archivos.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Journaling en XFS</div>
<div class="paragraph">
<p>El sistema de archivos <a href="https://es.wikipedia.org/wiki/XFS">XFS</a> modifica ligeramente esta técnica, sustituyendo las escrituras síncronas necesarias para actualizar el <strong>registro</strong> por escrituras asíncronas.
Es decir, el control se devuelve al proceso antes de terminar de escribir las operaciones en el <strong>registro</strong> y confirmar la transacción, por lo que el proceso puede seguir ejecutándose antes que en otros sistemas de archivos.</p>
</div>
<div class="paragraph">
<p>El uso de escrituras asíncronas en el <strong>registro</strong> es peligroso.
Cualquier caída del sistema podría provocar la corrupción del <strong>registro</strong>, porque las escrituras asíncronas pueden ocurrir en cualquier orden.
Esto, aparentemente, elimina cualquier ventaja de utilizar un <strong>registro</strong> de operaciones.
Sin embargo, XFS impone cierto orden en las operaciones de escritura sobre el registro —de forma similar a como se hace con los <strong>soft updates</strong>— de tal manera que la coherencia del registro está asegurada.</p>
</div>
<div class="paragraph">
<p>El utilizar escrituras asíncronas en el <strong>registro</strong> —aunque sea preservando cierto orden— ofrece alguna mejora en el rendimiento, porque el <strong>registro</strong> deja de ser un cuello de botella para las operaciones que modifica los <strong>metadatos</strong> del sistema de archivos.</p>
</div>
<div class="paragraph">
<p>Como hemos comentado, en otros <strong>sistemas de archivos basados en registro</strong>, el registro es un recurso al que se accede en <strong>exclusión mutua</strong>.
Es decir, las operaciones de una <strong>transacción</strong> se deben escribir antes de devolver el control al proceso y de permitir que otro proceso a la espera escriba las operaciones de su <strong>transacción</strong>.
Estas esperas en el acceso al <strong>registro</strong> son las que <a href="https://es.wikipedia.org/wiki/XFS">XFS</a> evita, permitiendo su modificación de manera asíncrona.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_sistemas_de_archivos_basados_en_copia_durante_la_escritura">19.8.4. Sistemas de archivos basados en copia durante la escritura</h4>
<div class="paragraph">
<p><em>Las técnicas anteriores son necesarias para preservar la coherencia porque la modificación de los metadatos se hace sobrescribiendo los datos que ya existen</em>.
Es decir, cuando se crea un nuevo archivo, el sistema busca un FCB libre, sobrescribe el bloque del dispositivo donde lo encuentra para almacenar el nuevo FCB, busca una entrada libre en el directorio y, nuevamente, sobrescribe el bloque del disco donde se almacena el directorio para incorporar la nueva entrada.
Si algunos de estos cambios tienen lugar pero otros no, el disco puede quedar en estado inconsistente.</p>
</div>
<div class="paragraph">
<p><em>Los <strong>sistemas de archivos basados en copia durante la escritura</strong></em> —o <em>copy-on-write</em>— <em>evitan cambiar los metadatos sobrescribiendo en el sitio</em>.
En su lugar buscan un hueco libre, hacen en él una copia del bloque completo con los cambios y después modifican los metadatos del sistema de archivos que sirven para localizar el bloque modificado en su nueva ubicación.
Estos cambios, a su vez, tampoco se hacen sobrescribiendo, sino que disparan la creación de copias modificadas de los bloques afectados, lo que nuevamente va seguido de cambios en los metadatos que ayudan a localizarlos.
El proceso se repite hasta que se alcanza el <em>bloque de control de volumen</em> y se cambia, momento en el que toda la secuencia de cambios se consolida.</p>
</div>
<div class="paragraph">
<p>Los sistemas de archivos basados en copy-on-write suele hacer hacer uso intensivo de estructuras de datos basadas en árbol porque es muy sencillo mover un nodo de bloque, con un efecto mínimo en el resto de la estructura.
Por ejemplo, al crear un archivo:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>Se busca un FCB libre, se lee el bloque que lo contiene en la memoria principal, se modifica y se escribe en un bloque libre</em>.
El sistema de archivos debe tener alguna estructura de datos que permita encontrar el bloque que contiene un FCB a partir de su identificador.
Por lo general, esta estructura es algún tipo de árbol.
Así que se modifica el nodo del árbol que señala al bloque con el nuevo FCB para que conozca la nueva ubicación.
Este cambio, implica crear un copia del bloque de dicho nodo con el cambio, lo que a su vez significa modificar el nodo que señala a este.
Y así sucesivamente hasta llegar a la raíz del árbol de FCB.</p>
</li>
<li>
<p><em>Se busca una entrada libre en el directorio que va a contener al archivo y se modifica para añadir el nombre del archivo, el identificador de su FCB y otras propiedades</em>.
Nuevamente, este cambio significa crear una copia, con los cambios descritos, del bloque que contiene la entrada y modificar el FCB del directorio para que contenga la nueva ubicación del bloque con el contenido del directorio.
Como antes, este cambio en el FCB dispara copias y modificaciones por todo el árbol de FCB, hasta la raíz</p>
</li>
<li>
<p>Una vez la raíz del árbol ha sido copiada a una nueva ubicación con los cambios, se actualiza su nueva posición en el <em>bloque de control de volumen.</em></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Si el sistema falla antes de la modificación del <em>bloque de control de volumen</em>, durante el montaje del sistema de archivos no quedará ni rastro de ninguno de los cambios porque dicho bloque aun hace referencia a la antigua raíz del árbol de FCB y, a partir de ellas, a todos los nodos, bloques y FCB originales.
Obviamente los sistemas que implementan este tipo de sistemas de archivo usan la memoria principal como caché con el objeto de combinar varias modificaciones sobre un mismo bloque antes de proceder a su escritura en disco, evitando desencadenar múltiples veces los cambios posteriores.</p>
</div>
<div class="paragraph">
<p>Los sistemas de archivos ZFS y Btrfs son los principales ejemplos de sistemas de archivos basados en <em>copy-on-write</em>.
Esta solución no sólo les permite tener las mismas propiedades que el uso de registro en cuanto a la preservación de la coherencia —con la ventaja de evitar dos escrituras en disco, una en el registro y otra para el cambio propiamente dicho— sino que además facilita que puedan ofrecer características adicionales, como la creación de copias instantáneas del volumen.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementación_de_sistemas_de_archivos">20. Implementación de sistemas de archivos</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>31 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Como ya hemos comentado, un sistema de archivos suele estar compuesto de varios niveles diferentes.
En la <a href="#estructura_sistema_de_archivos">Figura 56</a> se muestra un ejemplo de la estructura de un sistema de archivos diseñado en niveles.
Cada nivel utiliza las funciones de los niveles inferiores y proporciona nuevas funciones a los niveles superiores.
El papel de cada uno de estos niveles fue descrito en el <a href="#_estructura_de_un_sistema_de_archivos">Apartado 19.1</a>.
Mientras que las estructuras de metadatos utilizadas, tanto en la memoria como en disco, fueron tratadas brevemente en el <a href="#_estructuras_de_metadatos_en_disco">Apartado 19.2</a> y en el <a href="#_estructuras_de_metadatos_en_memoria">Apartado 19.3</a>.</p>
</div>
<div class="paragraph">
<p>A continuación, vamos a profundizar aun más en las estructuras y operaciones utilizadas para implementar los sistemas de archivos</p>
</div>
<div class="sect2">
<h3 id="_implementación_de_directorios">20.1. Implementación de directorios</h3>
<div class="paragraph">
<p>Cada directorio suele contener una estructura de datos que relaciona el nombre de cada archivo que contiene con el identificador de su <strong>FCB</strong>.
Dicho identificador permite localizar el FCB en la <strong>tabla de contenidos del volumen</strong>, que contiene el resto de los atributos del archivo.</p>
</div>
<div class="paragraph">
<p>En esta sección vamos a estudiar las formas más comunes de implementar la estructura de datos de un directorio.</p>
</div>
<div class="sect3">
<h4 id="_lista_lineal">20.1.1. Lista lineal</h4>
<div class="paragraph">
<p>El método mas simple para implementar un directorio consiste en utilizar una lista lineal o vector de nombres de archivos e identificadores del <strong>FCB</strong>.</p>
</div>
<div class="paragraph">
<p>Las acciones a realizar, para implementar cada una de las posibles operaciones sobre el directorio, serían:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Crear un archivo</strong>.
Primero se explora el directorio para estar seguros de que no haya ningún archivo con el mismo nombre.
Después se añade una nueva entrada al final del directorio.</p>
</li>
<li>
<p><strong>Borrar un archivo</strong>.
Primero se explora la lista en busca del archivo especificado y, una vez localizada, se libera la entrada correspondiente.
Para reutilizar la entrada del directorio tenemos diversas alternativas:</p>
<div class="ulist">
<ul>
<li>
<p>Se puede marcar la entrada como no utilizada.
Para eso se puede emplear un nombre especial o utilizar algún campo adicional —a parte de nombre de archivo e identificador del <strong>FCB</strong>— que se haya añadido a la entrada con ese propósito.</p>
</li>
<li>
<p>Insertar un puntero a la entrada en una lista de entradas libres, que se guarda dentro del mismo directorio.</p>
</li>
<li>
<p>Copiar la última entrada del directorio en la ubicación que ha quedado libre y reducir la longitud del directorio.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>La principal desventaja de un directorio implementado como una lista lineal de entradas es que para localizar un archivo es necesario realizar una búsqueda lineal, lo cual puede resultar muy costoso en directorios con un número muy grande de archivos.
Utilizando una lista ordenada se puede reducir el tiempo medio de búsqueda, pero complica los procesos de creación y borrado, pues puede que sea necesario mover cantidades importantes de información para mantener la lista ordenada.</p>
</div>
<div class="paragraph">
<p>También se puede utilizar una lista enlazada, tanto para reducir el tiempo necesario para borrar un archivo como para facilitar la tarea de mantener ordenada la lista.</p>
</div>
<div class="paragraph">
<p>Los sistemas de archivos <a href="https://es.wikipedia.org/wiki/Tabla_de_asignaci%C3%B3n_de_archivos">FAT</a> y <a href="https://es.wikipedia.org/w/index.php?title=FAT32">FAT32</a> implementan los directorios utilizando una lista lineal, donde en cada entrada se almacena el nombre del archivo y el <strong>FCB</strong> del mismo.
Al borrar un archivo, la entrada correspondiente se marca poniendo 0xE5 en el primer caracter del nombre del archivo.</p>
</div>
<div class="paragraph">
<p>Los sistemas de archivos <a href="https://es.wikipedia.org/wiki/Ext2">ext2</a> y <a href="https://es.wikipedia.org/wiki/Unix_File_System">UFS</a> también utilizan una lista lineal no ordenada, donde sólo se almacena el nombre del archivo o subdirectorio y el identificador del <strong>inodo</strong> —el FCB, esos sistemas de archivo— correspondiente.
En caso de borrar un archivo, el identificador del <strong>inodo</strong> se pone a 0.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tabla_de_dispersión">20.1.2. Tabla de dispersión</h4>
<div class="paragraph">
<p>En los directorios implementados con una <a href="https://es.wikipedia.org/wiki/Tabla_hash">tabla de dispersión</a> también se almacenan las entradas de directorio en una lista lineal, pero al mismo tiempo se utiliza una tabla de dispersión para reducir enormemente el tiempo de búsqueda en el directorio.
Para obtener la ubicación de dicho archivo dentro de la lista lineal, se usa un índice calculado con cierta función de dispersión a partir del nombre del archivo.</p>
</div>
<div class="paragraph">
<p>El único inconveniente es que debemos tratar la posible aparición de colisiones, que son aquellas situaciones en las que dos nombres de archivo dan lugar, al aplicarles la función de dispersión, la misma ubicación en la tabla.
Esto se puede resolver utilizando una lista enlazada en cada entrada de la lista —cada entrada en la lista señalaría la ubicación de la siguiente entrada de la lista que tiene el mismo valor para la función de dispersión— a cambio de que las búsquedas sean un poco más lentas.
En cualquier caso, este método será normalmente más rápido que una búsqueda lineal por todo el directorio.</p>
</div>
</div>
<div class="sect3">
<h4 id="_árbol_b">20.1.3. Árbol B</h4>
<div class="paragraph">
<p>Para mantener el directorio ordenado, algunos sistemas de archivos modernos utilizan estructuras de datos en árbol más sofisticadas, como por ejemplo árboles B.</p>
</div>
<div class="paragraph">
<p>Un caso concreto es el sistema de archivos <a href="https://es.wikipedia.org/wiki/NTFS">NTFS</a>, utilizado por Microsoft Windows.
<a href="https://es.wikipedia.org/wiki/NTFS">NTFS</a> utiliza una estructura de datos denominada <a href="https://es.wikipedia.org/wiki/%C3%81rbol_B%2B">árbol B+</a> para almacenar el índice de los nombres de archivo contenidos en un directorio.</p>
</div>
<div class="paragraph">
<p>En la entrada en la <strong>MFT</strong> (<em>Master File Table</em>) de cada directorio se almacena un atributo denominado <strong>raíz del índice</strong>.
Si el directorio es de pequeño tamaño, la <strong>raíz del índice</strong> contiene todas las entradas de archivos del directorio, pero para un directorio de gran tamaño, la <strong>raíz del índice</strong> sólo puede almacenar unas pocas entradas de archivos del directorio.
En ese caso la <strong>raíz del índice</strong> contiene el nivel superior del árbol B+.
Es decir, cada una de esas entradas de archivos en la <strong>raíz del índice</strong> incluye también un puntero al bloque del disco que contiene un nodo del árbol con las entradas con nombres alfabéticamente anteriores a ese.
Si en dicho nodo tampoco caben todas las entradas, sólo podrá contener algunas de ellas, por lo que cada una tendrá, a su vez, un puntero a un nuevo nodo del árbol; y así sucesivamente.</p>
</div>
<div class="paragraph">
<p>Las ventajas de los árboles B+ son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Eliminan el coste de reordenar las entradas del directorio.</p>
</li>
<li>
<p>La longitud desde la raíz del árbol hasta un nodo hoja es la misma para todas los caminos por el árbol, por lo que el tiempo de búsqueda tiene una cota superior.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Implementación de directorios en XFS</div>
<div class="paragraph">
<p>El sistema de archivos <a href="https://es.wikipedia.org/wiki/XFS">XFS</a> también utiliza un <a href="https://es.wikipedia.org/wiki/%C3%81rbol_B%2B">árbol B+</a>, pero en éste caso la implementación es un poco más compleja:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Un directorio de pequeño tamaño almacena sus entradas como una lista lineal no ordenada dentro de su mismo <strong>inodo</strong> o FCB.</p>
</li>
<li>
<p>Cuando el directorio no cabe en el <strong>inodo</strong> se le asigna un bloque propio, donde el directorio es implementado con una tabla de dispersión, tal y como hemos visto anteriormente.</p>
</li>
<li>
<p>Cuando el tamaño del directorio excede el tamaño del bloque, la tabla de dispersión se extrae y se almacena en un bloque diferente.
La lista lineal también se extrae, pero no tiene que ser almacenada en un único bloque, sino que puede estar repartida por distintos bloques a lo largo del disco.</p>
</li>
<li>
<p>Finalmente, cuando la tabla de dispersión excede el tamaño de un bloque, dicha tabla se convierte en un árbol B+.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_métodos_de_asignación">20.2. Métodos de asignación</h3>
<div class="paragraph">
<p>El siguiente problema es cómo asignar el espacio disponible en el disco a los archivos almacenados, de forma que el espacio sea utilizado de forma eficiente y que se pueda acceder a los archivos de la forma más rápida posible.</p>
</div>
<div class="paragraph">
<p>Como la unidad mínima de asignación de espacio a un archivo es el bloque, la fragmentación interna suele ser un problema común a todos los métodos que veremos a continuación.</p>
</div>
<div class="sect3">
<h4 id="_asignación_contigua">20.2.1. Asignación contigua</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>La <strong>asignación contigua</strong> requiere que cada archivo ocupe un conjunto contiguo de bloques en el disco.
Esto es muy eficiente, puesto que el acceso a todos los datos de un archivo requiere un movimiento mínimo del cabezal del disco.</p>
</div>
<div class="paragraph">
<p>El problema de la <strong>asignación contigua</strong> puede verse como un caso concreto del problema de la asignación dinámica del almacenamiento (véase el <a href="#_asignación_contigua_de_memoria">Apartado 15.5</a>).
Es decir, que en un momento dado tendremos una petición de tamaño <em>N</em> que deberemos satisfacer con una lista de huecos libres de tamaño variable.
Como estudiamos anteriormente, las estrategias más comunes son las de el <strong>primer ajuste</strong> y el <strong>mejor ajuste</strong>.</p>
</div>
<div class="sect4">
<h5 id="_fragmentación_externa_2">Fragmentación externa</h5>
<div class="paragraph">
<p>La asignación contigua sufre el problema de la <strong>fragmentación externa</strong>.
La solución sería utilizar alguna forma de <strong>compactación</strong> para unir los huecos libres, pero esto puede llevar mucho tiempo en discos duros de gran tamaño y en algunos sistemas esta tarea tiene que realizarse con el dispositivo desmontado.
Por eso es conveniente evitar utilizar técnicas de compactación en los sistemas en producción.</p>
</div>
<div class="paragraph">
<p>Afortunadamente, la mayor parte de los sistemas operativos modernos que necesitan mecanismos de <strong>desfragmentación</strong> pueden realizar esta tarea sin detener el sistema, aunque la perdida de rendimiento puede ser significativa.</p>
</div>
</div>
<div class="sect4">
<h5 id="_estimación_del_tamaño_del_archivo">Estimación del tamaño del archivo</h5>
<div class="paragraph">
<p>En la asignación contigua es necesario determinar cuánto espacio necesita un archivo antes de asignárselo.
El problema es que eso no siempre es posible.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, si vamos a copiar un archivo, es indudable que conocemos de antemano cuanto espacio necesita la copia.
Pero ¿qué ocurre cuando vamos a crear uno nuevo? Entonces al crear un archivo es necesario que el usuario haga una estimación del espacio que va necesitar y se la indique al sistema.</p>
</div>
<div class="paragraph">
<p>¿Y si la estimación no es correcta o posteriormente queremos añadir nuevos datos al archivo?
Entonces, Lo más probable es que el espacio situado a ambos lados del archivo ya esté ocupado, si hemos utilizado la estrategia del <strong>mejor ajuste</strong>.
Para resolver este problema existen dos estrategias:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La primera, es terminar el programa de usuario, emitiendo un error.
Entonces, el usuario deberá volver a crear el archivo indicando más espacio y volver a ejecutar el programa.
Puesto que las ejecuciones repetidas pueden ser muy costosas, lo más común es que el usuario acabe sobrestimando el espacio, lo que dará como resultado un desperdicio considerable de espacio.</p>
</li>
<li>
<p>La segunda, es buscar un hueco libre de mayor tamaño y copiar el contenido del archivo al nuevo espacio.
Esto puede hacerse siempre que exista suficiente espacio, aunque puede consumir bastante tiempo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Para minimizar estos problemas, se puede implementar un esquema de asignación contigua modificado, donde se asigna inicialmente un bloque contiguo de espacio al archivo y, posteriormente, si dicho espacio resulta no ser lo suficientemente grande, se añade otra área de espacio contiguo, denominado <strong>extensión</strong>.</p>
</div>
<div class="paragraph">
<p>La ubicación de las <strong>extensiones</strong> de un archivo se registran en el FCB, guardando la dirección del primer bloque de cada extensión que compone el archivo y el número de bloques que ocupa cada una.</p>
</div>
<div class="paragraph">
<p>Los sistemas de archivo <a href="https://es.wikipedia.org/wiki/XFS">XFS</a> y <a href="https://es.wikipedia.org/wiki/Ext4">ext4</a> utilizan <strong>extensiones</strong> para optimizar su funcionamiento.
El motivo es que cuantos más bloques contiguos sean asignados a un archivo, menos reposicionamientos del cabezal del disco son necesarios para leerlos.
En <a href="https://es.wikipedia.org/wiki/Ext4">ext4</a> el espacio se asigna a los archivos en <strong>extensiones</strong> de hasta 128 MiB, compuestas por bloques, generalmente, de 4KiB.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_asignación_enlazada">20.2.2. Asignación enlazada</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>En la <strong>asignación enlazada</strong> cada archivo es una lista enlazada de bloques de disco, pudiendo estos bloques estar dispersos por todo el disco:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Cada entrada de directorio contiene un puntero al primer bloque.
En ocasiones, la entrada también incluye un puntero al último, para facilitar añadir nuevos datos al final del archivo.</p>
</li>
<li>
<p>Cada bloque contiene un puntero al bloque siguiente.
Por ejemplo, si cada bloque tiene 512 bytes de tamaño y un puntero requiere 4 bytes, los bloques de disco tendrán un tamaño efectivo de 508 bytes.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Este mecanismo resuelve todos los problemas de la asignación contigua y además:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>No hay fragmentación externa</strong>, puesto que pueden utilizarse cualquier bloque libre para satisfacer una solicitud de espacio.</p>
</li>
<li>
<p><strong>No es necesario declarar el espacio del archivo</strong> en el momento de crearlo, pues el archivo podrá siempre podrá crecer mientras hayan bloques libres.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Sin embargo, la asignación enlazada también tiene sus desventajas.</p>
</div>
<div class="sect4">
<h5 id="_eficiencia_en_accesos_aleatorios">Eficiencia en accesos aleatorios</h5>
<div class="paragraph">
<p>La <strong>asignación enlazada</strong> sólo resulta eficaz para acceder a los archivos de acceso secuencial.</p>
</div>
<div class="paragraph">
<p>Si necesitamos ir directamente al bloque i-ésimo de un archivo, tendremos que comenzar desde el principio e ir leyendo cada bloque para obtener el puntero que nos indica el siguiente bloque.
Es muy posible que esas lecturas deban ir precedidas de un reposicionamiento de los cabezales del disco.</p>
</div>
<div class="paragraph">
<p>Una solución parcial a esto puede ser guardar en la memoria una caché de las direcciones de los bloques de los archivos accedidos recientemente.</p>
</div>
</div>
<div class="sect4">
<h5 id="_eficiencia_en_el_uso_del_espacio_de_almacenamiento">Eficiencia en el uso del espacio de almacenamiento</h5>
<div class="paragraph">
<p>En la <strong>asignación enlazada</strong> se pierde cierta cantidad de espacio con los punteros.</p>
</div>
<div class="paragraph">
<p>Si, por ejemplo, un puntero ocupa 4 bytes y un bloque tienen un tamaño de 512 bytes, el 0,758% del espacio en disco será utilizado para los punteros, en lugar de para almacenar información útil.</p>
</div>
<div class="paragraph">
<p>La solución para este problema consiste en asignar los bloques en grupos —denominados <strong>clústeres</strong>—.
Así, el primer bloque de cada <strong>clúster</strong> sólo tendría que almacenar un puntero al siguiente <strong>clúster</strong>, lo que reduciría la cantidad de espacio desperdiciada en los punteros y mejoraría la eficiencia al reducir el número de reposicionamientos del cabezal del disco.
Sin embargo, esto también incrementaría el grado de <strong>fragmentación interna</strong> pues se pierde más espacio cuando un <strong>clúster</strong> está parcialmente lleno.</p>
</div>
</div>
<div class="sect4">
<h5 id="_fiabilidad">Fiabilidad</h5>
<div class="paragraph">
<p>Teniendo en cuenta que los archivos están enlazados mediante punteros, parte de un archivo se puede corromper fácilmente con que solo uno de esos punteros se pierda o resulte dañado.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Asignación enlazada en FAT y FAT32</div>
<div class="paragraph">
<p>Los sistemas de archivos <a href="https://es.wikipedia.org/wiki/Tabla_de_asignaci%C3%B3n_de_archivos">FAT</a> y <a href="https://es.wikipedia.org/w/index.php?title=FAT32">FAT32</a> utilizan una variante del mecanismo de asignación enlazada en la que se emplea una <strong>tabla de asignación de archivo</strong> o <strong>FAT</strong> (<em>File-Allocation Table</em>).</p>
</div>
<div class="paragraph">
<p>La FAT se almacena en una sección al principio del volumen.
Contiene una entrada por cada <strong>clúster</strong> del disco y en cada una guarda el número del siguiente <strong>clúster</strong> del archivo.
Es decir, lo que hace la FAT es agrupa en un solo lugar los punteros de la <strong>asignación enlazada</strong>.</p>
</div>
<div id="estructura_fat" class="imageblock">
<div class="content">
<img src="C20-implementación_del_sistemas_de_archivos/media/estructura_fat.svg" alt="estructura fat">
</div>
<div class="title">Figura 57. Asignación enlazada en el sistema de archivos FAT.</div>
</div>
<div class="paragraph">
<p>Eso significa que la FAT es una estructura crítica.
Si se corrompe, puede provocar la pérdida de todo el sistema de archivos.
Por eso, realmente se almacenan dos copias de la FAT al principio del volumen.</p>
</div>
<div class="paragraph">
<p>El indexar con clústeres —o grupos de bloques— sirve para ubicar cerca bloques contiguos, pero sobre todo es una decisión de diseño para permitir que los sistemas de archivos <a href="https://es.wikipedia.org/wiki/Tabla_de_asignaci%C3%B3n_de_archivos">FAT</a> puedan gestionar volúmenes más grandes.
Por ejemplo, la FAT de MS-DOS 3.0 y posteriores usaba 16 bits para numerar los clústeres —por eso se llamaba FAT16—.
Si FAT16 trabaja directamente con bloques y cada bloque tuviera 512 bytes, no podría gestionar volúmenes de más de \$512* 2^16\$ bytes, es decir, 32 MiB.
Sin embargo, trabajando con 64 bloques por clúster, se puede usar para gestionar volúmenes de hasta 2 GiB.</p>
</div>
<div class="paragraph">
<p>Aunque algunas versiones de Microsoft Windows NT llegaron a admitir 128 e, incluso, 512 bloques por clúster, con clústeres tan grandes la <strong>fragmentación interna</strong> es un problema.</p>
</div>
<div class="paragraph">
<p>Por eso —entre otras cosas— Microsoft introdujo <a href="https://es.wikipedia.org/w/index.php?title=FAT32">FAT32</a>, que utiliza 32 bits para numerar los clústeres.
Eso implicar poder gestionar más cantidad de clústeres, lo que permite gestionar volúmenes más grandes con clústeres más pequeños y, por tanto, con menor <strong>fragmentación interna</strong>.
Por ejemplo, <a href="https://es.wikipedia.org/w/index.php?title=FAT32">FAT32</a> podía gestionar volúmenes de hasta 2 TiB con 64 bloques por clúster.</p>
</div>
<div class="paragraph">
<p>Como se puede ver en la <a href="#estructura_fat">Figura 57</a>, en los sistemas de archivos <a href="https://es.wikipedia.org/wiki/Tabla_de_asignaci%C3%B3n_de_archivos">FAT</a> cada entrada de directorio contiene, a parte del nombre del archivo y otros atributos, el número del primer clúster con datos del archivo.
La entrada de la FAT indexada según ese número contiene el número del siguiente clúster del archivo.
Iterando de esa manera, se puede conocer los números de todos los clústeres de un archivo.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>El último bloque del archivo se indica con un valor especial en su entrada en la FAT.
Mientras que los bloques no utilizados se indican con un valor igual a 0 en su entrada en la FAT.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>El uso de la FAT puede provocar un número importante de reposicionamientos del cabezal de disco, debido a que siempre es necesario volver al principio del volumen para leer dicha tabla.
Por eso, es muy habitual que el sistema operativo intente mantener una copia de la FAT en la memoria, a modo de caché.</p>
</div>
<div class="paragraph">
<p>Una de las ventajas de este esquema es que mejora el tiempo de los accesos aleatorios a los archivos —respecto a la asignación enlazada convencional— porque se puede conocer la ubicación de cualquier bloque a partir de la información en la FAT, sin tener que leer todos los bloques del archivo uno a uno.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_asignación_indexada">20.2.3. Asignación indexada</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El mecanismo de <strong>asignación indexada</strong> agrupa todos los punteros de la asignación enlazada en una única ubicación: el <strong>bloque de índices</strong>.
Así se resuelve la falta de eficiencia de la asignación enlazada convencional —en ausencia de FAT— cuando se realizan accesos aleatorios.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>En la <strong>asignación indexada</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cada archivo tiene su propio <strong>bloque de índices</strong>, que es un bloque del disco con una tabla con los números de los bloques del disco que contienen los datos del archivo.</p>
</li>
<li>
<p>La entrada i-ésima del bloque de índice contiene la dirección del bloque i-ésimo del archivo.</p>
</li>
<li>
<p>Cada entrada de directorio contiene la dirección del bloque de índices del archivo correspondiente.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Este mecanismo soporta el acceso aleatorio eficiente, además de no sufrir el problema de la fragmentación externa.
Sin embargo, también tiene sus desventajas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se pierde más espacio en los punteros que con el mecanismo de asignación enlazada, pues siempre hay que reservar un <strong>bloque de índices</strong> completo para cada archivo.
Mientras que con la asignación enlazada, sólo se pierde el espacio de los punteros que realmente es necesario utilizar.</p>
</li>
<li>
<p>Al diseñar el sistema de archivos debemos determinar el tamaño del <strong>bloque de índices</strong>.</p>
<div class="paragraph">
<p>Por el inconveniente anterior y puesto que cada archivo debe tener un bloque de índices, ese bloque debe ser lo más pequeño posible para no perder espacio.
Pero si es demasiado pequeño, no podrá almacenar suficientes punteros para un archivo de gran tamaño.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Entre los mecanismos que pueden utilizarse para resolver este último problema están los siguientes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En el <strong>esquema enlazado</strong>, se enlazan los bloques de índices.</p>
<div class="paragraph">
<p>Por ejemplo, se puede utilizar el último puntero del bloque de índices para apuntar al siguiente bloque de índices.
Si dicho puntero tiene valor 0, entonces estamos en el último bloque de índices del archivo.</p>
</div>
</li>
<li>
<p>En el <strong>índice multinivel</strong>, los punteros del bloque de índices no señalan a los bloques del archivo, sino a un conjunto de bloques de índices de segundo nivel y estos, a su vez señalan, a los bloques del archivo.
Esta técnica puede puede ampliarse utilizando un tercer o cuarto nivel, dependiendo del tamaño máximo de archivo que se desee.</p>
</li>
<li>
<p>En el <strong>esquema combinado</strong> las primeras entradas del bloque de índices apuntan directamente a los primeros bloques del archivo.
Mientras que las siguientes entradas contiene punteros indirectos, que apunta a un conjunto de bloques de índices de segundo nivel.
Después podrían haber entradas que contienen punteros doblemente indirectos y luego entradas con punteros triplemente indirectos.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Para mejorar el rendimiento de los mecanismos de asignación indexados, es muy común que el sistema operativo intente mantener los bloques de índices en la memoria.</p>
</div>
<div id="asignación_ext2" class="imageblock">
<div class="content">
<img src="C20-implementación_del_sistemas_de_archivos/media/asignación_ext2.svg" alt="asignación ext2">
</div>
<div class="title">Figura 58. Asignación indexada combinada en el sistema de archivos ext2.</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Los sistemas de archivos <a href="https://es.wikipedia.org/wiki/Ext2">ext2</a> y <a href="https://es.wikipedia.org/wiki/Ext3">ext3</a> utilizan el mecanismo de <strong>asignación indexada</strong> con <strong>esquema combinado</strong>.
Concretamente el mecanismo en <a href="https://es.wikipedia.org/wiki/Ext2">ext2</a> se implementa de la siguiente manera:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>El disco se divide en múltiples grupos de bloques de disco.</p>
</li>
<li>
<p>En cada grupo, se utilizan los primeros bloques para almacenar una tabla de <strong>inodos</strong>.
Estos <strong>inodos</strong> son los <strong>FCB</strong> de los archivos almacenados en el grupo.</p>
<div class="paragraph">
<p>El resto de los bloques se utilizan para almacenar los datos de los archivos representados por los <strong>inodos</strong> del grupo.</p>
</div>
</li>
<li>
<p>Dentro de cada <strong>inodo</strong> —entre otra información típica en un <strong>FCB</strong>— se almacenan los punteros a los bloques del archivo, en lugar de utilizar un bloque de índices aparte.</p>
</li>
<li>
<p>Como se puede ver en la <a href="#asignación_ext2">Figura 58</a>, los primeros 12 punteros en el <strong>inodo</strong> son directos, seguidos de un puntero indirecto, un puntero doblemente indirecto y uno triplemente indirecto.
Esto permite almacenar hasta \$2^64\$ bytes de información en cada archivo.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gestión_del_espacio_libre">20.3. Gestión del espacio libre</h3>
<div class="paragraph">
<p>Puesto que el espacio en disco es limitado, necesitamos poder reutilizar el espacio de los archivos borrados.
Para controlar el espacio libre en el disco, el sistema de archivos mantiene una <strong>lista de espacio libre</strong> que contiene todos los bloques de disco disponibles.
Para crear un archivo, se explora la <strong>lista de espacio libre</strong> hasta obtener la cantidad de espacio requerida y se asigna ese espacio al nuevo archivo.</p>
</div>
<div class="paragraph">
<p>A continuación estudiaremos las diferentes maneras de implementar esa lista.</p>
</div>
<div class="sect3">
<h4 id="_vector_de_bits">20.3.1. Vector de bits</h4>
<div class="paragraph">
<p>La lista de espacio libre puede ser implementada como un <strong>vector de bits</strong> o <strong>mapa de bits</strong>, donde cada bloque es representado por un bit.
Si el bloque está libre, el bit está a 1, mientras que si el bloque está asignado, el bit está a 0.</p>
</div>
<div class="paragraph">
<p>Este enfoque es relativamente sencillo y eficiente, puesto que muchos procesadores disponen de instrucciones para manipular bits, que pueden utilizarse para obtener rápidamente el primer bloque libre.
Por ejemplo, la familia de procesadores <a href="https://es.wikipedia.org/wiki/IA-32">x86</a>, a partir del <a href="https://es.wikipedia.org/wiki/Intel_80386">Intel 80386</a>, tiene instrucciones que devuelven la posición del primer bit a 1 en el valor de un registro.</p>
</div>
<div class="paragraph">
<p>Sin embargo, leer el vector de bits, modificarlo y actualizarlo en disco en cada ocasión, es tremendamente ineficiente.
Por tanto, usar vectores de bits es ineficiente, a menos que se mantenga el vector completo en la memoria principal, escribiéndose ocasionalmente en el disco.</p>
</div>
<div class="paragraph">
<p>Esto último puede ser imposible para los discos de gran tamaño, en función de la cantidad de memoria principal.
Por ejemplo, un disco de 40 GiB con bloques de 512 bytes necesitará un mapa de bits de más de 10 MiB, lo que no es un gran requisito para un sistema moderno pero si lo era hace dos décadas.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>El sistema de archivo NTFS y la familia <em>extended filesystem</em> —es decir, <a href="https://es.wikipedia.org/wiki/Extended_file_system">ext</a>, <a href="https://es.wikipedia.org/wiki/Ext2">ext2</a>, <a href="https://es.wikipedia.org/wiki/Ext3">ext3</a> y {ext4— utilizan mapas de bits, tanto para gestionar los bloques de datos libres como las entradas disponibles en la tabla de <strong>inodos</strong>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_lista_enlazada">20.3.2. Lista enlazada</h4>
<div class="paragraph">
<p>Otra técnica consiste en enlazar todos los bloques de disco libres.
Para eso se puede guardar un puntero al primer bloque libre en una ubicación especial del disco y que ese bloque contenga un puntero al siguiente bloque libre del disco.
El segundo bloque contendría un puntero al tercer bloque libre, y así sucesivamente.</p>
</div>
<div class="paragraph">
<p>El inconveniente es que recorrer la lista no resulta eficiente, pues tenemos que leer cada bloque para conocer la dirección del siguiente bloque libre en disco.
Sin embargo, debemos tener en cuenta que no es frecuente tener que recorrer la lista de espacio libre completa porque, por lo general, basta con encontrar el primer bloque libre para asignar el espacio.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Los sistemas de archivos <a href="https://es.wikipedia.org/wiki/Tabla_de_asignaci%C3%B3n_de_archivos">FAT</a> incorporan el control de bloques libres dentro de la <strong>tabla de asignación de archivos</strong> guardando un 0 en las entradas de los <strong>clústeres</strong> libres, por lo que no se necesita ningún método adicional.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_agrupamiento">20.3.3. Agrupamiento</h4>
<div class="paragraph">
<p>Una modificación de la técnica basada en la lista enlazada consiste en almacenar las direcciones de <em>N</em> bloques libres en el primer bloque libre.
Los primeros <em>N — 1</em> de esos bloques estarían realmente libres, pero el último de ellos apuntaría a otro bloque con <em>N</em> bloques libres.
Así podrían localizarse rápidamente las direcciones de un gran número de bloques libres, lo cual mejora la eficiencia respecto a la técnica de lista enlazada.</p>
</div>
</div>
<div class="sect3">
<h4 id="_recuento">20.3.4. Recuento</h4>
<div class="paragraph">
<p>Generalmente los bloques son asignados o liberados en bloques contiguos, especialmente si el espacio es asignado mediante asignación contigua o en <strong>extensiones</strong> o <strong>clústeres</strong>.
Esto puede ser aprovechado para mantener una lista donde cada entrada almacena la dirección del primer bloque de un conjunto de bloques libres contiguo, así como el número de bloques del conjunto.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, el sistema de archivos <a href="https://es.wikipedia.org/wiki/XFS">XFS</a> utiliza un árbol B+ para almacenar las direcciones de las extensiones de bloques libres y mantenerlas ordenadas por el tamaño de la extensión a la que apuntan.
Así el sistema operativo puede localizar rápidamente el espacio libre necesario para satisfacer una necesidad de espacio concreta.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_de_archivos_virtuales">20.4. Sistemas de archivos virtuales</h3>
<div class="paragraph">
<p>En el <a href="#_montaje_de_sistemas_de_archivos">Apartado 19.4</a> vimos cómo el sistema operativo <strong>monta</strong> sistemas de archivos de tal forma que aparenten estar integrados en una única estructura de directorios, permitiendo a los usuarios moverse de forma transparente entre distintos dispositivos y tipos de sistemas de archivos.
Para hacerlo, un sistema operativo moderno debe ser capaz de soportar de manera eficiente distintos tipos de sistemas de archivos, ocultando sus diferencias de cara a los usuarios.</p>
</div>
<div class="paragraph">
<p>Un método para implementar múltiples tipos de sistemas de archivos consiste en escribir diferentes rutinas de acceso, manipulación y gestión —de los directorios y archivos— para cada uno de los tipos de sistema de archivo existentes.
Sin embargo, en lugar de esta solución, la mayoría de los sistemas operativos utilizan técnicas de programación orientada a objetos para implementar diferentes tipos de sistemas de archivos detrás de una misma interfaz de programación.
Es decir, se utilizan estructuras de datos y procedimientos comunes para separar las llamadas al sistema de los detalles de su implementación real, para cada uno de los sistemas de archivos.</p>
</div>
<div class="paragraph">
<p>La implementación de un sistema de archivos está compuesta de tres niveles fundamentales: la <strong>interfaz del sistema de archivos</strong>, el <strong>sistema de archivos virtual</strong> y, finalmente, la implementación real del sistema de archivos.</p>
</div>
<div class="sect3">
<h4 id="_interfaz_del_sistema_de_archivos">20.4.1. Interfaz del sistema de archivos</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El primer nivel es la <strong>interfaz del sistema de archivos</strong>, a la que acceden los desarrolladores a través de las llamadas al sistema.
En sistemas POSIX, estamos hablando de las llamadas <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a>, <a href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a>, <a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a> y <a href="https://man7.org/linux/man-pages/man2/close.2.html">close()</a>, entre otras.
Y de los descriptores de archivos con los que se identifican los archivos abiertos.</p>
</div>
<div class="paragraph">
<p>Esta interfaz es la misma sea cual sea el sistema de archivos al que se esté intentando acceder.</p>
</div>
</div>
<div class="sect3">
<h4 id="_sistema_de_archivos_virtual">20.4.2. Sistema de archivos virtual</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El segundo nivel es la interfaz del <strong>sistema de archivos virtual</strong> o <strong>VFS</strong> (<em>Virtual File System</em>).
Este nivel es utilizado por el anterior para atender las peticiones realizadas.</p>
</div>
<div class="paragraph">
<p>Describe operaciones genéricas sobre cualquier sistema de archivos y estructuras genéricas.
Por ejemplo, el <strong>FCB virtual</strong>, que identifica de forma unívoca a cada archivo o directorio en uso en todo el sistema, dando acceso a sus metadatos.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En Linux el <strong>FCB virtual</strong> se denomina <strong>vnodo</strong>.
El <strong>vnodo</strong> de un archivo lo identifica de forma unívoca en todo el sistema, incluso diferenciando archivos en sistemas de archivos diferentes.
Mientras que el <strong>inodo</strong> es un detalle de la implementación real del sistema de archivos, por lo que solo es único dentro del mismo sistema de archivos.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Este nivel cumple con dos importantes funciones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Separa las operaciones genéricas sobre el sistema de archivos con respecto a su implementación.</p>
<div class="paragraph">
<p><strong>VFS</strong> define una interfaz muy clara y común para todos los sistemas de archivos.
De esta interfaz existirán diversas implementaciones en el mismo sistema, una para cada sistema de archivos diferente.</p>
</div>
</li>
<li>
<p>Proporcionar un mecanismo para acceder de forma coherente a los archivos a través de la red.</p>
<div class="paragraph">
<p>Una implementación de <strong>VFS</strong> no tiene que estar limitada exclusivamente a ofrecer acceso a archivos en dispositivos conectados físicamente al sistema.
Las operaciones de la interfaz <strong>VFS</strong> pueden implementarse de tal forma que usen un protocolo de acceso a algún servidor de archivos conectado a la red.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_implementación_del_sistema_de_archivos">20.4.3. Implementación del sistema de archivos</h4>
<div class="paragraph">
<p>El tercer nivel es donde se implementa cada tipo de sistema de archivos o los distintos protocolos de los servidores de archivos en la red.
La interfaz <strong>VFS</strong> recurre a la implementación correspondiente para cada tipo de sistema de archivos, para satisfacer las solicitudes de los niveles superiores.</p>
</div>
<div class="paragraph">
<p>Así, por ejemplo, un <a href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a> puede implicar que se tenga que recuperar el <strong>vnodo</strong> del archivo involucrado desde la tabla de archivos abiertos, usando el descriptor de archivo indicado en la llamada al sistema.
Después, se invocaría la operación <strong>VFS</strong> <code>read()</code> sobre el <strong>vnodo</strong>, en la implementación concreta de <strong>VFS</strong> según el tipo de sistema de archivos involucrado.
Será esa implementación quien extraiga del <strong>vnodo</strong> la información necesaria —por ejemplo, el <strong>inodo</strong> real del archivo en el sistema de archivos— para llevar acabo la operación indicada, según las especificidades del sistema de archivos.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_planificación_de_disco">20.5. Planificación de disco</h3>
<div class="paragraph">
<p>Como ya hemos comentado, es responsabilidad del sistema operativo usar los recursos del hardware de forma eficiente.
Eso incluye planificar los procesos en la CPU para conseguir el mínimo tiempo de espera que sea posible o aprovechar de la mejor forma la memoria principal disponible para atender la demanda de los distintos procesos al mismo tiempo; pero también, intentar obtener el menor tiempo de acceso y el mayor ancho de banda posible en el acceso a los discos.</p>
</div>
<div class="sect3">
<h4 id="_rendimiento_del_acceso_a_disco">20.5.1. Rendimiento del acceso a disco</h4>
<div class="paragraph">
<p>En un disco duro magnético el <strong>tiempo de acceso al disco</strong> \$T^d\$ viene determinado por el <strong>tiempo de búsqueda</strong> \$T^b\$ y la <strong>latencia rotacional</strong> \$T^r\$:</p>
</div>
<div class="stemblock">
<div class="content">
\$T_d=T_b+T_r\$
</div>
</div>
<div class="paragraph">
<p>El <strong>tiempo de búsqueda</strong> \$T^b\$ es el tiempo que se tarda en mover el brazo del disco hasta el cilindro deseado.
Mientras que la <strong>latencia rotacional</strong> \$T^r\$ es el tiempo que hay que esperar para que el disco gira hasta que la cabeza llegue al sector deseado del cilindro.
Por lo tanto, el <strong>tiempo de acceso al disco</strong> es menor cuando se realizan accesos consecutivos a sectores físicamente próximos que cuando están dispersos por todo el disco.</p>
</div>
<div class="paragraph">
<p>El <strong>ancho de banda</strong> o <strong>tasa de transferencia</strong> del disco es el total de bytes transferidos en una petición dividido por el tiempo total que transcurre desde la primera solicitud de servicio hasta el final de la última transferencia, con la que se termina de atender la petición.
Al considerar todo el tiempo necesario para atender la petición, a más <strong>tiempo de acceso al disco</strong> menor es el <strong>ancho de banda</strong>.</p>
</div>
<div class="paragraph">
<p>En los dispositivos de almacenamiento basados en memorias de estado sólido (véase el <a href="#_memorias_de_estado_sólido">Apartado 18.1.3</a>) el tiempo de acceso viene determinado por las características de la memoria —entre otros factores— lo que hace que las diferencias entre accesos secuenciales y accesos aleatorios sean mucho menos significativas.</p>
</div>
</div>
<div class="sect3">
<h4 id="_cola_de_es_al_disco">20.5.2. Cola de E/S al disco</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Cuando se solicita una operación de E/S sobre el almacenamiento, si la controladora y la unidad de disco están desocupadas, el sistema operativo puede atender la petición sobre la marcha.
Pero si están ocupadas, el sistema operativo almacena la solicitud en una cola de peticiones pendientes.
Cuando se resuelve una solicitud, el sistema operativo escoge otra de la cola y se comunica con el hardware para programar la siguiente petición.
La cuestión es ¿cuál es el orden adecuado para escoger la peticiones de E/S de la cola, si se quiere acceder al disco de la forma más eficaz posible?</p>
</div>
</div>
<div class="sect3">
<h4 id="_planificación_fcfs_2">20.5.3. Planificación FCFS</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>En la planificación <strong>FCFS</strong> (<em>First Come, First Served</em>) o <strong>primero que llega, primero servido</strong> la cola de E/S al disco es FIFO.
Es decir, que las las solicitudes se atienden en orden de llegada.</p>
</div>
<div class="paragraph">
<p>Es el algoritmo de planificación más simple y es equitativo, en sentido de que atiende a todos los procesos por igual.
Pero, lamentablemente, no proporciona el servicio más rápido en disco duros magnéticos, donde interesa mover el brazo del disco lo menos posible.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En Linux el <strong>FCFS</strong> es actualmente denominado <strong>NOOP</strong>.
Se suele utilizar en los discos basados en memorias de estado sólido, donde reordenar las solicitudes no proporciona una mejora significativa del rendimiento, o cuando se utilizan controladoras de disco inteligentes que pueden reordenar las solicitudes según su propio criterio.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_planificación_sstf">20.5.4. Planificación SSTF</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>En la planificación <strong>SSTF</strong> (<em>Sortest</em> <em>Seek Time First</em>) o algoritmo de <strong>tiempo de búsqueda más corto</strong>, de toda cola se selecciona la solicitud con el menor <strong>tiempo de búsqueda</strong> desde la posición actual de la cabeza.
Este algoritmo de planificación primero da servicio a las solicitudes cercanas a la posición actual de la cabeza, antes de alejarse para dar servicio a otras solicitudes, dado que el <strong>tiempo de búsqueda</strong> se incrementa a medida que lo hace el número de cilindros que es necesario recorrer para llegar a una posición dada.</p>
</div>
<div class="paragraph">
<p>Aun así, la solución no es óptima, dado que puede provocar inanición de algunas solicitudes, si van llegando constantemente nuevas solicitudes sobre regiones cercanas a donde está actualmente la cabeza del disco.</p>
</div>
</div>
<div class="sect3">
<h4 id="_planificación_scan_y_c_scan">20.5.5. Planificación SCAN y C-SCAN</h4>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>En la planificación <strong>SCAN</strong>, algoritmo de <strong>exploración</strong> o del <strong>ascensor</strong>, el brazo del disco comienza en un extremo del disco y se mueve hacia el otro, atendiendo solicitudes a medida que pasa por cada cilindro, hasta llegar al otro extremo del disco.
En el otro extremo, la dirección de movimiento de la cabeza se invierte para recorrer el disco en sentido inverso, repitiendo el proceso.</p>
</div>
<div class="paragraph">
<p>Suponiendo que las solicitudes se distribuyen de forma uniforme a lo largo del disco, es de suponer que cuando se llega a un extremo —justo antes de volver— la cantidad de solicitudes en dicho extremo será notablemente menor que dónde comenzó el barrido que acaba de terminar.
Entonces ¿por qué no volver a empezar desde ese extremo?</p>
</div>
<div class="paragraph">
<p>A la variante del <strong>SCAN</strong> que cuando llega a un extremo vuelve al inicio, para volver a barrer desde allí, sin atender ninguna solicitud por el camino, se la denomina <strong>C-SCAN</strong> —de <em>Circula SCAN</em>—.
Con esta variante el tiempo que tiene que esperar una solicitud para ser atendida es más uniforme que con el algoritmo <strong>SCAN</strong> original.</p>
</div>
</div>
<div class="sect3">
<h4 id="_planificación_look_y_c_look">20.5.6. Planificación LOOK y C-LOOK</h4>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>En teoría los algoritmos <strong>SCAN</strong> y <strong>C-SCAN</strong> hacen que el brazo recorra los cilindros del primero al último, pero normalmente no se suelen implementar así.</p>
</div>
<div class="paragraph">
<p>Por lo general, cuando en el recorrido del brazo, tras atender una solicitud, se descubre que ya no hay más solicitudes siguiendo la misma dirección, el brazo invierte la dirección sin llegar hasta el extremo del disco.</p>
</div>
<div class="paragraph">
<p>A estas variantes de <strong>SCAN</strong> y <strong>C-SCAN</strong> se las denomina <strong>(LOOK)</strong> y <strong>(C-LOOK)</strong>, respectivamente.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Linux utilizó <strong>C-LOOK</strong>, bajo el nombre de <strong><em>elevator</em></strong>, como planificador de E/S de disco hasta Linux 2.6.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_planificación_n_step_scan_n_step_look_y_f_scan">20.5.7. Planificación N-Step-SCAN, N-Step-LOOK y F-SCAN</h4>
<div class="paragraph">
<p>

</p>
</div>
<div class="paragraph">
<p>Los algoritmos <strong>N-Step-SCAN</strong> y <strong>N-Step-LOOK</strong> son variantes de los algoritmos <strong>SCAN</strong> y <strong>LOOK</strong>, respectivamente; donde se limita a <em>N</em> el número de solicitudes que se atenderán en cada barrido del brazo del disco.
Estos algoritmos funcionan de la siguiente manera:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Se utiliza una cola con espacio para <em>N</em> solicitudes pendientes, que se van atendiendo mientras el brazo barre el disco.</p>
</li>
<li>
<p>Mientras tanto, todas las nuevas solicitudes se incorporan a una cola diferente.</p>
</li>
<li>
<p>Cuando el brazo termina el barrido y las <em>N</em> primeras solicitudes han sido atendidas, el planificador toma otras <em>N</em> solicitudes de la segunda cola y las introduce en la primera para repetir el proceso.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Si en lugar de copiar <em>N</em> peticiones de la segunda a la primera cola, se copian todas las solicitudes pendientes, el algoritmo se denomina <strong>F-SCAN</strong>.</p>
</div>
<div class="paragraph">
<p>Estos algoritmos previenen un problema denominado <strong>rigidez del brazo</strong> —o <em>arm stickiness</em>, en inglés— a diferencia de los algoritmos SSTF, SCAN, C-SCAN, LOOK y C-LOOK, que no lo hacen.
El termino <strong>rigidez del brazo</strong> hace referencia a cuando hay un flujo continuo de solicitudes para el mismo cilindro, esto hace que con los algoritmos vistos hasta ahora, el brazo no avance por los cilindros hasta llegar al otro extremo.
Como <strong>F-SCAN</strong>, <strong>N-Step-SCAN</strong> y <strong>N-Step-LOOK</strong> separan las solicitudes en dos colas —haciendo que las nuevas tengan que esperar— el brazo siempre continua su barrido hacia el extremo del disco.</p>
</div>
</div>
<div class="sect3">
<h4 id="_planificación_cfq">20.5.8. Planificación CFQ</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El planificador <strong>CFQ</strong> (<em>Completely Fair Queuing</em>) se diseñó para compartir de forma equitativa el <strong>ancho de banda</strong> entre todos los procesos que solicitan acceso al disco.
Fue utilizado por defecto en muchas distribuciones de Linux hasta la versión 5.0 del núcleo y funciona de la siguiente manera:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>CFQ</strong> mantiene una cola de solicitudes para cada proceso y en ella inserta las solicitudes síncronas de E/S.
Cada cola tiene una ventana de tiempo —o <strong>cuanto</strong>— para acceder al disco.
La longitud del <strong>cuanto</strong> y el tamaño máximo de cada cola dependen de la prioridad de E/S que tenga el proceso.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Las solicitudes síncronas de E/S son aquellas que hacen que el proceso permanezca en estado <strong>esperando</strong> hasta que se resuelve la petición.
Por ejemplo, las operaciones de lectura bloqueantes, como ocurre por defecto con <a href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a>.
Mientras que las solicitudes asíncronas son las que permiten que el proceso continúe su ejecución en la CPU mientras se atiende la petición.
Como las escrituras con <a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>CFQ</strong> mantiene una cola de solicitudes por cada prioridad de E/S, donde se insertan las solicitudes asíncronas de todos los procesos.
Una solicitud asíncrona se inserta en una cola u otra según la prioridad del proceso que la generó.</p>
</li>
<li>
<p>Usando el algoritmo <strong><em>round-robin</em></strong>, el planificador <strong>CFQ</strong> recorre las colas y extrae de ellas las solicitudes durante el tiempo marcado por el cuanto de cada cola.
Las solicitudes extraídas se insertan en la cola de E/S al disco, donde se ordenan para minimizar el <strong>tiempo de búsqueda</strong>, antes de ser enviadas al dispositivo.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Actualmente, los planificadores <strong>CFS</strong> y <strong>NOOP</strong> se consideran obsoletos.
En su lugar el planificador por defecto en Linux para SSD y discos duros es <strong>mq-deadline</strong> —un adaptación del planificador <a href="https://en.wikipedia.org/wiki/Deadline_scheduler">deadline</a>, también obsoleto—.
Mientras que para dispositivos NVM Express se utiliza <strong>NONE</strong>, que básicamente desactiva la planificación de la E/S de disco.</p>
</div>
<div class="paragraph">
<p>Otros planificadores disponibles actualmente son <a href="http://algo.ing.unimo.it/people/paolo/disk_sched/">BFQ</a> —diseñado para minimizar la latencia— y Kyber.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_bibliografía">Bibliografía</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Parte de los contenidos de este documento están basados en las siguientes fuentes:</p>
</div>
<div class="ulist bibliography">
<ul class="bibliography">
<li>
<p><a id="Bavier2000"></a>[Bavier2000]
Bavier, A. «Creating New CPU Schedulers with Virtual Time». En 21st IEEE Real-Time Systems Symposium (RTSS 2000) WIP Proceedings, 2000.</p>
</li>
<li>
<p><a id="Chase2009"></a>[Chase2009]
Chase, K. y Russinovich, M. «Processes, Threads, and Jobs in the Windows Operating System». [en línea]. Pearson, 2009 [2009]. URL <a href="https://www.microsoftpressstore.com/articles/article.aspx?p=2233328&amp;seqNum=7" class="bare">https://www.microsoftpressstore.com/articles/article.aspx?p=2233328&amp;seqNum=7</a></p>
</li>
<li>
<p><a id="Friedman1999"></a>[Friedman1999]
Friedman, M. B. «Windows NT Page Replacement Policies». En 25th International Computer Measurement Group Conference, December 5-10, 1999, Pag. 234-244.</p>
</li>
<li>
<p><a id="Ganger2000"></a>[Ganger2000]
Ganger, G. R., McKusick, M. K., Soules, C. A. N. y Patt, Y. N. «Soft Updates: A Solution to the Metadata Update Problem in File Systems». En ACM Transactions on Computer Systems, Vol. 18, No. 2, May 2000, Pag. 127—153.</p>
</li>
<li>
<p><a id="Gaydov2016"></a>[Gaydov2016]
Gaydov, V. «File locking in Linux» [en línea]. 2016 [2020]. URL <a href="https://gavv.github.io/articles/file-locks/" class="bare">https://gavv.github.io/articles/file-locks/</a></p>
</li>
<li>
<p><a id="Gorman2004"></a>[Gorman2004]
Gorman, M. «Understanding the Linux Virtual Memory Manager». Prentice Hall, 2004.</p>
</li>
<li>
<p><a id="Hailperin2006"></a>[Hailperin2006]
Hailperin, M. «Operating Systems and Middleware: Supporting Controlled Interaction». Course Technology, 2006.</p>
</li>
<li>
<p><a id="Jacob1998"></a>[Jacob1998]
Jacob, B y Mudge, T. «Virtual Memory: Issues of Implementation». Computer, 31:33-43, 1998. ISSN 0018-9162. DOI: 10.1109/2.683005. URL <a href="http://dx.doi.org/10.1109/2.683005" class="bare">http://dx.doi.org/10.1109/2.683005</a>.</p>
</li>
<li>
<p><a id="Microsoft2005"></a>[Microsoft2005]
«Kernel Enhancements for Microsoft Windows Vista and Windows Server Longhorn» [en línea]. Microsoft Corporation, 2005. URL <a href="https://www.slideserve.com/iolani/kernel-enhancements-for-windows-server-longhorn" class="bare">https://www.slideserve.com/iolani/kernel-enhancements-for-windows-server-longhorn</a>.</p>
</li>
<li>
<p><a id="Microsoft2003"></a>[Microsoft2003]
«Kernel Enhancements for Windows XP» [en línea]. Microsoft Corporation, 2003 [2006]. ARCHIVADO <a href="https://web.archive.org/web/20080307105611/http://www.microsoft.com/whdc/driver/kernel/xp_kernel.mspx" class="bare">https://web.archive.org/web/20080307105611/http://www.microsoft.com/whdc/driver/kernel/xp_kernel.mspx</a>.</p>
</li>
<li>
<p><a id="Microsoft2018"></a>[Microsoft2018]
«Scheduling Priorities» [en línea]. Microsoft Corporation, 2018 [2020]. URL <a href="https://docs.microsoft.com/en-us/windows/win32/procthread/scheduling-priorities" class="bare">https://docs.microsoft.com/en-us/windows/win32/procthread/scheduling-priorities</a></p>
</li>
<li>
<p><a id="SGI2006"></a>[SGI2006]
«XFS Filesystem Structure» [en línea]. Silicon Graphics Inc, 2006 [2007]. URL <a href="https://goo.gl/YF82JB" class="bare">https://goo.gl/YF82JB</a></p>
</li>
<li>
<p><a id="Silberschatz2004"></a>[Silberschatz2004]
Silberschatz, A., Galvin, P. y Gagne, G. <a href="http://absysnetweb.bbtk.ull.es/cgi-bin/abnetopac?ACC=DOSEARCH&amp;xsqf99=184173.titn./">«Operating System Concepts with Java»</a>. 6º ed. John Wiley &amp; Sons Inc., 2004.</p>
</li>
<li>
<p><a id="Silberschatz2005"></a>[Silberschatz2005]
Silberschatz, A., Galvin, P. y Gagne, G. <a href="http://absysnetweb.bbtk.ull.es/cgi-bin/abnetopac?ACC=DOSEARCH&amp;xsqf99=345629.titn./">«Fundamentos de Sistemas Operativos»</a>. 7ª ed. McGraw Hill, 2005.</p>
</li>
<li>
<p><a id="Solomon2005"></a>[Solomon2005]
Solomon, D. A. y Russinovich, M. «Windows OS Internals&#8201;&#8212;&#8201;Unit OS4: Scheduling and Dispatch 4.4. Windows Thread» [en línea]. 2005 [2009]. URL <a href="https://slideplayer.com/slide/6972581/" class="bare">https://slideplayer.com/slide/6972581/</a></p>
</li>
<li>
<p><a id="Stallings2005"></a>[Stallings2005]
Stallings, W. <a href="http://absysnetweb.bbtk.ull.es/cgi-bin/abnetopac?TITN=314530">«Sistemas operativos: Aspectos internos y principios de diseño»</a>. 5ª ed. Pearson, 2005</p>
</li>
<li>
<p><a id="Sun2006"></a>[Sun2006]
«ZFS On-Disk Specification [en línea]». Sun Microsystems, Inc. 2006 [2009]. URL <a href="http://www.giis.co.in/Zfs_ondiskformat.pdf" class="bare">http://www.giis.co.in/Zfs_ondiskformat.pdf</a></p>
</li>
<li>
<p><a id="Tanenbaum2014"></a>[Tanenbaum2014]
Tanenbaum, A. y Bos, H. «Modern Operating Systems». 4ª ed. Prentice Hall Press 2014.</p>
</li>
<li>
<p><a id="Wikipedia-cmalloc"></a>[Wikipedia-cmalloc]
«C dynamic memory allocation» [en línea]. Wikipedia (en), [2011]. URL <a href="http://goo.gl/OkFJ3" class="bare">http://goo.gl/OkFJ3</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Última actualización 2020-12-10 18:09:28 UTC
</div>
</div>
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge .cm {
  color: #999988;
  font-style: italic;
}
pre.rouge .cp {
  color: #999999;
  font-weight: bold;
}
pre.rouge .c1 {
  color: #999988;
  font-style: italic;
}
pre.rouge .cs {
  color: #999999;
  font-weight: bold;
  font-style: italic;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cpf {
  color: #999988;
  font-style: italic;
}
pre.rouge .err {
  color: #a61717;
  background-color: #e3d2d2;
}
pre.rouge .gd {
  color: #000000;
  background-color: #ffdddd;
}
pre.rouge .ge {
  color: #000000;
  font-style: italic;
}
pre.rouge .gr {
  color: #aa0000;
}
pre.rouge .gh {
  color: #999999;
}
pre.rouge .gi {
  color: #000000;
  background-color: #ddffdd;
}
pre.rouge .go {
  color: #888888;
}
pre.rouge .gp {
  color: #555555;
}
pre.rouge .gs {
  font-weight: bold;
}
pre.rouge .gu {
  color: #aaaaaa;
}
pre.rouge .gt {
  color: #aa0000;
}
pre.rouge .kc {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kd {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kn {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kp {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kr {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kt {
  color: #445588;
  font-weight: bold;
}
pre.rouge .k, pre.rouge .kv {
  color: #000000;
  font-weight: bold;
}
pre.rouge .mf {
  color: #009999;
}
pre.rouge .mh {
  color: #009999;
}
pre.rouge .il {
  color: #009999;
}
pre.rouge .mi {
  color: #009999;
}
pre.rouge .mo {
  color: #009999;
}
pre.rouge .m, pre.rouge .mb, pre.rouge .mx {
  color: #009999;
}
pre.rouge .sb {
  color: #d14;
}
pre.rouge .sc {
  color: #d14;
}
pre.rouge .sd {
  color: #d14;
}
pre.rouge .s2 {
  color: #d14;
}
pre.rouge .se {
  color: #d14;
}
pre.rouge .sh {
  color: #d14;
}
pre.rouge .si {
  color: #d14;
}
pre.rouge .sx {
  color: #d14;
}
pre.rouge .sr {
  color: #009926;
}
pre.rouge .s1 {
  color: #d14;
}
pre.rouge .ss {
  color: #990073;
}
pre.rouge .s, pre.rouge .sa, pre.rouge .dl {
  color: #d14;
}
pre.rouge .na {
  color: #008080;
}
pre.rouge .bp {
  color: #999999;
}
pre.rouge .nb {
  color: #0086B3;
}
pre.rouge .nc {
  color: #445588;
  font-weight: bold;
}
pre.rouge .no {
  color: #008080;
}
pre.rouge .nd {
  color: #3c5d5d;
  font-weight: bold;
}
pre.rouge .ni {
  color: #800080;
}
pre.rouge .ne {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nf, pre.rouge .fm {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nl {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nn {
  color: #555555;
}
pre.rouge .nt {
  color: #000080;
}
pre.rouge .vc {
  color: #008080;
}
pre.rouge .vg {
  color: #008080;
}
pre.rouge .vi {
  color: #008080;
}
pre.rouge .nv, pre.rouge .vm {
  color: #008080;
}
pre.rouge .ow {
  color: #000000;
  font-weight: bold;
}
pre.rouge .o {
  color: #000000;
  font-weight: bold;
}
pre.rouge .w {
  color: #bbbbbb;
}
pre.rouge {
  background-color: #f8f8f8;
}
</style>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains('stemblock')) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>