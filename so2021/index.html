<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="author" content="JesÃºs Torres">
<title>Sistemas Operativos</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<meta name='robots' content='noindex,nofollow'>
<style>
    .imageblock {
        text-align: center;
    }
    .imageblock > .content {
        margin-bottom: 1rem;
    }
    .imageblock > .title {
        text-align: inherit;
    }
    .tableblock > .lightcell {
        color: gray;
    }
    table tfoot td p {
        font-weight: bold;
    }
</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Sistemas Operativos</h1>
<div class="details">
<span id="author" class="author">JesÃºs Torres</span><br>
<span id="email" class="email"><a href="mailto:jmtorres@ull.es">jmtorres@ull.es</a></span><br>
<span id="revdate">Curso 2020-2021</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Tabla de Contenido</div>
<ul class="sectlevel1">
<li><a href="#_ejemplos_de_cÃ³digo">Ejemplos de cÃ³digo</a></li>
<li><a href="#_introducciÃ³n">Parte I: IntroducciÃ³n</a>
<ul class="sectlevel1">
<li><a href="#_quÃ©_es_un_sistema_operativo">1. Â¿QuÃ© es un sistema operativo?</a>
<ul class="sectlevel2">
<li><a href="#_definiciÃ³n_de_sistema_operativo">1.1. DefiniciÃ³n de sistema operativo</a></li>
<li><a href="#_funciones_del_sistema_operativo">1.2. Funciones del sistema operativo</a></li>
</ul>
</li>
<li><a href="#_tipos_de_sistemas_operativos">2. Tipos de sistemas operativos</a>
<ul class="sectlevel2">
<li><a href="#_mainframe">2.1. Mainframe</a></li>
<li><a href="#_sistemas_de_escritorio">2.2. Sistemas de escritorio</a></li>
<li><a href="#_sistemas_de_mano">2.3. Sistemas de mano</a></li>
<li><a href="#_sistemas_multiprocesador">2.4. Sistemas multiprocesador</a></li>
<li><a href="#_sistemas_distribuidos">2.5. Sistemas distribuidos</a></li>
<li><a href="#_sistemas_en_cluster">2.6. Sistemas en cluster</a></li>
<li><a href="#_sistemas_de_tiempo_real">2.7. Sistemas de tiempo real</a></li>
</ul>
</li>
<li><a href="#_historia_de_los_sistemas_operativos">3. Historia de los sistemas operativos</a>
<ul class="sectlevel2">
<li><a href="#_historia_primera_generaciÃ³n">3.1. 1Âª GeneraciÃ³n (1945-55)</a></li>
<li><a href="#_historia_segunda_generaciÃ³n">3.2. 2Âª GeneraciÃ³n (1955-64)</a></li>
<li><a href="#_historia_tercera_generaciÃ³n">3.3. 3Âª GeneraciÃ³n (1965-1968)</a></li>
<li><a href="#_historia_cuarta_generaciÃ³n">3.4. 4Âª GeneraciÃ³n (1965-1980)</a></li>
<li><a href="#_5Âº_generaciÃ³n_desde_1980">3.5. 5Âº GeneraciÃ³n (desde 1980):</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_organizaciÃ³n_de_los_sistemas_operativos">Parte II: OrganizaciÃ³n de los sistemas operativos</a>
<ul class="sectlevel1">
<li><a href="#_componentes_del_sistema">4. Componentes del sistema</a>
<ul class="sectlevel2">
<li><a href="#componente_gestiÃ³n_de_procesos">4.1. GestiÃ³n de procesos</a></li>
<li><a href="#_gestiÃ³n_de_la_memoria_principal">4.2. GestiÃ³n de la memoria principal</a></li>
<li><a href="#_gestiÃ³n_del_sistema_de_es">4.3. GestiÃ³n del sistema de E/S</a></li>
<li><a href="#_gestiÃ³n_del_almacenamiento_secundario">4.4. GestiÃ³n del almacenamiento secundario</a></li>
<li><a href="#_gestiÃ³n_del_sistema_de_archivos">4.5. GestiÃ³n del sistema de archivos</a></li>
<li><a href="#_gestiÃ³n_de_red">4.6. GestiÃ³n de red</a></li>
<li><a href="#_protecciÃ³n_y_seguridad">4.7. ProtecciÃ³n y seguridad</a></li>
</ul>
</li>
<li><a href="#_servicios_del_sistema">5. Servicios del sistema</a>
<ul class="sectlevel2">
<li><a href="#_servicios_que_garantizan_el_funcionamiento_eficiente_del_sistema">5.1. Servicios que garantizan el funcionamiento eficiente del sistema</a></li>
<li><a href="#_servicios_Ãºtiles_para_el_usuario">5.2. Servicios Ãºtiles para el usuario</a></li>
<li><a href="#_interfaz_de_usuario">5.3. Interfaz de usuario</a></li>
</ul>
</li>
<li><a href="#_interfaz_de_programaciÃ³n_de_aplicaciones">6. Interfaz de programaciÃ³n de aplicaciones</a>
<ul class="sectlevel2">
<li><a href="#_interfaces_de_programaciÃ³n_de_aplicaciones">6.1. Interfaces de programaciÃ³n de aplicaciones</a></li>
<li><a href="#_llamadas_al_sistema">6.2. Llamadas al sistema</a></li>
<li><a href="#_librerÃ­a_del_sistema">6.3. LibrerÃ­a del sistema</a></li>
<li><a href="#_librerÃ­a_estÃ¡ndar">6.4. LibrerÃ­a estÃ¡ndar</a></li>
<li><a href="#_con_todas_las_piezas_juntas">6.5. Con todas las piezas juntas</a></li>
</ul>
</li>
<li><a href="#_operaciÃ³n_del_sistema_operativo">7. OperaciÃ³n del sistema operativo</a>
<ul class="sectlevel2">
<li><a href="#_software_controlado_mediante_interrupciones">7.1. Software controlado mediante interrupciones</a></li>
<li><a href="#_operaciÃ³n_en_modo_dual">7.2. OperaciÃ³n en modo dual</a></li>
<li><a href="#_protecciÃ³n_de_la_memoria">7.3. ProtecciÃ³n de la memoria</a></li>
<li><a href="#_el_temporizador">7.4. El temporizador</a></li>
<li><a href="#_maquinas_virtuales">7.5. Maquinas virtuales</a></li>
<li><a href="#_arranque_del_sistema">7.6. Arranque del sistema</a></li>
</ul>
</li>
<li><a href="#_sistemas_operativos_por_su_estructura">8. Sistemas operativos por su estructura</a>
<ul class="sectlevel2">
<li><a href="#_estructura_sencilla">8.1. Estructura sencilla</a></li>
<li><a href="#_estructura_en_capas">8.2. Estructura en capas</a></li>
<li><a href="#_microkernel">8.3. Microkernel</a></li>
<li><a href="#_estructura_modular">8.4. Estructura modular</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_gestiÃ³n_de_procesos">Parte III: GestiÃ³n de procesos</a>
<ul class="sectlevel1">
<li><a href="#_procesos">9. Procesos</a>
<ul class="sectlevel2">
<li><a href="#_el_proceso">9.1. El proceso</a></li>
<li><a href="#_estados_de_los_procesos">9.2. Estados de los procesos</a></li>
<li><a href="#_bloque_de_control_de_proceso">9.3. Bloque de control de proceso</a></li>
<li><a href="#_colas_de_planificaciÃ³n">9.4. Colas de planificaciÃ³n</a></li>
<li><a href="#_planificaciÃ³n_de_procesos">9.5. PlanificaciÃ³n de procesos</a></li>
<li><a href="#_cambio_de_contexto">9.6. Cambio de contexto</a></li>
<li><a href="#_operaciones_sobre_los_procesos">9.7. Operaciones sobre los procesos</a></li>
<li><a href="#_procesos_cooperativos">9.8. Procesos cooperativos</a></li>
</ul>
</li>
<li><a href="#_comunicaciÃ³n_mediante_de_paso_de_mensajes">10. ComunicaciÃ³n mediante de paso de mensajes</a>
<ul class="sectlevel2">
<li><a href="#_tamaÃ±o_del_mensaje">10.1. TamaÃ±o del mensaje</a></li>
<li><a href="#_referenciaciÃ³n">10.2. ReferenciaciÃ³n</a></li>
<li><a href="#_buffering_2">10.3. Buffering</a></li>
<li><a href="#_operaciones_sÃ­ncronas_y_asÃ­ncronas">10.4. Operaciones sÃ­ncronas y asÃ­ncronas</a></li>
<li><a href="#_ejemplos_de_sistemas_de_paso_de_mensajes">10.5. Ejemplos de sistemas de paso de mensajes</a></li>
</ul>
</li>
<li><a href="#_memoria_compartida">11. Memoria compartida</a>
<ul class="sectlevel2">
<li><a href="#_memoria_compartida_anÃ³nima">11.1. Memoria compartida anÃ³nima</a></li>
<li><a href="#_memoria_compartida_con_nombre">11.2. Memoria compartida con nombre</a></li>
</ul>
</li>
<li><a href="#_hilos">12. Hilos</a>
<ul class="sectlevel2">
<li><a href="#_introducciÃ³n_2">12.1. IntroducciÃ³n</a></li>
<li><a href="#_beneficios">12.2. Beneficios</a></li>
<li><a href="#_soporte_multihilo">12.3. Soporte multihilo</a></li>
<li><a href="#_modelos_multihilo">12.4. Modelos multihilo</a></li>
<li><a href="#_operaciones_sobre_los_hilos">12.5. Operaciones sobre los hilos</a></li>
<li><a href="#_otras_consideraciones_sobre_los_hilos">12.6. Otras consideraciones sobre los hilos</a></li>
</ul>
</li>
<li><a href="#_sincronizaciÃ³n">13. SincronizaciÃ³n</a>
<ul class="sectlevel2">
<li><a href="#_el_problema_de_las_secciones_crÃ­ticas">13.1. El problema de las secciones crÃ­ticas</a></li>
<li><a href="#_sincronizaciÃ³n_por_hardware">13.2. SincronizaciÃ³n por hardware</a></li>
<li><a href="#_semÃ¡foros">13.3. SemÃ¡foros</a></li>
<li><a href="#_mutex">13.4. Mutex</a></li>
<li><a href="#_variables_de_condiciÃ³n">13.5. Variables de condiciÃ³n</a></li>
<li><a href="#_esperas">13.6. Esperas</a></li>
<li><a href="#_funciones_reentrantes_y_seguras_en_hilos">13.7. Funciones reentrantes y seguras en hilos</a></li>
</ul>
</li>
<li><a href="#_planificaciÃ³n_de_la_cpu">14. PlanificaciÃ³n de la CPU</a>
<ul class="sectlevel2">
<li><a href="#_planificaciÃ³n_expropiativa">14.1. PlanificaciÃ³n expropiativa</a></li>
<li><a href="#_el_asignador">14.2. El asignador</a></li>
<li><a href="#_criterios_de_planificaciÃ³n">14.3. Criterios de planificaciÃ³n</a></li>
<li><a href="#_ciclo_de_rÃ¡fagas_de_cpu_y_de_es">14.4. Ciclo de rÃ¡fagas de CPU y de E/S</a></li>
<li><a href="#_algoritmos_de_planificaciÃ³n_de_la_cpu">14.5. Algoritmos de planificaciÃ³n de la CPU</a></li>
<li><a href="#_planificaciÃ³n_de_tiempo_real">14.6. PlanificaciÃ³n de tiempo real</a></li>
<li><a href="#_planificaciÃ³n_en_sistemas_multiprocesador">14.7. PlanificaciÃ³n en sistemas multiprocesador</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_gestiÃ³n_de_la_memoria">Parte IV: GestiÃ³n de la memoria</a>
<ul class="sectlevel1">
<li><a href="#_memoria_principal">15. Memoria principal</a>
<ul class="sectlevel2">
<li><a href="#_etapas_de_un_programa_de_usuario">15.1. Etapas de un programa de usuario</a></li>
<li><a href="#_reubicaciÃ³n_de_las_direcciones">15.2. ReubicaciÃ³n de las direcciones</a></li>
<li><a href="#_espacio_de_direcciones_virtual_frente_a_fÃ­sico">15.3. Espacio de direcciones virtual frente a fÃ­sico</a></li>
<li><a href="#_enlazado_dinÃ¡mico_y_librerÃ­as_compartidas">15.4. Enlazado dinÃ¡mico y librerÃ­as compartidas</a></li>
<li><a href="#_asignaciÃ³n_contigua_de_memoria">15.5. AsignaciÃ³n contigua de memoria</a></li>
<li><a href="#_fragmentaciÃ³n">15.6. FragmentaciÃ³n</a></li>
<li><a href="#_intercambio">15.7. Intercambio</a></li>
</ul>
</li>
<li><a href="#_paginaciÃ³n">16. PaginaciÃ³n</a>
<ul class="sectlevel2">
<li><a href="#_mÃ©todo_bÃ¡sico">16.1. MÃ©todo bÃ¡sico</a></li>
<li><a href="#_soporte_hardware_de_la_tabla_de_pÃ¡ginas">16.2. Soporte hardware de la tabla de pÃ¡ginas</a></li>
<li><a href="#_protecciÃ³n_de_la_memoria_2">16.3. ProtecciÃ³n de la memoria</a></li>
<li><a href="#_pÃ¡ginas_compartidas">16.4. PÃ¡ginas compartidas</a></li>
<li><a href="#_paginaciÃ³n_jerÃ¡rquica">16.5. PaginaciÃ³n jerÃ¡rquica</a></li>
</ul>
</li>
<li><a href="#_memoria_virtual">17. Memoria virtual</a>
<ul class="sectlevel2">
<li><a href="#_paginaciÃ³n_bajo_demanda">17.1. PaginaciÃ³n bajo demanda</a></li>
<li><a href="#_copy_on_write">17.2. Copy-on-write</a></li>
<li><a href="#_archivos_mapeados_en_memoria">17.3. Archivos mapeados en memoria</a></li>
<li><a href="#_reemplazo_de_pÃ¡gina">17.4. Reemplazo de pÃ¡gina</a></li>
<li><a href="#_asignaciÃ³n_de_marcos_de_pÃ¡gina">17.5. AsignaciÃ³n de marcos de pÃ¡gina</a></li>
<li><a href="#_hiperpaginaciÃ³n">17.6. HiperpaginaciÃ³n</a></li>
<li><a href="#_otras_consideraciones">17.7. Otras consideraciones</a></li>
<li><a href="#_interfaz_de_gestiÃ³n_de_la_memoria">17.8. Interfaz de gestiÃ³n de la memoria</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_gestiÃ³n_del_almacenamiento">Parte V: GestiÃ³n del almacenamiento</a>
<ul class="sectlevel1">
<li><a href="#_almacenamiento_secundario">18. Almacenamiento secundario</a>
<ul class="sectlevel2">
<li><a href="#_dispositivos_de_almacenamiento">18.1. Dispositivos de almacenamiento</a></li>
<li><a href="#_archivos_y_sistemas_de_archivos">18.2. Archivos y sistemas de archivos</a></li>
<li><a href="#_volÃºmenes_de_datos">18.3. VolÃºmenes de datos</a></li>
</ul>
</li>
<li><a href="#_sistemas_de_archivos">19. Sistemas de archivos</a>
<ul class="sectlevel2">
<li><a href="#_estructura_de_un_sistema_de_archivos">19.1. Estructura de un sistema de archivos</a></li>
<li><a href="#_estructuras_de_metadatos_en_disco">19.2. Estructuras de metadatos en disco</a></li>
<li><a href="#_estructuras_de_metadatos_en_memoria">19.3. Estructuras de metadatos en memoria</a></li>
<li><a href="#_montaje_de_sistemas_de_archivos">19.4. Montaje de sistemas de archivos</a></li>
<li><a href="#_archivos">19.5. Archivos</a></li>
<li><a href="#_estructura_de_directorios_2">19.6. Estructura de directorios</a></li>
<li><a href="#_comparticiÃ³n_de_archivos">19.7. ComparticiÃ³n de archivos</a></li>
<li><a href="#_coherencia">19.8. Coherencia</a></li>
</ul>
</li>
<li><a href="#_implementaciÃ³n_de_sistemas_de_archivos">20. ImplementaciÃ³n de sistemas de archivos</a>
<ul class="sectlevel2">
<li><a href="#_implementaciÃ³n_de_directorios">20.1. ImplementaciÃ³n de directorios</a></li>
<li><a href="#_mÃ©todos_de_asignaciÃ³n">20.2. MÃ©todos de asignaciÃ³n</a></li>
<li><a href="#_gestiÃ³n_del_espacio_libre">20.3. GestiÃ³n del espacio libre</a></li>
<li><a href="#_sistemas_de_archivos_virtuales">20.4. Sistemas de archivos virtuales</a></li>
<li><a href="#_planificaciÃ³n_de_disco">20.5. PlanificaciÃ³n de disco</a></li>
</ul>
</li>
<li><a href="#_bibliografÃ­a">BibliografÃ­a</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_ejemplos_de_cÃ³digo">Ejemplos de cÃ³digo</h2>
<div class="sectionbody">
<div class="paragraph">
<p>En algunos capÃ­tulos se enlazan ejemplos de cÃ³digo para ilustrar en mayor detalle los conceptos tratados.
Todos los ejemplos estÃ¡n disponibles en el repositorio <span class="icon"><i class="fa fa-github"></i></span> <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/tree/so2021">ull-esit-sistemas-operativos/ssoo-ejemplos</a>, de donde se pueden descargar.</p>
</div>
<div class="paragraph">
<p>Para compilar los ejemplos, es necesario disponer de herramientas de desarrollo para C y C&#43;&#43;.
Por ejemplo, en la distribuciÃ³n Debian de GNU/Linux y derivadas âcomo Ubuntu o Linux Mintâ basta con tener instalados los paquetes <strong>build-essential</strong> y <strong>cmake</strong>.
Mientras que en Microsoft Windows hacen falta las <a href="https://go.microsoft.com/fwlink/?linkid=840931"><strong>Visual Studio Build Tools</strong></a>.</p>
</div>
<div class="paragraph">
<p>Para compilar es necesario hacer lo siguiente desde la lÃ­nea de comandos:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Ir al directorio raÃ­z del repositorio descargado y descomprimido.</p>
</li>
<li>
<p>Ejecutar <code>cmake -B build</code> para configurar el proyecto.</p>
</li>
<li>
<p>Ejecutar <code>cmake --build build</code> para compilar los ejemplos.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>En Microsoft Windows estos comandos deben ejecutarse desde la consola de <strong>Developer Command Prompt</strong>.</p>
</div>
<div class="paragraph">
<p>En cada sistema solo se compilarÃ¡n los ejemplos compatibles, que se guardarÃ¡n en el directorio <code>build/bin/</code>, desde dÃ³nde se pueden ejecutar para probarlos.</p>
</div>
<div class="paragraph">
<p>El cÃ³digo fuente de los ejemplos estÃ¡ en el directorio <code>src/</code>, dentro del subdirectorio numerado con el capÃ­tulo correspondiente.</p>
</div>
</div>
</div>
<h1 id="_introducciÃ³n" class="sect0">Parte I: IntroducciÃ³n</h1>
<div class="sect1">
<h2 id="_quÃ©_es_un_sistema_operativo">1. Â¿QuÃ© es un sistema operativo?</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>7 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Â¿QuÃ© es un sistema operativo? Â¿cuÃ¡les son sus responsabilidades en el contexto de un sistema informÃ¡tico? Â¿cÃ³mo cumple con ellas?
Ãstas son algunas de las cuestiones que responderemos en este capÃ­tulo.
Aunque, cÃ³mo veremos, no son preguntas sencillas de responder.</p>
</div>
<div class="sect2">
<h3 id="_definiciÃ³n_de_sistema_operativo">1.1. DefiniciÃ³n de sistema operativo</h3>
<div class="paragraph">
<p>En general no existe una definiciÃ³n universal de lo quÃ© es un <strong>sistema operativo</strong>, aunque si muchas propuestas de diferentes autores:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Hay quiÃ©n considera que simplemente es una cuestiÃ³n del mercado: Â«lo que nos venden cuando llegamos a una tienda y pedimos un sistema operativoÂ».</p>
<div class="paragraph">
<p>En realidad esta definiciÃ³n no es muy precisa, puesto que las caracterÃ­sticas incluidas pueden variar enormemente de un sistema a otro.
Por ejemplo, algunos sistemas operativos apenas alcanzan el megabyte de espacio, careciendo incluso de las aplicaciones mÃ¡s bÃ¡sicas, mientras que otros ocupan gigabytes de espacio, incluyen una interfaz grÃ¡fica basada en ventanas y las aplicaciones mÃ¡s comunes que cualquier usuario puede necesitar.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Aunque pueda parecer lo contrario, la cuestiÃ³n de quÃ© componentes son parte o no de un sistema operativo no es trivial. Por ejemplo, Microsoft y el Departamento de Justicia de los Estados Unidos se enfrentaron en 1998 por la inclusiÃ³n del navegador Internet Explorer como parte del sistema operativo Microsoft Windows.</p>
</div>
<div class="paragraph">
<p>Microsoft afirmaba que ambos productos eran realmente uno solo y que su uniÃ³n fue el resultado de un proceso de innovaciÃ³n.
Mientras tanto, la otra parte alegaba que el navegador era un producto distinto y separado, que no formaba parte del sistema operativo y que todo el asunto restringÃ­a la libre competencia en el mercado de los navegadores.</p>
</div>
<div class="paragraph">
<p>Seguramente en 1998 los argumentos del Departamento de Justicia de los Estados Unidos tenÃ­an mucho sentido, Â¿pero quÃ© ocurrirÃ­a si se planteara este mismo asunto en la actualidad?.
Â¿Concibes que tu mÃ³vil o tu ordenador no trajeran de serie un navegador?</p>
</div>
<div class="paragraph">
<p>Para mÃ¡s informaciÃ³n, vÃ©ase <a href="https://es.wikipedia.org/wiki/Caso_Estados_Unidos_contra_Microsoft">Â«Caso Estados Unidos contra Microsoft&#8201;&#8212;&#8201;WikipediaÂ»</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Una definiciÃ³n mucho mÃ¡s comÃºn es que el sistema operativo es Â«aquel programa que se ejecuta continuamente en el ordenadorÂ» âlo que denominamos comÃºnmente como <em><strong>kernel</strong></em> o <strong>nÃºcleo</strong> del sistemaâ siendo todo lo demÃ¡s programas del sistema y aplicaciones.</p>
<div class="paragraph">
<p>Sin embargo, en algunos casos Ã©sta definiciÃ³n excluye como parte del sistema operativo algunos servicios que intuitivamente solemos considerar dentro del mismo.
Por ejemplo, si aplicamos esta definiciÃ³n a los sistemas operativos de estructura microkernel, no podrÃ­amos decir que servicios bÃ¡sicos como la comunicaciÃ³n en red, los sistemas de archivos y la gestiÃ³n de la memoria son parte del sistema operativo.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Como veremos en el <a href="#_microkernel">Apartado 8.3</a>, en los sistemas operativos <em>microkernel</em> la funcionalidad implementada en el nÃºcleo del sistema es la mÃ­nima necesaria.
Por lo tanto, segÃºn la definiciÃ³n anterior, muchos de los componentes y servicios bÃ¡sicos que damos por supuestos a un sistema operativo no formarÃ­an parte del mismo en ese tipo de sistemas.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_funciones_del_sistema_operativo">1.2. Funciones del sistema operativo</h3>
<div class="paragraph">
<p>Por lo que hemos visto hasta ahora, parece evidente que no es sencillo definir lo que Â«esÂ» un sistema operativo.
Sin embargo, es posible que tengamos mÃ¡s suerte definiÃ©ndolo a travÃ©s de lo que Â«haceÂ».
Es decir, describiendo sus funciones dentro de un sistema informÃ¡tico cualquiera.</p>
</div>
<div id="componentes_sistema_informÃ¡tico" class="imageblock">
<div class="content">
<img src="C01-definiciÃ³n/media/componentes_sistema_informÃ¡tico.svg" alt="componentes sistema informÃ¡tico">
</div>
<div class="title">Figura 1. Vista abstracta de los componentes de un sistema informÃ¡tico.</div>
</div>
<div class="paragraph">
<p>Un <strong>sistema informÃ¡tico</strong> puede ser dividido, <em>grosso modo</em>, en cuatro componentes: el hardware, los usuarios, los programas de aplicaciÃ³n y el sistema operativo (vÃ©ase la <a href="#componentes_sistema_informÃ¡tico">Figura 1</a>):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Programas de aplicaciÃ³n</strong>. El objetivo fundamental de cualquier sistema informÃ¡tico es ejecutar programas para resolver los problemas informÃ¡ticos de los usuarios.
Con ese objetivo se construye su hardware y se desarrollan los programas de aplicaciÃ³n âprocesadores de textos, hojas de cÃ¡lculo, compiladores, navegadores de Internet, etc.â que usan los usuarios para resolver sus problemas.</p>
</li>
<li>
<p><strong>Hardware</strong>. El hardware âla CPU, la memoria, los dispositivos de entrada salida, etc.â proporcionan los recursos computacionales del sistema informÃ¡tico.
Los programas de aplicaciÃ³n necesitan usar estos recursos computacionales para resolver los problemas informÃ¡ticos de los usuarios.</p>
</li>
<li>
<p><strong>Sistema operativo</strong>. En un sistema informÃ¡tico las aplicaciones necesitan realizar operaciones comunes, como acceder a los dispositivos de E/S o reservar porciones de la memoria.
En lugar de que cada aplicaciÃ³n intente hacerlo por su cuenta, es mucho mÃ¡s sencillo que estas operaciones comunes estÃ©n centralizadas en el sistema operativo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Por lo tanto, el sistema operativo controla, coordina el acceso y asigna los recursos computacionales del hardware a los distintos programas de aplicaciÃ³n.</p>
</div>
<div class="paragraph">
<p>En realidad Ã©sta es solo una de las dos perspectivas desde las que se pueden analizar las funciones del sistema operativo.
Es la denominada como: <strong>perspectiva del sistema informÃ¡tico</strong>, mientras que la otra es la <strong>perspectiva del usuario</strong>.</p>
</div>
<div class="sect3">
<h4 id="_perspectiva_del_sistema_informÃ¡tico">1.2.1. Perspectiva del sistema informÃ¡tico</h4>
<div class="paragraph">
<p>Un sistema informÃ¡tico tiene mÃºltiples recursos hardware, como son: tiempo de CPU, espacio de memoria, espacio de almacenamiento de archivos, dispositivos de E/S, etc.
TambiÃ©n tiene recursos software ofrecidos por algunos programas que se ejecutan en el sistema, como son: servicios de red, servicios de impresiÃ³n, seguridad, etc.â.
Estos recursos los necesitan los programas de aplicaciÃ³n para resolver los problemas informÃ¡ticos de los usuarios.</p>
</div>
<div class="paragraph">
<p>Dentro del sistema informÃ¡tico, el sistema operativo es el programa mÃ¡s Ã­ntimamente relacionado con el hardware y su funciÃ³n es gestionar los recursos hardware y software disponibles, asignarlos a los diferentes programas, resolver los conflictos en las peticiones y hacer que el sistema opere eficientemente para resolver los problemas de los usuarios.</p>
</div>
<div class="paragraph">
<p>AdemÃ¡s, el sistema operativo es el programa encargado del control de la ejecuciÃ³n de los programas de los usuarios, por lo que tiene la tarea de prevenir errores y el uso inadecuado del ordenador.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>En resumen, desde la perspectiva del sistema informÃ¡tico, las funciones del <strong>sistema operativo</strong> son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Gestionar los recursos computacionales del sistema informÃ¡tico.</p>
</li>
<li>
<p>Controlar la ejecuciÃ³n de los programas de usuario y el acceso a los dispositivos de E/S.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Un <strong>sistema operativo</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>No hace trabajo directamente Ãºtil para los usuarios.</p>
</li>
<li>
<p>Pero proporciona un entorno adecuado para que los programas de aplicaciÃ³n lo hagan.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Los sistemas operativos existen porque es mÃ¡s sencillo crear sistemas informÃ¡ticos Ãºtiles para los usuarios con ellos que sin ellos.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_perspectiva_del_usuario">1.2.2. Perspectiva del usuario</h4>
<div class="paragraph">
<p>Si intentamos definir las funciones del sistema operativo desde nuestra experiencia como usuarios, seguramente harÃ­amos referencia a la interfaz que nos proporciona para utilizar el sistema informÃ¡tico.
Sin embargo, debemos tener en cuenta que la interfaz varÃ­a con el tipo de sistema, por lo que definir las funciones del sistema operativo desde la perspectiva del usuario es mucho mÃ¡s difÃ­cil.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, los usuarios que se sientan frente a un sistema de escritorio disponen de: monitor, teclado, ratÃ³n y una unidad central.
Estos sistemas se diseÃ±an buscando la mÃ¡xima productividad en equipos donde un usuario monopoliza todos los recursos; por lo que el sistema operativo se diseÃ±a considerando fundamentalmente la facilidad de uso, poniendo algo de atenciÃ³n en el rendimiento y nada en el aprovechamiento de los recursos.</p>
</div>
<div class="paragraph">
<p>Esto difiere mucho de otro tipo de sistema informÃ¡tico dÃ³nde mÃºltiples usuarios se sientan frente a terminales conectadas a un gran ordenador central.
AsÃ­ todos los usuarios comparten los recursos del sistema informÃ¡tico y pueden intercambiar informaciÃ³n entre sÃ­.
En este tipo de sistemas el sistema operativo maximiza el aprovechamiento de los recursos con el objeto de garantizar que toda la CPU, memoria y E/S son empleadas de forma eficiente y que ningÃºn usuario utiliza mÃ¡s de lo que le corresponde.
Obviamente, en este tipo de sistemas la facilidad de uso estÃ¡ en un segundo plano.</p>
</div>
<div class="paragraph">
<p>Otros sistemas operativos se diseÃ±an para sistemas informÃ¡ticos que tienen poca o ninguna interacciÃ³n con los usuarios.
Es, por ejemplo, el caso de los sistema empotrados de los electrodomÃ©sticos.</p>
</div>
<div class="paragraph">
<p>Todos estos tipos de sistemas tienen interfaces muy diferentes, lo que dificulta obtener una definiciÃ³n Ãºnica de sistema operativo desde la perspectiva del usuario.</p>
</div>
<div class="paragraph">
<p>En los tres casos los objetivos con los que se diseÃ±a el sistema operativo son opuestos, por lo que seguramente sea diferente Â«lo que tiene que hacerÂ» cada sistema operativo para alcanzarlos.
Sin embargo, en los tres casos el sistema operativo es el responsable de la gestiÃ³n de los recursos computacionales y del control de los programas, funciones que definimos anteriormente desde la perspectiva del sistema informÃ¡tico y que no cambian de un tipo de sistema a otro.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tipos_de_sistemas_operativos">2. Tipos de sistemas operativos</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>23 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Ahora que sabemos que todos los sistemas operativos hacen lo mismo pero que el Â«cÃ³moÂ» lo hacen difiere de un tipo de sistema informÃ¡tico a otro, vamos a ver los tipos de sistemas informÃ¡ticos, las caracterÃ­sticas de los sistemas operativos que los gestionan y cÃ³mo han evolucionado a lo largo de la historia.</p>
</div>
<div class="sect2">
<h3 id="_mainframe">2.1. Mainframe</h3>
<div class="paragraph">
<p>Los <strong>ordenadores centrales</strong> o <em><strong>mainframes</strong></em> fueron los primeros computadores utilizados en muchas aplicaciones comerciales y cientÃ­ficas.
Se caracterizan no tanto por la potencia de su CPU como por su: gran capacidad de memoria, gran capacidad de almacenamiento secundario, gran cantidad de dispositivos de E/S y rapidez de Ã©stos y alta fiabilidad.</p>
</div>
<div class="paragraph">
<p>Los <em>mainframes</em> pueden funcionar durante aÃ±os sin problemas ni interrupciones y las reparaciones se realizan sin detener su funcionamiento.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>La mayor diferencia entre los superordenadores y los <em>mainframes</em> estÃ¡ en que los primeros se centran en resolver problemas limitados por la velocidad de cÃ¡lculo âlo cual requiere miles de CPU de alto rendimientoâ mientras que los segundos se centran en la fiabilidad y en problemas limitados por la E/S âpor lo que los <em>mainframes</em> suelen tener Â«soloÂ» entre una y varias docenas de CPUâ.</p>
</div>
<div class="paragraph">
<p>Para mÃ¡s informaciÃ³n sobre los <em>mainframes</em>, vÃ©ase <a href="http://es.wikipedia.org/wiki/Ordenador_central">Â«Ordenador central&#8201;&#8212;&#8201;WikipediaÂ»</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Los <em>mainframes</em> aparecieron a finales de la dÃ©cada de los 50 del siglo pasado y han seguido evolucionando hasta la actualidad, por lo que dentro de este tipo de sistemas nos encontramos con varios categorÃ­as.</p>
</div>
<div class="sect3">
<h4 id="_sistemas_de_procesamiento_por_lotes">2.1.1. Sistemas de procesamiento por lotes</h4>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>Los primeros <em>mainframe</em> eran enormes mÃ¡quinas operadas desde una consola y conectados a lectores de tarjetas perforadas, dispositivos de cinta e impresoras.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Para imÃ¡genes y mÃ¡s informaciÃ³n sobre las tarjetas perforadas, vÃ©ase <a href="https://en.wikipedia.org/wiki/Computer_programming_in_the_punched_card_era">Â«Computer programming in the punched card era&#8201;&#8212;&#8201;WikipediaÂ»</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>El trabajo era preparado por cada programador ânormalmente en tarjetas perforadasâ y entregado al operador del sistema, que era quiÃ©n tenÃ­a acceso al sistema y la responsabilidad de ejecutar los programas y devolver los resultados al programador correspondiente.</p>
</div>
<div class="paragraph">
<p>No habÃ­a sistema operativo y el operador debÃ­a cargar y ejecutar cada programa de uno en uno.</p>
</div>
<div id="consola_ibm_705" class="imageblock">
<div class="content">
<img src="C02-tipos_de_sistemas/media/consola_ibm_705.jpg" alt="consola ibm 705">
</div>
<div class="title">Figura 2. Operadora en la consola de un mainframe IBM 705&#8201;&#8212;&#8201;Fuente: <a href="https://www.ibm.com/ibm/history/ibm100/images/icp/Y444110I58591Z46/us__en_us__ibm100__700_series__705__620x350.jpg">IBM</a></div>
</div>
<div class="paragraph">
<p>Estos sistemas se convirtieron en <strong>sistemas de procesamiento por lotes</strong> o <strong>sistemas en <em>batch</em></strong> cuando se comenzÃ³ a utilizar un pequeÃ±o programa âllamado <strong>monitor del sistema</strong>â cuya funciÃ³n era cargar y ejecutar sin interrupciÃ³n un conjunto âo loteâ de programas.</p>
</div>
<div class="paragraph">
<p>Para preparar los lotes, por lo general, el operador cargaba previamente en cinta magnÃ©tica el conjunto de programas a partir de las tarjetas perforadas proporcionadas por los programadores.
Para ello se utilizaba un lector de tarjetas autÃ³nomo, independiente del <em>mainframe</em>.</p>
</div>
<div id="sistemas_procesamiento_lotes" class="imageblock">
<div class="content">
<img src="C02-tipos_de_sistemas/media/sistemas_procesamiento_lotes.svg" alt="sistemas procesamiento lotes">
</div>
<div class="title">Figura 3. OrganizaciÃ³n de la memoria en sistemas de procesamiento por lotes.</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>El <strong>monitor del sistema</strong> es un predecesor de los sistemas operativos y tenÃ­a las siguientes caracterÃ­sticas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>PermanecÃ­a cargado durante todo el tiempo en la memoria del sistema (vÃ©ase la <a href="#sistemas_procesamiento_lotes">Figura 3</a>).</p>
</li>
<li>
<p>Su Ãºnica tarea era cargar y transferir automÃ¡ticamente la ejecuciÃ³n de un programa al siguiente cuando el anterior terminaba.</p>
</li>
<li>
<p>El mayor inconveniente de este tipo de sistemas era que la CPU permanecÃ­a mucho tiempo desocupada porque era ây sigue siendoâ varios ordenes de magnitud mÃ¡s rÃ¡pida que los dispositivos de E/S.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Cualquier programa necesita realizar operaciones de E/S para obtener los datos requeridos para sus cÃ¡lculos âguardados en tarjetas perforadas y unidades de cinta o, si hablamos de hoy en dÃ­a, en discos duros y memorias USBâ.
TambiÃ©n necesita hacer operaciones de E/S para guardar o imprimir los resultados de esos cÃ¡lculos.</p>
</div>
<div class="paragraph">
<p>Si solo se puede ejecutar un programa la vez, cuando el programa solicita una operaciÃ³n de E/S, la CPU queda a la espera de que esta termine para continuar con la ejecuciÃ³n del programa, por lo que se pierde tiempo de CPU en no hacer nada.
Este desaprovechamiento de la CPU es peor cuanto mÃ¡s rÃ¡pida es la CPU respecto a los dispositivos de E/S.</p>
</div>
</div>
<div class="sect3">
<h4 id="_sistemas_multiprogramados">2.1.2. Sistemas multiprogramados</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>La soluciÃ³n al inconveniente de los sistemas de procesamiento por lotes con la E/S fue que los programas no accedieran directamente al dispositivo de E/S, sino que, en su lugar, solicitaran la operaciÃ³n al <strong>monitor del sistema</strong> para que Ã©ste la solicitara al hardware.
AsÃ­ el sistema operativo âcomo podemos comenzar a llamarloâ tiene la oportunidad de sustituir el programa en la CPU por otro, mientras la operaciÃ³n de E/S se completa.</p>
</div>
<div class="paragraph">
<p>AdemÃ¡s, con la apariciÃ³n de la tecnologÃ­a de los discos magnÃ©ticos en la dÃ©cada de los 60 del siglo pasado, los trabajos de los programadores comenzaron a ser almacenados en discos, desde donde eran escogidos por el sistema operativo para su ejecuciÃ³n.</p>
</div>
<div class="paragraph">
<p>A estos sistemas se los llamÃ³ <strong>multiprogramados</strong>.</p>
</div>
<div id="sistemas_multiprogramados" class="imageblock">
<div class="content">
<img src="C02-tipos_de_sistemas/media/sistemas_multiprogramados.svg" alt="sistemas multiprogramados">
</div>
<div class="title">Figura 4. OrganizaciÃ³n de la memoria en sistemas multiprogramados.</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>En los <strong>sistemas multiprogramados</strong> la ejecuciÃ³n de los trabajos funcionaba de la siguiente manera:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>En el disco magnÃ©tico se almacenaba una cola donde se iban colocando todos los trabajos que tenÃ­an que ser ejecutados.</p>
</li>
<li>
<p>El sistema operativo cargaba varios trabajos en memoria del conjunto de trabajos en la cola en el disco magnÃ©tico (vÃ©ase la <a href="#sistemas_multiprogramados">Figura 4</a>).</p>
</li>
<li>
<p>El sistema operativo cede la CPU a uno de los trabajos en memoria.</p>
</li>
<li>
<p>Cuando el trabajo en la CPU requerÃ­a usar la E/S se lo pedÃ­a al sistema operativo.
En lugar de mantener a la CPU ocupada inÃºtilmente, el sistema operativo programaba la operaciÃ³n de E/S pero escogÃ­a otro trabajo de entre los que estaban en memoria y lo ejecutaba en la CPU.</p>
<div class="paragraph">
<p>Cuando la operaciÃ³n de E/S del anterior trabajo terminaba, el programa que ocupaba la CPU no era interrumpido, sino que debÃ­a esperar a una nueva oportunidad de ser escogido para ejecutarse en la CPU.</p>
</div>
</li>
<li>
<p>Cuando un programa en la CPU terminaba, sus recursos se liberaban, dejando memoria libre.
Por lo tanto, el sistema operativo escogÃ­a un nuevo trabajo de la cola de trabajos en el disco magnÃ©tico y lo cargaba en la memoria.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Todo este proceso se repetÃ­a mientras hubiera trabajos que ejecutar en la cola de trabajos en el disco.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Para operar de la forma descrita es necesario que el sistema operativo realice tres tareas esenciales:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La <strong>planificaciÃ³n de trabajos</strong>, cuya responsabilidad es seleccionar el siguiente trabajo que serÃ¡ cargado en la memoria principal para mantenerla llena.</p>
</li>
<li>
<p>La <strong>planificaciÃ³n de la CPU</strong>, cuya responsabilidad es elegir el siguiente trabajo que serÃ¡ ejecutado en la CPU, de entre los disponibles en la memoria principal.</p>
</li>
<li>
<p>La <strong>gestiÃ³n de la memoria</strong>, cuya responsabilidad es repartir la memoria principal entre los trabajos alojados en la misma.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Un ejemplo de este tipo de sistemas operativos es el IBM OS/360, que fue lanzado en 1966 para utilizarlo en los <em>mainframes</em> IBM System/360 (vÃ©ase el <a href="#_historia_segunda_generaciÃ³n">Apartado 3.2</a>).</p>
</div>
</div>
<div class="sect3">
<h4 id="_sistemas_de_tiempo_compartido">2.1.3. Sistemas de tiempo compartido</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Los sistemas multiprogramados ofrecÃ­an un uso mÃ¡s eficiente de la CPU pero no eran capaces de proporcionar interacciÃ³n directa con los usuarios.
Los programadores seguÃ­an teniendo que entregar los trabajos al operador y esperar a que Ã©ste les devolviera los resultados.</p>
</div>
<div class="paragraph">
<p>Los <strong>sistemas de tiempo compartido</strong> se desarrollaron tras observar que al dar acceso a un grupo de usuarios se podÃ­a conseguir un uso mÃ¡s eficiente del sistema, en comparaciÃ³n a cuando solo podÃ­a ser utilizado por un usuario a la vez.
Esto es debido a que, generalmente, un usuario introduce informaciÃ³n de forma continua para luego detenerse durante largos periodos de tiempo, mientras que en un grupo de usuarios, las pausas de uno de ellos se pueden llenar con la actividad de los otros.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Los <strong>sistemas de tiempo compartido</strong> se caracterizaban por:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Tener <strong>terminales</strong>, es decir, hardware especializado en hacer de interfaz directa entre los usuarios y el sistema.
A travÃ©s de estas terminales los usuarios podÃ­an dar Ã³rdenes al sistema e interactuar con sus trabajos.
PodÃ­an haber mÃºltiples usuarios al mismo tiempo pero cada uno solo podÃ­a tener un trabajo en ejecuciÃ³n a la vez.</p>
</li>
<li>
<p>Usar la <strong>multiprogramaciÃ³n</strong> para tener varios trabajos en la memoria principal al mismo tiempo e intercambiar el trabajo en la CPU cuando Ã©ste solicitaba una operaciÃ³n de E/S, como ya se venÃ­a haciendo en los <strong>sistemas multiprogramados</strong> para hacer un uso mÃ¡s eficiente de la CPU.</p>
</li>
<li>
<p>Repartir el tiempo de CPU entre usuarios.
El sistema operativo asignaba un tiempo de CPU a cada usuario âdenominado <strong>ventana de tiempo</strong> o <strong>cuanto</strong> de CPUâ.
Cuando este tiempo se agotaba, el sistema intercambiaba el trabajo en la CPU por el de otro usuario en el sistema.
La ventana de tiempo era extremadamente pequeÃ±a, dando a cada usuario la impresiÃ³n de que su trabajo nunca se detenÃ­a, como si dispusiera de la CPU en exclusiva.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Los sistemas que, como los de tiempo compartido, pueden ser utilizados por varios usuarios simultÃ¡neamente se denominan sistemas <strong>multiusuario</strong> .</p>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En los primeros sistemas se usaban <strong>terminales</strong> electro-mecÃ¡nicos con un teclado y una impresora, como el <a href="https://en.wikipedia.org/wiki/Teletype_Model_33">Teletype Model 3</a> (1963).
Posteriormente llegaron los terminales electrÃ³nicos, que usaban un monitor en lugar de una impresora, como el <a href="https://es.wikipedia.org/wiki/IBM_3270">IBM 3270</a>.
En cualquier caso solo disponÃ­an del hardware necesario para realizar la tarea de conectar a los usuarios con el ordenador central.</p>
</div>
<div class="paragraph">
<p>Estos terminales no deben confundirse con las terminales por software que traen algunos sistemas operativos modernos.
Las terminales por software o <em>terminales virtuales</em> se programan para emular las especificaciones de alguna versiÃ³n de esas terminales fÃ­sicas antiguas que hemos comentado.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Los sistemas de tiempo compartido significaron un salto importante en complejidad por diversas razones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Como varios trabajos estÃ¡n en la memoria principal al mismo tiempo, el sistema operativo requiere mecanismos de <strong>gestiÃ³n de la memoria</strong> y <strong>protecciÃ³n</strong>.</p>
</li>
<li>
<p>Para tener un tiempo de respuesta razonable, los trabajos deben estar cargados en la memoria principal.
Para que quepan mÃ¡s trabajos de los usuarios en la memoria, el sistema operativo debe utilizar tÃ©cnicas de <strong>memoria virtual</strong> para ejecutar trabajos que no estÃ¡n completamente cargados en la memoria principal.</p>
</li>
<li>
<p>Como la CPU debe ser compartida entre todos los trabajos, el sistema operativo necesita mecanismos de <strong>planificaciÃ³n de la CPU</strong>.</p>
</li>
<li>
<p>Como varios trabajos pueden tener la necesidad de cooperar y que su ejecuciÃ³n siga cierto orden, el sistema operativo debe proporcionar mecanismos de <strong>sincronizaciÃ³n</strong> y <strong>comunicaciÃ³n</strong>.</p>
</li>
<li>
<p>Como el sistema debe disponer de un <strong>sistema de archivos</strong> para repartir el espacio en disco y facilitar a los usuarios el acceso y gestiÃ³n de sus datos, el sistema operativo necesita un componente de <strong>gestiÃ³n de discos</strong>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Las primeras versiones de UNIX âlanzado por primera vez en 1970â el sistema operativo VMS âdesarrollado en 1978â para los VAX de Digital Equipment Corportation y el IBM OS/400 âintroducido en 1988â utilizado en los minicomputadoras AS/400, son algunos ejemplos de sistemas operativos de tiempo compartido (vÃ©ase el <a href="#_historia_tercera_generaciÃ³n">Apartado 3.3</a>).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Estrictamente hablando, el tÃ©rmino <strong>sistemas de tiempo compartido</strong> hace referencia a estos <em>mainframes</em> desarrollados a partir de principios de la dÃ©cada de 1970.
AsÃ­ que no es comÃºn utilizarlo con <em>mainframe</em> modernos.</p>
</div>
<div class="paragraph">
<p>Los <em>mainframe</em> modernos permiten a un mismo usuario ejecutar varios trabajos al mismo tiempo, repartiendo el tiempo de CPU entre todos los trabajo en el sistema y no solo entre los usuarios.
Y lo mismo ocurre en la mayor parte de los sistemas operativos de propÃ³sito general actuales âutilizados en ordenadores de escritorio, servidores, portÃ¡tiles y dispositivos mÃ³vilesâ que con el tiempo han copiado muchas caracterÃ­sticas de los <strong>sistemas de tiempo compartido</strong>.
Por eso el termino actuales <strong>sistema multitarea</strong>, que es mucho mÃ¡s general.</p>
</div>
<div class="paragraph">
<p>La <strong>multitarea</strong>  es un mÃ©todo para tener varios procesos en memoria y ejecutarlos Â«al mismo tiempoÂ».
Generalmente requiere de tÃ©cnicas de multiprogramaciÃ³n, como las empleadas por los antiguos <strong>sistemas multiprogramados</strong>, y de reparto del tiempo de CPU, como ocurre en los antiguos <strong>sistemas de tiempo compartido</strong>.
Por eso se puede decir que esos dos tipos de sistemas <em>mainframe</em> eran <strong>sistemas multitarea</strong>.
Al igual que lo son los <em>mainframe</em> modernos y muchos sistemas operativos actuales de escritorio y de dispositivos mÃ³viles.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_de_escritorio">2.2. Sistemas de escritorio</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>En la dÃ©cada de los 70 del siglo pasado tambiÃ©n aparecieron las primeras CPU en microprocesadores y con Ã©stas llegaron las <strong>microcomputadoras</strong> o <strong>microordenadores</strong>.
Las primeras <strong>microcomputadoras</strong> no incluÃ­an teclado ni monitor y se programaban usando interruptores y ledes ubicados en el frontal de la unidad.
Pero en torno a 1977 apareciÃ³ la segunda generaciÃ³n de <strong>microcomputadoras</strong>, que si incluÃ­an estos perifÃ©ricos de E/S, por lo que eran mÃ¡s fÃ¡ciles de usar que sus predecesoras.
Entonces comenzaron a recibir el nombre de <em>ordenadores domÃ©sticos</em> y de su mano llegaron los primeros <strong>sistemas operativos de escritorio</strong>.</p>
</div>
<div id="ordenadores_domÃ©sticos_1977" class="imageblock">
<div class="content">
<img src="C02-tipos_de_sistemas/media/ordenadores_domÃ©sticos_1977.jpg" alt="ordenadores domÃ©sticos 1977">
</div>
<div class="title">Figura 5. Los tres ordenadores que la revista Byte denominÃ³ como la "Trinidad de 1977" de la computaciÃ³n domÃ©stica: el <a href="https://es.wikipedia.org/wiki/Commodore_PET">Commodore PET 2001</a>, el <a href="https://es.wikipedia.org/wiki/Apple_II">Apple II</a> y el <a href="https://es.wikipedia.org/wiki/TRS-80">TRS-80 Model I</a>&#8201;&#8212;&#8201;Fuente: <a href="https://commons.wikimedia.org/wiki/File:Trinity77.jpg">Wikipedia</a></div>
</div>
<div class="paragraph">
<p>Los <em>mainframes</em> y las minicomputadoras de la Ã©poca siguieron siendo los ordenadores corporativos por excelencia, ya que eran mucho mÃ¡s grandes y potentes, y tambiÃ©n costosos.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>El tÃ©rmino en desuso <strong>minicomputadora</strong> o <strong>miniordenador</strong> hace referencia a mÃ¡quinas multiusuario de rango medio, entre los <em>mainframes</em> y los ordenadores domÃ©sticos.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Los primeros <strong>sistemas operativos de escritorio</strong> eran muy bÃ¡sicos.
Por ejemplo, en un sistema diseÃ±ado para ser utilizado por un Ãºnico usuario no tiene sentido implementar un sistema de archivos con permisos.
AsÃ­ que, los primeros sistemas operativos de escritorio carecÃ­an de esta caracterÃ­stica que, sin embargo, ya existÃ­a en los sistemas de tiempo compartido de la Ã©poca.
De la misma manera, carecÃ­an de otros mecanismos de protecciÃ³n y no eran ni multiusuario ni multitarea.</p>
</div>
<div class="paragraph">
<p>Pese a estas diferencias, los <strong>sistemas operativos de escritorio</strong> se han beneficiado del desarrollo de los sistemas operativos para <em>mainframes</em>.
Los sistemas de escritorio actuales son <strong>multiusuario</strong> y <strong>multitarea</strong>; incluyen sistemas de archivos con permisos, autenticaciÃ³n y mecanismos de protecciÃ³n de la memoria âcomo medidas para proteger los datos de los usuariosâ y han incorporado muchas otras caracterÃ­sticas de los sistemas operativos para <em>mainframe</em>.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Aunque con el tiempo los sistemas de escritorio han ido adquiriendo caracterÃ­sticas desarrolladas en los <em>mainframe</em>, no debemos olvidar que ambos tipos de sistemas se siguen diseÃ±ando con objetivos diferentes.
Mientras que en los <em>mainframe</em> se persigue maximizar la fiabilidad y utilizaciÃ³n eficiente de los recursos, en los sistemas de escritorio se maximiza la facilidad de uso y el tiempo de respuesta al usuario, poniendo algo de atenciÃ³n al rendimiento.</p>
</div>
<div class="paragraph">
<p>Los <strong>sistemas operativos de escritorio</strong> modernos ya nos son Â«solo de escritorioÂ» ni se ejecutan Ãºnicamente en ordenadores domÃ©sticos.
Se utilizan en un altÃ­simo porcentaje en servidores, superordenadores y hasta en dispositivos mÃ³viles.
Por eso, en la actualidad, el tÃ©rmino <strong>sistema operativo de propÃ³sito general</strong>  es mucho mÃ¡s adecuado.</p>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>El <strong>tiempo de respuesta</strong> al usuario se puede considerar como el intervalo de tiempo entre un comando de un usuario âpor ejemplo un clicâ y la respuesta del sistema a dicho comando.
En ocasiones este tiempo se minimiza a costa de un uso menos eficiente de los recursos del sistema, por lo que no es un objetivo deseable para diseÃ±ar un <em>mainframe</em>.
Para mÃ¡s informaciÃ³n, vÃ©ase el <a href="#_criterios_de_planificaciÃ³n">Apartado 14.3</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Son muchos los ejemplos de sistemas operativos en esta categorÃ­a. Van desde CP/M âlanzado en 1977â hasta los actuales GNU/Linux, Microsoft Windows y Apple macOS, pasando por MS-DOS, IBM OS/2 y todas las versiones anteriores de Microsoft Windows (vÃ©ase el <a href="#_historia_cuarta_generaciÃ³n">Apartado 3.4</a>).</p>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_de_mano">2.3. Sistemas de mano</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Con el nombre genÃ©rico de <strong>sistemas de mano</strong> hacemos referencia a las <em>tablets</em>, lectores de libros electrÃ³nicos y telÃ©fonos mÃ³viles.
Los desarrolladores de aplicaciones y sistemas de mano deben enfrentarse a diversos desafÃ­os, originados por el tamaÃ±o limitado de los dispositivos y la alimentaciÃ³n mediante el uso de baterÃ­as.
Debido a esas limitaciones muchos sistemas de mano tienen poca cantidad de memoria, procesadores lentos âen comparaciÃ³n con sus equivalentes de escritorioâ y pantallas mÃ¡s pequeÃ±as.</p>
</div>
<div class="paragraph">
<p>En el diseÃ±o del sistema operativo suele primar la facilidad de uso y buscar un buen equilibrio entre rendimiento y tiempo de vida de la baterÃ­a.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_multiprocesador">2.4. Sistemas multiprocesador</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Un <strong>sistema multiprocesador</strong> es aquel ordenador hay procesadores interconectados que comparten el bus del sistema, el reloj y, en ocasiones la memoria, y los perifÃ©ricos.</p>
</div>
<div class="paragraph">
<p>Hace aÃ±os esto solo se daban en sistemas con varias CPU, lo que era relativamente comÃºn en servidores y sistemas de alto rendimiento para trabajos tÃ©cnicos o cientÃ­ficos.
Sin embargo, en la actualidad cualquier dispositivo digital u ordenador domÃ©stico puede tener una CPU con mÃºltiples nÃºcleos, lo que los convierte en sistemas multiprocesador.</p>
</div>
<div class="paragraph">
<p>Las principales de ventajas de estos sistemas son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Aumentan la cantidad de trabajo realizado</strong>. A mayor nÃºmero de procesadores, mayor cantidad
de trabajo puede realizar el sistema.
Sin embargo debemos de tener en cuenta que un sistema con \$N\$ CPU no es un sistema \$N\$ veces mÃ¡s
rÃ¡pido.
Cuando varios procesadores cooperan para realizar una tarea, existe cierta pÃ©rdida de
rendimiento debida a los mecanismos de sincronizaciÃ³n requeridos para controlar el acceso a los recursos compartidos por los procesadores.</p>
</li>
<li>
<p><strong>EconomÃ­a de escala</strong>. Un sistema multiprocesador puede costar menos que mÃºltiples sistemas monoprocesadores conectados para hacer un trabajo equivalente, porque comparten perifÃ©ricos, almacenamiento, alimentaciÃ³n, etc.</p>
</li>
<li>
<p><strong>Alta disponibilidad</strong>. Con el hardware adecuado el sistema puede ser tolerante al fallo de uno de los procesadores.
En caso de fallo el sistema no se detendrÃ­a pero si trabajarÃ­a mÃ¡s despacio.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>En la actualidad existen dos tipos de sistemas multiprocesador:</p>
</div>
<div id="smp" class="imageblock">
<div class="content">
<img src="C02-tipos_de_sistemas/media/multiprocesamiento_simÃ©trico.svg" alt="multiprocesamiento simÃ©trico">
</div>
<div class="title">Figura 6. Arquitectura de un sistema de multiprocesamiento simÃ©trico.</div>
</div>
<div class="ulist">
<ul>
<li>
<p>En los <strong>sistemas de multiprocesamiento simÃ©trico</strong> o <strong>SMP</strong> (<em>Symmetric Multiprocessing</em>) todos los procesadores son iguales.
Todos comparten los mismos recursos, pueden acceder a los
mismos dispositivos (vÃ©ase la <a href="#smp">Figura 6</a>) y cada uno ejecuta una copia del nÃºcleo del sistema operativo.
El sistema operativo debe haber sido diseÃ±ado para saber repartir el trabajo entre los procesadores y compartir adecuadamente entre tareas y procesadores el resto de recursos del sistema.
Casi todos los sistemas multiprocesador modernos son de este tipo.</p>
</li>
<li>
<p>En los <strong>sistemas de multiprocesamiento asimÃ©trico</strong> o <strong>AMP</strong> (<em>Asymmetric Multiprocessing</em>) hay un procesador principal y varios secundarios a quienes el principal planifica y entrega las tareas que deben ejecutar.
En ocasiones los procesadores secundarios se distinguen del principal por haber sido diseÃ±ados para realizar algÃºn tipo concreto de tareas de forma muy eficiente o por estar conectadas a hardware especial.
Ejemplos de esto son las <a href="https://es.wikipedia.org/wiki/Unidad_de_procesamiento_gr%C3%A1fico">GPU</a>, que no son sino procesadores diseÃ±ados especÃ­ficamente para el procesamiento de grÃ¡ficos, o las CPU de E/S conectadas a
discos duros para gestionarlos de forma mÃ¡s eficiente.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Un ejemplo bastante ilustrativo es el de <a href="https://es.wikipedia.org/wiki/Cell_(microprocesador)">Cell</a>, la CPU de PlayStation 3.
TenÃ­a un nÃºcleo principal de propÃ³sito general y 8 nÃºcleos optimizados para ejecutar de forma muy eficiente operaciones vectoriales.
Con la ayuda del sistema operativo, los programas debÃ­an envÃ­an tareas matemÃ¡ticamente intensivas a los procesadores secundarios, si querÃ­an extraer el mÃ¡ximo provecho de la arquitectura.</p>
</div>
<div class="paragraph">
<p>Desarrollar para un sistema asÃ­ es mÃ¡s complejo.
Por lo que, aunque sobre el papel esta arquitectura ofrecÃ­a gran rendimiento, aprovecharlo era un verdadero reto para los desarrolladores.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_distribuidos">2.5. Sistemas distribuidos</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>En la actualidad es comÃºn el uso de redes para interconectar ordenadores individuales âpor ejemplo Internet o la red de Ã¡rea local de una oficinaâ cada uno equipado con su procesador, su memoria, sus dispositivos de almacenamiento, su fuente de alimentaciÃ³n, etc.
En las redes de ordenadores los procesadores de dichos ordenadores se comunican con otros procesadores a travÃ©s de lÃ­neas de comunicaciÃ³n, como: redes Ethernet, lÃ­neas telefÃ³nicas o wifi.
Estos sistemas son comÃºnmente denominados <strong>sistemas distribuidos</strong>.</p>
</div>
<div class="paragraph">
<p>Sin entrar en detalles, los sistemas distribuidos pueden ser clasificados en <strong>sistemas cliente-servidor</strong> y <strong>sistemas de redes entre iguales</strong>.</p>
</div>
<div class="sect3">
<h4 id="_sistemas_cliente_servidor">2.5.1. Sistemas cliente-servidor</h4>
<div class="paragraph">
<p>En los <strong>sistemas cliente-servidor</strong>  existen ordenadores que actÃºan como <strong>servidores</strong> encargados de satisfacer las peticiones generadas por otros ordenadores que actÃºan como <strong>clientes</strong>.</p>
</div>
<div class="paragraph">
<p>Este tipo de sistemas han sustituido, en un gran nÃºmero de casos, a los terminales conectados a <em>mainframes</em>, debido a que los sistemas de escritorio son cada vez mÃ¡s potentes y baratos.
Concretamente:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Los terminales han sido sustituidos por sistemas de escritorio que, al disponer de mÃ¡s recursos, son capaces de realizar muchas de las funcionalidades que anteriormente eran manejadas directamente por los <em>mainframes</em>.</p>
</li>
<li>
<p>Al mismo tiempo estos <em>mainframes</em> se han reemplazado por servidores, no muy diferentes a los sistemas de escritorios, pero preparados para atender las peticiones de sus clientes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ejemplos de este este tipo de sistemas son los servidores de base de datos, que responden a las consultas SQL de los clientes, o los servidores de archivos, que proporcionan una interfaz de sistema de archivos con la que los clientes pueden crear, leer, escribir y borrar archivos en el servidor; de forma similar a como si estuvieran almacenados localmente en el propio cliente.</p>
</div>
</div>
<div class="sect3">
<h4 id="_sistemas_de_redes_entre_iguales">2.5.2. Sistemas de redes entre iguales</h4>
<div class="paragraph">
<p>En los <strong>sistemas de redes entre iguales</strong>   o <strong>P2P</strong> (<em>peer-to-peer</em>) clientes y servidores no se distinguen los unos de los otros.
Todos los nodos del sistema son iguales y cada uno puede actuar como cliente o servidor, dependiendo de cuÃ¡ndo piden o proporcionan un servicio.</p>
</div>
<div class="paragraph">
<p>La ventaja fundamental de este tipo de sistemas es que en los sistemas cliente-servidor el servidor puede ser el cuello de botella del rendimiento, pero en los sistemas de redes entre iguales la carga se distribuye entre todos los nodos de la red.
Ejemplos de este tipo de sistemas son las redes <a href="https://es.wikipedia.org/wiki/BitTorrent">BitTorrent</a> y <a href="https://es.wikipedia.org/wiki/Bitcoin">Bitcoin</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Un servidor puede ser el cuello de botella no solo por su potencia sino tambiÃ©n por el ancho de banda de su conexiÃ³n a la red.
La potencia del servidor es lo de menos cuando se intenta distribuir en Internet archivos de gran tamaÃ±o âpor ejemplo imÃ¡genes de CD o DVDâ pues el problema es que varias descargas simultÃ¡neas pueden consumir todo el ancho de banda del servidor durante largos periodos de tiempo.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_sistemas_operativos_para_sistemas_distribuidos">2.5.3. Sistemas operativos para sistemas distribuidos</h4>
<div class="paragraph">
<p>Desde el punto de vista de los sistemas operativos para sistemas distribuidos es posible hacer la siguiente distinciÃ³n:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Los <strong>sistemas operativos de red</strong>  ofrecen a las aplicaciones que corren sobre ellos servicios de acceso a redes de ordenadores.
Por ejemplo, implementan algÃºn mecanismo que permita a diferentes procesos en diferentes ordenadores enviar y recibir mensajes.
AdemÃ¡s suelen incorporar la opciÃ³n de proporcionar algunos servicios de red, como la comparticiÃ³n de archivos y dispositivos con otros equipos de la misma red.</p>
<div class="paragraph">
<p>Los ordenadores con sistemas operativos de red son autÃ³nomos.
Simplemente es que gracias al sistema operativo de red, conocen la existencia de la red y saben usarla para comunicarse con otros ordenadores de la misma.</p>
</div>
<div class="paragraph">
<p>Este tipo de sistemas operativos son los mÃ¡s utilizados en los tipos de sistemas distribuidos comentados anteriormente.
En la actualidad, la inmensa mayorÃ­a de sistemas de escritorio y dispositivos de mano utilizan sistemas operativos de red.</p>
</div>
</li>
<li>
<p>Los <strong>sistemas operativos distribuidos</strong>  crean en el usuario la ilusiÃ³n de que estÃ¡ en un Ãºnico ordenador, aunque en realidad el sistema operativo controla todos los ordenadores de la red, dando al usuario acceso transparente a los recursos en todos los equipos de la misma.</p>
<div class="paragraph">
<p>Con este tipo de sistemas operativos el usuario no sabe en quÃ© ordenador se ejecutan sus procesos, dÃ³nde se almacenan sus archivos, ni quÃ© equipo tiene conectado los distintos perifÃ©ricos a los que tiene acceso.</p>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Un ejemplo de sistema operativo distribuido es <a href="https://en.wikipedia.org/wiki/Amoeba_(operating_system)">Amoeba</a>, un sistema operativo distribuido de investigaciÃ³n escrito por Andrew S. Tanenbaum en Vrije Universiteit.
Para mÃ¡s informaciÃ³n, vÃ©ase el <a href="http://www.cs.vu.nl/pub/amoeba/">sitio web de Amoeba</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_en_cluster">2.6. Sistemas en cluster</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Como los sistemas distribuidos, los <strong>sistemas en <em>cluster</em></strong> interconectar ordenadores individuales.
Sin embargo generalmente se acepta que los <strong>sistemas en <em>cluster</em></strong> comparten el almacenamiento y estÃ©n conectados por medio de una red local, condiciones que no tienen por quÃ© darse en los sistemas distribuidos.</p>
</div>
<div class="paragraph">
<p>Los <strong>sistemas en <em>cluster</em></strong> se utilizan para:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Obtener servicios con alta disponibilidad</strong>.
Para ello un nodo del <em>cluster</em> puede estar ejecutando un servicio mientras otro nodo lo monitoriza.
En caso de fallo en el nodo que da el servicio, el que lo monitoriza lo sustituye.</p>
<div class="paragraph">
<p>Si es necesario proporcionar varios servicios, el mecanismo anterior se puede extender repartiendo los servicios entre dos o mÃ¡s nodos y haciendo que se monitoricen entre ellos.</p>
</div>
</li>
<li>
<p><strong>ComputaciÃ³n de alto rendimiento</strong> o <strong>HPC</strong>.
En este caso todos los nodos se utilizan para dar un mismo servicio.
Un nodo especial, denominado balanceador de carga, tiene la responsabilidad de repartir el trabajo entre los nodos.</p>
<div class="paragraph">
<p>Este tipo de <strong>sistemas en <em>cluster</em></strong> se utiliza para realizar trabajos de cÃ¡lculo muy pesados, como simulaciones âpor ejemplo simulaciÃ³n meteorolÃ³gica, nuclear o de gestiÃ³n hospitalariaâ o romper sistemas de cifrado.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>TambiÃ©n es muy utilizado en servidores de Internet âcomo servidores web, correo electrÃ³nico o de mensajerÃ­a instantÃ¡neaâ o servidores de base de datos que deban dar
servicio a una gran cantidad de clientes simultÃ¡neamente.
En estos casos el balanceador de carga realiza su trabajo repartiendo las conexiones de los usuarios entre los servidores del <em>cluster</em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_de_tiempo_real">2.7. Sistemas de tiempo real</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Los <strong>sistemas de tiempo real</strong> se utilizan cuando existen requerimientos estrictos de tiempo en la ejecuciÃ³n de ciertas tareas o en el procesamiento de flujos de datos.</p>
</div>
<div class="paragraph">
<p>En general se usan frecuentemente en dispositivos de control donde, dentro de unos mÃ¡rgenes estrictos de tiempo, se deben tomar datos de uno o varios sensores, para analizarlos posteriormente y realizar, en consecuencia, alguna acciÃ³n con algÃºn mecanismo de control.
Por ejemplo, se suelen utilizar en sistemas de control industrial, domÃ³tica, armamento, automociÃ³n âen la inyecciÃ³n electrÃ³nica de combustible, sistemas de frenado y de control de tracciÃ³nâ o en dispositivos mÃ©dicos.</p>
</div>
<div class="paragraph">
<p>Los <strong>sistema de tiempo real</strong> estÃ¡n muy relacionados con los <strong>sistemas empotrados</strong>.
Estos Ãºltimos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se diseÃ±an para realizar tareas muy especÃ­ficas. No son sistemas de propÃ³sito general sino de propÃ³sito especÃ­fico.</p>
</li>
<li>
<p>Sus sistemas operativos tienen caracterÃ­sticas muy limitadas y no tienen que tener necesariamente una interfaz de usuario.</p>
</li>
<li>
<p>Estos sistemas estÃ¡n tanto en el motor de los automÃ³viles y los robots que los fabrican, como en reproductores de DVD, microondas o dispositivos de red.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Los <strong>sistemas de tiempo real</strong> pueden ser clasificados en <strong>sistemas de tiempo real estricto</strong> y <strong>sistemas de tiempo real flexible</strong>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Los <strong>sistemas de tiempo real estricto</strong>  o <strong>hard real-time</strong> garantizan que las tareas serÃ¡n realizadas dentro de unos mÃ¡rgenes estrictos de tiempo.</p>
<div class="paragraph">
<p>Para ello, todas las situaciones imprevistas que puedan ocasionar retardos en el funcionamiento del sistema operativo deben estar perfectamente limitadas en tiempo.
Por lo tanto, suelen carecer de memoria virtual y de otras abstracciones que aÃ­slen al desarrollador del funcionamiento real del hardware ya que introducen impredecibilidad.</p>
</div>
<div class="paragraph">
<p>Los sistemas de tiempo real estricto no son compatibles con los sistemas de tiempo compartido.</p>
</div>
</li>
<li>
<p>Los <strong>sistemas de tiempo real flexible</strong>   o <strong>soft real-time</strong> son Ãºtiles cuando en un sistema operativo convencional hay tareas que tienen mayor importancia que el resto, por lo que deben ser realizadas con mayor prioridad.</p>
<div class="paragraph">
<p>El tiempo real flexible no sirve cuando se tienen tareas con limitaciones precisas de tiempo, porque no hay manera de garantizar que dichas restricciones se van a cumplir.
Sin embargo si es Ãºtil para tareas relacionadas con la multimedia, la realidad virtual, los videojuegos, etc. y es compatible con la memoria virtual y otras caracterÃ­sticas presentes en los sistemas de escritorio.
Por eso la mayor parte de los sistemas de escritorio actuales soportan tareas de tiempo real flexible.</p>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_historia_de_los_sistemas_operativos">3. Historia de los sistemas operativos</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>19 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>La historia de los sistemas operativos se puede dividir en cinco grandes etapas o generaciones, obviamente conectadas con las generaciones de los ordenadores donde funcionaban.</p>
</div>
<div class="sect2">
<h3 id="_historia_primera_generaciÃ³n">3.1. 1Âª GeneraciÃ³n (1945-55)</h3>
<div class="paragraph">
<p>En la primera generaciÃ³n de ordenadores no se utilizaban sistemas operativos.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Sus principales caracterÃ­sticas son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Computadoras construidas con electrÃ³nica de <a href="https://es.wikipedia.org/wiki/V%C3%A1lvula_termoi%C3%B3nica">vÃ¡lvulas de vacÃ­o</a>.</p>
</li>
<li>
<p>Sin sistema operativo.</p>
</li>
<li>
<p>Sin lenguajes de programaciÃ³n.
Se programaban directamente en lenguaje mÃ¡quina.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Algunos ejemplos de ordenadores destacables fueron:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="https://es.wikipedia.org/wiki/ENIAC">ENIAC</a> (1945)</dt>
<dd>
<p>Se le considera el primer ordenador electrÃ³nico digital de propÃ³sito general, aunque existe cierta polÃ©mica sobre este punto.
Lo cierto es que se construyeron otros ordenadores antes que Ã©ste pero o no eran de propÃ³sito general âcomo las famosas computadoras <a href="https://es.wikipedia.org/wiki/Colossus">Colossus</a> (1944), que fueron diseÃ±adas para ayudar en <a href="https://es.wikipedia.org/wiki/Criptoan%C3%A1lisis">criptoanÃ¡lisis</a>â o no eran electrÃ³nicos sino electro-mecÃ¡nicos âcomo la computadora <a href="https://es.wikipedia.org/wiki/Z3">Z3</a> (1941), que usaba <a href="https://es.wikipedia.org/wiki/Rel%C3%A9">relÃ©s</a>â.</p>
<div class="paragraph">
<p>No era un producto comercial sino un proyecto experimental de defensa que principalmente se diseÃ±o y utilizÃ³ para calcular tablas de tiro de artillerÃ­a destinadas al Laboratorio de InvestigaciÃ³n BalÃ­stica del EjÃ©rcito de los Estados Unidos.</p>
</div>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/Z4">Z4</a> (1945) fue el primer ordenador digital comercial, pero era electro-mecÃ¡nico.</p>
</div>
</dd>
<dt class="hdlist1"><a href="https://es.wikipedia.org/wiki/IBM_701">IBM 701</a> (1953)</dt>
<dd>
<p>Fue el primer <em>mainframe</em> de la serie IBM 700, que a la larga se convertirÃ­a en un Ã©xito de ventas.
Utilizaba tubos de vacÃ­o y tarjetas perforadas.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>El IBM 7090 âversiÃ³n transistorizada del 709, que utilizaba vÃ¡lvulas de vacÃ­o, como todos los de la serie 700â y el posterior 7094, fueron usados por la NASA para los cÃ¡lculos de control de las misiones de los programas espaciales Mercury y Gemini y durante la primera etapa del programa Apolo.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_historia_segunda_generaciÃ³n">3.2. 2Âª GeneraciÃ³n (1955-64)</h3>
<div class="paragraph">
<p>En la segunda generaciÃ³n de ordenadores los transistores reemplazan a las vÃ¡lvulas de vacÃ­o.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>En lo que respecta a los sistemas operativos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Aparecen los monitores del sistema, que se pueden considerar un predecesor de los sistemas operativos.</p>
</li>
<li>
<p>Sistema de procesamiento por lotes.</p>
</li>
<li>
<p>Se comienzan a utilizar lenguajes de programaciÃ³n, como: ensamblador, FORTRAN y COBOL.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/GM-NAA_I/O">GM-NAA I/O</a> (<em>General Motors and North American Aviation Input/Output system</em>) fue el primer sistema operativo.
Fue desarrollado por General Motors Research Laboratory en 1956 para el <em>mainframe</em> <a href="https://en.wikipedia.org/wiki/IBM_704">IBM 704</a> con el fin de automatizar la carga y ejecuciÃ³n de un nuevo trabajo una vez habÃ­a terminado el anterior.
Para su desarrollo se basaron en un monitor del sistema creado en 1955 por programadores de General Motors para el IBM 701.</p>
</div>
<div id="instalaciÃ³n_ibm_702" class="imageblock">
<div class="content">
<img src="C03-historia/media/instalaciÃ³n_ibm_702.jpg" alt="instalaciÃ³n ibm 702">
</div>
<div class="title">Figura 7. InstalaciÃ³n de un mainframe IBM 702&#8201;&#8212;&#8201;Fuente: <a href="https://commons.wikimedia.org/wiki/File:BRL61-IBM_702.jpg">Wikipedia</a></div>
</div>
</div>
<div class="sect2">
<h3 id="_historia_tercera_generaciÃ³n">3.3. 3Âª GeneraciÃ³n (1965-1968)</h3>
<div class="paragraph">
<p>En la tercera generaciÃ³n se comenzaron a utilizar los circuitos integrados, que fue una invenciÃ³n de finales de la dÃ©cada de 1950.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>En lo que respecta a los sistemas operativos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Aparecen los sistemas operativos multiprogramados.</p>
</li>
<li>
<p>Aparecen mÃ¡s lenguajes de programaciÃ³n.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>El ejemplo mÃ¡s destacado de esta Ã©poca es el <a href="https://en.wikipedia.org/wiki/OS/360_and_successors">IBM OS/360</a>
Fue un sistema operativo desarrollado por IBM para su <em>mainframe</em> <a href="https://en.wikipedia.org/wiki/IBM_System/360">IBM System/360</a> (S/360) (vÃ©ase la <a href="#instalaciÃ³n_ibm_system_360">Figura 8</a>).
Su versiÃ³n DOS/360 (<em>Disk Operating System/360</em>) fue el primer sistema operativo en hacer los discos magnÃ©ticos un requisito para poder operar.</p>
</div>
<div id="instalaciÃ³n_ibm_system_360" class="imageblock">
<div class="content">
<img src="C03-historia/media/instalaciÃ³n_ibm_system_360.jpg" alt="instalaciÃ³n ibm system 360">
</div>
<div class="title">Figura 8. InstalaciÃ³n de un mainframe IBM System/360&#8201;&#8212;&#8201;Fuente: <a href="http://www-03.ibm.com/ibm/history/ibm100/us/en/icons/system360/impacts/">IBM</a></div>
</div>
<div class="paragraph">
<p>Se anunciÃ³ en 1964 pero fue lanzado en 1966, con un aÃ±o de retraso respecto a la fecha prevista originalmente.
Los motivos fundamentales fueron ciertos problemas de organizaciÃ³n interna de la compaÃ±Ã­a y la falta de experiencia en proyectos de esa envergadura.
Las previsiones iniciales eran de 1 millÃ³n de lÃ­neas de cÃ³digo y miles de componentes de software.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Algunos autores fechan los inicios de la ingenierÃ­a del software en la publicaciÃ³n del libro Â«The Mythical Man-Month: Essays on Software EngineeringÂ», escrito por Frederick Brooks y publicado en 1975.
Frederick Brooks se basÃ³ en la experiencia adquirida mientras administraba el desarrollo del IBM OS/360, donde era jefe de proyecto.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_historia_cuarta_generaciÃ³n">3.4. 4Âª GeneraciÃ³n (1965-1980)</h3>
<div class="paragraph">
<p>La cuarta generaciÃ³n abarca desde mediados de los aÃ±os 60 hasta finales de la dÃ©cada de los 70.
Respecto a los ordenadores, es el resultado del desarrollo de los microprocesadores.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>En lo que respecta a los sistemas operativos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Aparecen los sistemas operativos de tiempo compartido.</p>
</li>
<li>
<p>Aparecen los terminales, los programas interactivos y las mÃ¡quinas virtuales.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>A continuaciÃ³n veremos los ejemplos mÃ¡s representativos de esta Ã©poca.</p>
</div>
<div class="sect3">
<h4 id="_multics">3.4.1. MULTICS</h4>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/Multics">MULTICS</a> fue anunciado en 1964, fruto de la colaboraciÃ³n entre el MIT, General Electrics y Bell Labs, como el primer sistema operativo de propÃ³sito general.</p>
</div>
<div id="multics_mainframe" class="imageblock">
<div class="content">
<img src="C03-historia/media/multics_mainframe.jpg" alt="multics mainframe">
</div>
<div class="title">Figura 9. Mainframe GE-6180 con sistema MULTICS, entorno a 1976 en el MIT&#8201;&#8212;&#8201;Fuente: <a href="http://www.multicians.org/multics-stories.html">Multicians</a></div>
</div>
<div class="paragraph">
<p>Fue el primer sistema operativo en proporcionar un sistema de archivos jerÃ¡rquico, intÃ©rprete de comandos implementado como programa de usuario, listas de control de acceso individuales para cada archivo y enlazado dinÃ¡mico, entre otras caracterÃ­sticas novedosas.</p>
</div>
<div class="paragraph">
<p>AdemÃ¡s experimentÃ³ con eliminar la separaciÃ³n entre el espacio de direcciones de los procesos y los archivos.
Es decir, como si todos los archivos estuvieran mapeados en memoria, permitiendo a los procesos acceder al contenido de los archivos directamente (vÃ©ase el <a href="#_archivos_mapeados_en_memoria">Apartado 17.3</a>).</p>
</div>
</div>
<div class="sect3">
<h4 id="_vmcms">3.4.2. VM/CMS</h4>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/VM_(sistema_operativo)">VM/CMS</a> es un sistema de IBM utilizado en los <em>mainframe</em> <a href="https://en.wikipedia.org/wiki/IBM_System/360">IBM System/360</a>, System/370, System/390 y zSeries.
VM es un <a href="https://es.wikipedia.org/wiki/Hipervisor">hipervisor</a> que se encarga de virtualizar el hardware para crear mÃºltiples mÃ¡quinas virtuales, dando la sensaciÃ³n de que cada una es un <em>mainframe</em> independiente.</p>
</div>
<div class="paragraph">
<p>Como sistema operativo de las maquinas virtuales, una opciÃ³n comÃºn es CMS, un sistema interactivo y monousuario muy ligero, diseÃ±ado para operar fundamentalmente en una mÃ¡quina virtual de VM.
Gracias a VM/CMS, cada usuario tiene la sensaciÃ³n de trabajar en un sistema completamente independiente y seguro.</p>
</div>
<div class="paragraph">
<p>El desarrollo de VM/CMS comenzÃ³ en 1965 y la primera versiÃ³n estuvo disponible a primeros de 1966.
Las versiones actuales se denominan IBM z/VM.</p>
</div>
</div>
<div class="sect3">
<h4 id="_unix">3.4.3. UNIX</h4>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/Unix">UNIX</a> fue desarrollado originalmente por Bell Labs en 1970 para los sistemas <a href="https://es.wikipedia.org/wiki/PDP-11">PDP-11/20</a> (vÃ©ase la <a href="#dec_pdp11">Figura 10</a>).
La autorÃ­a del mismo se le atribuye a un grupo de programadores, liderados por Ken Thompson, que decidieron rehacer el trabajo de MULTICS pero a menor escala; despuÃ©s de que Bell Labs abandonara el proyecto MULTICS en 1969.
Inicialmente se llamÃ³ UNICS y fue desarrollado para los sistemas PDP-7.</p>
</div>
<div id="dec_pdp11" class="imageblock">
<div class="content">
<img src="C03-historia/media/dec_pdp11_ken_den.jpg" alt="dec pdp11 ken den">
</div>
<div class="title">Figura 10. Dennis Ritchie (de pie) y Ken Thompson (sentado) frente a un PDP-11 y sus dos terminales <a href="https://en.wikipedia.org/wiki/Teletype_Model_33">Teletype 33</a>&#8201;&#8212;&#8201;Fuente: <a href="https://www.bell-labs.com/usr/dmr/www/">Dennis Ritchie</a></div>
</div>
<div class="paragraph">
<p>La primer versiÃ³n de UNIX fue implementada en ensamblador, como era comÃºn en la Ã©poca.
Posteriormente, Dennis Ritchie y Brian Kernighan diseÃ±aron un nuevo lenguaje de programaciÃ³n llamado Â«CÂ», especialmente pensado para que UNIX fuera escrito con Ã©l.
Eso facilitÃ³ que UNIX pudiera ser portado a ordenadores diferentes.
AdemÃ¡s, gracias al lenguaje C, el cÃ³digo era mÃ¡s conciso y compacto, lo que se tradujo en que se pudieron desarrollar nuevas funcionalidades mÃ¡s rÃ¡pidamente.</p>
</div>
<div class="paragraph">
<p>AT&amp;T, la compaÃ±Ã­a matriz de Bell Labs, no podÃ­a competir en la industria de los ordenadores, por lo que puso el cÃ³digo fuente de UNIX a disposiciÃ³n de universidades, compaÃ±Ã­as privadas y del gobierno de los Estados Unidos.
Eso aumento su difusiÃ³n y dio resultados inesperados.
Por ejemplo, una de las variantes mÃ¡s importantes de UNIX fue <a href="https://es.wikipedia.org/wiki/Berkeley_Software_Distribution">BSD</a>, desarrollada por la Universidad de California en Berkeley.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>La versiÃ³n 4.2BSD (<em>Berkeley Software Distribution</em>) de esta variante de UNIX fue la primera que incluyÃ³ la interfaz de <em>sockets</em> para facilitar la comunicaciÃ³n entre procesos a travÃ©s de Internet y otras redes.
Esta interfaz se ha convertido en estÃ¡ndar en prÃ¡cticamente cualquier sistemas operativo.</p>
</div>
<div class="paragraph">
<p>TambiÃ©n implementÃ³ y ayudÃ³ a difundir el estÃ¡ndar de comunicaciones TCP/IP, base de la actual Internet.
Muchos sistemas operativos actuales, tanto libres como privativos, utilizan cÃ³digo de UNIX BSD en su implementaciones de los protocolos TCP/IP y de diversas utilidades de red.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>En la actualidad se considera que hay dos grandes familias de UNIX y las distintas variantes pertenecen a una u otra en funciÃ³n del UNIX del que derivaron originalmente:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La familia derivada de <strong>AT&amp;T UNIX System V</strong>, en la que se incluyen sistemas operativos no libres, tales como: <a href="https://es.wikipedia.org/wiki/SCO_OpenServer">SCO OpenServer</a>, <a href="https://es.wikipedia.org/wiki/Solaris_(sistema_operativo)">Oracle/Sun Microsystems Solaris Operating Environment</a> y <a href="https://es.wikipedia.org/wiki/UnixWare">SCO UnixWare</a>.</p>
</li>
<li>
<p>La familia derivada de <strong>UNIX BSD</strong>, en la que se incluyen sistemas libres como: <a href="https://es.wikipedia.org/wiki/FreeBSD">FreeBSD</a>, <a href="https://es.wikipedia.org/wiki/NetBSD">NetBSD</a>, <a href="https://es.wikipedia.org/wiki/OpenBSD">OpenBSD</a>, <a href="https://en.wikipedia.org/wiki/Darwin_(operating_system)">Darwin</a> y <a href="https://es.wikipedia.org/wiki/DragonFly_BSD">DragonFly BSD</a>, entre muchos otros.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/FreeBSD">FreeBSD</a> es el sistema base de algunos sistemas no libres.
Por ejemplo, <a href="https://en.wikipedia.org/wiki/Darwin_(operating_system)">Darwin</a> es el sistema operativo en el que se basan los sistemas operativos de Apple: macOS, IOS, watchOS, tvOS e iPadOS.
A su vez Darwin utiliza mÃºltiples elementos de FreeBSD (vÃ©ase el <a href="#_mach">Apartado 3.5.8</a>).</p>
</div>
<div class="paragraph">
<p>Otro ejemplo destacable es <a href="https://en.wikipedia.org/wiki/PlayStation_4_system_software">Orbis OS</a> âel sistema operativo de PlayStation 4â que tambiÃ©n estÃ¡ basado en FreeBSD.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_vms">3.4.4. VMS</h4>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/OpenVMS">VMS</a> es un sistema operativo de 32 bits diseÃ±ado originalmente por Digital Equipment Corporation (DEC) âahora propiedad de HPâ en 1978 para usarlo en minicomputadoras <a href="https://es.wikipedia.org/wiki/VAX">VAX</a>.
Posteriormente fue portado a sistemas DEC Alpha e Intel Itanium.</p>
</div>
<div id="dec_vax11" class="imageblock">
<div class="content">
<img src="C03-historia/media/dec_vax11.jpg" alt="dec vax11">
</div>
<div class="title">Figura 11. InstalaciÃ³n de VAX 11/780 en 1980&#8201;&#8212;&#8201;Fuente: <a href="http://www.chilton-computing.org.uk/">Science and Technology Facilities Council</a></div>
</div>
<div class="paragraph">
<p>Las siglas VMS vienen de <em>Virtual Memory System</em>, ya que una de sus principales caracterÃ­sticas era explotar el concepto de <strong>memoria virtual</strong>.
Este concepto tambiÃ©n es muy utilizando en los sistemas operativos modernos.
Permite que los procesos se ejecuten aislados, unos de otros, en la memoria principal y sin tener que ser cargados completamente, lo que permite que cada uno consuma memos memoria.</p>
</div>
<div class="paragraph">
<p>VMS era un sistema multiusuario y multiprocesador que podÃ­a distribuir el trabajo entre varias mÃ¡quinas, lo que le permitÃ­a ser tolerante a fallos.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>VMS es en cierta medida un ancestro de Microsoft Windows NT (vÃ©ase el <a href="#_windows_nt">Apartado 3.5.6</a>).
Para desarrollar Windows NT, Microsoft contratÃ³ a un grupo de desarrolladores de Digital Equipment Corporation.
Muchos aspectos del diseÃ±o de Windows NT reflejan la experiencia de DEC en VMS.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_ibm_os400">3.4.5. IBM OS/400</h4>
<div class="paragraph">
<p>El <a href="https://es.wikipedia.org/wiki/OS/400">IBM OS/400</a> es un sistema utilizado en la familia de minicomputadoras <a href="https://es.wikipedia.org/wiki/AS/400">IBM AS/400</a> âllamada iSeries desde 2006â.
Fueron introducidos en el mercado en 1988, pero aÃºn es posible verlos en algunas organizaciones.
En 2008 el sistema operativo IBM OS/400 pasÃ³ a llamarse IBM i y siguen publicÃ¡ndose nuevas versiones en la actualidad.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_5Âº_generaciÃ³n_desde_1980">3.5. 5Âº GeneraciÃ³n (desde 1980):</h3>
<div class="paragraph">
<p>Esta Ãºltima generaciÃ³n abarca desde la dÃ©cada de 1980 hasta la actualidad.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Respecto a los sistemas operativos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Incluye a los sistemas operativos de escritorio y ordenadores personales (PC).</p>
</li>
<li>
<p>Aparecen mÃºltiples conceptos nuevos: monousuario, multitarea, distribuidos, paralelos, tiempo real, etc.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Se puede observar una muestra de la interfaz grÃ¡fica de usuario de algunos estos sistemas en el artÃ­culo <a href="https://www.webdesignerdepot.com/2009/03/operating-system-interface-design-between-1981-2009/">Â«Operating System Interface Design Between 1981-2009Â»</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_cpm">3.5.1. CP/M</h4>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/CP/M">CP/M</a> (1974) fue el sistema operativo estÃ¡ndar en la primera generaciÃ³n de microcomputadoras. Fue creado por Digital Research, Inc. âfundada por Gary Kildallâ para ser el sistema operativo de los microordenadores basados en <a href="https://es.wikipedia.org/wiki/Intel_8080">Intel 8080/85</a> y <a href="https://es.wikipedia.org/wiki/Zilog_Z80">Zilog Z80</a>.</p>
</div>
<div class="paragraph">
<p>Con la elecciÃ³n de MS-DOS por parte de IBM para su <a href="https://es.wikipedia.org/wiki/IBM_PC">IBM PC</a>, CP/M fue perdiendo mercado paulatinamente hasta desaparecer.
Sin embargo, la influencia de CP/M en MS-DOS es indudable, en tanto en cuanto 86-DOS, el predecesor de MS-DOS, estaba basado en las ideas de CP/M.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ms_dos">3.5.2. MS-DOS</h4>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/MS-DOS">MS-DOS</a> fue el sistema operativo estÃ¡ndar en la segunda generaciÃ³n de microcomputadoras.
No era ni multitarea ni multiusuario.
Fue el primer sistema operativo del <a href="https://es.wikipedia.org/wiki/IBM_PC">IBM PC</a> âlanzado en 1981â y durante mucho tiempo fue ampliamente utilizado en toda la plataforma Â«PC compatibleÂ».</p>
</div>
<div class="paragraph">
<p>MS-DOS fue creado por Seattle Computer Products (SCP) con el nombre de <a href="https://es.wikipedia.org/wiki/QDOS">86-DOS</a> en 1979.
Se basaron en ideas de CP/M, pues pretendÃ­an ofrecer una versiÃ³n de CP/M para procesadores <a href="https://es.wikipedia.org/wiki/Intel_8086_y_8088">Intel 8086</a>.
Inicialmente era conocido como QDOS (<em>Quick and Dirty Operating System</em>) pero SCP le cambiÃ³ el nombre en 1980, cuando comenzaron al licenciarlo.
Posteriormente Microsoft adquiriÃ³ el sistema y lo vendiÃ³ a IBM en 1981 con el nombre de MS-DOS.</p>
</div>
<div class="paragraph">
<p>Tanto IBM como Microsoft lanzaron versiones de DOS, aunque originalmente IBM solamente validaba y empaquetaba el software de Microsoft.
Microsoft lanzaba sus versiones bajo el nombre de MS-DOS, mientras IBM las lanzaba bajo el nombre de <a href="https://es.wikipedia.org/wiki/IBM_PC_DOS">IBM PC-DOS</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En <a href="https://www.pcjs.org/">PCjs</a> se pueden probar de forma sencilla sistemas operativos y aplicaciones antiguas del IBM PC.
Solo hace falta acceder con el navegador y elegir la experiencia que mÃ¡s nos llame la atenciÃ³n.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_os2">3.5.3. OS/2</h4>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/OS/2">OS/2</a> fue un sistema operativo creado por Microsoft e IBM para aprovechar las nuevas caracterÃ­sticas de la segunda generaciÃ³n de ordenadores personales de IBM, equipados con procesador <a href="https://es.wikipedia.org/wiki/Intel_80286">Intel 80286</a>.
Pero al final terminÃ³ siendo desarrollado en exclusiva por IBM.</p>
</div>
<div class="paragraph">
<p>OS/2 fue pensado como un sucesor con <strong>operaciÃ³n en modo dual</strong> de MS-DOS y de Microsoft Windows 2.0.
Fue anunciado en abril y lanzado en diciembre de 1987 como un sistema operativo en modo texto.
En la versiÃ³n 1.1, lanzada en noviembre de 1988, se le aÃ±adiÃ³ interfaz grÃ¡fica.</p>
</div>
<div id="os_2_1" class="imageblock">
<div class="content">
<img src="C03-historia/media/os_2_1.png" alt="os 2 1">
</div>
<div class="title">Figura 12. Panel de control de Microsoft-IBM OS/2 1.1&#8201;&#8212;&#8201;Fuente: Michal Necasek</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En los sistemas con <strong>operaciÃ³n en modo dual</strong> se distingue entre dos modos de ejecuciÃ³n, de tal forma que solo en el modo en el que se ejecuta el cÃ³digo del sistema operativo se pueden realizar operaciones peligrosas.
En el otro modo y con menos privilegios, se ejecutan las aplicaciones de usuario.
Para mÃ¡s informaciÃ³n, vÃ©ase el <a href="#_operaciÃ³n_en_modo_dual">Apartado 7.2</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>La colaboraciÃ³n entre IBM y Microsoft terminÃ³ en 1990, entre el lanzamiento de Windows 3.0 y la de OS/2 1.3.
El aumento de popularidad de Windows llevo a Microsoft a dejar de centrarse en el desarrollo de OS/2, lo que hizo que IBM se preocupara por los continuos retrasos en el desarrollo de OS/2 2.0.
Inicialmente ambas compaÃ±Ã­as acordaron que IBM tomarÃ­a el mantenimiento de OS/2 1.0 y el desarrollo de OS/2 2.0, mientras Microsoft continuarÃ­a desarrollando OS/2 3.0, que entonces era conocido como Â«NT OS/2Â».
Sin embargo Microsoft finalmente decidiÃ³ renombrar NT OS/2 como Windows NT, dejando el futuro desarrollo de OS/2 en manos de IBM.</p>
</div>
<div class="paragraph">
<p>OS/2 Warp 3 fue un sistema completo de 32 bits lanzado en 1994.
Le seguirÃ­a OS/2 Warp 4, en 1996.
Poco despuÃ©s, IBM anunciÃ³ que OS/2 desaparecerÃ­a.</p>
</div>
</div>
<div class="sect3">
<h4 id="_windows_3_x">3.5.4. Windows 3.x</h4>
<div class="paragraph">
<p>La familia <a href="https://es.wikipedia.org/wiki/Windows_3.1x">Windows 3.x</a> de Microsoft Windows fue desarrollada desde 1990 hasta 1994.
Windows 3.0 fue la primera versiÃ³n de Ã©xito de Windows, permitiendo a Microsoft competir con el <a href="https://es.wikipedia.org/wiki/Macintosh">Macintosh</a> de Apple Computer y el <a href="https://es.wikipedia.org/wiki/Commodore_Amiga">Commodore Amiga</a>.</p>
</div>
<div id="windows_30" class="imageblock">
<div class="content">
<img src="C03-historia/media/windows_30.png" alt="windows 30">
</div>
<div class="title">Figura 13. Administrador de programas de Microsoft Windows 3.0&#8201;&#8212;&#8201;Fuente: <a href="https://guidebookgallery.org/screenshots/win30">Guidebook</a></div>
</div>
<div class="paragraph">
<p>En 1983, Microsoft anunciÃ³ el desarrollo de Windows, una interfaz grÃ¡fica de usuario para su sistema MS-DOS, que se usaba en los IBM PC y compatibles desde 1981.
Windows requerÃ­a una instalaciÃ³n previa de MS-DOS y era iniciado como un programa mÃ¡s, que podÃ­a ser terminado en cualquier momento, devolviendo al usuario a la lÃ­nea de comandos de MS-DOS.</p>
</div>
<div class="paragraph">
<p>MS-DOS le proporcionaba a Windows controladores de dispositivo para ciertas tareas, como el acceso al CD-ROM o a la interfaz de red.
Sin embargo Windows ejecutaba aplicaciones especificas de Windows, almacenadas en un formato ejecutable mucho mÃ¡s complejo que el de los programas de MS-DOS.
AdemÃ¡s, debido a que MS-DOS no aislaba a las aplicaciones del hardware y no se protegÃ­a asÃ­ mismo de los errores en dichas aplicaciones, Windows disponÃ­a de controladores de dispositivo propios, asÃ­ como sus propios sistemas de gestiÃ³n de procesos y de memoria.
En realidad Windows no se ejecutaba sobre MS-DOS, sino que hacÃ­a uso de Ã©l.
Por ello puede ser considerado como un sistema operativo.</p>
</div>
</div>
<div class="sect3">
<h4 id="_windows_95_98_me">3.5.5. Windows 95, 98, Me</h4>
<div class="paragraph">
<p>La familia Windows 3.x fue sustituida por una serie de sistemas operativos grÃ¡ficos hÃ­bridos de 16/32 bits.</p>
</div>
<div id="windows_95" class="imageblock">
<div class="content">
<img src="C03-historia/media/windows_95.png" alt="windows 95">
</div>
<div class="title">Figura 14. Escritorio de Microsoft Windows 95&#8201;&#8212;&#8201;Fuente: <a href="http://www.guidebookgallery.org/screenshots/win95">Guidebook</a></div>
</div>
<div class="paragraph">
<p>Windows 95 fue lanzado en 1995.
Fue el primer Windows unido a una versiÃ³n de MS-DOS especÃ­fica, aunque este hecho se intentaba mantener oculto.
Entre las caracterÃ­sticas de Windows 95 destacan: mejoras significativas en la interfaz de usuario (vÃ©ase la <a href="#windows_95">Figura 14</a>), nombres de archivo de hasta 256 caracteres con conservaciÃ³n de mayÃºsculas y minÃºsculas âen MS-DOS el lÃ­mite era de 8 caracteres para el nombre mÃ¡s 3 de extensiÃ³nâ y multitarea expropiativa para las aplicaciones de 32 bits.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Como veremos en el <a href="#_planificaciÃ³n_expropiativa">Apartado 14.1</a>, la planificaciÃ³n expropiativa es una tÃ©cnica que permite al sistema operativo expulsar de la CPU a los procesos en ciertas circunstancias; como, por ejemplo, que lleven demasiado tiempo utilizando la CPU de forma ininterrumpida.</p>
</div>
<div class="paragraph">
<p>En la familia Windows 3.x la planificaciÃ³n era cooperativa, es decir, los procesos abandonaban la CPU voluntariamente.
Esto ocasionaba problemas con programas que no devolvÃ­a la CPU al sistema con la suficiente frecuencia, ya que asÃ­ el resto de procesos no tenÃ­a ocasiÃ³n de ejecutarse para hacer su trabajo o responder al usuario.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Windows 98 fue lanzado el 25 de junio de 1998.
Le siguiÃ³ Windows Me, el 14 de septiembre de 2000.
Windows Me fue la Ãºltima versiÃ³n de la familia de sistemas operativos hÃ­bridos de 16/32 bits que sucediÃ³ a la familia Windows 3.x.</p>
</div>
</div>
<div class="sect3">
<h4 id="_windows_nt">3.5.6. Windows NT, 2000, XP, Vista, 7, 8 y 10</h4>
<div class="paragraph">
<p>Windows NT fue un sistema operativo de 32 bits.
El primero de la familia de sistemas operativos Microsoft Windows actuales.</p>
</div>
<div class="paragraph">
<p>Su desarrollo empezÃ³ en 1988 con el nombre de OS/2 3.0.
Cuando Windows 3.0 fue lanzado en mayo de 1990, tuvo tanto Ã©xito que Microsoft decidiÃ³ cambiar la API del aÃºn en desarrollo NT OS/2 âque era como Microsoft lo llamaba entoncesâ pasando de ser una versiÃ³n extendida de la API de OS/2 a una versiÃ³n extendida de la API de Windows 3.0.
Esta decisiÃ³n causÃ³ tensiÃ³n entre Microsoft e IBM y provocÃ³ que finalmente la colaboraciÃ³n terminara.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Una interfaz de programaciÃ³n de aplicaciones o API (del inglÃ©s <em>Application Programming Interface</em>) es el conjunto de funciones, procedimientos o mÃ©todos que ofrece el sistema operativo para ser utilizado por las aplicaciones.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Como hemos comentado anteriormente, Microsoft contratÃ³ a un grupo de desarrolladores de Digital Equipment Corporation para crear Windows NT.
Por lo que muchos de sus elementos reflejan la experiencia anterior de DEC en VMS.</p>
</div>
<div class="paragraph">
<p>Windows NT soportaba varias API de distintos sistemas operativos âpor ejemplo Win32, POSIX y OS/2 2.1â que eran implementadas como subsistemas encima de un API nativo no documentado pÃºblicamente.
Esta estructura en subsistemas, fue lo que permitiÃ³ la adopciÃ³n tardÃ­a de la API de Windows 3.0 como API principal, tal y como hemos comentado.</p>
</div>
<div class="paragraph">
<p>La primera versiÃ³n âWindows NT 3.1â lanzada el 13 de julio de 1993, era un sistema operativo <em>microkernel</em> (vÃ©ase el <a href="#_mach">Apartado 3.5.8</a> un poco mÃ¡s adelante) multiplataforma que corrÃ­a sobre procesadores <a href="https://es.wikipedia.org/wiki/IA-32">x86</a>, <a href="https://es.wikipedia.org/wiki/DEC_Alpha">DEC Alpha</a>, <a href="https://es.wikipedia.org/wiki/MIPS_(procesador)">MIPS</a> 4000 y <a href="https://es.wikipedia.org/wiki/PowerPC">PowerPC</a>.</p>
</div>
<div class="paragraph">
<p>Windows NT 4.0 âlanzado en 1996â fue la Ãºltima versiÃ³n en soportar plataformas distintas a Intel IA-32.
Aunque el desarrollo de Windows 2000 para procesador Alpha continuÃ³ un poco mÃ¡s, hasta 1999, cuando Compaq dejÃ³ de soportar Windows NT en esa arquitectura.
AdemÃ¡s Windows NT 4.0 integrÃ³ en el nÃºcleo mÃ¡s funciones âpor ejemplo, parte del subsistema grÃ¡ficoâ para obtener un rendimiento mÃ¡s prÃ³ximo al de Windows 95 en ese apartado.</p>
</div>
<div class="paragraph">
<p>Windows 2000 âo Windows NT 5.0â fue lanzado en el 17 de febrero de 2000 y fue el primer sistema operativo de la familia NT al que se le eliminaron las siglas del nombre.
Fue por motivos de marketing, para favorecer la unificaciÃ³n de las dos familias de sistemas operativos Microsoft Windows de entonces âWindows 9x y Windows NTâ alrededor de la tecnologÃ­a NT.</p>
</div>
<div class="paragraph">
<p>Windows XP âo Windows NT 5.1â completÃ³ en 2001 el proceso de unificaciÃ³n de las dos familias de sistemas operativos Windows.
Con su apariciÃ³n forzÃ³ la extinciÃ³n de la familia Windows 9x, al sustituirla con una versiÃ³n de Windows XP denominada Windows XP Home Edition, especÃ­fica para la informÃ¡tica domÃ©stica.</p>
</div>
</div>
<div class="sect3">
<h4 id="_gnulinux">3.5.7. GNU/Linux</h4>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/GNU/Linux">GNU/Linux</a> es un sistema operativo libre y, tal vez, el mÃ¡s famoso proyecto de <a href="https://es.wikipedia.org/wiki/Software_libre">software libre</a>.</p>
</div>
<div class="paragraph">
<p>El proyecto GNU se iniciÃ³ en 1983, con el fin de desarrollar un sistema operativo estilo UNIX enteramente libre.
El proyecto incluÃ­a la creaciÃ³n de herramientas de desarrollo de software y aplicaciones de usuario.</p>
</div>
<div class="paragraph">
<p>Mucho tiempo despuÃ©s, el estudiante universitario finÃ©s Linus Torvalds comenzÃ³ a desarrollar el nÃºcleo Linux como hobby, mientras estudiaba en la Universidad de Helsinki.
Torvalds originalmente usaba <a href="https://es.wikipedia.org/wiki/MINIX">Minix</a>, un sistema operativo simplificado escrito por Andrew Tanenbaum para enseÃ±ar diseÃ±o de sistemas operativos.
Sin embargo, el hecho de que Tanenbaum no diera soporte a las mejoras del sistema operativo que eran propuestas por otros desarrolladores, llevÃ³ a Torvalds a escribir un sustituto de MINIX.</p>
</div>
<div class="paragraph">
<p>En 1991, cuando se liberÃ³ la primera versiÃ³n del nÃºcleo Linux, el proyecto GNU habÃ­a desarrollado todos los componentes necesarios del sistema operativo excepto el nÃºcleo.
Torvalds y otros desarrolladores rÃ¡pidamente adaptaron Linux para que funcionara con los componentes de GNU, creando un sistema operativo completamente funcional que se denomina GNU/Linux.</p>
</div>
<div class="paragraph">
<p>El nÃºcleo Linux fue licenciado bajo la GNU General Public License (GPL), como el resto del proyecto GNU.
Pero Linux no es parte de dicho proyecto.
El proyecto GNU tiene su propio nÃºcleo, denominado <a href="https://es.wikipedia.org/wiki/GNU_Hurd">GNU/Hurd</a>, que lleva 30 aÃ±os en desarrollo y parece que aun estÃ¡ muy lejos de estar listo.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>GNU no es el Ãºnico sistema operativo que utiliza el nÃºcleo Linux.
<a href="https://es.wikipedia.org/wiki/Android">Android</a>, por ejemplo, es un sistema operativo que usa el nÃºcleo Linux pero no es GNU.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_mach">3.5.8. Mach</h4>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/Mach_(n%C3%BAcleo)">Mach</a> es un nÃºcleo de sistema operativo desarrollado en la Universidad Carnegie-Mellon (CMU).
El proyecto en la CMU se desarrollÃ³ desde 1985 hasta 1994.</p>
</div>
<div class="paragraph">
<p>Mach explora el concepto que denominamos <strong><em>microkernel</em></strong>.
En los sistemas operativos <strong><em>microkernel</em></strong> solo se implementa en el nÃºcleo del sistema un conjunto mÃ­nimo de servicios bÃ¡sicos.
El resto de los servicios proporcionados por el sistema operativo se implementan como procesos con menos privilegios.</p>
</div>
<div class="paragraph">
<p>Por sus ventajas en cuanto a seguridad y fiabilidad, en algÃºn momento se pensÃ³ que los <em>microkernel</em> dominarÃ­an el universo de los sistema operativos.
Sin embargo, el mayor esfuerzo hasta la fecha para conseguirlo es <a href="https://es.wikipedia.org/wiki/GNU_Hurd">GNU/Hurd</a>, que lleva varias dÃ©cadas de retraso.
Por fortuna, otros sistemas operativos <em>microkernel</em> han tenido algo mÃ¡s Ã©xito, como es el caso de <a href="https://es.wikipedia.org/wiki/QNX">QNX</a> o <a href="https://en.wikipedia.org/wiki/MINIX_3">MINIX 3</a>.
Mientras que Google parece que lo va a intentar con <a href="https://es.wikipedia.org/wiki/Google_Fuchsia">Google Fuchsia</a>, el posible sustituto de Android.</p>
</div>
<div class="paragraph">
<p>A mediados de los 90, Apple Computers seleccionÃ³ <a href="https://es.wikipedia.org/wiki/NEXTSTEP">OpenStep</a> como base para el sucesor de su clÃ¡sico <a href="https://es.wikipedia.org/wiki/Mac_OS_Classic">Mac OS</a>.
OpenStep es realmente una versiÃ³n actualizada de NeXTSTEP que era un sistema basado en un nÃºcleo Mach 2.5 con porciones del sistema UNIX BSD de la Universidad de Berkeley.
Por tanto, la mezcla de Mach con UNIX BSD de OpenStep es la base del sistema operativo <a href="https://es.wikipedia.org/wiki/MacOS">macOS</a> actual de Apple.</p>
</div>
<div id="openstep_42" class="imageblock">
<div class="content">
<img src="C03-historia/media/openstep_42.png" alt="openstep 42">
</div>
<div class="title">Figura 15. Entorno grÃ¡fico de OpenStep 4.2&#8201;&#8212;&#8201;Fuente: <a href="https://guidebookgallery.org/screenshots/openstep42">Guidebook</a></div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Para ser exactos, la base del sistema operativo macOS es un sistema operativo libre denominado <a href="https://en.wikipedia.org/wiki/Darwin_(operating_system)">Darwin</a> y desarrollado por Apple .
Se trata de un sistema <a href="https://es.wikipedia.org/wiki/FreeBSD">FreeBSD</a> adaptado para correr sobre el nÃºcleo Mach.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<img src="C03-historia/media/historia_sistemas_operativos.svg" alt="historia sistemas operativos">
</div>
<div class="title">Figura 16. LÃ­nea de tiempo de la historia de los sistemas operativos.</div>
</div>
</div>
</div>
</div>
</div>
<h1 id="_organizaciÃ³n_de_los_sistemas_operativos" class="sect0">Parte II: OrganizaciÃ³n de los sistemas operativos</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>El estudio de la organizaciÃ³n interna de los sistemas operativos requiere del anÃ¡lisis de tres aspectos diferentes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Los componentes del sistema operativo y sus interrelaciones.</p>
</li>
<li>
<p>Los servicios que el sistema operativo proporciona a travÃ©s del funcionamiento coordinado de dichos componentes.</p>
</li>
<li>
<p>La interfaz de programaciÃ³n que el sistema operativo ofrece a usuarios y programadores como forma de acceso a dichos servicios.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>TambiÃ©n veremos como como se categorizan los sistemas operativos segÃºn la forma en la que se interconectan sus componentes.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_componentes_del_sistema">4. Componentes del sistema</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>11 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Crear un software tan complejo como un sistema operativo no es sencillo, por ello resulta mÃ¡s prÃ¡ctico dividirlo en piezas mÃ¡s pequeÃ±as especializadas en aspectos concretos de la gestiÃ³n del sistema.</p>
</div>
<div class="paragraph">
<p>Cada sistema operativo tiene diferentes componentes con distinto nombre.
Lo que veremos en este capÃ­tulo es un esquema de los mÃ¡s comunes a la mayorÃ­a de sistemas operativos actuales.</p>
</div>
<div class="sect2">
<h3 id="componente_gestiÃ³n_de_procesos">4.1. GestiÃ³n de procesos</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>La gestiÃ³n de los procesos es un elemento central de todo sistema operativo:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>El <strong>proceso</strong> es la unidad de trabajo en cualquier sistema operativo moderno.
Es quiÃ©n realiza las tareas que interesan a los usuarios.
Por eso, es a cada proceso al que se le asigna el tiempo de CPU y el resto de recursos del sistema, como por ejemplo: memoria, archivos o dispositivos de E/S abiertos.</p>
</li>
<li>
<p>Un <strong>proceso</strong> es un programa en ejecuciÃ³n.
Un programa se convierte en proceso cuando las instrucciones del programa son cargadas en la memoria desde el archivo del ejecutable y se le asignan recursos para su ejecuciÃ³n.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Los procesos son entidades activas que necesita recursos âCPU, memoria, archivos, dispositivos E/Sâ.
Algunos de esos recursos se asignan durante su creaciÃ³n, mientras que otros son solicitados por el proceso durante su ejecuciÃ³n âpor ejemplo la memoria, de la que todo proceso necesita cierta cantidad para comenzar pero que luego puede pedir mÃ¡s dinÃ¡micamente durante su ejecuciÃ³nâ.
Cuando el proceso termina el sistema operativo reclama de estos recursos aquellos que sean reutilizables para otros procesos.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Un <strong>programa</strong> no es un proceso, es una entidad pasiva.
Es el contenido de un archivo en disco con las instrucciones que algÃºn dÃ­a una CPU ejecutarÃ¡.
Un programa no puede hacer ningÃºn tipo de trabajo a menos que sus instrucciones sean ejecutadas por una CPU, pero si eso ocurre, ya no serÃ­a un programa sino un proceso.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Aunque varios procesos estÃ©n asociados al mismo programa no pueden ser considerados el mismo proceso.
La CPU ejecuta las instrucciones de cada proceso una detrÃ¡s de otra, de manera que para conocer la siguiente instrucciÃ³n a ejecutar cada proceso tiene un contador de programa que se lo indica a la CPU, asÃ­ como valores en los registros de la CPU que dependen de la historia pasada del proceso.
Aunque varios procesos ejecuten el mismo programa, la secuencia de instrucciones ejecutadas y el estado del proceso en cada momento seguramente sean diferentes.
Por lo tanto, no son el mismo proceso.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Por el momento estamos considerando que <strong>proceso</strong> y <strong>trabajo</strong> hacen referencia al mismo concepto porque en los sistemas mÃ¡s antiguos (vÃ©ase el <a href="#_mainframe">Apartado 2.1</a>) la unidad de trabajo se llamaba <strong>trabajo</strong> mientras que en los sistemas modernos se llama <strong>proceso</strong>, de tal forma que podemos considerar al segundo una evoluciÃ³n del primero.</p>
</div>
<div class="paragraph">
<p>Sin embargo, mirÃ¡ndolo exclusivamente desde la perspectiva de los sistemas operativos modernos, son dos conceptos diferentes aunque relacionados.
En un sistema moderno un trabajo puede ser realizado por un solo proceso o mediante la colaboraciÃ³n de varios.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_responsabilidades_de_la_gestiÃ³n_de_procesos">4.1.1. Responsabilidades de la gestiÃ³n de procesos</h4>
<div class="paragraph">
<p>El componente de gestiÃ³n de procesos es el responsable de la siguientes actividades:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Crear y terminar procesos.</p>
</li>
<li>
<p>Suspender y reanudar los procesos.</p>
</li>
<li>
<p>Proporcionar mecanismos para la sincronizaciÃ³n de procesos.</p>
</li>
<li>
<p>Proporcionar mecanismos para la comunicaciÃ³n entre procesos.</p>
</li>
<li>
<p>Proporcionar mecanismos para el tratamiento de interbloqueos.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gestiÃ³n_de_la_memoria_principal">4.2. GestiÃ³n de la memoria principal</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>La memoria principal es un recurso fundamental para las operaciones de cualquier sistema operativo moderno.
Esto es asÃ­ porque generalmente es el Ãºnico almacenamiento al que la CPU tiene acceso directo.
Para que un programa pueda ser ejecutado debe ser copiado a la memoria principal.
Y para que un proceso tenga acceso a datos almacenados en cualquier otro dispositivo de almacenamiento, primero deben ser copiados a la memoria principal.</p>
</div>
<div class="paragraph">
<p>Para mejorar el aprovechamiento de la CPU y la respuesta al usuario es necesario tener en la memoria varios programas al mismo tiempo.
Puesto que dichos programas deben compartir la memoria durante su ejecuciÃ³n, automÃ¡ticamente existe la necesidad de que el sistema operativo disponga de un componente de gestiÃ³n de la memoria principal.</p>
</div>
<div class="sect3">
<h4 id="_responsabilidad_de_la_gestiÃ³n_de_la_memoria">4.2.1. Responsabilidad de la gestiÃ³n de la memoria</h4>
<div class="paragraph">
<p>El componente de gestiÃ³n de la memoria debe asumir las siguientes responsabilidades:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Controlar quÃ© partes de la memoria estÃ¡n actualmente en uso y cuÃ¡les no.</p>
</li>
<li>
<p>Decidir que procesos âo partes de procesosâ aÃ±adir o extraer de la memoria cuando hay o falta espacio en la misma.</p>
</li>
<li>
<p>Asignar y liberar espacio de la memoria principal segÃºn sea necesario.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gestiÃ³n_del_sistema_de_es">4.3. GestiÃ³n del sistema de E/S</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El <strong>sistema de E/S</strong> hace de interfaz con el hardware, oculta las peculiaridades del hardware al resto del sistema.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>El sistema de E/S consta de:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Un componente de gestiÃ³n de memoria especializado en E/S</strong>, con soporte para servicios de <em>buffering</em>, <em>caching</em> y <em>spooling</em>.
Estos servicios son utilizados por el resto del sistema de E/S.</p>
</li>
<li>
<p><strong>Una interfaz genÃ©rica de acceso a los controladores de dispositivo</strong>.
Cada dispositivo es diferente, pero los procesos y el resto de componentes del sistema no deben tener necesidad de conocer sus particularidades a la hora de acceder a ellos.
Es decir, para acceder a cualquier disco duro el sistema ofrece una misma interfaz, impedientemente de su marca y modelo.
Y lo mismo ocurre con las tarjetas de sonido o con los dispositivos de entrada, como teclados y ratones.
AsÃ­ los programadores pueden acceder a cualquier dispositivo abstrayendo de las particularidades concretas del hardware instalado en cada ordenador.</p>
</li>
<li>
<p><strong>Controladores de dispositivo</strong>, que generalmente son desarrollados por los fabricantes de los dispositivos y son el componente que realmente conoce las peculiaridades especÃ­ficas del dispositivo.
Por tanto, las peticiones que hacen los procesos a la interfaz de E/S genÃ©rica la traslada el sistema a los controladores de dispositivo para que Ã©stos las conviertan en acciones concretas sobre el hardware del dispositivo.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Una caracterÃ­stica de los sistemas UNIX es que todos los dispositivos de E/S se representa como un archivo en el sistema de archivos.
Esto se puede comprobar rÃ¡pidamente visitando el directorio <code>/dev</code> en cualquier sistema GNU/Linux o UNIX BSD, ya que es allÃ­ donde suelen estar.</p>
</div>
<div class="paragraph">
<p>AsÃ­ no hace falta diseÃ±ar y aprender una interfaz diferente para cada tipo de dispositivo.
Los procesos que quiere utilizar cualquier dispositivo de E/S solo tienen que usar las mismas funciones y llamadas al sistema que emplean para manipular los archivos normales.
Por ejemplo, <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a>, <a href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a>, <a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a> o <a href="https://man7.org/linux/man-pages/man2/close.2.html">close()</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_buffering">4.3.1. Buffering</h4>
<div class="paragraph">
<p>El <strong>buffering</strong> o uso de memoria intermedia es una estrategia en la que se almacenan los datos de manera temporal en una zona de la memoria, llamada bÃºfer.</p>
</div>
<div class="paragraph">
<p>Consiste en que el controlador indica a un dispositivo que escriba los bloques de datos solicitados en un bÃºfer.
Cuando la escritura del bÃºfer se ha completado, se transfiere su contenido al proceso que hizo la solicitud para que procese los datos.
Mientras lo hace, el controlador indica al dispositivo que copie nuevos datos en el bÃºfer.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, al grabar sonido del dispositivo de sonido del sistema no se entregan las muestras una a una al proceso.
En su lugar se graban varios miles de muestras que se escriben en un bÃºfer.
Cuando el bÃºfer estÃ¡ lleno, se transfieren todas las muestras al proceso de una sola vez y se siguen grabando muestras en el bÃºfer.</p>
</div>
<div class="paragraph">
<p>Lo mismo ocurre al reproducir sonido.
El proceso no entrega las muestras de sonido de una en una al dispositivo, sino que empaqueta varias miles que se copian al bÃºfer de una sola vez.
Entonces el controlador indica al dispositivo que lea las muestras desde ese bÃºfer segÃºn lo vaya necesitando.</p>
</div>
</div>
<div class="sect3">
<h4 id="_caching">4.3.2. Caching</h4>
<div class="paragraph">
<p>En el <strong>caching</strong> el sistema mantiene en la memoria principal una copia de datos  leÃ­dos o escritos recientemente en los dispositivos de E/S del sistema âpor ejemplo, en los discos duros o en las memorias USBâ.
Esto mejora la eficiencia del sistema si accede con frecuencia a los mismos datos, puesto que el acceso a la memoria principal es mÃ¡s rÃ¡pido que el acceso a los dispositivos de E/S.
La memoria principal es de tamaÃ±o limitado, por lo que sÃ³lo se mantiene copia de los datos utilizados con mayor frecuencia.</p>
</div>
</div>
<div class="sect3">
<h4 id="_spooling">4.3.3. Spooling</h4>
<div class="paragraph">
<p>El <strong>spooling</strong> se utiliza en dispositivos que no admiten el acceso simultÃ¡neo de varias aplicaciones a vez, como es el caso de impresoras y unidades de cinta.</p>
</div>
<div class="paragraph">
<p>Cuando varias aplicaciones intentan enviar un trabajo a una impresora, el sistema operativo lo intercepta para copiar los datos enviados a un archivo independiente.
Cuando una aplicaciÃ³n termina de enviar el trabajo, el archivo correspondiente se mete en una cola de donde son extraÃ­dos los trabajos para su impresiÃ³n de uno en uno.
AsÃ­ no hay acceso simultÃ¡neo al dispositivo por parte de varios procesos, mientras que Ã©stos pueden entregar el trabajo y continuar con su trabajo sin esperar a que la impresora estÃ© disponible.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gestiÃ³n_del_almacenamiento_secundario">4.4. GestiÃ³n del almacenamiento secundario</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Dentro de los dispositivos de E/S, los dedicados al almacenamiento secundario âcomo discos duros, memorias USB o lectores de DVD-ROMâ merecen un tratamiento especial.</p>
</div>
<div class="paragraph">
<p>Los programas que se desean ejecutar deben estar en la memoria principal âo almacenamiento primarioâ pero Ã©sta es demasiado pequeÃ±a para alojar todos los datos y todos los programas del sistema.
AdemÃ¡s, incluso aunque pudiera ser asÃ­, los datos almacenados en la memoria principal se perderÃ­an en caso de que ocurriera un fallo de alimentaciÃ³n.
Por eso los ordenadores disponen de un almacenamiento secundario para guardar datos de forma masiva y permanente.</p>
</div>
<div class="paragraph">
<p>El gestor del almacenamiento secundario utiliza el sistema de E/S para acceder a los dispositivos y ofrecer al sistema servicios mÃ¡s complejos.</p>
</div>
<div class="sect3">
<h4 id="_responsabilidades_de_la_gestiÃ³n_del_almacenamiento_secundario">4.4.1. Responsabilidades de la gestiÃ³n del almacenamiento secundario</h4>
<div class="paragraph">
<p>El gestor del almacenamiento secundario es el responsable de:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Gestionar el espacio libre en discos duros y resto de dispositivos de almacenamiento secundario.</p>
</li>
<li>
<p>Asignar el espacio de almacenamiento.</p>
</li>
<li>
<p>Planificar el acceso a los dispositivos, de tal forma que se ordenen las operaciones de forma eficiente.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gestiÃ³n_del_sistema_de_archivos">4.5. GestiÃ³n del sistema de archivos</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Los ordenadores pueden almacenar informaciÃ³n en diferentes tipos de medios fÃ­sicos âpor ejemplo en discos duros magnÃ©ticos, CD/DVD-ROM, memorias USB o SSDâ cada uno de los cuales tiene caracterÃ­sticas propias.
El acceso a cada tipo de medio es controlado por un dispositivo âpor ejemplo el controlador de disco o la unidad de DVD-ROMâ que tambiÃ©n tiene caracterÃ­sticas propias.
El sistema de E/S y la gestiÃ³n del almacenamiento secundario simplifican el acceso a estos dispositivos, pero no lo suficiente como para que sea cÃ³modo usarlos constantemente en cualquier programa.</p>
</div>
<div class="paragraph">
<p>Para simplificar aun mÃ¡s el acceso al almacenamiento, el sistema operativo proporciona una visiÃ³n lÃ³gica uniforme de todos los sistemas de almacenamiento.
Es decir, abstrae las propiedades fÃ­sicas de los dispositivos de almacenamiento para definir el <strong>archivo</strong>, una unidad de almacenamiento lÃ³gico con la que trabajan los procesos para guardar y recuperar datos.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Un <strong>archivo</strong> o <strong>fichero</strong> es una colecciÃ³n de datos relacionados, identificados por un nombre, que es tratada por el sistema operativo como una unidad de informaciÃ³n en el almacenamiento secundario âpor ejemplo un programa, una imagen o un documentoâ.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Los archivos normalmente se organizan en directorios para facilitar su uso y organizaciÃ³n.</p>
</div>
<div class="sect3">
<h4 id="_responsabilidades_de_la_gestiÃ³n_del_sistema_de_archivos">4.5.1. Responsabilidades de la gestiÃ³n del sistema de archivos</h4>
<div class="paragraph">
<p>El sistema de archivos utiliza al gestor del almacenamiento secundario y al sistema de E/S y es responsable de las siguientes actividades:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Crear y borrar archivos.</p>
</li>
<li>
<p>Crear y borrar directorios para organizar los archivos.</p>
</li>
<li>
<p>Soportar operaciones bÃ¡sicas para la manipulaciÃ³n de archivos y directorios: lectura y escritura de datos, cambio de nombre, cambio de permisos, etc.</p>
</li>
<li>
<p>Mapear en memoria archivos del almacenamiento secundario.</p>
</li>
<li>
<p>Hacer copias de seguridad de los archivos en sistemas de almacenamiento estables y seguros.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gestiÃ³n_de_red">4.6. GestiÃ³n de red</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El componente de red se responsabiliza de la comunicaciÃ³n con otros sistemas interconectados mediante una red de ordenadores âpor ejemplo, en Internet o en la red de Ã¡rea local de una oficinaâ.</p>
</div>
</div>
<div class="sect2">
<h3 id="_protecciÃ³n_y_seguridad">4.7. ProtecciÃ³n y seguridad</h3>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><strong>ProtecciÃ³n</strong> es cualquier mecanismo para controlar el acceso de los procesos y usuarios a los recursos definidos por el sistema.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Son mecanismos necesarios cuando un sistema informÃ¡tico tiene mÃºltiples usuarios y permite la ejecuciÃ³n concurrente de varios procesos, pues asÃ­ sÃ³lo pueden utilizar los recursos aquellos procesos que hayan obtenido la autorizaciÃ³n del sistema operativo.</p>
</li>
<li>
<p>Permite mejorar la fiabilidad, al permitir detectar los elementos del sistema que no operan correctamente.
Un recurso desprotegido no puede defenderse contra el uso âo mal usoâ de un usuario no autorizado o incompetente.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Ejemplos tÃ­picos de mecanismos de protecciÃ³n son el hardware de direccionamiento de memoria, que se utiliza para que los procesos se ejecuten en su propio espacio de direcciones, y el temporizador, que garantiza que ningÃºn proceso toma el control de la CPU por tiempo indefinido.
AdemÃ¡s, los registros de los dispositivos de E/S suelen estar protegidos del acceso directo de los usuarios, lo que protege la integridad de los dispositivos.
Mientras que en algunos sistemas se pueden establecer permisos sobre los archivos para garantizar que sÃ³lo los procesos con la debida autorizaciÃ³n tengan acceso.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Un sistema puede tener la protecciÃ³n adecuada pero estar expuesto a fallos y permitir accesos inapropiados.
Por eso es necesario disponer de mecanismos de <strong>seguridad</strong> que se encarguen de defender el sistema frente a ataques internos y externos.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Eso incluye a virus y gusanos, ataques de <a href="https://es.wikipedia.org/wiki/Ataque_de_denegaci%C3%B3n_de_servicio">denegaciÃ³n de servicio</a>, robo de identidad y uso no autorizado del sistema, entre muchos otros tipos de ataque.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_servicios_del_sistema">5. Servicios del sistema</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>5 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Un sistema operativo proporciona un entorno para la ejecuciÃ³n de programas.
Ese entorno debe proporcionar ciertos servicios a los programas y a los usuarios de esos programas.
Estos servicios son proporcionados gracias al funcionamiento coordinado de los diferentes componentes del sistema.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="C05-servicios/media/organizaciÃ³n_sistema.svg" alt="organizaciÃ³n sistema">
</div>
<div class="title">Figura 17. Diagrama general de organizaciÃ³n de los sistemas operativos.</div>
</div>
<div class="paragraph">
<p>Aunque cada sistema operativo proporciona servicios diferentes, es posible identificar unas pocas clases comunes.</p>
</div>
<div class="sect2">
<h3 id="_servicios_que_garantizan_el_funcionamiento_eficiente_del_sistema">5.1. Servicios que garantizan el funcionamiento eficiente del sistema</h3>
<div class="ulist">
<ul>
<li>
<p><strong>AsignaciÃ³n de recursos</strong>.
Cuando hay mÃºltiples usuarios o mÃºltiples trabajos ejecutÃ¡ndose los recursos deben ser asignados a cada uno de ellos.</p>
<div class="paragraph">
<p>Ejemplos de estos recursos son la CPU âasignada por el planificador de la CPU del gestor de procesosâ la memoria principal âasignada por el gestor de memoriaâ y el almacenamiento de archivos âasignada por el sistema de archivos y el gestor del almacenamiento secundarioâ.
Esta asignaciÃ³n debe hacerse con el fin de garantizar la mÃ¡xima eficacia del sistema.</p>
</div>
</li>
<li>
<p><strong>MonitorizaciÃ³n</strong>.
Es normal querer hacer seguimiento de los recursos que los usuarios usan y en quÃ© cantidad.
Esto puede ser Ãºtil para facturar a los usuarios por el uso de los recursos âpor ejemplo, facturar por el tiempo de CPUâ para configurar el sistema mejorando el rendimiento o para limitar cuÃ¡nto de cada recurso puede usar cada usuario como mÃ¡ximo.</p>
</li>
<li>
<p><strong>ProtecciÃ³n y seguridad</strong>.
ProtecciÃ³n implica asegurar que el acceso a los recursos del sistema
estÃ¡ controlado.
Por ejemplo, que la informaciÃ³n almacenada en un sistema multiusuario sÃ³lo puede ser accedida por su propietario o que un proceso no pueda interferir con otro o con el sistema operativo.
La seguridad del sistema respecto a los agentes exteriores tambiÃ©n es
importante.
Empieza obligando a los usuarios a autenticarse en Ã©l para obtener acceso a los recursos del mismo, pero incluye defender de intentos de acceso invÃ¡lidos a travÃ©s de la red.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_servicios_Ãºtiles_para_el_usuario">5.2. Servicios Ãºtiles para el usuario</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Interfaz de usuario</strong>. Los sistemas operativos diseÃ±ados para que los usuarios interactÃºen con ellos deben proporcionar una interfaz de usuario adecuada, que puede ser diferente formas segÃºn le propÃ³sito del sistema.</p>
</li>
<li>
<p><strong>Operaciones de E/S</strong>. Un programa puede necesitar realizar operaciones de E/S que pueden
involucrar a archivos o a dispositivos de E/S.
Por eficiencia y protecciÃ³n un usuario, normalmente los procesos no puede tener acceso directo a los dispositivos; por lo que el sistema operativo debe proporcionar medios para solicitar estas operaciones a los componentes correspondientes del sistema operativo.</p>
</li>
<li>
<p><strong>ManipulaciÃ³n de sistemas de archivos</strong>. Los programas necesitan leer y escribir archivos y
directorios, crearlos y borrarlos por nombre, buscar un archivo dado y listar informaciÃ³n
acerca del mismo.</p>
</li>
<li>
<p><strong>Comunicaciones</strong>. Los procesos necesitan poder intercambiar informaciÃ³n entre ellos, tanto si
se ejecutan en el mismo ordenador, como en diferentes equipos unidos por una red.</p>
</li>
<li>
<p><strong>DetecciÃ³n de errores</strong>. El sistema operativo necesita tener conocimiento de los posibles errores y para cada tipo de error debe tomar la acciÃ³n apropiada para asegurar una computaciÃ³n consiste y segura.
Por ejemplo, pueden haber errores del hardware âcomo fallos de energÃ­a o errores en la
memoriaâ en la E/S âcomo errores de paridad o falta de papel en la impresoraâ y en los
programas de usuario âcomo desbordamientos aritmÃ©ticos o accesos ilegales a la memoriaâ.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_interfaz_de_usuario">5.3. Interfaz de usuario</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>La <strong>interfaz de usuario</strong> es un servicio fundamental para todos los sistemas diseÃ±ados para que los usuarios interactÃºen con ellos directamente, por lo que nos vamos a detener un poco mÃ¡s en Ã©l.</p>
</div>
<div class="paragraph">
<p>Las interfaces de usuario pueden ser de diferentes tipos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Interfaz de lÃ­nea de comandos</strong> o <strong>intÃ©rprete de comandos</strong>, que permite que los usuarios introduzcan directamente los comandos que el sistema operativo debe ejecutar.
En algunos sistemas este tipo de interfaz se incluye dentro del nÃºcleo, pero en la mayor parte âcomo MS-DOS y UNIXâ se trata de un programa especial denominado <em>shell</em> que se ejecuta cuando un usuario inicia una sesiÃ³n.</p>
</li>
<li>
<p><strong>Interfaz de proceso por lotes</strong>, en la que los comandos y directivas para controlar dichos comandos se listan en archivos que posteriormente pueden ser ejecutados.
Este tipo de interfaz es la utilizada en sistemas no interactivos, como los antiguos sistemas de procesamiento por lotes y los sistemas multiprogramados.</p>
<div class="paragraph">
<p>TambiÃ©n suele estar disponible en los sistemas de tiempo compartido y en los sistemas de escritorio modernos, junto con algÃºn otro tipo de interfaz de usuario.
Por ejemplo, la <em>shell</em> de los sistemas UNIX permite indicar comandos uno a uno âde forma interactivaâ pero tambiÃ©n permite usar <em>scripts</em> âun archivo con una lista de Ã³rdenes para que se ejecuten automÃ¡ticamente de principio a finâ.</p>
</div>
</li>
<li>
<p><strong>Interfaz grÃ¡fica de usuario</strong> o <strong>GUI</strong> (<em>Graphical User Interface</em>) que permite a los usuarios utilizar un sistema de ventanas y menÃºs controlable mediante el ratÃ³n.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Puesto que la interfaz de usuario puede variar de un sistema a otro, y de un usuario a otro dentro del mismo sistema, no se suele etiquetar como un componente bÃ¡sico del sistema operativo, sino como un servicio ofrecido por el sistema operativo.</p>
</div>
<div class="paragraph">
<p>A parte de la interfaz de usuario, cualquier sistema operativo moderno incluye una colecciÃ³n de <strong>programas del sistema</strong>.
El papel de estos programas del sistema es proporcionar un entorno conveniente para la ejecuciÃ³n y desarrollo de programas.
Entre los programas del sistema se suelen incluir aplicaciones para manipular archivos y directorios, programas para obtener informaciÃ³n sobre el estado del sistema âcomo la fecha y hora o la memoria y el espacio en disco disponibleâ herramientas de desarrollo âcomo intÃ©rpretes, compiladores, enlazadores y depuradoresâ programas de comunicaciones âcomo clientes de correo electrÃ³nico y navegadores webâ etc.</p>
</div>
<div class="paragraph">
<p>AdemÃ¡s, muchos sistemas operativos disponen de programas que son Ãºtiles para resolver los problemas mÃ¡s comunes de los usuarios.
Entre estos programas se suelen incluir: editores de archivos de texto y procesadores de texto, hojas de cÃ¡lculo, sistemas de base de datos, juegos, etc.
Ha esta colecciÃ³n de aplicaciones se la suele conocer con el tÃ©rmino de <strong>utilidades del sistema</strong> o <strong>programas de aplicaciÃ³n</strong>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_interfaz_de_programaciÃ³n_de_aplicaciones">6. Interfaz de programaciÃ³n de aplicaciones</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>15 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Un sistema operativo proporciona un entorno controlado para la ejecuciÃ³n de programas.
Dicho entorno debe proporcionar ciertos servicios que pueden ser accedidos por los programas a travÃ©s de una <strong>interfaz de programaciÃ³n de aplicaciones</strong> o <strong>API</strong> (<em>Application Programming Interface</em>).</p>
</div>
<div class="sect2">
<h3 id="_interfaces_de_programaciÃ³n_de_aplicaciones">6.1. Interfaces de programaciÃ³n de aplicaciones</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Algunas de las API disponibles para los desarrolladores de aplicaciones son Windows API y POSIX.</p>
</div>
<div class="sect3">
<h4 id="_windows_api">6.1.1. Windows API</h4>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/Win32_API">Windows API</a> es el nombre que recibe la <strong>interfaz de programaciÃ³n de aplicaciones</strong> de Microsoft Windows, con la que prÃ¡cticamente tienen que interactuar todas las aplicaciones, de una forma u otra.</p>
</div>
<div class="paragraph">
<p>Antiguamente se denominaba Win32 API, pero Microsoft ha querido aglutinar bajo una misma denominaciÃ³n las distintas versiones de la API de Windows que han existido, como Win16 âusada en las versiones de 16 bits de Windowsâ o Win64 âque es la variante de Win32 adaptada a arquitecturas de 64 bitsâ.</p>
</div>
<div class="paragraph">
<p>EstÃ¡ compuesta por funciones en C almacenadas, principalmente, en las librerÃ­as de enlace dinÃ¡mico (<a href="https://es.wikipedia.org/wiki/Biblioteca_de_enlace_din%C3%A1mico">DLL</a>): <code>kernel32.dll</code>, <code>user32.dll</code> y <code>gdi32.dll</code>.
Aunque segÃºn se ha ido ampliando la API, se han incorporado otras librerÃ­as adicionales.</p>
</div>
<div class="paragraph">
<p>Provee un conjunto muy amplio de servicios: E/S a archivos y dispositivos, gestiÃ³n de procesos, hilos y memoria, manejo de errores, registro de Windows, interfaz a dispositivos grÃ¡ficos âpantallas e impresorasâ gestiÃ³n de ventanas, comunicaciones en red, etc.</p>
</div>
</div>
<div class="sect3">
<h4 id="_posix">6.1.2. POSIX</h4>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/POSIX">POSIX</a> (<em>Portable Operating System Interface for Unix</em>) es el nombre de una familia de estÃ¡ndares que definen una <strong>interfaz de programaciÃ³n de aplicaciones</strong> para sistemas operativos.
Esto permite que un mismo programa pueda ser ejecutado en distintos sistemas operativos, siempre que sean compatibles con POSIX.</p>
</div>
<div class="paragraph">
<p>El lenguaje C fue diseÃ±ado originalmente para implementar sistemas UNIX y por eso la librerÃ­a estÃ¡ndar de C tenÃ­a mucho parecido con la librerÃ­a del sistema de UNIX.
Con el tiempo, al ir aÃ±adiendo mÃ¡s funcionalidades, la librerÃ­a del sistema de los sistemas UNIX de los distintos fabricantes fue divergiendo, haciendo muy complicado desarrollar programas que usaran las caracterÃ­sticas mÃ¡s avanzadas y que a la vez pudieran ejecutarse en varios de ellos.
Por eso el <a href="https://es.wikipedia.org/wiki/Institute_of_Electrical_and_Electronics_Engineers">IEEE</a> desarrollo el estÃ¡ndar POSIX, que define una API comÃºn para todos los UNIX y sistemas estilo UNIX modernos âcomo es el caso de GNU/Linuxâ.
AsÃ­ que la prÃ¡ctica totalidad de estos sistemas son compatible POSIX.</p>
</div>
<div class="paragraph">
<p>Por su origen, la API POSIX es un superconjunto de la API de la librerÃ­a estÃ¡ndar de C.
Por eso en los sistemas POSIX, la librerÃ­a estÃ¡ndar de C es parte de la librerÃ­a del sistema, en lugar de dos librerÃ­as separadas.</p>
</div>
<div class="paragraph">
<p>Las funciones POSIX estÃ¡n almacenadas, principalmente, en la librerÃ­a <code>libc</code>.
Aunque algunas caracterÃ­sticas pueden estar en otras librerÃ­as, como <code>libm</code> âla librerÃ­a matemÃ¡ticaâ o <code>libpthread</code> âla librerÃ­a de hilosâ.</p>
</div>
<div class="paragraph">
<p>Los desarrolladores del sistema a veces aÃ±aden funciones no incluidas en el estÃ¡ndar POSIX, con el objeto de soportar algÃºn tipo de funcionalidad avanzada del sistema.
Antes de usarlas debemos tener presente que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Un programa que solo utilice la API POSIX podrÃ¡ ejecutarse en cualquier sistema operativo compatible POSIX.</p>
</li>
<li>
<p>Mientras que uno que utilice, por ejemplo, alguna funcionalidad adicional no POSIX de Linux o macOS, solo podrÃ¡ compilarse y ejecutarse en Linux o en macOS, segÃºn el caso.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_llamadas_al_sistema">6.2. Llamadas al sistema</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Para un programa, acceder a los servicios del sistema operativo no es tan sencillo como invocar una funciÃ³n.
Para invocar una funciÃ³n, un programa necesita conocer la direcciÃ³n en la memoria del punto de entrada de dicha funciÃ³n âes decir, la ubicaciÃ³n de su primera instrucciÃ³nâ.
Sin embargo, el cÃ³digo del nÃºcleo del sistema puede estar en cualquier ubicaciÃ³n de la memoria principal.
AsÃ­ que las direcciones de los puntos de entrada a las funciones del nÃºcleo son desconocidas.
AdemÃ¡s, generalmente, el cÃ³digo y los datos del nÃºcleo estÃ¡n protegidos frente a accesos indebidos (vÃ©ase el <a href="#_protecciÃ³n_de_la_memoria">Apartado 7.3</a>).
Eso significa que para que un proceso pueda invocar los servicios que necesita hace falta un procedimiento diferente, denominado <strong>llamada al sistema</strong>.</p>
</div>
<div class="sect3">
<h4 id="_invocar_llamadas_al_sistema">6.2.1. Invocar llamadas al sistema</h4>
<div class="paragraph">
<p>Generalmente una llamada al sistema se invoca mediante una instrucciÃ³n especÃ­fica en lenguaje ensamblador que genera una <strong>excepciÃ³n</strong> âque no es mÃ¡s que una interrupciÃ³n lanzada por la propia CPU al detectar instrucciones especiales o un error al ejecutar una instrucciÃ³n, como una divisiÃ³n por 0 o un acceso indebido a ciertas zonas de la memoriaâ.
Por ejemplo, en MIPS e Intel x86 se usa la instrucciÃ³n <code>syscall</code>, que lanza un excepciÃ³n, haciendo que la CPU salte a una rutina en el cÃ³digo del nÃºcleo del sistema, deteniendo asÃ­ la ejecuciÃ³n del proceso que la invocÃ³.</p>
</div>
<div class="paragraph">
<p>Al realizar una llamada, es necesario que el sistema sepa quÃ© operaciÃ³n le estÃ¡ pidiendo el proceso.
Esto se suele hacer poniendo un nÃºmero identificativo de la llamada en un registro concreto de la CPU.
Por ejemplo, en Linux para x86 la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a> âque se utiliza para abrir archivosâ se identifica con el nÃºmero 2 o con el 5, segÃºn si es en 64 o en 32 bits, respectivamente.
Este nÃºmero se debe guardar en el registro <code>v0</code> en MIPS o <code>eax</code> en x86, antes de la instrucciÃ³n <code>syscall</code>.</p>
</div>
<div class="paragraph">
<p>Los nÃºmeros utilizados para identificar cada llamada al sistema dependen del sistema operativo.
Mientras que el registro donde se guarda, la instrucciÃ³n utilizada y el resto de detalles sobre cÃ³mo realizar la llamada, dependen tambiÃ©n de la arquitectura de la CPU.</p>
</div>
</div>
<div class="sect3">
<h4 id="_paso_de_argumentos">6.2.2. Paso de argumentos</h4>
<div class="paragraph">
<p>Obviamente una llamada al sistema suele requerir mÃ¡s informaciÃ³n que la identidad de la llamada.
Si, por ejemplo, se quiere abrir un archivo, al menos es necesario indicar su nombre, asÃ­ como si se abre para leer o para escribir.</p>
</div>
<div class="paragraph">
<p>En concreto hay tres mÃ©todos para pasar parÃ¡metros adicionales al identificador a una llamada al sistema:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Mediante registros de la CPU</strong>.
Consiste en cargar los parÃ¡metros de la llamada al sistema en los registros de la CPU antes de realizar la llamada al sistema.
Este mÃ©todo es el mÃ¡s eficiente, pero limita el nÃºmero de parÃ¡metros al nÃºmero de registros disponibles.</p>
<div class="paragraph">
<p>Es utilizado, por ejemplo, en Linux para MIPS (vÃ©ase el <a href="#linux_mips_syscall">Ejemplo 1</a>) y en la mayorÃ­a de sistemas operativos para x86-64.</p>
</div>
</li>
<li>
<p><strong>Mediante tabla en memoria</strong>
Consiste en copiar los parÃ¡metros de la llamada al sistema en una tabla en la memoria principal y luego guardar la direcciÃ³n de dicha tabla en un registro especÃ­fico de la CPU, antes de la llamada al sistema.
AsÃ­ no se limita el nÃºmero de parÃ¡metros que pueden ser pasados en cada llamada al sistema.</p>
<div class="paragraph">
<p>Era utilizado por Microsoft Windows 2000 y anteriores.
TambiÃ©n en Linux para x86 32 bits, cuando el nÃºmero de parÃ¡metros es superior a 6.</p>
</div>
</li>
<li>
<p><strong>Mediante la pila del proceso</strong> se insertan los parÃ¡metros de la llamada al sistema en la pila del proceso âque tambiÃ©n se suele usar para guardar variables locales y, en algunas arquitecturas, los argumentos pasados al llamar a funcionesâ y el sistema operativo los recupera de allÃ­ durante la llamada al sistema.
Al igual que en el caso anterior, tampoco limita el nÃºmero de parÃ¡metros que pueden ser pasados en cada llamada al sistema.</p>
<div class="paragraph">
<p>Es utilizado, por ejemplo, en sistemas UNIX BSD y en Windows XP y posteriores para x86 de 32 bits.</p>
</div>
</li>
</ul>
</div>
<div id="linux_mips_syscall" class="exampleblock">
<div class="title">Ejemplo 1. Llamada al sistema en Linux MIPS.</div>
<div class="content">
<div class="paragraph">
<p>Veamos como invocar directamente la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a> en Linux para MIPS.</p>
</div>
<div class="paragraph">
<p>Esta llamada sirve para escribir datos en un archivo.
AsÃ­ que necesita tres argumentos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>SIZE</strong>: El nÃºmero de bytes a escribir.</p>
</li>
<li>
<p><strong>BUFFER</strong>: La direcciÃ³n de la memoria de la que coger los bytes.</p>
</li>
<li>
<p><strong>FILEDES</strong>: El descriptor que identifica a un archivo abierto donde se van a escribir los datos.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Al terminar devuelve el nÃºmero de bytes escritos en el archivo, que puede ser inferior a <code>SIZE</code>.</p>
</div>
<div class="paragraph">
<p>El identificador de la llamada al sistema es 4004, segÃºn el <a href="https://git.linux-mips.org/cgit/ralf/linux.git/tree/arch/mips/include/uapi/asm/unistd.h">listado de llamadas al sistema</a> para Linux en MIPS.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>  lw      $a0, FILEDES   <i class="conum" data-value="1"></i><b>(1)</b>
  la      $a1, BUFFER    <i class="conum" data-value="1"></i><b>(1)</b>
  lw      $a2, SIZE      <i class="conum" data-value="1"></i><b>(1)</b>
  li      $v0, 40004     <i class="conum" data-value="2"></i><b>(2)</b>
  syscall                <i class="conum" data-value="3"></i><b>(3)</b> <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Cargar cada uno de los 3 argumentos de la llamada al sistema en los registros <code>a0</code>, <code>a1</code> y <code>a2</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Cargar el identificador de la llamada <code>write()</code> en el registro <code>v0</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Invocar la llamada al sistema.
Aunque vemos que es una Ãºnica instrucciÃ³n, lo que realmente va a ocurrir es que el sistema operativo va a tomar el control de la CPU para realizar la tarea solicitada.
La siguiente instrucciÃ³n no comenzarÃ¡ a ejecutarse hasta que el sistema operativo no lo decida, por lo que, desde el punto de vista del programa, va a ser como si <code>syscall</code> fuera una instrucciÃ³n mÃ¡s lenta de lo normal.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Al ejecutar la siguiente instrucciÃ³n del cÃ³digo del programa, el registro <code>v0</code> contendrÃ¡ el nÃºmero de bytes escritos.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap06/syscall.s">syscalls.s</a> se puede ver un ejemplo completo similar, pero para Linux x86 de 64 bits.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>En cualquier caso, sea cual sea el mÃ©todo utilizado, el sistema operativo es responsable de comprobar de manera estricta la validez de los parÃ¡metros enviados en la llamada al sistema antes de realizar cualquier operaciÃ³n, puesto que nunca debe confiar en que los procesos hagan su trabajo correctamente.
A fin de cuentas, una de las funciones del sistema operativo es el control de dichos procesos.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_librerÃ­a_del_sistema">6.3. LibrerÃ­a del sistema</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Las <strong>llamadas al sistema</strong> proporcionan una interfaz con la que los procesos pueden invocar los servicios que el sistema operativo ofrece.
El problema es que como se hacen mediante instrucciones en lenguaje ensamblador (vÃ©ase el <a href="#linux_mips_syscall">Ejemplo 1</a>) no son demasiado cÃ³modas de utilizar.
AsÃ­ que generalmente los programas no las invocan directamente.
En su lugar, lo que hacen es llamar a funciones de la <strong>librerÃ­a del sistema</strong>, que a su vez son las encargadas de hacer las llamadas al sistema necesarias.</p>
</div>
<div class="paragraph">
<p>Cuando hablamos anteriormente de <a href="https://es.wikipedia.org/wiki/Win32_API">Windows API</a> y del estÃ¡ndar <a href="https://es.wikipedia.org/wiki/POSIX">POSIX</a>, hablÃ¡bamos de la interfaz de la <strong>librerÃ­a del sistema</strong> en esos sistemas operativos.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>La <strong>librerÃ­a del sistema</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Es parte del sistema operativo, por lo que se distribuye con Ã©l.</p>
</li>
<li>
<p>Es una colecciÃ³n de clases o funciones que ofrecen los servicios del sistema operativo a los programas, apoyÃ¡ndose en las llamadas al sistema.</p>
<div class="paragraph">
<p>Algunas funciones de la librerÃ­a del sistema son traducciones literales de llamadas al sistema âpor ejemplo, <a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a> o <a href="https://man7.org/linux/man-pages/man2/close.2.html">close()</a>â mientras que otras pueden ser mÃ¡s complejas, hacer mÃ¡s trabajo o mostrar conceptos mÃ¡s abstractos que los usados por el sistema operativo al nivel de llamadas al sistema.</p>
</div>
</li>
<li>
<p>Constituye la verdadera <strong>interfaz de programaciÃ³n de aplicaciones</strong> del sistema operativo.
Es la forma recomendada de solicitar servicios al sistema operativo.
Invocar directamente las llamadas al sistema debe ser el Ãºltimo recurso.</p>
</li>
<li>
<p>Sus funciones se llaman como cualquier otra.
Al igual que el resto de librerÃ­as, se carga dentro de la regiÃ³n de memoria asignada al proceso.
Por lo tanto, la invocaciÃ³n de las funciones de la librerÃ­a del sistema se realiza como si fueran cualquier otra funciÃ³n del programa.</p>
</li>
<li>
<p>Es muy comÃºn que estÃ© implementada en C, lo que permite que tanto los programas en C como en C&#43;&#43; la puedan utilizar directamente.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_librerÃ­a_estÃ¡ndar">6.4. LibrerÃ­a estÃ¡ndar</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Lenguajes distintos de C y C&#43;&#43; pueden tener difÃ­cil usar las funciones de la librerÃ­a del sistema.
Pero de alguna forma deben poder hacerlo, porque sus programadores necesitan acceso a los servicios que ofrece el sistema operativo.</p>
</div>
<div class="paragraph">
<p>Incluso en C y en C&#43;&#43; puede ser interesante tener acceso a funcionalidades adicionales a las ofrecidas por la API del sistema operativo: estructuras de datos, algoritmos de ordenamiento o bÃºsqueda, funciones para manipular cadenas, funciones matemÃ¡ticas, etc.
TambiÃ©n abstracciones de los servicios del sistema, que encajen mejor con las particularidades del lenguaje de programaciÃ³n en cuestiÃ³n.
Por ejemplo, utilizando clases y objetos en lenguajes que soportan programaciÃ³n orientada a objetos.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Por eso, junto a cada intÃ©rprete o compilador de cada lenguaje de programaciÃ³n suele ir una <strong>librerÃ­a estÃ¡ndar</strong> que ofrece clases o funciones con las que los programas pueden acceder a los servicios del sistema operativo y realizar las tareas mÃ¡s comunes de forma mÃ¡s sencilla.</p>
</div>
<div class="paragraph">
<p>Estas librerÃ­as generalmente no forman parte del sistema operativo, sino de las herramientas de desarrollo de cada lenguaje de programaciÃ³n, y constituyen la <strong>interfaz de programaciÃ³n de aplicaciones</strong> del lenguaje al que acompaÃ±an.</p>
</div>
<div class="paragraph">
<p>La <strong>librerÃ­a estÃ¡ndar</strong> necesita acceder a los servicios del sistema operativo para, a su vez, dar servicio a los programas que la usan.
Es decir, cuando un programa invoca alguna funciÃ³n o mÃ©todo de la librerÃ­a estÃ¡ndar que lo acompaÃ±a, es muy probable que Ã©sta necesite invocar uno o mÃ¡s servicios del sistema operativo para atender la peticiÃ³n convenientemente.
Para ello la <strong>librerÃ­a estÃ¡ndar</strong> utiliza la <strong>librerÃ­a del sistema</strong> que acompaÃ±a al sistema operativo, que a su vez realiza las <strong>llamadas al sistema</strong> necesarias.</p>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">De archivos a flujos</div>
<div class="paragraph">
<p>Un ejemplo del papel de las <strong>librerÃ­as estÃ¡ndar</strong> lo podemos encontrar en el acceso a los archivos.</p>
</div>
<div class="paragraph">
<p>Las llamadas al sistema y la librerÃ­a del sistema de los sistemas operativos ofrecen funciones bÃ¡sicas para manipular archivos.
Los archivos se abren indicando su ruta y, al hacerlo, el sistema operativo devuelve un identificador del archivo abierto (vÃ©ase <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a>).
Este identificador se puede usar para leer o escribir en bytes el contenido del archivo.</p>
</div>
<div class="paragraph">
<p>Si embargo en C, C&#43;&#43; y otros lenguajes, todo lo que son flujos de datos se generalizan en el concepto de flujo o <em>stream</em> (vÃ©ase <a href="https://en.cppreference.com/w/c/io">&lt;stdio.h&gt;</a> e <a href="https://en.cppreference.com/w/cpp/header/iostream">std::iostream</a>).
En Ã©l. se incluye la entrada de teclado y la salida por pantalla, la impresiÃ³n de documentos, las conexiones de red âpotencialmenteâ y, obviamente, el acceso a archivos y a dispositivos.</p>
</div>
<div class="paragraph">
<p>Los flujos pueden ser de texto o binarios, lo que implica algunas transformaciones en los datos.
AdemÃ¡s van ligados al concepto del <em>buffering</em>, es decir, que los bytes o caracteres escritos en el flujo no se Â«envÃ­anÂ» inmediatamente, sino que se acumulan en la memoria para ser enviados en bloque.</p>
</div>
<div class="paragraph">
<p>Todas estas caracterÃ­sticas adicionales las implementa la <strong>librerÃ­a estÃ¡ndar</strong>.
Pero por debajo, al final, los datos tiene que ser escritos en un archivo, una impresora o el monitor, recursos que gestiona el sistema operativo.
Por lo tanto, las <strong>librerÃ­as estÃ¡ndar</strong> necesitan hacer uso de la <strong>librerÃ­a del sistema</strong> para comunicarse con el sistema operativo.</p>
</div>
<hr>
<div class="paragraph">
<p>Algo que suele ocurrir al crear mayores abstracciones es que se suele perder control y caracterÃ­sticas especÃ­ficas.
Por ejemplo, la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a> con la que se pueden crear archivos permite asignar permisos o crear archivos temporales.
Sin embargo, con las interfaces de <em>streams</em> de C y C&#43;&#43; no se puede hacer eso, ya que los permisos y la temporalidad son propiedades de los archivos que no son comunes a todas fuentes de flujos de datos.</p>
</div>
<div class="paragraph">
<p>AsÃ­ que en ocasiones puede ser que nos resulte mÃ¡s Ãºtil llamar a las funciones de la <strong>librerÃ­a del sistema</strong>, que usar las facilidades de la <strong>librerÃ­a estÃ¡ndar</strong>.
Sin embargo, debemos valorar que asÃ­ perdemos portabilidad, ya que ahora nuestro programa ya no podrÃ¡ usarse allÃ­ donde haya un compilador o intÃ©rprete de nuestro lenguaje, sino solo en sistemas operativos con una <strong>librerÃ­a del sistema</strong> compatible.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_con_todas_las_piezas_juntas">6.5. Con todas las piezas juntas</h3>
<div class="paragraph">
<p>En la <a href="#api_win32">Figura 18</a> se ilustra el papel de todos los elementos comentados, con el ejemplo de programas en C y Python, ejecutados en Microsoft Windows, que invocan los mÃ©todos <a href="https://en.cppreference.com/w/c/io/fopen">fopen()</a> y <code>file()</code> de la librerÃ­a estÃ¡ndar de estos lenguajes, respectivamente.</p>
</div>
<div id="api_win32" class="imageblock">
<div class="content">
<img src="C06-api/media/interfaz_programaciÃ³n_aplicaciones_win32.svg" alt="interfaz programaciÃ³n aplicaciones win32">
</div>
<div class="title">Figura 18. Elementos de la interfaz de programaciÃ³n de aplicaciones en Microsoft Windows.</div>
</div>
<div class="paragraph">
<p>En ambos casos, la librerÃ­a estÃ¡ndar llama a la funciÃ³n <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile()</a> de la librerÃ­a del sistema de Windows, que finalmente realiza una llamada al sistema que hace que el sistema operativo tome el control, deteniendo la ejecuciÃ³n del proceso que la solicita.
Entonces se realiza la tarea solicitada mediante el funcionamiento coordinado de los diferentes componentes del sistema (vÃ©ase el <a href="#_componentes_del_sistema">CapÃ­tulo 4</a>).</p>
</div>
<div class="paragraph">
<p>El programa en C, puede usar tanto la funciÃ³n <a href="https://en.cppreference.com/w/c/io/fopen">fopen()</a> de su librerÃ­a estÃ¡ndar como llamar directamente a la funciÃ³n <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile()</a> de la librerÃ­a del sistema âmarcado en rojo en la <a href="#api_win32">Figura 18</a>â.
Sin embargo, en el programa en Python no tenemos esa facilidad âal menos directamenteâ.</p>
</div>
<div class="paragraph">
<p>Usar directamente las funciones de la librerÃ­a del sistema desde programas en C o C&#43;&#43; tiene la ventaja de que permite utilizar todas las caracterÃ­sticas del sistema operativo.
Por ejemplo, utilizar las opciones adicionales de <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile()</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">HANDLE</span> <span class="n">WINAPI</span> <span class="nf">CreateFile</span><span class="p">(</span>
  <span class="n">LPCTSTR</span> <span class="n">lpFileName</span><span class="p">,</span>                           <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="n">DWORD</span> <span class="n">dwDesiredAccess</span><span class="p">,</span>                        <i class="conum" data-value="2"></i><b>(2)</b>
  <span class="n">DWORD</span> <span class="n">dwShareMode</span><span class="p">,</span>                            <i class="conum" data-value="3"></i><b>(3)</b>
  <span class="n">LPSECURITY_ATTRIBUTES</span> <span class="n">lpSecurityAttributes</span><span class="p">,</span>   <i class="conum" data-value="4"></i><b>(4)</b>
  <span class="n">DWORD</span> <span class="n">dwCreationDisposition</span><span class="p">,</span>                  <i class="conum" data-value="5"></i><b>(5)</b>
  <span class="n">DWORD</span> <span class="n">dwFlagsAndAttributes</span><span class="p">,</span>                   <i class="conum" data-value="6"></i><b>(6)</b>
  <span class="n">HANDLE</span> <span class="n">hTemplateFile</span>                          <i class="conum" data-value="7"></i><b>(7)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Nombre del archivo.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Modo de acceso: lectura o escritura.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Modo en el que se compartirÃ¡ el archivo con otros procesos que accedan al mismo tiempo.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Permisos del archivo, en caso de crearlo.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>AcciÃ³n en caso de que el archivo exista o no: siempre crear, solo abrir, truncar si existe, etc.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Atributos del archivo, en caso de crearlo.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Archivo abierto del que copiar los atributos para copiarlo en Ã©ste,
en caso de crearlo.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>que <a href="https://en.cppreference.com/w/c/io/fopen">fopen()</a> no posee:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">FILE</span><span class="o">*</span> <span class="nf">fopen</span><span class="p">(</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mode</span>  <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Nombre del archivo.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Modo de acceso: lectura o escritura.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Sin embargo, debemos tener en cuenta que se pierde portabilidad pues <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile()</a> solo estÃ¡ disponible en Microsoft Window, mientras que <a href="https://en.cppreference.com/w/c/io/fopen">fopen()</a> viene con la librerÃ­a estÃ¡ndar de cualquier compilador de C.</p>
</div>
<div class="paragraph">
<p>En la <a href="#api_posix">Figura 19</a> se puede observar un ejemplo similar en <a href="https://es.wikipedia.org/wiki/GNU/Linux">GNU/Linux</a> âun sistema compatible <a href="https://es.wikipedia.org/wiki/POSIX">POSIX</a>â pero en esta ocasiÃ³n con programas en C y C&#43;&#43;.
En este caso la llamada al sistema es <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a> y tanto <a href="https://en.cppreference.com/w/c/io/fopen">fopen()</a> en C como <a href="https://en.cppreference.com/w/cpp/io/basic_ofstream/open">std::ofstream::open()</a> en C&#43;&#43; la utilizan.
AdemÃ¡s, ambos lenguajes pueden invocar directamente la librerÃ­a del sistema âmarcado en rojo en la <a href="#api_posix">Figura 19</a>â si necesitan alguna caracterÃ­stica adicional de la funciÃ³n <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a>.</p>
</div>
<div id="api_posix" class="imageblock">
<div class="content">
<img src="C06-api/media/interfaz_programaciÃ³n_aplicaciones_posix.svg" alt="interfaz programaciÃ³n aplicaciones posix">
</div>
<div class="title">Figura 19. Elementos de la interfaz de programaciÃ³n de aplicaciones en GNU/Linux.</div>
</div>
<div class="paragraph">
<p>La Ãºnica diferencia es que en <a href="#api_posix">Figura 19</a> las funciones <a href="https://en.cppreference.com/w/c/io/fopen">fopen()</a> y <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a> estÃ¡n realmente en la misma librerÃ­a, porque en los sistemas POSIX la librerÃ­a del sistema y la librerÃ­a estÃ¡ndar de C pueden ser la misma, dado que el estÃ¡ndar POSIX se diseÃ±Ã³ como un superconjunto de la librerÃ­a estÃ¡ndar de C.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_operaciÃ³n_del_sistema_operativo">7. OperaciÃ³n del sistema operativo</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>17 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Dado que el sistema operativo y los procesos de usuarios comparten los recursos del sistema informÃ¡tico, necesitamos estar seguros de que un error en un programa sÃ³lo afecte al proceso que lo ejecuta âpor ejemplo, que un proceso no puede modificar la memoria de otro proceso o la del nÃºcleo del sistemaâ.
Por eso es necesario establecer mecanismos de protecciÃ³n frente a los errores en los programas que se ejecutan en el sistema.</p>
</div>
<div class="sect2">
<h3 id="_software_controlado_mediante_interrupciones">7.1. Software controlado mediante interrupciones</h3>
<div class="paragraph">
<p>Antes de entender como funcionan estos mecanismos de protecciÃ³n debemos entender que los sistemas operativos modernos pertenecen a un tipo de software que se dice que estÃ¡ controlado mediante interrupciones.</p>
</div>
<div class="paragraph">
<p>Los sucesos que requieren la atenciÃ³n del sistema casi siempre se indican mediante una interrupciÃ³n:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cuando un proceso comete un error âcomo una divisiÃ³n por cero o un acceso a memoria no vÃ¡lidoâ o un programa solicita un servicio al sistema operativo a travÃ©s de una llamada al sistema lo que se genera es una excepciÃ³n.
Esta excepciÃ³n despierta al sistema operativo para que haga lo que sea mÃ¡s conveniente.</p>
</li>
<li>
<p>Cuando un proceso necesita un servicio lo que hace es lanzar una llamada al sistema, que no es mÃ¡s que ejecutar una instrucciÃ³n que lanza una excepciÃ³n.
Esta excepciÃ³n despierta al sistema operativo para que atienda la peticiÃ³n.</p>
</li>
<li>
<p>Cuando los dispositivos de E/S requieren la atenciÃ³n del sistema operativo âpor ejemplo, porque se ha completado una transferencia de datosâ se genera una interrupciÃ³n que despierta al sistema operativo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Esto funciona asÃ­ porque el sistema operativo configura la CPU durante el arranque para que si ocurre cualquier interrupciÃ³n o excepciÃ³n la ejecuciÃ³n, salte a rutinas en el cÃ³digo del nÃºcleo, con el objeto de darles el tratamiento adecuado.</p>
</div>
<div class="paragraph">
<p>Si ningÃºn proceso realiza una acciÃ³n ilegal o pide un servicio, ni ningÃºn dispositivo de E/S pide la atenciÃ³n del sistema, el sistema operativo permanece inactivo esperado a que algo ocurra.</p>
</div>
<div class="paragraph">
<p>Teniendo todo esto en cuenta podremos entender mejor como funciona el modo dual.</p>
</div>
</div>
<div class="sect2">
<h3 id="_operaciÃ³n_en_modo_dual">7.2. OperaciÃ³n en modo dual</h3>
<div class="paragraph">
<p>Para proteger el sistema de programas con errores es necesario poder distinguir entre la ejecuciÃ³n de cÃ³digo del sistema operativo y del cÃ³digo de los programas de usuario, de tal forma que el cÃ³digo de los programas de usuario estÃ© mÃ¡s limitado en lo que puede hacer que el del sistema operativo.</p>
</div>
<div class="paragraph">
<p>El mÃ©todo que utilizan la mayor parte de los sistemas operativos consiste en utilizar algÃºn tipo de soporte en la CPU que permita diferenciar entre varios modos de ejecuciÃ³n y restringir la utilizaciÃ³n de las instrucciones peligrosas âllamadas <strong>instrucciones privilegiadas</strong>â para que sÃ³lo puedan ser utilizadas en el modo en el que se ejecuta el cÃ³digo del sistema operativo.</p>
</div>
<div class="sect3">
<h4 id="_modos_de_operaciÃ³n">7.2.1. Modos de operaciÃ³n</h4>
<div class="paragraph">
<p>AsÃ­ que como mÃ­nimo son necesarios dos modos de operaciÃ³n diferentes:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>En el <strong>modo usuario</strong>, en el que se ejecuta el cÃ³digo de los procesos de los usuarios.
Si se hace un intento de ejecutar una instrucciÃ³n privilegiada en este modo, el hardware la trata como ilegal y genera una excepciÃ³n que es interceptada por el sistema operativo, en lugar de ejecutar la instrucciÃ³n.</p>
</li>
<li>
<p>En el <strong>modo privilegiado</strong> âtambiÃ©n denominado <strong>modo supervisor</strong>, <strong>modo del sistema</strong> o <strong>modo kernel</strong>â se ejecuta el cÃ³digo de las tareas del sistema operativo.
La CPU es la encargada de garantizar que las instrucciones privilegiadas sÃ³lo pueden ser ejecutadas en este modo.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>El modo actual de operaciÃ³n puede venir indicado por un <strong>bit de modo</strong> en alguno de los registros de configuraciÃ³n de la CPU, de tal forma que, si por ejemplo, el bit estÃ¡ a 0, la CPU considera que el cÃ³digo en ejecuciÃ³n opera en modo privilegiado, mientras que si el bit estÃ¡ a 1, el cÃ³digo en ejecuciÃ³n opera en modo usuario.</p>
</div>
<div class="paragraph">
<p>ComÃºnmente en el grupo de las <strong>instrucciones privilegiadas</strong> se suelen incluir:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La instrucciÃ³n para conmutar al modo usuario desde el modo privilegiado.</p>
</li>
<li>
<p>Las instrucciones para acceder a dispositivos de E/S.</p>
</li>
<li>
<p>Las instrucciones necesarias para la gestiÃ³n de las interrupciones.
Por ejemplo, para desactivarlas âevitando que se lancenâ, activarlas y configurarlas.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Niveles de privilegio en procesadores x86</div>
<div class="paragraph">
<p>Aunque para operar en modo dual solo se necesita que la CPU admita los dos modos descritos, existen procesadores que soportan mÃ¡s, con la idea de tener mayor control sobre el nivel de privilegio en el que se ejecuta cada componente del sistema.</p>
</div>
<div class="paragraph">
<p>Es el caso de la arquitectura Intel x86, que soporta 4 modos de operaciÃ³n.
El modo 0 es para el software mÃ¡s confiable y el que necesita mÃ¡s privilegios, que generalmente es el nÃºcleo.
Mientras que el modo 3 se utiliza para el software menos confiable y que necesita mÃ¡s supervisiÃ³n, que normalmente son los procesos de usuario.</p>
</div>
<div class="paragraph">
<p>La idea detrÃ¡s de tener los modos 1 y 2 es usarlos para controladores de dispositivo o procesos que dan servicio al resto del sistema.
AsÃ­ estos componentes pueden tener mayores privilegios que los procesos de usuario âpor ejemplo, los controladores de dispositivo necesitan acceso directo al hardwareâ pero al mismo tiempo serÃ­an supervisados y no podrÃ­an afectar al nÃºcleo, que se ejecuta en el modo 0.</p>
</div>
<div class="paragraph">
<p>Sin embargo, los sistemas operativos con mayor cuota de mercado âincluyendo Microsoft Windows, macOS, Linux y Androidâ solo utilizan los modos 0 y 3.
Los motivos son que los desarrolladores de sistemas no encuentran realmente ninguna ventaja en utilizar mÃ¡s modos y que complica portar el sistema operativo a procesadores donde solo se soporten dos.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
En procesadores x86 recientes, que vienen con instrucciones especÃ­ficas para facilitar la ejecuciÃ³n de mÃ¡quinas virtuales, se ha incorporado un modo -1, para que el nÃºcleo del sistema operativo virtualizado se ejecute en el modo 0 mientras es supervisado desde el modo -1 por el nÃºcleo del sistema operativo anfitriÃ³n.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Para mÃ¡s informaciÃ³n, vÃ©ase <a href="https://es.wikipedia.org/wiki/Anillo_(seguridad_inform%C3%A1tica)">Â«Anillo (seguridad informÃ¡tica)&#8201;&#8212;&#8201;WikipediaÂ»</a>.</p>
</div>
<hr>
<div class="paragraph">
<p>En los procesadores x86 es importante no confundir los <strong>modos real</strong> y <strong>protegido</strong> con el modo dual y los niveles de privilegio de los que estamos hablando.</p>
</div>
<div class="paragraph">
<p>Por compatibilidad hacia atrÃ¡s, los procesadores x86 se inician en modo real, donde se comportan como una CPU <a href="https://es.wikipedia.org/wiki/Intel_8086_y_8088">Intel 8086</a>.
En este modo, por ejemplo, solo tienen acceso al primer mega de memoria RAM âya que los procesadores <a href="https://es.wikipedia.org/wiki/Intel_8086_y_8088">Intel 8086</a> solo tenÃ­an 20 bits para direcciones de memoriaâ.</p>
</div>
<div class="paragraph">
<p>Cuando un sistema operativo moderno arranca, lo primero que hace es iniciar el modo protegido, en el que se activan todas las caracterÃ­sticas de la CPU.
Entra otras, el direccionamiento de 32 o 64 bits âsegÃºn el procesador que seaâ y la posibilidad de usar los 4 niveles de privilegio, de los que hemos hablado, para que el nÃºcleo pueda supervisar al resto de componentes.</p>
</div>
<div class="paragraph">
<p>Para mÃ¡s informaciÃ³n, vÃ©ase <a href="https://es.wikipedia.org/wiki/Modo_protegido">Â«Modo protegido&#8201;&#8212;&#8201;WikipediaÂ»</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ejecuciÃ³n_de_instrucciones">7.2.2. EjecuciÃ³n de instrucciones</h4>
<div class="paragraph">
<p>A continuaciÃ³n podemos ver el ciclo de vida de la ejecuciÃ³n de instrucciones en un sistema con modo dual de operaciÃ³n:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Inicialmente, al arrancar el ordenador, la CPU se inicia en el modo privilegiado âes decir, en nuestro ejemplo, con el bit de modo a 0â.
En este modo se carga el nÃºcleo del sistema operativo e inicia su ejecuciÃ³n.</p>
</li>
<li>
<p>El nÃºcleo del sistema operativo debe cambiar al modo usuario âponiendo el bit de modo a 1â antes de ceder la CPU a un proceso de usuario.
Esto ocurre cuando es necesario que un proceso de usuario continÃºe o inicie su ejecuciÃ³n (vÃ©ase el <a href="#_el_asignador">Apartado 14.2</a>).
AsÃ­ se asegura que el cÃ³digo de los procesos de usuario siempre se ejecuten en modo usuario, con menos privilegios.</p>
</li>
<li>
<p>La CPU conmuta a modo privilegiado cuando ocurre una interrupciÃ³n o una excepciÃ³n âponiendo el bit de modo a 0â antes de comenzar el cÃ³digo del sistema operativo que se encargarÃ¡ de tratarlas.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>Esto Ãºltimo es muy importante.
Como ya hemos comentado, los sistemas operativos estÃ¡n controlados mediante interrupciones.
Al activarse el modo privilegiado cada vez que ocurre una interrupciÃ³n, podemos estar seguros de que las tareas del sistema operativo se ejecutarÃ¡n siempre en modo privilegiado.</p>
</div>
<div class="paragraph">
<p>Cuando se dispone de la protecciÃ³n del modo dual, el hardware se encarga de detectar los errores de ejecuciÃ³n y de notificarlo al sistema operativo mediante excepciones, siendo responsabilidad de este Ãºltimo realizar un tratamiento adecuado de los mismos.
Por lo general, si un programa falla de alguna forma âcomo por ejemplo, intentando utilizar una instrucciÃ³n ilegal o de acceder a una zona de memoria invÃ¡lidaâ el sistema operativo lo hace terminar.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_protecciÃ³n_de_la_memoria">7.3. ProtecciÃ³n de la memoria</h3>
<div class="paragraph">
<p>La memoria principal debe acomodar tanto el sistema operativo como a los diferentes procesos de los usuarios.
Por eso la memoria normalmente se divide en dos partes o espacios:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>La primera parte es el <strong>espacio del nÃºcleo</strong>.
Sirve para albergar el nÃºcleo del sistema operativo.</p>
<div class="paragraph">
<p>El sistema operativo puede estar localizado tanto en la parte baja como en la parte alta de la memoria.
El factor determinante en la elecciÃ³n es la localizaciÃ³n del vector de interrupciones, que es una tabla en la memoria que define las direcciones a las que saltarÃ¡ la CPU en caso de que ocurra una interrupciÃ³n o una excepciÃ³n.</p>
</div>
<div class="paragraph">
<p>Puesto que en la mayor parte de las arquitecturas Ã©ste reside en la parte baja de la memoria, normalmente el sistema operativo tambiÃ©n se aloja en la parte baja.</p>
</div>
</li>
<li>
<p>La segunda parte es el <strong>espacio de usuario</strong> y alberga los procesos de usuario.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Sin embargo, en los sistemas operativos modernos, los procesos no tienen acceso libre a toda memoria fÃ­sica, con el objeto de proteger a los procesos en ejecuciÃ³n y al sistema operativo de posibles errores en cualquiera de ellos:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>El sistema operativo proporciona a cada proceso una Â«vistaÂ» privada de la memoria RAM; de tal forma que el <strong>espacio de usuario</strong> que ve cada proceso es similar al que verÃ­a cada uno de ellos si se estuviera ejecutando en solitario (vÃ©ase la <a href="#protecciÃ³n_memoria">Figura 20</a>).</p>
</li>
<li>
<p>A esa Â«vistaÂ» que tiene cada proceso de la memoria es a lo que se denomina <strong>espacio de direcciones virtual</strong> del proceso.
EstÃ¡ formada por el conjunto de todas las direcciones que puede generar la CPU para un proceso dado.
Por ejemplo, en una CPU de 32 bits el espacio de direcciones virtual tiene 4 GiB, desde la direcciÃ³n 0x00000000 a 0xFFFFFFFF.</p>
</li>
<li>
<p>En los accesos a la memoria principal durante la ejecuciÃ³n del proceso, estas <strong>direcciones virtuales</strong> son convertidas por la CPU en direcciones fÃ­sicas, antes de ser enviadas a la memoria principal.
Por tanto las <strong>direcciones fÃ­sicas</strong> son las direcciones reales que ve la memoria.
Mientras que el <strong>espacio de direcciones fÃ­sico</strong> es el conjunto de direcciones fÃ­sicas que corresponden a todas las direcciones virtuales de un espacio de direcciones virtual dado.</p>
</li>
</ul>
</div>
</div>
</div>
<div id="protecciÃ³n_memoria" class="imageblock">
<div class="content">
<img src="C07-modo_dual/media/protecciÃ³n_memoria.svg" alt="protecciÃ³n memoria">
</div>
<div class="title">Figura 20. Mapeo de la memoria fÃ­sica en el espacio de direcciones virtual de un proceso.</div>
</div>
<div class="paragraph">
<p>La conversiÃ³n de una direcciÃ³n virtual en una fÃ­sica, la realiza en tiempo de ejecuciÃ³n un componente de la CPU denominado MMU (<em>Memory-Management Unit</em>).</p>
</div>
<div class="paragraph">
<p>Las ventajas de usar esta tÃ©cnica, desde el punto de vista de la protecciÃ³n de la memoria son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Permite el aislamiento de los procesos, creando para cada uno la ilusiÃ³n de que toda la memoria es para Ã©l y evitando que un proceso pueda acceder a la memoria de otros procesos.</p>
</li>
<li>
<p>Permite marcar modos de acceso autorizados en las diferentes regiones de la memoria âcomo por ejemplo lectura, escritura y ejecuciÃ³nâ evitando que el cÃ³digo ejecutado en modo usuario tenga acceso a zonas a las que no deberÃ­a tenerlo.
El acceso a la memoria en un modo no autorizado se considera una instrucciÃ³n privilegiada, por lo que ese tipo de acceso desde el modo usuario siempre genera una excepciÃ³n.
Por ejemplo, si se intenta ejecutar instrucciones en una zona de memoria no marcada con el permiso de ejecuciÃ³n.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_el_temporizador">7.4. El temporizador</h3>
<div class="paragraph">
<p>El <strong>temporizador</strong> se configura por el sistema operativo durante el arranque del sistema para interrumpir a la CPU a intervalos regulares.
AsÃ­, cuando el temporizador interrumpe, el control se transfiere automÃ¡ticamente al nÃºcleo del sistema.
Entonces Ã©ste puede:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Conceder mÃ¡s tiempo al proceso en ejecuciÃ³n.</p>
</li>
<li>
<p>Detenerlo y darle mÃ¡s tiempo de CPU en el futuro</p>
</li>
<li>
<p>Tratar la interrupciÃ³n como un error y terminar el programa.</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>El temporizador se utiliza para asegurar que ningÃºn proceso acapara la CPU indefinidamente.
Por ejemplo, un programa mal desarrollado que entra en un bucle infinito, del que no sale jamÃ¡s.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Obviamente, las instrucciones que pueden modificar el contenido del temporizador son instrucciones privilegiadas.</p>
</div>
</div>
<div class="sect2">
<h3 id="_maquinas_virtuales">7.5. Maquinas virtuales</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Utilizando las tÃ©cnicas comentadas anteriormente, el sistema operativo crea a los procesos la ilusiÃ³n de que se ejecutan en su propio procesador y memoria principal, aunque realmente los comparten.
Aun asÃ­, los procesos saben que hay un sistema operativo que los supervisa, porque le deben solicitar a Ã©l los distintos recursos a travÃ©s de las llamadas al sistema.</p>
</div>
<div class="paragraph">
<p>Una mÃ¡quina virtual tambiÃ©n es un proceso en un sistema operativo una mÃ¡quina real âtambiÃ©n llamado sistema operativo anfitriÃ³nâ.
Se utilizan la mismas tÃ©cnicas para crear la ilusiÃ³n de que se ejecuta en su propia mÃ¡quina.
Sin embargo, en lugar de llamadas al sistema, el software que gestiona la mÃ¡quina virtual ofrece una interfaz de hardware virtual.
Es decir:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>El sistema operativo de la mÃ¡quina virtual intenta acceder al hardware, ya que presupone que se ejecuta en una mÃ¡quina real.</p>
</li>
<li>
<p>El sistema operativo anfitriÃ³n intercepta estos intentos âya que son instrucciones privilegiadas, prohibidas para los procesos en el modo usuarioâ y, en lugar de detener el proceso, comunica el suceso al software de gestiÃ³n de la mÃ¡quina virtual.</p>
</li>
<li>
<p>El software de gestiÃ³n de la mÃ¡quina virtual identifica a quÃ© dispositivo y que intenta hacer el sistema operativo de la mÃ¡quina virtual en Ã©l âpara lo que generalmente se utilizan mÃ¡quinas de estado que simulan el comportamiento del hardware realâ y lo transforma en peticiones al sistema operativo anfitriÃ³n.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Por ejemplo, los intentos del sistema operativo virtual de acceder a los discos duros del hardware virtual, son convertidos en operaciones sobre un archivo, en un sistema de archivos real que contiene la imagen en disco de la mÃ¡quina virtual.</p>
</div>
</div>
<div class="sect2">
<h3 id="_arranque_del_sistema">7.6. Arranque del sistema</h3>
<div class="paragraph">
<p>Desde el momento en que el ordenador se pone en marcha hasta que el sistema operativo inicia
su ejecuciÃ³n se realizan una serie de operaciones.
Estos son los pasos mÃ¡s comunes en el arranque de un sistema:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Llega a la CPU una seÃ±al de RESET motivada por el encendido del sistema o por un reinicio.</p>
</li>
<li>
<p>La CPU inicializa el contador de programa a una direcciÃ³n predefinida de la memoria.
En esa direcciÃ³n estÃ¡ el <em>bootstrap</em> inicial.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>El <em>bootstrap</em> es el programa que se encarga en primera instancia del arranque.
Debe estar almacenado en una memoria no volÃ¡til âROM o Flashâ por que la RAM estÃ¡ en un estado indeterminado en el momento del arranque.</p>
</div>
<div class="paragraph">
<p>En los PC el <em>bootstrap</em> forma parte del <em>firmware</em> âsea BIOS o UEFIâ de las placas madres.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>El tÃ©rmino <em>firmware</em> viene de que por sus caracterÃ­sticas se sitÃºa en algÃºn lugar entre el hardware y el software.
Concretamente es un componente de software instalado en un dispositivo hardware para encargase de su control a bajo nivel.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_tareas_del_bootstrap">7.6.1. Tareas del bootstrap</h4>
<div class="paragraph">
<p>El <em>bootstrap</em> debe realizar diversas tareas:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Diagnostico de la mÃ¡quina</strong> âo <em>Power-on Self-Test</em> (POST)â.
El <em>bootstrap</em> se detiene en este punto si el sistema no supera el diagnostico.</p>
</li>
<li>
<p><strong>Inicializar el sistema</strong>.
Por ejemplo, configurar los registros de la CPU, inicializar los dispositivos y contenido de la memoria, etc.</p>
</li>
<li>
<p><strong>Iniciar el sistema operativo</strong>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Al iniciar el sistema operativo hay que considerar que puede estar en diferentes ubicaciones segÃºn el tipo de dispositivo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En <strong>consolas de videojuegos, mÃ³viles y otros dispositivos empotrados</strong> se almacena el sistema operativo en alguna forma de memoria de sÃ³lo lectura âROM o Flashâ.
Como la ejecuciÃ³n en esas memorias es mÃ¡s lenta que en la RAM, muchas veces el <em>bootstrap</em> suele copiar el sistema a la RAM durante el arranque, antes de iniciarlo.</p>
</li>
<li>
<p>En <strong>sistemas operativos de gran tamaÃ±o</strong> âincluidos los de propÃ³sito generalâ el sistema se almacena en disco.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>En los sistemas mas antiguos, el <em>bootstrap</em> lee de una posiciÃ³n fija del disco âgeneralmente el bloque 0â el gestor de arranque, lo copia en la memoria y lo ejecuta.
Esto es lo que ocurre en los PC mÃ¡s antiguos que utilizan BIOS y particiones MBR.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>TambiÃ©n se llama MBR a ese bloque 0 del disco donde estÃ¡ el gestor de arranque.
De hecho MBR son las siglas de <em>Master Boot Record</em> o <a href="https://es.wikipedia.org/wiki/Registro_de_arranque_principal">registro de arranque principal</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Aunque en ocasiones el cÃ³digo de ese bloque inicial de arranque sabe cargar e iniciar el sistema operativo completo, es comÃºn que sÃ³lo sepa donde estÃ¡ el resto del gestor de arranque en el disco, para cargarlo y ejecutarlo.
No debemos olvidar que el cÃ³digo cargado por el <em>bootstrap</em> debe caber en un sÃ³lo bloque del disco, que generalmente tiene solo 512 bytes.</p>
</div>
<div class="paragraph">
<p>En los PC mÃ¡s modernos que utilizan UEFI y particiones GPT, la UEFI tiene la capacidad de leer el sistema de archivo en las particiones para buscar directamente los archivos del gestor de arranque completo.
Una vez el <em>bootstrap</em> los encuentra, los carga y ejecuta.</p>
</div>
<div class="paragraph">
<p>En ambos casos, el gestor de arranque completo es el programa que sabe como iniciar el sistema operativo asÃ­ que: explora el sistema de ficheros en busca del nÃºcleo del sistema, lo carga e inicia su ejecuciÃ³n.</p>
</div>
<div class="paragraph">
<p>A partir de esto punto cada sistema operativo prosigue de forma diferente.
A modo de ejemplo, veremos como prosigue el arranque en sistemas UNIX en modo texto.</p>
</div>
</div>
<div class="sect3">
<h4 id="_arranque_de_sistemas_unix">7.6.2. Arranque de sistemas UNIX</h4>
<div class="paragraph">
<p>Al iniciarse el nÃºcleo del sistema, este realiza una serie de tareas:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Configura el sistema para crear un entorno adecuado para la ejecuciÃ³n de los procesos: configuraciÃ³n de interrupciones, configuraciÃ³n de los modos de ejecuciÃ³n âprivilegiado y usuarioâ y de la gestiÃ³n de la memoria; inicializaciÃ³n de dispositivos y controladores; montaje del sistema de ficheros raÃ­z; creaciÃ³n del proceso inactivo âque se ejecutarÃ¡ cuando no haya nada que hacerâ etc.</p>
</li>
<li>
<p>Crea el proceso <strong>init</strong> âque por ser el primero tiene PID 1â a partir de la carga del programa <code>init</code> almacenado en el sistema de ficheros raÃ­z.
En los sistemas GNU/Linux actuales el proceso <strong>init</strong> mÃ¡s comÃºn es <a href="https://es.wikipedia.org/wiki/Systemd">systemd</a>.</p>
</li>
<li>
<p>El planificador de la CPU toma el control de la gestiÃ³n de la CPU y el nÃºcleo queda dormido.
Puesto que la funciÃ³n del planificador es asignar procesos a la CPU y solo hay uno, el proceso <strong>init</strong>, Ã©ste es escogido y comienza su ejecuciÃ³n.</p>
</li>
<li>
<p>El proceso <strong>init</strong> lanza los <em>scripts</em> encargados de configurar los servicios âtambiÃ©n llamados demoniosâ del sistema.
Por ejemplo, para el registro de eventos del sistema, gestiÃ³n de dispositivos, particiones, impresoras, entre otros.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>El proceso <strong>init</strong> tambiÃ©n configura el entorno de usuario.
Configura las terminales del sistema, inicia un proceso <strong>login</strong> conectado a cada una y se duerme a la espera.
Estos procesos <strong>login</strong> son monitorizados por <strong>init</strong> para reiniciarlos en caso de que mueran.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Aunque, por lo general, un sistema de escritorio tiene una Ãºnica pareja de teclado y monitor y, por lo tanto, una Ãºnica terminal real; el sistema suele esta configurado para crear varios terminales virtuales entre los que el usuario puede conmutar usando las combinaciones de teclas adecuadas.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Los procesos <strong>login</strong> se encargan de autenticar a los usuarios y de iniciar y configurar su sesiÃ³n:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Muestran una pantalla de inicio de sesiÃ³n donde se solicita el nombre del usuario y su contraseÃ±a.</p>
</li>
<li>
<p>Autentican al usuario comprobando las credenciales proporcionadas por el mismo.</p>
</li>
<li>
<p>Si la autenticaciÃ³n es positiva, el proceso <strong>login</strong> cambia su identidad actual âgeneralmente de <em>root</em> o administrador del sistemaâ por la del usuario autenticado, configura la sesiÃ³n y sustituye su programa actual por el del intÃ©rprete de comandos que tiene configurado ese usuario (vÃ©ase el <a href="#procesos_posix_api">Apartado 9.7.3.2</a>).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>El intÃ©rprete de comandos completa la configuraciÃ³n del entorno en base a sus ficheros de configuraciÃ³n, muestra el <a href="https://es.wikipedia.org/wiki/Prompt">prompt</a> y queda a la espera del primer comando del usuario.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sistemas_operativos_por_su_estructura">8. Sistemas operativos por su estructura</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>10 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Ya hemos discutido anteriormente acerca de los componentes mÃ¡s comunes en un sistema operativo (vÃ©ase el <a href="#_componentes_del_sistema">CapÃ­tulo 4</a>).
En esta secciÃ³n comentaremos cÃ³mo se clasifican los distintos sistemas operativos segÃºn la organizaciÃ³n e interconexiÃ³n de sus componentes.</p>
</div>
<div class="sect2">
<h3 id="_estructura_sencilla">8.1. Estructura sencilla</h3>
<div class="paragraph">
<p></p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Los sistemas con <strong>estructura sencilla</strong> se caracterizan por:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>No tener una estructura bien definida.
Los componentes no estÃ¡n bien separados y las interfaces entre ellos no estÃ¡n bien definidas.</p>
</li>
<li>
<p>Son sistemas <strong>monolÃ­ticos</strong>, dado que gran parte de la funcionalidad del sistema se implementa en el nÃºcleo.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ms_dos_2">8.1.1. MS-DOS</h4>
<div class="paragraph">
<p>Por ejemplo, en el <a href="https://es.wikipedia.org/wiki/MS-DOS">MS-DOS</a> los programas de aplicaciÃ³n podÃ­an acceder directamente a toda la memoria y a cualquier dispositivo.
Disponiendo de esa libertad un programa errÃ³neo cualquiera podÃ­a corromper el sistema completo.</p>
</div>
<div id="estructura_msdos" class="imageblock">
<div class="content">
<img src="C08-estructura/media/estructura_msdos.svg" alt="estructura msdos">
</div>
<div class="title">Figura 21. Esquema de la estructura de MS-DOS.</div>
</div>
<div class="paragraph">
<p>Como el <a href="https://es.wikipedia.org/wiki/Intel_8086_y_8088">Intel 8086</a> para el que fue escrito MS-DOS no proporcionaba un modo dual de operaciÃ³n, los diseÃ±adores del sistema no tuvieron mÃ¡s opciÃ³n que dejar accesible el hardware a los programas de usuario.</p>
</div>
</div>
<div class="sect3">
<h4 id="_unix_2">8.1.2. UNIX</h4>
<div class="paragraph">
<p>Otro ejemplo es el de <a href="https://es.wikipedia.org/wiki/Unix">UNIX original</a>, donde si habÃ­a una separaciÃ³n clara entre procesos de usuario y cÃ³digo del sistema, pero juntaba un montÃ³n de funcionalidad en el nÃºcleo del sistema.</p>
</div>
<div id="estructura_unix" class="imageblock">
<div class="content">
<img src="C08-estructura/media/estructura_unix.svg" alt="estructura unix">
</div>
<div class="title">Figura 22. Esquema de la estructura de UNIX.</div>
</div>
<div class="paragraph">
<p>El nÃºcleo proporciona la planificaciÃ³n de CPU, la gestiÃ³n de la memoria, el soporte de los sistemas de archivos y muchas otras funcionalidades del sistema operativo.
En general se trata de una enorme cantidad de funcionalidad que es difÃ­cil de implementar y mantener, si no se compartimenta adecuadamente.</p>
</div>
<div class="paragraph">
<p>Tanto MS_DOS como UNIX eran originalmente sistemas pequeÃ±os y simples, limitados por las funcionalidades del hardware de su Ã©poca, que fueron creciendo mÃ¡s allÃ¡ de las previsiones originales.
Lo cierto es que con mejor soporte del hardware se puede dividir el sistema operativo en piezas mÃ¡s pequeÃ±as y apropiadas que las del MS-DOS y el UNIX original.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_estructura_en_capas">8.2. Estructura en capas</h3>
<div class="paragraph">
<p></p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Los sistemas con <strong>estructura en capas</strong> se caracterizan por:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La funcionalidad se divide en capas, de tal forma que una capa solo utiliza funciones y servicios de la capa inmediatamente inferior y lo hace a travÃ©s de una interfaz bien definida.</p>
</li>
<li>
<p>Como en la programaciÃ³n orientada a objetos, cada capa oculta a la capa superior los detalles de su implementaciÃ³n.
Por ejemplo, las estructuras de datos internas que usa y las operaciones o el hardware de la capa inferior que utiliza.</p>
</li>
<li>
<p>Escalan mejor que los sistemas con <strong>estructura sencilla</strong> porque las capas hacen que el cÃ³digo estÃ© mejor compartimentado.
Por ejemplo, al corregir un <em>bug</em> o aÃ±adir una nueva funcionalidad solo hay que preocuparse de su efecto en la capa a la que afecta y no en todo el cÃ³digo del nÃºcleo âsiempre que no se altere la interfaz de la capa con el exteriorâ.</p>
</li>
<li>
<p>Ser menos eficiente que la de los sistemas de <strong>estructura sencilla</strong>.
En cada capa los argumentos son transformados y los datos necesarios deben de ser transferidos al invocar operaciones en la capa inferior, por lo que cada una aÃ±ade cierto nivel de sobrecarga al funcionamiento del sistema.</p>
</li>
<li>
<p>TambiÃ©n son sistemas <strong>monolÃ­ticos</strong>, dado que gran parte de la funcionalidad del sistema se implementa en el nÃºcleo, aunque ahora el nÃºcleo estÃ© compartimentado en capas.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Un ejemplo de este tipo de sistemas operativos es el <a href="https://es.wikipedia.org/wiki/OS/2">OS/2</a>.</p>
</div>
<div id="estructura_os2" class="imageblock">
<div class="content">
<img src="C08-estructura/media/estructura_os2.svg" alt="estructura os2">
</div>
<div class="title">Figura 23. Esquema de la estructura de IBM OS/2.</div>
</div>
<div class="sect3">
<h4 id="_dificultades_con_el_diseÃ±o">8.2.1. Dificultades con el diseÃ±o</h4>
<div class="paragraph">
<p>Es importante tener en cuenta que diseÃ±ar un sistema con <strong>estructura en capas</strong> no es tan sencillo como pudiera parecer.
La definiciÃ³n de las capas y sus funcionalidades debe ser planificada cuidadosamente debido a la restricciÃ³n, comentada anteriormente, de que un capa sÃ³lo puede utilizar los servicios de las capas inferiores.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, el planificador de la CPU suele tener informaciÃ³n de los procesos que estÃ¡n en la memoria.
Parte de esa informaciÃ³n puede ser almacenada en el disco para aumentar la memoria principal disponible.
Esto nos deberÃ­a llevar a pensar que la gestiÃ³n del almacenamiento secundario debe ir en una capa inferior a la del planificador de la CPU, para que asÃ­ el segundo pueda pedir al primero que guarde los datos en disco.</p>
</div>
<div class="paragraph">
<p>Sin embargo, el planificador de la CPU debe asignar la CPU a otro proceso cuando el proceso que actualmente la ocupa solicita alguna operaciÃ³n de E/S âlo tÃ­pico en multiprogramaciÃ³nâ.
Como es la gestiÃ³n del almacenamiento secundario el que debe pedir una operaciÃ³n al planificador de la CPU, ahora el primero debe estar sobre el segundo.</p>
</div>
<div class="paragraph">
<p>La soluciÃ³n a esta dependencia circular es hacer que ambos componentes estÃ©n en la misma capa.
Este tipo de dependencias no son raras, ocurre en muchos otros casos, ya que los componentes del sistema operativo suelen depender mucho unos de otros.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Al final, la soluciÃ³n de compromiso es tender hacia sistemas con muy pocas capas donde cada una tiene mucha funcionalidad.
Esto limita mucho las ventajas de esta tÃ©cnica porque no permite compartimentar el nÃºcleo tanto como serÃ­a deseable.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_microkernel">8.3. Microkernel</h3>
<div class="paragraph">
<p>
</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Los sistemas con <strong>estructura microkernel</strong> se caracterizan por:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Eliminar todos los componentes no esenciales del nÃºcleo e implementarlos como procesos a nivel de usuario.</p>
</li>
<li>
<p>Un nÃºcleo <strong>microkernel</strong> proporciona funciones mÃ­nimas de gestiÃ³n de procesos y de memoria y algÃºn mecanismo de comunicaciÃ³n entre procesos.
Sin embargo, hay que tener en cuenta que hay poco consenso a este respecto, por lo que algunos <strong>microkernel</strong> reales incluyen en el nÃºcleo algunas funcionales adicionales.</p>
</li>
<li>
<p>El mecanismo de comunicaciÃ³n permite a los procesos de los usuarios solicitar servicios a los componentes del sistema.
TambiÃ©n sirve para que los componentes del sistema se comuniquen entre sÃ­ y se pidan servicio.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Dado que los componentes del sistema estÃ¡n aislados unos de otros âya que se implementan como procesos de usuarioâ el mecanismo de comunicaciÃ³n entre procesos es la Ãºnica forma que tienen los procesos de los usuarios y los componentes, de solicitarles un servicio.</p>
</div>
<div id="estructura_minix3" class="imageblock">
<div class="content">
<img src="C08-estructura/media/estructura_minix3.svg" alt="estructura minix3">
</div>
<div class="title">Figura 24. Esquema de la estructura microkernel de MINIX 3.</div>
</div>
<div class="paragraph">
<p>Generalmente esta comunicaciÃ³n se implementa mediante paso de mensajes (vÃ©ase el <a href="#_comunicaciÃ³n_entre_procesos">Apartado 9.8.2</a>).</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Entre los beneficios de estos sistemas operativos se incluyen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Facilidad a la hora de aÃ±adir nuevas funcionalidades</strong>.
Los nuevos servicios son aÃ±adidos como aplicaciones de nivel de usuario, por lo que no es necesario hacer modificaciones en el nÃºcleo.
Desarrollar en el modo privilegiado siempre es mÃ¡s peligrosos que en el modo usuario porque los errores pueden ser catastrÃ³ficos: bloqueo o caÃ­da del sistema, corrupciÃ³n de datos, etc.</p>
</li>
<li>
<p><strong>Facilidad a la hora de portar el sistema a otras plataformas</strong>.
Puesto que el nÃºcleo es muy pequeÃ±o, resulta muy sencillo de portar a otras plataformas.</p>
</li>
<li>
<p><strong>MÃ¡s seguridad y fiabilidad</strong>.
Puesto que la mayor parte de los servicios se ejecutan a nivel de usuario en procesos separados, un servicio que falla no puede afectar a otros ni puede ser utilizado para ganar acceso a otros servicios o al nÃºcleo.
AdemÃ¡s se pueden implementar estrategias para mejorar la tolerancia a fallos, como reiniciar un servicio que ha fallado, como si fuera un programa cualquiera.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_rendimiento">8.3.1. Rendimiento</h4>
<div class="paragraph">
<p>El mayor inconveniente es el pobre rendimiento que puede tener, causado por la sobrecarga que aÃ±ade el mecanismo de comunicaciÃ³n.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, <a href="https://es.wikipedia.org/wiki/Windows_NT">Microsoft Windows NT</a> naciÃ³ con una estructura de <strong>microkernel</strong> en capas donde una parte importante de los servicios eran proporcionados por unos procesos de usuario llamados subsistemas.</p>
</div>
<div class="paragraph">
<p>El sistema operativo podÃ­a mostrar diferentes personalidades o <em>entornos operativos</em> âbÃ¡sicamente de OS/2, POSIX y MS-DOSâ a travÃ©s del uso de subsistemas ambientales, que tambiÃ©n se ejecutaban como procesos de usuario.
Las aplicaciones de Microsoft Windows NT se comunicaban con estos subsistemas utilizando un mecanismo de comunicaciÃ³n denominado <a href="https://en.wikipedia.org/wiki/Local_Inter-Process_Communication">LPC</a> (<em>Local Inter-Process Communication</em>).</p>
</div>
<div class="paragraph">
<p>Con esta estructura, la pÃ©rdida de rendimiento respecto a Microsoft Windows 95 era tan importante âespecialmente en lo relativo a operaciones grÃ¡ficasâ que los diseÃ±adores se vieron obligados a mover mÃ¡s servicios al espacio del nÃºcleo en la versiÃ³n 4.0.
El resultado es que los Windows sucesores a Windows NT 4.0 tienen una arquitectura mÃ¡s monolÃ­tica que microkernel, ya que aunque muchos servicios siguen siendo proporcionados por procesos de usuario, esto sÃ³lo ocurre con aquellos donde el rendimiento no es un factor crÃ­tico.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Microsoft Windows XP tiene 280 llamadas al sistema a las que hay que sumar las mÃ¡s de 650 llamadas del subsistema grÃ¡fico, que tambiÃ©n se aloja en el nÃºcleo desde Microsoft Windows NT 4.0.
Mientras que Microsoft Windows NT 3.51 tenÃ­a algo menos de 200 llamadas al sistema.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Sin embargo varios sistemas operativos siguen utilizando nÃºcleos <strong>microkernel</strong>, como <a href="https://es.wikipedia.org/wiki/QNX">QNX</a> o <a href="https://en.wikipedia.org/wiki/MINIX_3">MINIX 3</a>.
Ambos son sistemas operativos de tiempo real, que basan en la estructura de <strong>microkernel</strong> su estabilidad como sistema para tareas crÃ­ticas.</p>
</div>
<div class="paragraph">
<p>En la <a href="#estructura_minix3">Figura 24</a>, por ejemplo, se puede observar un esquema de <a href="https://en.wikipedia.org/wiki/MINIX_3">MINIX 3</a>.
El nÃºcleo es muy pequeÃ±o âapenas tiene 5000 lÃ­neas de cÃ³digoâ por lo que la mayor parte de la funcionalidad reside en los procesos de servicios y de controladores de dispositivo.</p>
</div>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/MINIX_3">MINIX 3</a> es un sistema compatible POSIX.
AsÃ­ que soporta las llamadas al sistema definidas por este estÃ¡ndar, pero Ã©stas se convierten en mensajes enviados al servidor correspondiente con la peticiÃ³n, y no en llamadas directas al nÃºcleo.
Para que un servidor pueda atender una peticiÃ³n, quizÃ¡s tenga que enviar peticiones a otros servidores o controladores de dispositivo.
Incluso pueden tener que hacer llamadas al nÃºcleo, para solicitar alguna operaciÃ³n privilegiada que no se puede implementar en el modo usuario.
Por ejemplo, operaciones de E/S âfundamentales para los controladores de dispositivoâ o el acceso a tablas del nÃºcleo âcomo la tabla de procesosâ.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Es este trasiego de mensaje con peticiones y respuestas ây la correspondiente conmutaciÃ³n de procesos en la CPU para ejecutar el proceso que atiende cada mensajeâ para resolver una peticiÃ³n de un proceso de usuario, lo que teÃ³ricamente justica el menor rendimiento de los sistemas <strong>microkernel</strong>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_estructura_modular">8.4. Estructura modular</h3>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Los sistemas con <strong>estructura modular</strong> se caracterizan por:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Dividir el nÃºcleo en mÃ³dulos, cada uno de los cuales implementa funciones y servicios concretos y se comunican entre sÃ­ a travÃ©s de una interfaz bien definida.</p>
</li>
<li>
<p>Como en la programaciÃ³n orientada a objetos, cada mÃ³dulo oculta al resto los detalles de su implementaciÃ³n.</p>
</li>
<li>
<p>Todos los mÃ³dulos pueden llamar a funciones de la interfaz de cualquier otro mÃ³dulo, a diferencia de los sistemas operativos con <strong>estructura en capas</strong>, donde una capa solo podÃ­a usar a la inmediatamente inferior.</p>
</li>
<li>
<p>TambiÃ©n son sistemas <strong>monolÃ­ticos</strong>, dado que gran parte de la funcionalidad del sistema se implementa en el nÃºcleo, aunque ahora el nÃºcleo estÃ© compartimentado en mÃ³dulos.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Estos nÃºcleos suelen disponer de un pequeÃ±o conjunto de componentes fundamentales que se cargan durante el arranque.
Posteriormente pueden cargar mÃ³dulos adicionales, tanto durante la inicializaciÃ³n del sistema como en tiempo de ejecuciÃ³n.</p>
</div>
<div id="estructura_linux" class="imageblock">
<div class="content">
<img src="C08-estructura/media/estructura_linux.svg" alt="estructura linux">
</div>
<div class="title">Figura 25. Esquema de la estructura del nÃºcleo Linux.</div>
</div>
<div class="paragraph">
<p>En este aspecto se asemejan a los nÃºcleos <strong>microkernel</strong>, ya que el mÃ³dulo principal sÃ³lo tiene funciones bÃ¡sicas.
Sin embargo los nÃºcleos modulares:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Son mÃ¡s eficientes</strong> al no necesitar un mecanismo de comunicaciÃ³n, puesto que los componentes se cargan en la memoria destinada al nÃºcleo, por lo que pueden llamarse directamente.</p>
</li>
<li>
<p><strong>Son menos seguros y fiables</strong>, puesto que gran parte de su funcionalidad se ofrece desde el modo privilegiado.
Un error en cualquier componente puede comprometer o hacer caer el sistema.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Este tipo de estructura es la utilizada en los UNIX modernos, como <a href="https://es.wikipedia.org/wiki/Solaris_(sistema_operativo)">Oracle/Sun Microsystems Solaris</a>, <a href="https://es.wikipedia.org/wiki/FreeBSD">FreeBSD</a>, <a href="https://es.wikipedia.org/wiki/GNU/Linux">Linux</a> (vÃ©ase la <a href="#estructura_linux">Figura 25</a>) y <a href="https://es.wikipedia.org/wiki/MacOS">macOS</a>.</p>
</div>
</div>
</div>
</div>
<h1 id="_gestiÃ³n_de_procesos" class="sect0">Parte III: GestiÃ³n de procesos</h1>
<div class="sect1">
<h2 id="_procesos">9. Procesos</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>39 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Los primeros sistemas informÃ¡ticos solo permitÃ­an que un programa se ejecutara cada vez.
Dicho programa tenÃ­a control completo sobre el sistema y acceso a todos los recursos del mismo.
Por el contrario, los sistemas <strong>multitarea</strong> actuales permiten que mÃºltiples programas sean cargados y ejecutados concurrentemente.</p>
</div>
<div class="paragraph">
<p>Obviamente esta evoluciÃ³n implica un control mÃ¡s fino y la compartimentaciÃ³n de los diversos programas, para que no interfieran unos con otros.
Esto, a su vez, conduce a la apariciÃ³n de la nociÃ³n de <strong>proceso</strong>, que no es sino la unidad de trabajo en un sistema operativo moderno de tiempo compartido.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Por simplicidad, en este capÃ­tulo utilizaremos los tÃ©rminos <strong>trabajo</strong> y <strong>proceso</strong> de forma indistinta.
A fin de cuentas tanto los <strong>trabajos</strong> en los antiguos <em>mainframes</em> como los <strong>procesos</strong> en los sistemas modernos son la unidad de trabajo en sus respectivos sistemas y el origen de toda actividad en la CPU.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Por Ãºltimo, antes de continuar, es importante seÃ±alar que en un sistema operativo hay varios tipos de procesos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Procesos del sistema</strong>.
Ejecutan el cÃ³digo del sistema operativo contenido en los <strong>programas del sistema</strong>, que generalmente sirven para hacer tareas del sistema operativo que es mejor mantener fuera del nÃºcleo.</p>
</li>
<li>
<p><strong>Procesos de usuario</strong>
Ejecutan el cÃ³digo contenido en los <em>programas de aplicaciÃ³n</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Sin embargo, en lo que resta de capÃ­tulo, no estableceremos ninguna distinciÃ³n entre ellos.
En lo que respecta a la gestiÃ³n de estos procesos en el sistema, no hay ninguna diferencia.</p>
</div>
<div class="sect2">
<h3 id="_el_proceso">9.1. El proceso</h3>
<div class="paragraph">
<p>Como ya hemos comentado con anterioridad, un <strong>proceso</strong> es un programa en ejecuciÃ³n (vÃ©ase el <a href="#componente_gestiÃ³n_de_procesos">Apartado 4.1</a> para una definiciÃ³n mÃ¡s completa).
Sin embargo, los procesos no solo estÃ¡n compuestos por el cÃ³digo del programa, sino que tambiÃ©n son importantes otros elementos:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1">Segmento de cÃ³digo</dt>
<dd>
<p>Contiene las instrucciones ejecutables del programa.
TambiÃ©n es conocido como segmento <strong>text</strong> o <strong>.text</strong>.</p>
</dd>
<dt class="hdlist1">Segmento de datos</dt>
<dd>
<p>Contiene las variables globales y estÃ¡ticas del programa que se inicializan con un valor predefinido.
TambiÃ©n es conocido como segmento <strong>.data</strong>.</p>
</dd>
<dt class="hdlist1">Segmento BSS</dt>
<dd>
<p>Contiene las variables globales y estÃ¡ticas del programa inicializadas a 0 o sin inicializaciÃ³n explÃ­cita   .
TambiÃ©n es conocido como segmento <strong>.bss</strong>.</p>
</dd>
<dt class="hdlist1">Pila</dt>
<dd>
<p>Contiene datos temporales, como los parÃ¡metros y direcciones de retorno de las funciones y las variables locales.</p>
</dd>
<dt class="hdlist1">MontÃ³n</dt>
<dd>
<p>Contiene el espacio de la memoria que se asigna dinÃ¡micamente durante la ejecuciÃ³n del proceso.
TambiÃ©n es conocido como <strong>heap</strong>.</p>
</dd>
<dt class="hdlist1">InformaciÃ³n sobre el estado actual de ejecuciÃ³n</dt>
<dd>
<p>Como el <strong>contador de programa</strong>, los valores de los <strong>registros de la CPU</strong>, el <strong>estado</strong> del proceso y mÃ¡s (vÃ©ase el <a href="#_bloque_de_control_de_proceso">Apartado 9.3</a>).</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>Los <strong>segmentos de cÃ³digo</strong>, <strong>datos</strong> y <strong>BSS</strong> por lo general son secciones dentro del archivo ejecutable que contiene el programa.
El resto de elementos los crea el sistema operativo al cargar el programa y crear el proceso.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Como vimos en el <a href="#componente_gestiÃ³n_de_procesos">Apartado 4.1</a> varios procesos pueden estar asociados al mismo programa pero no por eso dejan de ser distintos procesos.
Todos tendrÃ¡n una copia del mismo segmento de cÃ³digo, pero diferente: contador de programa, valores en los registros de la CPU, pila, segmento de datos, montÃ³n y demÃ¡s propiedades.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>En la <a href="#proceso_en_memoria">Figura 26</a> se puede observar la disposiciÃ³n de algunos de estos elementos de un proceso en el espacio de usuario en la memoria.</p>
</div>
<div id="proceso_en_memoria" class="imageblock">
<div class="content">
<img src="C09-procesos/media/proceso_en_memoria.svg" alt="proceso en memoria">
</div>
<div class="title">Figura 26. AnatomÃ­a de un proceso en memoria.</div>
</div>
</div>
<div class="sect2">
<h3 id="_estados_de_los_procesos">9.2. Estados de los procesos</h3>
<div class="paragraph">
<p>Cada proceso tiene un <strong>estado</strong> que cambia a lo largo de su ejecuciÃ³n y que estÃ¡ definido, parcialmente, por la actividad que realiza actualmente el propio proceso.</p>
</div>
<div id="diagrama_estado_proceso" class="imageblock">
<div class="content">
<img src="C09-procesos/media/diagrama_estado_proceso.svg" alt="diagrama estado proceso">
</div>
<div class="title">Figura 27. Diagrama de estado de un proceso.</div>
</div>
<div class="paragraph">
<p>Los estados por los que puede pasar un procesos varÃ­an de un sistema operativo a otro, aunque los siguientes son comunes a todos ellos:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Nuevo</dt>
<dd>
<p>El proceso estÃ¡ en proceso de creaciÃ³n.
Este estado existe porque la creaciÃ³n de un proceso no es algo instantÃ¡neo.
Necesita de varias operaciones que pueden tardar tiempo en realizarse, como: reservar memoria libre, cargar el programa en la memoria, inicializar estructuras de datos y configurar el entorno de ejecuciÃ³n.</p>
</dd>
<dt class="hdlist1">Ejecutando</dt>
<dd>
<p>El proceso estÃ¡ siendo ejecutado en la CPU.
Para eso tiene que haber sido escogido por el planificador de la CPU de entre todos los procesos en estado <strong>preparado</strong>.
SÃ³lo puede haber un proceso en este estado por CPU en el sistema.</p>
</dd>
<dt class="hdlist1">Esperando</dt>
<dd>
<p>El proceso estÃ¡ esperando por algÃºn <strong>evento</strong> como, por ejemplo, que termine una operaciÃ³n de E/S solicitada previamente o que otro proceso termine su ejecuciÃ³n.
MÃºltiples procesos pueden estar en este estado de espera.</p>
</dd>
<dt class="hdlist1">Preparado</dt>
<dd>
<p>El proceso estÃ¡ esperando a poder usar la CPU.
MÃºltiples procesos pueden estar en este estado.</p>
</dd>
<dt class="hdlist1">Terminado</dt>
<dd>
<p>El proceso ha finalizado su ejecuciÃ³n y espera a que el sistema operativo recupere los recursos que le fueron asignados.
Como en el caso del estado <strong>nuevo</strong>, este estado existe porque terminar un proceso no es algo instantÃ¡neo.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>El diagrama de estados de los procesos, con las transiciones posibles entre ellos, se muestra en la <a href="#diagrama_estado_proceso">Figura 27</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_bloque_de_control_de_proceso">9.3. Bloque de control de proceso</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El <strong>bloque de control de proceso</strong> o <strong>PCB</strong> (<em>Process Control Block</em>) es una estructura de datos que representa a cada proceso en el sistema operativo y que guarda informaciÃ³n sobre su estado de actividad actual.</p>
</div>
<div class="paragraph">
<p>En el sistema hay un PCB por proceso y sirve de almacÃ©n para cualquier informaciÃ³n que puede variar de un proceso a otro:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Estado del proceso</strong>.
El estado actual del proceso de la lista que hemos visto anteriormente.
Por ejemplo: nuevo, preparado, esperando, etc.</p>
</li>
<li>
<p><strong>Contador de programa</strong>.
Indica la direcciÃ³n de la prÃ³xima instrucciÃ³n del proceso que debe ser ejecutada por la CPU.
Obviamente, durante el estado <strong>ejecutando</strong> el contador de programa estÃ¡ en el registro correspondiente de la CPU.
Su valor se guarda en el PCB al salir el proceso de la CPU para que comience ejecutarse en ella otro proceso.</p>
</li>
<li>
<p><strong>Registros de la CPU</strong>.
El valor de los registros de la CPU tambiÃ©n forman parte del estado de actividad del proceso.
Como en el caso del <strong>contador de programa</strong>, durante el estado <strong>ejecutando</strong> los valores estÃ¡n en los registros de la CPU, pero se guardan en el PCB cuando el proceso sale de la CPU para que se ejecute otro proceso.</p>
</li>
<li>
<p><strong>InformaciÃ³n de planificaciÃ³n de la CPU</strong>.
Incluye la informaciÃ³n requerida por el planificador de la CPU.
Por ejemplo la prioridad del proceso, punteros a las colas de planificaciÃ³n donde estÃ¡ el proceso, punteros al PCB del proceso padre y de los procesos hijos, etc.</p>
</li>
<li>
<p><strong>InformaciÃ³n de gestiÃ³n de la memoria</strong>.
Incluye la informaciÃ³n requerida para la gestiÃ³n de la memoria.
Por ejemplo los valores de los registros base y lÃ­mite que definen el Ã¡rea de la memoria fÃ­sica que ocupa el proceso âen el caso de se use asignaciÃ³n contigua de memoria (vÃ©ase el <a href="#_asignaciÃ³n_contigua_de_memoria">Apartado 15.5</a> o la direcciÃ³n a la tabla de pÃ¡ginas âen el caso de que se use paginaciÃ³n (vÃ©ase el <a href="#_paginaciÃ³n">CapÃ­tulo 16</a>)â.</p>
</li>
<li>
<p><strong>InformaciÃ³n de registro</strong>.
AquÃ­ se incluye la cantidad de CPU usada, lÃ­mites de tiempo en el uso de la CPU, estadÃ­sticas de la cuenta del usuario a la que pertenece el proceso, estadÃ­sticas de la ejecuciÃ³n del proceso, etc.</p>
</li>
<li>
<p><strong>InformaciÃ³n de estado de la E/S</strong>.
Incluye la lista de dispositivos de E/S reservados por el proceso, la lista de archivos abiertos, etc.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_colas_de_planificaciÃ³n">9.4. Colas de planificaciÃ³n</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>En los sistemas operativos hay diferentes <strong>colas de planificaciÃ³n</strong> para los procesos en distintos <strong>estados</strong>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Cola de trabajo</dt>
<dd>
<p>Contiene a todos los trabajos en el sistema, de manera que cuando entran en el sistema van a esta cola, a la espera de ser escogidos para ser cargados en la memoria y ejecutados.
Esta cola existÃ­a en los <strong>sistemas multiprogramados</strong> pero no existe en los sistemas operativos modernos.</p>
</dd>
<dt class="hdlist1">Cola de preparados</dt>
<dd>
<p>Contiene a los procesos que estÃ¡n en estado <strong>preparado</strong>.
Es decir, procesos cargados en la memoria principal que esperan para usar la CPU.
La cola de preparados es generalmente una lista enlazada de PCB, donde cada uno incluye un puntero al PCB del siguiente proceso en la cola.</p>
</dd>
<dt class="hdlist1">Colas de espera</dt>
<dd>
<p>Contienen a los procesos que estÃ¡n en estado <strong>esperando</strong>.
Es decir, que esperan por un evento concreto, como por ejemplo la finalizaciÃ³n de una peticiÃ³n de E/S.
Estas colas tambiÃ©n suelen ser implementadas como listas enlazadas de PCB y suele haber una por evento, de manera que cuando ocurre algÃºn evento todos los procesos en la cola asociada pasan automÃ¡ticamente al estado <strong>preparado</strong> y a la <strong>cola de preparados</strong>.</p>
</dd>
<dt class="hdlist1">Colas de dispositivo</dt>
<dd>
<p>Son un caso particular de cola de espera.
Cada dispositivo de E/S tiene asociada una <strong>cola de dispositivo</strong> que contiene los procesos que estÃ¡n <strong>esperando</strong> por ese dispositivo en particular.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Una manera habitual de representar la planificaciÃ³n de procesos es a travÃ©s de un diagrama de colas como el de la <a href="#colas_de_planificaciÃ³n_procesos">Figura 28</a>.</p>
</div>
<div id="colas_de_planificaciÃ³n_procesos" class="imageblock">
<div class="content">
<img src="C09-procesos/media/colas_planificaciÃ³n_procesos.svg" alt="colas planificaciÃ³n procesos">
</div>
<div class="title">Figura 28. Diagrama de colas de la planificaciÃ³n de procesos.</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>AnalizÃ¡ndolo podemos tener una idea clara del flujo tÃ­pico de los procesos dentro del sistema:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Un nuevo proceso llega al sistema</strong>.
Una vez pasa del estado <strong>nuevo</strong> a <strong>preparado</strong> es colocado en la <strong>cola de preparados</strong>.
AllÃ­ espera hasta que es seleccionado por el <strong>planificado de la CPU</strong> para su ejecuciÃ³n y se le asigna la CPU.
Mientras se ejecuta pueden ocurrir varias cosas:</p>
<div class="ulist">
<ul>
<li>
<p><strong>El proceso solicita una operaciÃ³n de E/S</strong> por lo que abandona la CPU y es colocado en la <em>cola de dispositivo</em> correspondiente en estado <strong>esperando</strong>.
No debemos olvidar que aunque en nuestro diagrama no exista mÃ¡s que una de estas colas, en un sistema operativo real suele haber una para cada dispositivo.</p>
</li>
<li>
<p><strong>El proceso puede querer esperar por un evento</strong>.
Por ejemplo, puede crear otro proceso y esperar a que termine.
En ese caso el proceso hijo es creado, mientras el proceso padre abandona la CPU y es colocado en una <strong>cola de espera</strong> en estado <strong>esperando</strong> hasta que el proceso hijo termine.
La terminaciÃ³n del proceso hijo es el evento que espera el proceso padre para salir de la <strong>cola de espera</strong> y entrar en la <strong>cola de preparados</strong> para continuar su ejecuciÃ³n en la CPU cuando sea posible.</p>
</li>
<li>
<p><strong>El proceso puede ser sacado forzosamente de la CPU</strong>, como resultado de la interrupciÃ³n del temporizador, que permite determinar cuando un proceso lleva demasiado tiempo ejecutÃ¡ndose, asÃ­ que es colocado en la <strong>cola de preparados</strong> en estado <strong>preparado</strong>.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Cuando las esperas concluyen, los procesos vuelven a la cola de preparado</strong>, pasando del estado de espera al de preparado.</p>
</li>
<li>
<p><strong>Los procesos repiten este ciclo hasta que terminan</strong>.
En ese momento son eliminados de todas las colas mientras el PCB y los recursos asignados son recuperados por parte del sistema operativo para poder usarlos con otros procesos.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_planificaciÃ³n_de_procesos">9.5. PlanificaciÃ³n de procesos</h3>
<div class="paragraph">
<p>Durante su ejecuciÃ³n, los procesos se mueven entre las diversas colas de planificaciÃ³n a criterio del sistema operativo.
Este proceso de selecciÃ³n debe ser realizado por el <strong>planificador</strong> adecuado:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>El <strong>planificador de largo plazo</strong> o <strong>planificador de trabajos</strong>â selecciona los trabajos desde la cola de trabajos en el almacenamiento secundario âdÃ³nde estÃ¡n todos almacenadosâ y los carga en memoria.</p>
<div class="paragraph">
<p>Este planificador se usaba en los sistemas multiprogramados, donde habÃ­a cola de trabajos.
Los sistemas de tiempo compartido posteriores y los sistemas modernos, carecen de planificador de trabajos, porque los programas se cargan directamente en memoria para ser ejecutados, cuando el usuario lo solicita.</p>
</div>
</li>
<li>
<p>El <strong>planificador de corto plazo</strong> o <strong>planificador de CPU</strong> selecciona uno de los procesos en la cola de preparados y lo asigna a la CPU.
Obviamente este planificador es invocado cuando un proceso en ejecuciÃ³n abandona la CPU, dejÃ¡ndola disponible para otro proceso.</p>
</li>
<li>
<p>El <strong>planificador de medio plazo</strong>  era utilizado en algunos sistemas para sacar procesos de la memoria cuando escasea y reintroducirlos posteriormente cuando vuelve a haber suficiente memoria libre.
A este esquema se le denomina <strong>intercambio</strong> âo <strong><em>swapping</em></strong>.</p>
<div class="paragraph">
<p>Esto era Ãºtil en sistemas antiguos donde un proceso tenÃ­a que estar cargado completamente en la memoria para poder ejecutarse.
AsÃ­ que si faltaba memoria, se podÃ­a suspender un proceso completo, preservar el contenido de su memoria en disco y liberar la memoria ocupada para usarla con otros procesos.</p>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En los sistemas de propÃ³sito general modernos no se utiliza <strong>planificador de medio plazo</strong> porque utilizan tÃ©cnicas de <strong>memoria virtual</strong> (vÃ©ase el <a href="#_memoria_virtual">CapÃ­tulo 17</a>), que permite mover parte de la memoria de los procesos al disco para liberar memoria, sin tener que suspender su ejecuciÃ³n.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_cambio_de_contexto">9.6. Cambio de contexto</h3>
<div class="paragraph">
<p>El <strong>cambio de contexto</strong> es la tarea de asignar la CPU a un proceso distinto al que la tiene asignada en el momento actual.
Esto implica salvar el estado del viejo proceso en su PCB y cargar en la CPU el estado del nuevo.
Entre la informaciÃ³n que debe ser preservada en el PCB se incluyen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>El <strong>contador de programa</strong>.</p>
</li>
<li>
<p>Los <strong>registros de la CPU</strong>.</p>
</li>
<li>
<p>El <strong>estado del proceso</strong>.</p>
</li>
<li>
<p>La <strong>informaciÃ³n de gestiÃ³n de la memoria</strong>.
Por ejemplo, la informaciÃ³n necesaria para configurar el espacio de direcciones del proceso.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El cambio de contexto es sobrecarga pura, puesto que no hace ningÃºn trabajo Ãºtil mientras se conmuta.
Su velocidad depende de aspectos tales como: el nÃºmero de registros, la velocidad de la memoria y la existencia de instrucciones especiales.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Algunas CPU disponen de instrucciones especiales para salvar y cargar todos los registros de manera eficiente.
Esto reduce el tiempo que la CPU estÃ¡ ocupada en los cambios de contexto.</p>
</div>
<div class="paragraph">
<p>Otra opciÃ³n es el uso de <a href="https://en.wikipedia.org/wiki/Register_file">juegos de registros</a>, como es el caso de los procesadores <a href="https://es.wikipedia.org/wiki/UltraSPARC">Sun UltraSPARC</a> e <a href="https://es.wikipedia.org/wiki/Intel_Itanium">Intel Itanium</a>.
Con ellos el juegos de registros actual de la CPU se mapea sobre un banco de registros mucho mÃ¡s extenso.
Al hacer cambio de contexto, se mapea el juego de registros a otros registros diferentes del banco.
Esto permite que la CPU almacene de forma eficiente el valor de los registros de mÃ¡s de un proceso, sin que en cada cambio de contexto sea necesario copiarlos al PCB del proceso en la memoria principal.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_operaciones_sobre_los_procesos">9.7. Operaciones sobre los procesos</h3>
<div class="paragraph">
<p>En general es necesario que los procesos pueden ser creados y eliminados dinÃ¡micamente, por lo que los sistemas operativos deben proporcionar servicios para la creaciÃ³n y terminaciÃ³n de los mismos.</p>
</div>
<div class="sect3">
<h4 id="_creaciÃ³n_de_procesos">9.7.1. CreaciÃ³n de procesos</h4>
<div class="paragraph">
<p>Un proceso âdenominado <strong>padre</strong>â puede crear mÃºltiples procesos âlos <strong>hijos</strong>â utilizando una llamada al sistema especÃ­fica para la creaciÃ³n de procesos.
Cada proceso creado se identifica de manera unÃ­voca mediante un <strong>identificador de proceso</strong> o <strong>PID</strong> (<em>Process Identifier</em>), que normalmente es un nÃºmero entero.</p>
</div>
<div class="paragraph">
<p>Por ejemplo en sistemas POSIX un programa puede crear otro proceso asÃ­:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">pid_t</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>mientras que en Windows API es asÃ­:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">PROCESS_INFORMATION</span> <span class="n">pi</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">CreateProcess</span><span class="p">(</span> <span class="s">"C:</span><span class="se">\\</span><span class="s">Windows</span><span class="se">\\</span><span class="s">System32</span><span class="se">\\</span><span class="s">charmap.exe"</span><span class="p">,</span> <span class="cm">/* ... */</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pi</span> <span class="p">))</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">pi</span><span class="p">.</span><span class="n">dwhProcessId</span><span class="p">;</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="n">HANDLE</span> <span class="n">handle</span> <span class="o">=</span> <span class="n">pi</span><span class="p">.</span><span class="n">hProcess</span><span class="p">;</span> <i class="conum" data-value="3"></i><b>(3)</b>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a> devuelve <code>TRUE</code> si el proceso se creÃ³ con Ã©xito.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-process_information">PROCESS_INFORMATION</a> contiene el <strong>identificador de proceso</strong> del nuevo proceso, si <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a> ha tenido Ã©xito.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-process_information">PROCESS_INFORMATION</a> tambiÃ©n contiene el manejador del proceso âo <em>handle</em> en inglÃ©sâ que sirve para obtener y manipular el nuevo proceso.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>En ambos casos <code>pid</code> identifica al nuevo proceso en el sistema.
Sin embargo, mientras que los sistemas POSIX ese identificador se puede usar en otras llamadas al sistema para indicar futuras operaciones sobre el proceso, en Windows lo que se utiliza es el manejador <code>hProcess</code> devuelto en <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-process_information">PROCESS_INFORMATION</a>.</p>
</div>
<div class="paragraph">
<p>Obviamente, cada proceso puede obtener del sistema su propio identificador de procesos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cm">/* POSIX API */</span>
<span class="n">pid_t</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>

<span class="cm">/* Windows API */</span>
<span class="n">HANDE</span> <span class="n">handle</span> <span class="o">=</span> <span class="n">GetCurrentProcess</span><span class="p">();</span>
<span class="n">DWORD</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">GetProcessId</span><span class="p">(</span> <span class="n">handle</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>o el de su padre:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cm">/* POSIX API */</span>
<span class="n">pid_t</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">getppid</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_Ã¡rbol_de_procesos">Ãrbol de procesos</h5>
<div class="paragraph">
<p>Puesto que cada nuevo proceso puede a su vez crear otros procesos, al final se acaba obteniendo un <strong>Ã¡rbol de procesos</strong>.
En los sistemas POSIX es muy sencillo de ver ejecutando el comando <a href="https://man7.org/linux/man-pages/man1/pstree.1.html">pstree</a>.</p>
</div>
<div class="paragraph">
<p>En estos sistemas el proceso <strong>init</strong> es el proceso padre raÃ­z de todos los procesos de usuario.
Su PID siempre es 1 ya que es el primer proceso creado por el sistema operativo al terminar la inicializaciÃ³n del nÃºcleo.
Por lo tanto, es el responsable de crear todos los otros procesos que son necesarios para el funcionamiento del sistema.</p>
</div>
</div>
<div class="sect4">
<h5 id="_cÃ³mo_obtienen_los_procesos_hilos_los_recursos_que_necesitan">CÃ³mo obtienen los procesos hilos los recursos que necesitan</h5>
<div class="paragraph">
<p>Hay varios aspectos en la creaciÃ³n de los procesos que pueden variar de un sistema operativo a otro.
Uno de ellos es cÃ³mo obtienen los procesos hilos los recursos que necesitan para hacer su trabajo.</p>
</div>
<div class="paragraph">
<p>Fundamentalmente existen dos alternativas:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Que cada proceso hijo pueda solicitar y obtener los recursos directamente del sistema operativo, compitiendo por los recursos del sistema en las mismas condiciones que el resto de procesos en ejecuciÃ³n.
Esta es la opciÃ³n mÃ¡s comÃºn en los sistemas de propÃ³sito general actuales, como Microsoft Windows, Android, Linux, macOS, UNIX BSD y muchos otros.</p>
</li>
<li>
<p>Que los procesos hijo solo puedan aspirar a obtener un subconjunto de los recursos de su padre.
Esto es interesante en sistemas diseÃ±ados para ser muy robustos, ya que evita que un proceso pueda sobrecargar el sistema creando mÃºltiples procesos que consuman demasiada memoria o tiempo de CPU.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>En este Ãºltimo caso, el proceso padre puede estar obligado a repartir sus recursos entre los procesos hijo. O pueda que el sistema les permita compartir algunos de esos recursos âcomo memoria o archivosâ con algunos de sus hijos.</p>
</div>
</div>
<div class="sect4">
<h5 id="_cÃ³mo_pasar_parÃ¡metros_de_inicializaciÃ³n_a_los_procesos_hijo">CÃ³mo pasar parÃ¡metros de inicializaciÃ³n a los procesos hijo</h5>
<div class="paragraph">
<p>Generalmente, el proceso padre suele disponer de algÃºn mecanismo para pasar parÃ¡metros de inicializaciÃ³n a sus procesos hijo.</p>
</div>
<div class="sect5">
<h6 id="_argumentos_de_lÃ­nea_de_comandos">Argumentos de lÃ­nea de comandos</h6>
<div class="paragraph">
<p>Por ejemplo, en Windows API un proceso puede usar el segundo argumento de <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a> para indicar al proceso hijo opciones y argumentos de lÃ­nea de comandos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">HANDLE</span> <span class="n">handle</span> <span class="o">=</span> <span class="n">CreateProcess</span><span class="p">(</span><span class="s">"C:</span><span class="se">\\</span><span class="s">holamundo.exe"</span><span class="p">,</span> <span class="s">"/v /s foo.txt bar.png"</span><span class="p">,</span> <span class="cm">/* ... */</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Si el proceso hijo estÃ¡ programado en C o C&#43;&#43;, podrÃ¡ acceder a los argumentos <code>/v</code>, <code>/s</code>, <code>foo.txt</code> y <code>bar.png</code> a travÃ©s de los argumentos <code>argc</code> y <code>argv</code> de la funciÃ³n <a href="https://en.cppreference.com/w/c/language/main_function">main()</a> del programa:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="cm">/* . . . */</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>de forma que <code>argv[0]</code> contendrÃ¡ <code>/v</code>, <code>argv[2]</code> contendrÃ¡ <code>/s</code> y asÃ­ sucesivamente.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Obviamente, en otros lenguajes de programaciÃ³n se accede de manera diferente a estos argumentos de lÃ­nea de comandos.</p>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_variables_de_entorno">Variables de entorno</h6>
<div class="paragraph">
<p>Otra forma de pasar parÃ¡metros a un proceso hijo es usando las <strong>variables de entorno</strong>, que no son sino variables dinÃ¡micas que se pueden crear, leer y modificar durante la ejecuciÃ³n del proceso.</p>
</div>
<div class="paragraph">
<p>Las <strong>variables de entorno</strong> se gestionan con funciones especÃ­ficas ofrecidas por la API del sistema operativo:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 1. Funciones de la API para gestionar variables de entorno.</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">POSIX API</th>
<th class="tableblock halign-left valign-top">Windows API</th>
</tr>
</thead>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Leer</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/getenv.3.html">getenv()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getenvironmentvariable">GetEnvironmentVariable()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Leer todos</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man7/environ.7.html">environ</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/processenv/nf-processenv-getenvironmentstrings">GetEnvironmentStrings()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Crear / modificar</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/setenv.3.html">setenv()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setenvironmentvariable">SetEnvironmentVariable()</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>por ejemplo, en sistemas POSIX un programa leer la variable de entorno <code>PATH</code> asÃ­:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">char</span><span class="o">*</span> <span class="n">path</span> <span class="o">=</span> <span class="n">getenv</span><span class="p">(</span><span class="s">"PATH"</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>mientras que en Windows API es asÃ­:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">DWORD</span> <span class="n">buffSize</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
<span class="n">TCHAR</span> <span class="n">path</span><span class="p">[</span><span class="n">buffSize</span><span class="p">];</span>
<span class="n">GetEnvironmentVariable</span><span class="p">(</span><span class="s">"PATH"</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">buffSize</span><span class="p">);</span> <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>El valor de la variable de entorno <code>PATH</code> se copia en <code>path</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Usando <a href="https://man7.org/linux/man-pages/man3/setenv.3.html">setenv()</a> o <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setenvironmentvariable">SetEnvironmentVariable()</a> de forma similar, cualquier proceso puede crear variables de entorno que serÃ¡n accesibles a sus procesos hijos, porque por defecto los nuevos procesos heredan un duplicado de las variables de entorno de su proceso padre.
AsÃ­ se pueden pasar parÃ¡metros de configuraciÃ³n para alterar el comportamiento de los procesos hijo.</p>
</div>
<div class="paragraph">
<p>Todas las variantes de sistemas UNIX, asÃ­ como MS-DOS y todas las versiones de Microsoft Windows soportan variables de entorno.</p>
</div>
</div>
<div class="sect5">
<h6 id="_herencia_de_recursos">Herencia de recursos</h6>
<div class="paragraph">
<p>En algunos sistemas operativos los procesos hijos pueden heredar cierto tipo de recursos del proceso padre, lo que tambiÃ©n puede servir para inicializar y alterar el comportamiento del proceso hijo.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, en los sistemas POSIX todos los archivos abiertos por un proceso son heredados en el mismo estado por sus hijos.
Lo interesante es que en estos sistemas muchos recursos se gestionan como archivos.
Algunos ejemplo podrÃ­an ser: dispositivos de E/S, memoria compartida, tuberÃ­as, <em>sockets</em> y otros mecanismos de comunicaciÃ³n.</p>
</div>
<div class="paragraph">
<p>En POSIX todo proceso tiene, por defecto, tres archivos abiertos que corresponden a tres dispositivos de E/S especiales:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Entrada estÃ¡ndar</strong>, de dÃ³nde los procesos leen la entrada del teclado de la terminal.</p>
</li>
<li>
<p><strong>Salida estÃ¡ndar</strong>, donde el proceso escribe para mostrar texto en la pantalla de la terminal.</p>
</li>
<li>
<p><strong>Salida de error</strong>, usada para mostrar errores en la pantalla de la terminal.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Debido a la herencia de los archivos abiertos del proceso padre, todo proceso hijo tiene acceso a estos tres mismos dispositivos.
Y a su vez tambiÃ©n la tendrÃ¡n sus hijos y los hijos de Ã©stos.
De esta manera, todo proceso tiene acceso a los dispositivos de E/S de la terminal donde se ejecuta.
Pero tambiÃ©n permite a un proceso controlar el destino de la E/S de un proceso hijo ây de los hijos de Ã©steâ.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, si antes de crear el proceso hijo sustituye el dispositivo de salida estÃ¡ndar por un archivo real, todo lo que el hijo intente mostrar por pantalla se guardarÃ¡ en dicho archivo, en lugar de mostrarse.
Mientras que si lo hace con el dispositivo de entrada estÃ¡ndar, todo lo que pretenda leer de teclado realmente lo leerÃ¡ de un archivo que el padre puede haber preparado, como si de algÃºn tipo de control remoto se tratara.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Esta misma idea se puede extender a procesos que ofrecen servicios, ya sea a otros procesos del mismo sistema o a redes de ordenadores, como Internet.</p>
</div>
<div class="paragraph">
<p>Cada conexiÃ³n con un cliente es como archivo abierto, por lo que los hijos del proceso heredan las conexiones.
AsÃ­ que es comÃºn la estrategia de crear un hijo por conexiÃ³n para que la atienda en nombre del padre, mientras Ã©ste se encarga de recibir nuevas conexiones.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>En Microsoft Windows existe un mecanismo similar pero no por defecto.
La funciÃ³n <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a> de Windows API permite indicar si se quiere que el nuevo proceso herede los recursos abiertos.
Y tambiÃ©n tiene ajustes especÃ­ficos para la entrada y salida estÃ¡ndar y la salida de error del nuevo proceso.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_quÃ©_ocurre_con_la_ejecuciÃ³n_del_padre">QuÃ© ocurre con la ejecuciÃ³n del padre</h5>
<div class="paragraph">
<p>Se suelen contemplar dos posibilidades en tÃ©rminos de la ejecuciÃ³n del padre:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Que el padre continÃºe ejecutÃ¡ndose al mismo tiempo que el hijo.
Es lo mÃ¡s comÃºn en los sistemas multitarea actuales.</p>
</li>
<li>
<p>Que le padre quede detenido a la espera que de algunos o todos sus hijos terminen.
Era lo mÃ¡s frecuente en sistemas monotarea, como <a href="https://es.wikipedia.org/wiki/MS-DOS">MS-DOS</a>.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_cÃ³mo_se_construye_el_espacio_de_direcciones_de_los_procesos_hijo">CÃ³mo se construye el espacio de direcciones de los procesos hijo</h5>
<div class="paragraph">
<p>En general hay dos posibilidades:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Que el espacio de direcciones del proceso hijo sea un duplicado del que tiene el padre.
Es decir, que inicialmente el hijo tenga el mismo cÃ³digo y datos que el padre.
Es lo que hace <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> en los sistemas POSIX.</p>
</li>
<li>
<p>Que el espacio de direcciones del proceso hijo se cree desde cero y se cargue en Ã©l un nuevo programa.
Es lo que hace <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a> en Windows.
Por eso siempre hay que indicarle el nombre del programa que se quiere ejecutar en el nuevo proceso.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Esto lo veremos con mÃ¡s detalle en el <a href="#_ejemplos_de_operaciones_con_procesos">Apartado 9.7.3</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_terminaciÃ³n_de_procesos">9.7.2. TerminaciÃ³n de procesos</h4>
<div class="paragraph">
<p>Un proceso termina cuando se lo indica al sistema operativo con la llamada al sistema <strong>exit</strong>.
En ese momento puede devolver un valor de estado a su padre.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Esto ocurre en C y C&#43;&#43; incluso si el programa termina usando la sentencia <code>return</code> en <a href="https://en.cppreference.com/w/c/language/main_function">main()</a>.
Lo que ocurre es que es el cÃ³digo, introducido por el compilador, que llamÃ³ a <a href="https://en.cppreference.com/w/c/language/main_function">main()</a> es el que llama a <strong>exit</strong> usando el valor devuelto por <a href="https://en.cppreference.com/w/c/language/main_function">main()</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>El proceso padre puede esperar a que el hijo termine y recuperar ese valor a travÃ©s de la llamada al sistema <strong>wait</strong>.
Cuando un proceso termina, todos los recursos son liberados, incluyendo: la memoria fÃ­sica y virtual, archivos y dispositivos abiertos, bÃºferes de E/S, etc.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 2. Funciones de la API para salir, esperar y terminar procesos.</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">POSIX API</th>
<th class="tableblock halign-left valign-top">Windows API</th>
</tr>
</thead>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Salir</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.man7.org/linux/man-pages/man3/exit.3.html">exit()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess">ExitProcess()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Esperar (un hijo concreto)</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/waitpid.2.html">waitpid()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject">WaitForSingleObject()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Esperar (mÃºltiples hijos)</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/wait.2.html">wait()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects">WaitForMultipleObject()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Terminar otro proceso</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/kill.2.html">kill()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminateprocess">TerminateProcess()</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>En todo caso un proceso puede provocar la terminaciÃ³n de otro proceso a travÃ©s de una llamada al sistema.
Por ejemplo, en sistemas POSIX se usa un mecanismo llamado <strong>seÃ±ales</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">kill</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">SIGTERM</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>mientras que en Windows API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">TerminateProcess</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Habitualmente el proceso que invoca estas funciones es el proceso padre, ya que puede que sea el Ãºnico con permisos para hacerlo.</p>
</div>
<div class="paragraph">
<p>Los motivos para terminar un procesos hijo pueden ser:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>El hijo ha excedido el uso de algunos de los recursos reservados</strong>.
Obviamente esto tiene sentido cuando los hijos utilizan un subconjunto de los recursos asignados al padre.</p>
</li>
<li>
<p><strong>La tarea asignada al hijo ya no es necesaria</strong>.
Por ejemplo, se creÃ³ para comprimir un archivo pero el usuario ha pedido cancelar la operaciÃ³n.</p>
</li>
<li>
<p><strong>El padre termina y el sistema operativo estÃ¡ diseÃ±ado para no permitir que el hijo pueda seguir ejecutÃ¡ndose si no tiene un padre</strong>.
En esos sistemas, la terminaciÃ³n de un proceso provoca que el sistema operativo inicie lo que se denomina una <strong>terminaciÃ³n en cascada</strong>, en la que termina todos los procesos que cuelgan de dicho proceso.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En sistemas UNIX y estilo UNIX, si un proceso muere a sus hijos no terminan sino que se les reasigna como padre el proceso <strong>init</strong>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplos_de_operaciones_con_procesos">9.7.3. Ejemplos de operaciones con procesos</h4>
<div class="paragraph">
<p>En C estÃ¡ndar la funciÃ³n <a href="https://en.cppreference.com/w/c/program/system">system()</a> de la librerÃ­a estÃ¡ndar permite ejecutar otro proceso, con sus argumentos, esperar a que termine y obtener el valor de estado con el que finalizÃ³ el proceso.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">system</span><span class="p">(</span><span class="s">"holamundo -v foo.txt"</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Esta funciÃ³n es portable.
EstÃ¡ disponible en cualquier sistema donde haya un compilador de C estÃ¡ndar, pero sus funcionalidades son bastante limitadas.
Por ejemplo, no permite que el programa padre continÃºe su ejecuciÃ³n mientras se ejecuta el hijo, aunque el sistema sea multitarea y ese sea el comportamiento por defecto.
Tampoco facilita el control de los recursos que son heredados por el proceso hijo o hacer redirecciones de los dispositivos de E/S estÃ¡ndar.</p>
</div>
<div class="paragraph">
<p>Como hemos comentado anteriormente, para acceder a todas las funcionalidades ofrecidas por los sistemas operativos, muchas veces es necesario utilizar directamente la librerÃ­a del sistema.</p>
</div>
<div class="sect4">
<h5 id="_windows_api_2">Windows API</h5>
<div class="paragraph">
<p>En Windows la librerÃ­a del sistema ofrece la funciÃ³n <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a>.
A diferencia de <a href="https://en.cppreference.com/w/c/program/system">system()</a>, recibe muchÃ­simos argumentos, ya que permite configurar bastantes aspectos de la creaciÃ³n de un nuevo proceso.</p>
</div>
<div class="paragraph">
<p>En el <a href="#ejemplo_createprocess">Ejemplo 2</a> se puede ver como se usa <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a> para ejecutar un programa y esperar a que termine, de forma similar a como lo hace <a href="https://en.cppreference.com/w/c/program/system">system()</a>.</p>
</div>
<div id="ejemplo_createprocess" class="exampleblock">
<div class="title">Ejemplo 2. Crear un proceso usando Windows API</div>
<div class="content">
<div class="paragraph">
<p>El cÃ³digo fuente completo de este ejemplo estÃ¡ disponible en <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap09/createprocess.c">createprocess.c</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">STARTUPINFO</span> <span class="n">si</span> <span class="o">=</span> <span class="p">{</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">STARTUPINFO</span><span class="p">)</span> <span class="p">};</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="n">PROCESS_INFORMATION</span> <span class="n">pi</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span> <i class="conum" data-value="2"></i><b>(2)</b>

<span class="c1">// Crear procesos hijo y comprobar si no se creÃ³ con Ã©xito.</span>
<span class="k">if</span><span class="p">(</span> <span class="o">!</span> <span class="n">CreateProcess</span><span class="p">(</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="nb">NULL</span><span class="p">,</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="s">"C:</span><span class="se">\\</span><span class="s">Windows</span><span class="se">\\</span><span class="s">System32</span><span class="se">\\</span><span class="s">charmap.exe"</span><span class="p">,</span>  <i class="conum" data-value="4"></i><b>(4)</b> <i class="conum" data-value="5"></i><b>(5)</b>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="n">FALSE</span><span class="p">,</span> <i class="conum" data-value="6"></i><b>(6)</b>
    <span class="mi">0</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span>  <i class="conum" data-value="7"></i><b>(7)</b>
    <span class="nb">NULL</span><span class="p">,</span>  <i class="conum" data-value="8"></i><b>(8)</b>
    <span class="o">&amp;</span><span class="n">si</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">pi</span> <span class="p">))</span>
<span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span> <span class="n">stderr</span><span class="p">,</span> <span class="s">"Error (%d) al crear el proceso.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">()</span> <span class="p">);</span> <i class="conum" data-value="9"></i><b>(9)</b>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">printf</span><span class="p">(</span> <span class="s">"[PADRE] El PID del nuevo proceso hijo es: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pi</span><span class="p">.</span><span class="n">dwProcessId</span> <span class="p">);</span>

<span class="c1">// Esperar hasta que el hijo termine.</span>
<span class="n">WaitForSingleObject</span><span class="p">(</span> <span class="n">pi</span><span class="p">.</span><span class="n">hProcess</span><span class="p">,</span> <span class="n">INFINITE</span> <span class="p">);</span> <i class="conum" data-value="10"></i><b>(10)</b>

<span class="n">DWORD</span> <span class="n">dwExitCode</span><span class="p">;</span>
<span class="n">GetExitCodeProcess</span><span class="p">(</span> <span class="n">pi</span><span class="p">.</span><span class="n">hProcess</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dwExitCode</span> <span class="p">);</span> <i class="conum" data-value="11"></i><b>(11)</b>
<span class="n">printf</span><span class="p">(</span> <span class="s">"[PADRE] El valor de salida del proceso hijo es: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dwExitCode</span> <span class="p">);</span>

<span class="c1">// Cerrar los manejadores del proceso y del hilo principal del proceso.</span>
<span class="n">CloseHandle</span><span class="p">(</span> <span class="n">pi</span><span class="p">.</span><span class="n">hProcess</span> <span class="p">);</span> <i class="conum" data-value="12"></i><b>(12)</b>
<span class="n">CloseHandle</span><span class="p">(</span> <span class="n">pi</span><span class="p">.</span><span class="n">hThread</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfoa">STARTUPINFO</a> sirve para pasar a <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a> parÃ¡metros adicionales sobre el inicio de la aplicaciÃ³n, como configurar la redirecciÃ³n de la E/S estÃ¡ndar o caracterÃ­sticas de la primera ventana creada por la aplicaciÃ³n âen aplicaciones con interfaz grÃ¡ficaâ.
Si no se va a usar, debe inicializarse a 0, excepto el primer campo que debe contener el tamaÃ±o de la estructura.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-process_information">PROCESS_INFORMATION</a> sirve para devolver el manejador y el <strong>identificador de proceso</strong> del nuevo proceso.
Es comÃºn inicializar la estructura a 0.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a> devuelve <code>TRUE</code> o <code>FALSE</code>, en funciÃ³n de si ha tenido Ã©xito o no, respectivamente.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>El primer argumento â<code>lpApplicationName</code>â se usa para pasar la ruta del ejecutable, mientras que los argumentos de lÃ­nea de comando generalmente se pasan por el segundo â<code>lpCommandLine</code>â.
Si en <code>lpApplicationName</code> se indica NULL, se puede pasar todo junto por <code>lpCommandLine</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>En <code>lpCommandLine</code> indicamos la ruta al ejecutable y los argumentos de la lÃ­nea de comandos, si hicieran falta.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Con <code>bInheritHandles</code> a <code>FALSE</code> seÃ±alamos que no queremos que el proceso hijo herede ningÃºn manejador abierto del proceso padre.
Estos manejadores son recursos a los que el padre tiene acceso y, si fuera necesario, el hijo tambiÃ©n podrÃ­a tenerlo.
Los manejadores pueden representar, por ejemplo, archivos abiertos, tuberÃ­as, <em>sockets</em> u otros mecanismos de comunicaciÃ³n, procesos o archivos mapeados en memoria, entre muchos otros tipos de recursos.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Con <code>NULL</code> en <code>lpEnvironment</code> indicamos que el hijo herede el conjunto de variables de entorno directamente del padre.
La otra opciÃ³n es indicar un nuevo conjunto de variables de entorno.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td><code>lpCurrentDirectory</code> sirve para indicar el directorio del trabajo del proceso hijo.
Es decir, el directorio respecto al que se resolverÃ¡n las rutas de archivo relativas.
Con <code>NULL</code> indicamos que utilice la misma ruta que el proceso padre.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>Si <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a> falla, devuelve <code>FALSE</code>.
Llamando a <a href="https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError()</a> obtiene el cÃ³digo que identifica el motivo del error de la Ãºltima funciÃ³n utilizada de Windows API.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>Usando <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject">WaitForSingleObject()</a> hacemos que el proceso padre se quede en estado <strong>esperando</strong> âsin que pueda seguir ejecutÃ¡ndoseâ hasta que el proceso hijo termine.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>Cuando el proceso ha terminado, el padre puede conocer su valor de salida.
Es decir, el valor usado para terminar en la sentencia <code>return</code> de <a href="https://en.cppreference.com/w/c/language/main_function">main()</a> o al llamar a  <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess">ExitProcess()</a> en el programa del proceso hijo.
Como convenciÃ³n, el hijo indica con un 0 que terminÃ³ con Ã©xito, mientras que con un valor distinto indica que tuvo algÃºn tipo de problema.</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>Cuando ya no hace falta obtener informaciÃ³n del proceso hijo o manipularlo, es necesario cerrar los manejadores devueltos por <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a>.
AsÃ­ el sistema operativo sabe que las estructuras de datos relacionadas con el proceso hijo ya no son necesarias, por lo que pueden liberarse.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a> siempre necesita la ruta a un ejecutable âsea en el primer o en el segundo argumento de la funciÃ³nâ porque se utiliza para crear un proceso completamente limpio y ejecutar en Ã©l un nuevo programa.</p>
</div>
</div>
<div class="sect4">
<h5 id="procesos_posix_api">POSIX API</h5>
<div class="paragraph">
<p>Por el contrario, en los sistemas POSIX se utiliza una estrategia muy diferente.
Los nuevos procesos se crean con la llamada <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>, que se encargar de crearlo como una copia del proceso padre.</p>
</div>
<div class="exampleblock">
<div class="title">Ejemplo 3. Crear un proceso en sistemas POSIX</div>
<div class="content">
<div class="paragraph">
<p>El cÃ³digo fuente completo de este ejemplo estÃ¡ disponible en <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap09/fork.c">fork.c</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">pid_t</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span> <i class="conum" data-value="7"></i><b>(7)</b>

<span class="c1">// Crear un proceso hijo</span>
<span class="n">pid_t</span> <span class="n">child</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span> <i class="conum" data-value="1"></i><b>(1)</b>

<span class="k">if</span> <span class="p">(</span><span class="n">child</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">{</span>
    <span class="c1">// AquÃ­ solo entra el proceso hijo</span>
    <span class="n">puts</span><span class="p">(</span> <span class="s">"[HIJO] Â¡Soy el proceso hijo!"</span> <span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[HIJO] El valor de mi variable 'child' es: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">child</span> <span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[HIJO] Este es mi PID: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">()</span> <span class="p">);</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[HIJO] El valor de mi variable 'pid' es: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pid</span> <span class="p">);</span> <i class="conum" data-value="7"></i><b>(7)</b>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[HIJO] El PID de mi padre es: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getppid</span><span class="p">()</span> <span class="p">);</span> <i class="conum" data-value="7"></i><b>(7)</b>

    <span class="n">puts</span><span class="p">(</span> <span class="s">"[HIJO] Durmiendo 10 segundos..."</span> <span class="p">);</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[HIJO] Salgo con %d Â¡Adios!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">status</span> <span class="p">);</span>
    <span class="k">return</span> <span class="n">status</span><span class="p">;</span> <i class="conum" data-value="9"></i><b>(9)</b>
<span class="p">}</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">child</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>  <i class="conum" data-value="3"></i><b>(3)</b> <i class="conum" data-value="4"></i><b>(4)</b>
<span class="p">{</span>
    <span class="c1">// AquÃ­ solo entra el proceso padre</span>
    <span class="n">puts</span><span class="p">(</span> <span class="s">"[PADRE] Â¡Soy el proceso padre!"</span> <span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[PADRE] El valor de mi variable 'child' es: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">child</span> <span class="p">);</span>  <i class="conum" data-value="3"></i><b>(3)</b> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[PADRE] Este es mi PID: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">()</span> <span class="p">);</span> <i class="conum" data-value="7"></i><b>(7)</b>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[PADRE] El valor de mi variable 'pid' es: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pid</span> <span class="p">);</span> <i class="conum" data-value="7"></i><b>(7)</b>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[PADRE] El PID de mi padre es: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getppid</span><span class="p">()</span> <span class="p">);</span>

    <span class="n">puts</span><span class="p">(</span> <span class="s">"[PADRE] Voy a esperar a que mi hijo termine..."</span> <span class="p">);</span>

    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
    <span class="n">wait</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">status</span> <span class="p">);</span>  <i class="conum" data-value="8"></i><b>(8)</b> <i class="conum" data-value="9"></i><b>(9)</b>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[PADRE] El valor de salida de mi hijo fue: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">WEXITSTATUS</span><span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">);</span> <i class="conum" data-value="9"></i><b>(9)</b>

    <span class="n">puts</span><span class="p">(</span> <span class="s">"[PADRE] Â¡Adios!"</span> <span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span> <i class="conum" data-value="5"></i><b>(5)</b>
    <span class="c1">// AquÃ­ solo entra el padre si no pudo crear el hijo</span>
    <span class="n">fprintf</span><span class="p">(</span> <span class="n">stderr</span><span class="p">,</span> <span class="s">"Error (%d) al crear el procesos: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">errno</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">)</span> <span class="p">);</span> <i class="conum" data-value="6"></i><b>(6)</b>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>El proceso llama a <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> pero al retornar de la llamada vuelven dos procesos: el proceso padre, que es el que llamÃ³ originalmente a <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>, y el proceso hijo.
Como el proceso hijo es una copia del padre, tiene el mismo cÃ³digo, las mismas variables y los mismos recursos que tenÃ­a el padre en el momento de llamar a <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>.
La Ãºnica diferencia es el valor devuelto por <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>, que guardamos en <code>child</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Los dos procesos ejecutan el mismo programa, asÃ­ que ambos llegan a la lÃ­nea detrÃ¡s del <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>.
Como queremos que cada proceso haga cosas diferentes, necesitamos que cada uno vaya a ramas distintas del cÃ³digo.
Eso se hace comprobando el valor de <code>child</code>, porque si vale 0 es que el proceso que actualmente ejecuta el programa es el hijo.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Si, por el contrario, el valor de <code>child</code> es mayor de 0, el proceso que ejecuta el programa es el padre y el valor de <code>child</code> es el PID del proceso hijo creado.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>AsÃ­ que el valor de <code>child</code> en el padre coincide con el devuelto por <a href="https://man7.org/linux/man-pages/man2/getpid.2.html">getpid()</a> en el hijo.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Finalmente, si el valor devuelto por <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> es negativo, es que ocurriÃ³ un error y el proceso hijo no llegÃ³ a crearse.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>En los sistemas POSIX es comÃºn que las llamadas al sistema devuelvan un valor negativo para indicar un error.
El motivo del error se puede conocer a travÃ©s de la variable global <a href="https://man7.org/linux/man-pages/man3/errno.3.html">errno</a>, que siempre guarda el cÃ³digo de identificaciÃ³n del error en la Ãºltima funciÃ³n invocada de la API POSIX.
La funciÃ³n <a href="https://man7.org/linux/man-pages/man3/strerror.3.html">strerror()</a> permite obtener un texto descriptivo de cualquier valor de <a href="https://man7.org/linux/man-pages/man3/errno.3.html">errno</a>, lo que siempre resulta Ãºtil para crear mensajes de error que ayuden a determinar dÃ³nde estuvo el problema.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>A modo de ejemplo hemos guardado el PID del proceso en la variable <code>pid</code>, antes de la llamada a <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>.
Como el proceso hijo es una copia del proceso padre, la variable existe en ambos pero en el proceso hijo su valor coincide con lo devuelto por <a href="https://man7.org/linux/man-pages/man2/getppid.2.html">getppid()</a> mientras que en el proceso padre con lo devuelto por <a href="https://man7.org/linux/man-pages/man2/getpid.2.html">getpid()</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td><a href="https://man7.org/linux/man-pages/man2/wait.2.html">wait()</a> hace que el proceso padre interrumpa su ejecuciÃ³n hasta que algÃºn hijo termine y devuelve el estado de salida en <code>status</code>.
<div class="paragraph">
<p>Debemos asegurarnos de llamar a <a href="https://man7.org/linux/man-pages/man2/wait.2.html">wait()</a> o <a href="https://man7.org/linux/man-pages/man2/waitpid.2.html">waitpid()</a> una vez por cada proceso hijo, en algÃºn momento, porque asÃ­ es como el sistema sabe que el padre ya no tiene mÃ¡s interÃ©s en el proceso y puede liberar su PCB, dÃ³nde se guarda el estado de salida.
No hacerlo genera <strong>procesos zombi</strong> o <em>defunct</em>.</p>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>El valor de salida del proceso hijo lo obtiene el proceso a travÃ©s del estado de salida devuelto por <a href="https://man7.org/linux/man-pages/man2/wait.2.html">wait()</a>.
Pero ese estado contiene mÃ¡s informaciÃ³n sobre la causa por la que el proceso terminÃ³.
Para recuperar el valor de salida se usa la macro <code>WEXITSTATUS</code> sobre el estado de salida.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Lo siguiente es un posible resultado de ejecutar el programa anterior en una terminal de Linux,
numerado con las anotaciones realizadas al cÃ³digo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./fork
[PADRE] Â¡Soy el proceso padre!
[PADRE] El valor de mi variable 'child' es: 2360 <i class="conum" data-value="4"></i><b>(4)</b>
[PADRE] Este es mi PID: 2359 <i class="conum" data-value="7"></i><b>(7)</b>
[PADRE] El valor de mi variable 'pid' es: 2359 <i class="conum" data-value="7"></i><b>(7)</b>
[HIJO] Â¡Soy el proceso hijo!
[PADRE] El PID de mi padre es: 1857
[PADRE] Voy a esperar a que mi hijo termine...
[HIJO] El valor de mi variable 'child' es: 0 <i class="conum" data-value="2"></i><b>(2)</b>
[HIJO] Este es mi PID: 2360
[HIJO] El valor de mi variable 'pid' es: 2359 <i class="conum" data-value="7"></i><b>(7)</b>
[HIJO] El PID de mi padre es: 2359 <i class="conum" data-value="7"></i><b>(7)</b>
[HIJO] Durmiendo 10 segundos...
[HIJO] Salgo con 42 Â¡Adios! <i class="conum" data-value="9"></i><b>(9)</b>
[PADRE] El valor de salida de mi hijo fue: 42 <i class="conum" data-value="9"></i><b>(9)</b>
[PADRE] Â¡Adios!</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Aunque pueda parecer algo complejo, esta estrategia facilita la comunicaciÃ³n entre procesos.
Es muy sencillo lanzar otro proceso para hacer una tarea en paralelo que tendrÃ¡ automÃ¡ticamente una copia de los datos del proceso original.</p>
</div>
<div class="paragraph">
<p>Como se trata de una copia, las nuevas variables o la modificaciÃ³n de variables existentes que realice cualquiera de los procesos, no serÃ¡n visibles para el otro.
Es decir, despuÃ©s del <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> ambos procesos son complemente independientes.
Pero como el proceso hijo hereda el acceso a todo tipo de recursos abiertos por el proceso padre, como: archivos, tuberÃ­as, <em>sockets</em> o regiones de memoria compartida, entre muchos otros recursos; es muy sencillo crear un canal de comunicaciÃ³n entre ambos procesos, si fuera necesario.</p>
</div>
<div class="paragraph">
<p>Sin embargo, <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> no proporciona una funcionalidad similar a la de <a href="https://en.cppreference.com/w/c/program/system">system()</a>.
No sirve para crear otro proceso con un programa diferente.
Para eso necesitamos <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a>, una familia de funciones cuyo propÃ³sito es cargar un nuevo programa en el proceso que la invoca.</p>
</div>
<div class="exampleblock">
<div class="title">Ejemplo 4. Ejecutar otro programa en un proceso nuevo en sistemas POSIX</div>
<div class="content">
<div class="paragraph">
<p>El cÃ³digo fuente completo de este ejemplo estÃ¡ disponible en <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap09/fork-exec.c">fork-exec.c</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="c1">// Crear un proceso hijo</span>
<span class="n">pid_t</span> <span class="n">child</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span> <i class="conum" data-value="1"></i><b>(1)</b>

<span class="k">if</span> <span class="p">(</span><span class="n">child</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// AquÃ­ solo entra el proceso hijo</span>
    <span class="n">puts</span><span class="p">(</span> <span class="s">"[HIJO] Â¡Soy el proceso hijo!"</span> <span class="p">);</span>
    <span class="n">puts</span><span class="p">(</span> <span class="s">"[HIJO] Voy a ejecutar el comando 'ls'"</span> <span class="p">);</span>

    <span class="cm">/* Hacer otras cosas necesarias antes de ejecutar el programa... */</span> <i class="conum" data-value="4"></i><b>(4)</b>

    <span class="n">execl</span><span class="p">(</span> <span class="s">"/bin/ls"</span><span class="p">,</span> <span class="s">"ls"</span><span class="p">,</span> <span class="s">"-l"</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">);</span>   <i class="conum" data-value="2"></i><b>(2)</b> <i class="conum" data-value="3"></i><b>(3)</b> <i class="conum" data-value="5"></i><b>(5)</b>

    <span class="n">fprintf</span><span class="p">(</span> <span class="n">stderr</span><span class="p">,</span> <span class="s">"Error (%d) al ejecuta el programa: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">errno</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">)</span> <span class="p">);</span> <i class="conum" data-value="6"></i><b>(6)</b>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <i class="conum" data-value="7"></i><b>(7)</b>
<span class="p">}</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">child</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// AquÃ­ solo entra el proceso padre</span>
    <span class="n">puts</span><span class="p">(</span> <span class="s">"[PADRE] Â¡Soy el proceso padre!"</span> <span class="p">);</span>
    <span class="n">puts</span><span class="p">(</span> <span class="s">"[PADRE] Voy a esperar a que mi hijo termine..."</span> <span class="p">);</span>

    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
    <span class="n">wait</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">status</span> <span class="p">);</span> <i class="conum" data-value="8"></i><b>(8)</b>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[PADRE] El valor de salida de mi hijo fue: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">WEXITSTATUS</span><span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">);</span>

    <span class="n">puts</span><span class="p">(</span> <span class="s">"[PADRE] Â¡Adios!"</span> <span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="c1">// AquÃ­ solo entra el padre si no pudo crear el hijo</span>
    <span class="n">fprintf</span><span class="p">(</span> <span class="n">stderr</span><span class="p">,</span> <span class="s">"Error (%d) al crear el procesos: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">errno</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">)</span> <span class="p">);</span>
    <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Primero creamos un proceso hijo, donde ejecutaremos el nuevo programa.
Si nos diera por llamar directamente a una funciÃ³n de la familia <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a>, nuestro programa serÃ­a sustituido y no tendrÃ­amos ningÃºn control sobre lo que pase despuÃ©s.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>En la rama de cÃ³digo que se va a ejecutar en el hijo âgracias a la comprobaciÃ³n del valor devuelto por <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>â ejecutamos la funciÃ³n de la familia <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> que mÃ¡s nos interese.
Esta funciÃ³n no crea otro proceso, sino que carga el programa indicado en el proceso hijo, sustituyendo asÃ­ a nuestro programa.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Todas las funciones de la familia <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> reciben como primer argumento la ruta al ejecutable, pero en <code>execlp()</code> en particular, a continuaciÃ³n se indican los argumentos de lÃ­nea de comandos, tal y como queremos que los reciba el programa en el argumento <code>argv</code> de su <a href="https://en.cppreference.com/w/c/language/main_function">main()</a>.
Es decir, que el programa del comando <code>/bin/ls</code> recibirÃ¡ <code>ls</code> y <code>-l</code> en <code>argv[0]</code> y <code>argv[1]</code>, respectivamente.
El <code>NULL</code> del final indica cuando no hay mÃ¡s argumentos de lÃ­nea de comandos para pasar.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Antes de ejecutar la funciÃ³n <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> se pueden hacer cosas para configurar adecuadamente el proceso donde se ejecutarÃ¡ el nuevo programa.
Por ejemplo, cambiar las variables de entorno, redirigir la E/S estÃ¡ndar, cambiar el usuario al que pertenece el proceso âsi originalmente se ejecuta con un usuario con ese privilegioâ o cerrar archivos abiertos del procesos padre que ha heredado el proceso hijo y que, obviamente, no queremos que se queden abiertos para programas diferentes al nuestro.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Las funciones <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> no retornan si tienen Ã©xito, porque el programa actual es sustituido por el indicado, que comenzarÃ¡ a ejecutarse de su <a href="https://en.cppreference.com/w/c/language/main_function">main()</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Si la funciÃ³n <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> retorna es porque fallÃ³ y, como es comÃºn, el motivo del error estÃ¡ disponible en <a href="https://man7.org/linux/man-pages/man3/errno.3.html">errno</a>.
Un motivo de fallo muy tÃ­pico es que el ejecutable indicado no exista.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Si la funciÃ³n <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> retorna, la ejecuciÃ³n del programa en el proceso hijo continua hasta salir de <a href="https://en.cppreference.com/w/c/language/main_function">main()</a>.
Generalmente, el proceso hijo no es Ãºtil si no puede ejecutar el programa que le hemos indicado.
Por eso es importante asegurarnos de que el proceso hijo termina, si <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> falla.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Mientras todo lo anterior ocurre en el proceso hijo, el proceso padre espera.
Cuando el proceso hijo termine, el padre podrÃ¡ obtener su estado de salir para saber si tuvo Ã©xito o no.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Lo siguiente es un posible resultado de ejecutar el programa anterior en una terminal de Linux,
numerado con las anotaciones realizadas al cÃ³digo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./fork-exec
[PADRE] Â¡Soy el proceso padre!
[PADRE] Voy a esperar a que mi hijo termine...
[HIJO] Â¡Soy el proceso hijo!
[HIJO] Voy a ejecutar el comando 'ls'
total 628 <i class="conum" data-value="2"></i><b>(2)</b>
-rwxr--r-- 1 jesus jesus 72640 Sep 16 13:41 fifo-client
-rwxr--r-- 1 jesus jesus 72784 Sep 16 13:41 fifo-server
-rwxr--r-- 1 jesus jesus 20056 Sep 16 13:41 fork
-rwxr-xr-x 1 jesus jesus 19896 Sep 18 13:24 fork-exec
-rwxr--r-- 1 jesus jesus 80744 Sep 16 13:41 mmap
-rwxr--r-- 1 jesus jesus 45712 Sep 16 13:41 pipe
-rwxr--r-- 1 jesus jesus 87024 Sep 16 13:41 shared-memory
-rwxr--r-- 1 jesus jesus 77696 Sep 16 13:41 shared-memory-sync
-rwxr--r-- 1 jesus jesus 19608 Sep 16 13:41 softstack-c
-rwxr--r-- 1 jesus jesus 39328 Sep 16 13:41 softstack-cpp
-rwxr--r-- 1 jesus jesus  9920 Sep 16 13:41 syscall
-rwxr--r-- 1 jesus jesus 40712 Sep 16 13:41 threads-mutex-pthread
-rwxr--r-- 1 jesus jesus 39944 Sep 16 13:41 threads-pthread
[PADRE] El valor de salida de mi hijo fue: 0 <i class="conum" data-value="8"></i><b>(8)</b>
[PADRE] Â¡Adios!</pre>
</div>
</div>
<div class="paragraph">
<p>Veamos quÃ© ocurre si la lÃ­nea de la funciÃ³n <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> fuera:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">execl</span><span class="p">(</span> <span class="s">"/bin/ls"</span><span class="p">,</span> <span class="s">"ls"</span><span class="p">,</span> <span class="s">"-l"</span><span class="p">,</span> <span class="s">"/foo"</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>para intentar ver el contenido del directorio <code>/foo</code>, que no existe:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./fork-exec
[PADRE] Â¡Soy el proceso padre!
[PADRE] Voy a esperar a que mi hijo termine...
[HIJO] Â¡Soy el proceso hijo!
[HIJO] Voy a ejecutar el comando 'ls'
ls: cannot access '/foo': No such file or directory <i class="conum" data-value="1"></i><b>(1)</b>
[PADRE] El valor de salida de mi hijo fue: 2 <i class="conum" data-value="2"></i><b>(2)</b>
[PADRE] Â¡Adios!</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>El comando <code>ls</code> se ejecuta pero falla porque el directorio indicado no existe.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Por eso el programa, al terminar el proceso, no devuelve 0 sino 2 y es ese el valor que recibe el proceso padre.
Esto le permite saber al proceso padre que el comando <code>ls</code> no tuvo Ã©xito.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Y finalmente cambiemos la lÃ­nea de la funciÃ³n <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> asÃ­:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">execl</span><span class="p">(</span> <span class="s">"/noexists"</span><span class="p">,</span> <span class="s">"ls"</span><span class="p">,</span> <span class="s">"-l"</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>para que intente ejecutar un programa que no existe:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./fork-exec
[PADRE] Â¡Soy el proceso padre!
[PADRE] Voy a esperar a que mi hijo termine...
[HIJO] Â¡Soy el proceso hijo!
[HIJO] Voy a ejecutar el comando 'ls'
Error (2) al ejecuta el programa: No such file or directory <i class="conum" data-value="1"></i><b>(1)</b>
[PADRE] El valor de salida de mi hijo fue: 255 <i class="conum" data-value="2"></i><b>(2)</b>
[PADRE] Â¡Adios!</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> falla y se muestra el mensaje de error con el motivo.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>El proceso hijo termina con -1 y asÃ­ llega ese valor al proceso padre.
Al utilizar un valor de salida diferente a los que usa el programa que intenta ejecutar, el padre distingue las terminaciones causadas por errores al llamar a <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> de los errores del propio programa.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Todas las funciones <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> hacen lo mismo.
Primero liberan la memoria reservada en el proceso, despuÃ©s cargan el nuevo programa y finalmente inicia la ejecuciÃ³n del programa desde su punto de entrada.
La diferencia entre las distintas funciones estÃ¡ en los argumentos que aceptan.
Esa diferencia se puede conocer fijÃ¡ndonos en las letras al final del nombre de cada funciÃ³n:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Sin 'p'</strong>, como <code>execl()</code> o <code>execv()</code>, el primer argumento de la funciÃ³n es la ruta hasta el ejecutable del programa que se quiere ejecutar.</p>
</li>
<li>
<p><strong>Con 'p'</strong>, como <code>execlp()</code> o <code>execvp()</code>, la funciÃ³n busca el ejecutable como lo hace la <em>shell</em>.
Es decir, si el primer argumento no contiene ninguna '/' se toma como el nombre del ejecutable y se busca en los directorios listados en la variable de entorno <code>PATH</code>.
Si el primero argumento contienen alguna '/', se considera una ruta y se busca directamente el ejecutable en ella.</p>
</li>
<li>
<p><strong>Con 'l'</strong>, como <code>execl()</code> o <code>execlp()</code>, los argumentos de lÃ­nea de comandos para pasar al programa se indican directamente como argumentos diferentes de la funciÃ³n âpor ejemplo <code>execl("/bin/ls", "ls", "-l", "-a" NULL)</code>â lo que es ideal cuando el nÃºmero de argumentos es fijo.
La lista de argumentos debe terminar en <code>NULL</code>.</p>
</li>
<li>
<p><strong>Con 'v'</strong>, como <code>execv()</code> o <code>execvp()</code>, los argumentos de la lÃ­nea de comandos para pasar al programa se indican en un <em>array</em> de punteros a cadenas terminadas en '\0', lo que resulta muy prÃ¡ctico si el nÃºmero de argumentos es desconocido en el momento de compilar.
El Ãºltimo elemento del <em>array</em> debe apuntar a <code>NULL</code>.
Por ejemplo:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">"ls"</span><span class="p">,</span> <span class="s">"-l"</span><span class="p">,</span> <span class="s">"-a"</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>
<span class="n">execv</span><span class="p">(</span><span class="s">"/bin/ls"</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p><strong>Con 'e'</strong>, como <code>execvpe()</code> o <code>execle()</code>, la funciÃ³n admite un argumento adicional para indicar el conjunto de variables de entorno con el que se ejecutarÃ¡ el nuevo programa.
Con las otras funciones <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> se conservan las variables de entorno actuales en el proceso que llama a la funciÃ³n.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_procesos_cooperativos">9.8. Procesos cooperativos</h3>
<div class="paragraph">
<p>Desde el punto de vista de la cooperaciÃ³n podemos clasificar los procesos en dos grupos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Los <strong>procesos independientes</strong>, que no afectan o pueden ser afectados por otros procesos del sistema. Cualquier proceso que no comparte datos âtemporales o persistentesâ con otros procesos es independiente.</p>
</li>
<li>
<p>Los <strong>procesos cooperativos</strong>, que pueden afectar o ser afectados por otros procesos ejecutados en el sistema.
Los procesos que comparten datos, sea cual sea la forma en la que lo hacen, siempre son cooperativos.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_motivaciones_para_la_colaboraciÃ³n_entre_procesos">9.8.1. Motivaciones para la colaboraciÃ³n entre procesos</h4>
<div class="paragraph">
<p>Hay diversos motivos para proporcionar un entorno que permita la cooperaciÃ³n de los procesos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>ComparticiÃ³n de informaciÃ³n</strong>.
Dado que varios usuarios pueden estar interesados en los mismos bloques de informaciÃ³n âpor ejemplo, en un archivo compartidoâ el sistema operativo debe proporcionar un entorno que permita el acceso concurrente a este tipo de recursos.</p>
</li>
<li>
<p><strong>Velocidad de cÃ³mputo</strong>.
Para que una tarea se ejecute mÃ¡s rÃ¡pido se puede partir en subtareas que se ejecuten en paralelo.
Es importante destacar que la mejora en la velocidad sÃ³lo es posible si el sistema tiene varios componentes de procesamiento como procesadores âsi se quiere acelerar la ejecuciÃ³n en la CPUâ o canales E/S âsi se quieren acelerar las operaciones de E/S â.</p>
</li>
<li>
<p><strong>Modularidad</strong>.
Podemos querer crear nuestro software de forma modular, dividiendo las funciones del programa en procesos separados que se comunican entre sÃ­.</p>
</li>
<li>
<p><strong>Conveniencia</strong>.
Incluso un usuario individual puede querer hacer varias tareas al mismo tiempo.
Por ejemplo, editar, imprimir y compilar al mismo tiempo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Las ejecuciÃ³n simultÃ¡nea de procesos cooperativos requiere mecanismos tanto para comunicar unos con otros como para sincronizar sus acciones (vÃ©ase el <a href="#_sincronizaciÃ³n">CapÃ­tulo 13</a>).</p>
</div>
</div>
<div class="sect3">
<h4 id="_comunicaciÃ³n_entre_procesos">9.8.2. ComunicaciÃ³n entre procesos</h4>
<div class="paragraph">
<p>Para comunicar procesos cooperativos existen diversas aproximaciones, que en general se pueden encajar en alguna de las siguientes estrategias:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Memoria compartida</dt>
<dd>
<p>MÃ©todo de comunicaciÃ³n en el que los procesos utilizan regiones compartidas de la memoria principal para compartir informaciÃ³n.</p>
</dd>
<dt class="hdlist1">Paso de mensajes</dt>
<dd>
<p>MÃ©todo en el que los procesos utilizan funciones del sistema operativo para enviarse mensajes entre ellos, compartiendo informaciÃ³n y sincronizando acciones, sin necesidad de compartir memoria.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>En la <a href="#modelos_de_comunicaciÃ³n">Figura 29</a> se puede un esquema comparativo entre ambos modelos de comunicaciÃ³n.
Veremos cada uno en detalle en el <a href="#_memoria_compartida">CapÃ­tulo 11</a> y el <a href="#_comunicaciÃ³n_mediante_de_paso_de_mensajes">CapÃ­tulo 10</a>, respectivamente.</p>
</div>
<div id="modelos_de_comunicaciÃ³n" class="imageblock">
<div class="content">
<img src="C09-procesos/media/modelos_comunicaciÃ³n.svg" alt="modelos comunicaciÃ³n">
</div>
<div class="title">Figura 29. Modelos de comunicaciÃ³n.</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comunicaciÃ³n_mediante_de_paso_de_mensajes">10. ComunicaciÃ³n mediante de paso de mensajes</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>32 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>El <strong>paso de mensajes</strong> es un mecanismo que permite a los procesos compartir informaciÃ³n y sincronizar sus acciones sin necesidad de compartir recursos âcompartir memoria, archivos, etc.â</p>
</div>
<div class="paragraph">
<p>Esto lo hace especialmente Ãºtil en entornos distribuidos, dÃ³nde los procesos a comunicar residen en ordenadores diferentes conectados a una red, por lo que tiene muy difÃ­cil âo incluso imposibleâ compartir memoria u otros recursos para comunicarse.
En este caso, el sistema operativo es el encargado de codificar los mensajes y enviarlos a travÃ©s de la red para hacerlos llegar a su destinatario.
La web âdonde un navegador se conecta a un servidor web para obtener contenidoâ y el resto de servicios de Internet son ejemplos de sistemas de paso de mensajes.</p>
</div>
<div class="paragraph">
<p>El sistema de paso de mensajes debe ser proporcionado por el sistema operativo que, a diferencia de cuando se usa memoria compartida, se encarga de la sincronizaciÃ³n âya que no existen riesgos en el envÃ­o y recepciÃ³n de mensajes al mismo tiempoâ y de establecer el formato que deben tener los datos del mensaje.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En alguna fuentes se sigue haciendo referencia al tÃ©rmino <strong>IPC</strong> (<em>Interprocess Communication</em>) âo <strong>comunicaciÃ³n entre procesos</strong>â para identificarlo exclusivamente con <strong>sistemas de paso de mensajes</strong>.
Sin embargo, la <strong>memoria compartida</strong> y otras tÃ©cnicas tambiÃ©n sirven para Â«comunicar procesosÂ», por lo que es mÃ¡s adecuado usar el tÃ©rmino <strong>IPC</strong> para englobar todas las tÃ©cnicas conocidas de comunicaciÃ³n entre procesos.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Los sistemas de paso de mensaje de cualquier sistema operativo debe proporcionar al menos dos llamadas al sistema similares a:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>send( message )</strong> para mandar mensajes a otro proceso.</p>
</li>
<li>
<p><strong>receive( &amp;message )</strong> para recibir mensajes de otro proceso y copiarlo en <em>message</em>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Vamos a hablar de funciones de un sistema de paso de mensajes hipotÃ©tico.
Meros ejemplos para ilustrar la diferentes alternativas.
Esto no significa que en los sistemas operativos reales las funciones se llamen asÃ­ y tengan esos mismos argumentos.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Para que estas llamadas puede enviar y recibir mensajes entre dos procesos es necesario que haya un <strong>enlace de comunicaciones</strong> entre ambos.
No trataremos aquÃ­ la implementaciÃ³n fÃ­sica del enlace âque por ejemplo puede ser mediante memoria compartida, un bus hardware o una red de ordenadoresâ sino de su implementaciÃ³n lÃ³gica, es decir, las caracterÃ­sticas de la interfaz que usan las aplicaciones para comunicarse con sus correspondientes operaciones de envÃ­o y recepciÃ³n.</p>
</div>
<div class="sect2">
<h3 id="_tamaÃ±o_del_mensaje">10.1. TamaÃ±o del mensaje</h3>
<div class="paragraph">
<p>Los diseÃ±adores del sistema operativo deben escoger entre implementar un sistema de paso de mensajes con mensajes de tamaÃ±o fijo o mensajes de tamaÃ±o variable:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Mensajes de tamaÃ±o fijo</strong>.
La implementaciÃ³n del sistema operativo es muy sencilla pero el uso de la interfaz por parte de las aplicaciones es mucho mÃ¡s compleja.</p>
<div class="paragraph">
<p>Por ejemplo, para comunicar procesos en un mismo ordenador cada enlace puede tener un bÃºfer de tamaÃ±o fijo donde se copia el mensaje enviado y de donde se extrae el mensaje al recibirlo.
Esto es muy sencillo de implementar en el sistema operativo.
Sin embargo, si el desarrollador de la aplicaciÃ³n quiere enviar algo de mayor tamaÃ±o que el tamaÃ±o del mensaje, debe trocearlo en varios mensajes para enviarlo y reconstruirlo al recibirlo.</p>
</div>
</li>
<li>
<p><strong>Mensajes de tamaÃ±o variable</strong>.
La implementaciÃ³n del sistema operativo es mÃ¡s compleja, ya que ahora tiene que gestionar la memoria para almacenar mensajes de tamaÃ±o variable hasta que son recibidos.
Sin embargo, la programaciÃ³n de aplicaciones es mÃ¡s simple puesto que el programador puede mandar mensajes de cualquier tamaÃ±o sin ninguna preocupaciÃ³n</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_comunicaciÃ³n_orientada_a_flujos">10.1.1. ComunicaciÃ³n orientada a flujos</h4>
<div class="paragraph">
<p>En algunos sistemas con <strong>mensajes de tamaÃ±o variable</strong> no se preserva la separaciÃ³n entre mensajes al recibirlos.
Es decir, que los procesos leen un nÃºmero arbitrario de bytes, donde puede haber parte de un mensaje o varios mensajes al mismo tiempo.
Por ejemplo, en esos sistemas el transmisor puede mandar tres mensajes de 16000, 3200 y 100 bytes, pero el receptor leer la secuencia de bytes en bloques de 512 bytes.</p>
</div>
<div class="paragraph">
<p>A esto se lo denomina <strong>comunicaciÃ³n orientada a flujos</strong> o <strong><em>(streams)</em></strong>.
Si usamos este tipo de sistema es importante conservar la separaciÃ³n entre los mensajes recibidos, serÃ¡ nuestra responsabilidad escoger un formato de mensaje adecuado que permita al receptor recuperar dÃ³nde comienza y termina un mensaje dentro de la secuencia de bytes.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_referenciaciÃ³n">10.2. ReferenciaciÃ³n</h3>
<div class="paragraph">
<p>Los procesos que se quieran comunicar debe tener una forma de seÃ±alarse el uno al otro.
Para ello el diseÃ±ador del sistema puede elegir que el sistema de paso de mensajes sea con comunicaciÃ³n directa o indirecta.</p>
</div>
<div class="sect3">
<h4 id="_comunicaciÃ³n_directa">10.2.1. ComunicaciÃ³n directa</h4>
<div class="paragraph">
<p>En la <strong>comunicaciÃ³n directa</strong> cada proceso debe nombrar explÃ­citamente al proceso destinatario o receptor de la informaciÃ³n.
Por ejemplo, ahora las llamadas al sistema bÃ¡sicas podrÃ­an ser asÃ­:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>send( A, message )</strong> para mandar un mensaje al proceso identificado como Â«AÂ».</p>
</li>
<li>
<p><strong>receive( A, &amp;message )</strong> para recibir un mensaje del proceso identificado como Â«AÂ», copiÃ¡ndolo en Â«<em>message</em>Â».</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>De hecho el ejemplo anterior corresponde a un caso de <strong>comunicaciÃ³n directa</strong> con <strong>direccionamiento simÃ©trico</strong> pero existe una variante de ese mismo esquema denominado <strong>direccionamiento asimÃ©trico</strong> donde el receptor puede recibir mensajes de cualquier proceso, de forma que al volver de la llamada recibe el mensaje y la identidad del remitente.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>send( A, message )</strong> para mandar un mensaje al proceso identificado como Â«AÂ»</p>
</li>
<li>
<p><strong>receive( &amp;pid, &amp;message )</strong> para recibir un mensaje de cualquier proceso, recibiendo en Â«<em>message</em>Â» una copia del <em>message</em> y en Â«pidÂ» la identidad del remitente.</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>En resumen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En el <strong>direccionamiento simÃ©trico</strong> tanto el proceso que envÃ­a como el que recibe tienen que identificar al otro para comunicarse.</p>
</li>
<li>
<p>En el <strong>direccionamiento asimÃ©trico</strong> sÃ³lo el proceso que envÃ­a identifica a que recibe, mientras que este Ãºltimo no tiene que nombrar al remitente.
Es el sistema operativo el que informa de quiÃ©n es el remitente del mensaje que se ha recibido.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Un <strong>enlace de comunicaciones</strong> segÃºn este esquema tiene las siguientes caracterÃ­sticas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Un enlace se establece automÃ¡ticamente entre cada par de procesos que quieren comunicarse.
Por tanto, los procesos sÃ³lo necesitan conocer la identidad de los otros para comunicarse.</p>
</li>
<li>
<p>Cada enlace se asocia exactamente a dos procesos.</p>
</li>
<li>
<p>Entre cada par de procesos sÃ³lo hay un enlace.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>La principal desventaja de este tipo de comunicaciÃ³n es que si cambia el identificador de un proceso hay que actualizar todas las referencias en todos los procesos que se comunican con Ã©l.
En general cualquier tÃ©cnica que requiera que los identificadores de los procesos sean establecidos explÃ­citamente en el cÃ³digo de los programas no es deseable, puesto que en muchos sistemas los identificadores de los procesos cambian de una ejecuciÃ³n a otra.
Por lo tanto, lo mejor serÃ­a disponer de una soluciÃ³n con un nivel adicional de indirecciÃ³n que evite que los procesos usen sus identificadores para comunicarse.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Colas de mensajes en Windows API</div>
<div class="paragraph">
<p>En Windows API un hilo puede enviar mensajes a otro hilo usando <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-postthreadmessagea">PostThreadMessage()</a>.
Como aun no hemos visto el concepto de hilo, podemos asumir que es equivalente al de proceso.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">BOOL</span> <span class="nf">PostThreadMessage</span><span class="p">(</span>
    <span class="n">DWORD</span>  <span class="n">idThread</span><span class="p">,</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">UINT</span>   <span class="n">Msg</span><span class="p">,</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="n">WPARAM</span> <span class="n">wParam</span><span class="p">,</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="n">LPARAM</span> <span class="n">lParam</span> <i class="conum" data-value="3"></i><b>(3)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Identificador del hilo.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Un nÃºmero entero que identifica el mensaje.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>ParÃ¡metros del mensaje de tipo entero.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Como se puede observar, en las colas de mensajes de Windows API el <strong>tamaÃ±o del mensaje es fijo</strong> y con un estructura muy bien definida: un identificador del mensaje y dos enteros que sirven de parÃ¡metros opcionales del mensaje.</p>
</div>
<div class="paragraph">
<p>Para recibir el mensaje el proceso llama a <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmessagea">GetMessage()</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">BOOL</span> <span class="nf">GetMessage</span><span class="p">(</span>
    <span class="n">LPMSG</span> <span class="n">lpMsg</span><span class="p">,</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">HWND</span>  <span class="n">hWnd</span><span class="p">,</span>
    <span class="n">UINT</span>  <span class="n">wMsgFilterMin</span><span class="p">,</span>
    <span class="n">UINT</span>  <span class="n">wMsgFilterMax</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Puntero a una estructura <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-msg">MSG</a> que a la vuelta contendrÃ¡ el identificador y los parÃ¡metros del mensaje recibido, entre otra informaciÃ³n.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Como se puede observar, no se indica de quÃ© hilo o proceso se quiere recibir el mensaje, por lo que se trata de un caso de <strong>comunicaciÃ³n directa asimÃ©trica</strong>.
De hecho, si se quiere conocer la identidad del remitente, este tendrÃ­a que poner su identificador en alguno de los parÃ¡metros del mensaje.</p>
</div>
<div class="paragraph">
<p>El sistema de colas de mensajes de Windows API es una pieza fundamental del entorno grÃ¡fico de Microsoft Windows.
Sin embargo, podemos definir nuestros propios mensaje privados para comunicar unos hilos o procesos con otros.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_comunicaciÃ³n_indirecta">10.2.2. ComunicaciÃ³n indirecta</h4>
<div class="paragraph">
<p>En la <strong>comunicaciÃ³n indirecta</strong> los mensajes son enviados a <strong>buzones</strong>, <strong><em>maillox</em></strong> o <strong>puertos</strong> que son objetos dÃ³nde los procesos pueden dejar y recoger mensajes.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>send( P, message )</strong> para mandar un mensaje al puerto Â«PÂ»</p>
</li>
<li>
<p><strong>receive( P, &amp;message )</strong> para recibir un mensaje del puerto Â«PÂ».</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Un <strong>enlace de comunicaciones</strong> segÃºn este esquema tiene las siguientes caracterÃ­sticas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Un enlace se establece entre un par de procesos solo si ambos comparten un mismo puerto, dado que cada enlace corresponde con un puerto.</p>
</li>
<li>
<p>Un enlace puede estar asociado a mÃ¡s de dos procesos, puesto que mÃºltiples procesos pueden compartir el mismo puerto.</p>
</li>
<li>
<p>Entre cada par de procesos en comunicaciÃ³n pueden haber varios enlaces, cada uno de los
cuales corresponde a un puerto.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Colas de mensajes en sistemas POSIX</div>
<div class="paragraph">
<p>El estÃ¡ndar POSIX tambiÃ©n define un sistema de colas de mensajes pero es bastante diferente a la soluciÃ³n en Windows API (vÃ©ase <a href="https://www.man7.org/linux/man-pages/man7/mq_overview.7.html">Â«mq_overview(7)&#8201;&#8212;&#8201;Linux ManualÂ»</a>).</p>
</div>
<div class="paragraph">
<p>Para usarlo, lo primero es abrir o crear âsi aun no existeâ la cola de mensajes llamando a <a href="https://man7.org/linux/man-pages/man3/mq_open.3.html">mq_open()</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">mqd_t</span> <span class="n">mqueue</span> <span class="o">=</span> <span class="n">mq_open</span><span class="p">(</span>
    <span class="s">"/foo-mqueue"</span><span class="p">,</span>      <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_RDWR</span><span class="p">,</span>   <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="mo">0644</span><span class="p">,</span>               <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="nb">NULL</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Nombre que identifica la cola de mensajes.
Como con los archivos, para que varios procesos puedan acceder a la misma cola, deben indicar el mismo nombre.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Valores que indican diferentes opciones a la hora de abrir la cola de mensajes.
Por ejemplo, usando <code>O_RDWR</code> se indica abrir para enviar o recibir y con <code>O_CREAT</code> se indica que la cola debe crearse si no existe previamente.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Indica los permisos de la cola de mensajes al crearla nueva, de forma similar a los permisos que se aplican a los archivos.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>El valor devuelto por <a href="https://man7.org/linux/man-pages/man3/mq_open.3.html">mq_open()</a> es el descriptor de la cola de mensajes.
Como otros descriptores, se hereda de padres a hijos al usar <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>.</p>
</div>
<div class="paragraph">
<p>Este descriptor se utiliza como primer argumento en funciones posteriores para indicar sobre quÃ© cola queremos realizar la correspondiente operaciÃ³n.
Por ejemplo, para enviar un mensaje se utiliza <a href="https://man7.org/linux/man-pages/man3/mq_send.3.html">mq_send()</a> asÃ­:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="nf">mq_send</span><span class="p">(</span>
    <span class="n">mqueue</span><span class="p">,</span>                 <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">message</span><span class="p">,</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">message</span><span class="p">),</span>        <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="mi">0</span>                       <i class="conum" data-value="4"></i><b>(4)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Descriptor de la cola a la que enviar el mensaje.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Puntero a la direcciÃ³n de memoria donde estÃ¡ el mensaje.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>TamaÃ±o del mensaje en bytes.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Prioridad del mensaje.
Los mensaje con mayor prioridad se entregarÃ¡n antes.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Mientras que para recibir un mensaje se utiliza <a href="https://man7.org/linux/man-pages/man3/mq_receive.3.html">mq_receive()</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msg_prio</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">mq_receive</span><span class="p">(</span>
    <span class="n">mqueue</span><span class="p">,</span>                 <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">message</span><span class="p">,</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">message</span><span class="p">),</span>        <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="o">&amp;</span><span class="n">msg_prio</span>               <i class="conum" data-value="4"></i><b>(4)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Descriptor de la cola de la que recibir el mensaje.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Puntero a la direcciÃ³n de memoria donde guardar el mensaje al recibirlo.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>TamaÃ±o mÃ¡ximo de espacio reservado en <code>message</code> para guardar el mensaje.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Puntero a variable entera dÃ³nde devolver la prioridad del mensaje recibido.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Como los mensajes no se dirigen directamente a los procesos sino a estas entidades llamadas colas de mensajes, se trata de un caso de <strong>comunicaciÃ³n indirecta</strong>.
AdemÃ¡s, el <strong>tamaÃ±o de los mensajes es variable</strong>, aunque limitado por defecto a 8 KiB si no se configura de otra manera.</p>
</div>
<div class="paragraph">
<p>Si varios procesos intentan recibir de una misma cola de mensajes al mismo tiempo, queda en manos del sistema operativo decidir cuÃ¡l recibirÃ¡ el siguiente mensaje que llegue.
Por lo general es el primero en ser escogido por el planificador de la CPU para seguir ejecutÃ¡ndose.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_recepciÃ³n_concurrente">RecepciÃ³n concurrente</h5>
<div class="paragraph">
<p>Este tipo de comunicaciÃ³n da lugar a algunas situaciones que deben ser resueltas durante el diseÃ±o.</p>
</div>
<div class="paragraph">
<p>Â¿QuÃ© ocurre, por ejemplo, si los procesos A, B y C comparten el puerto P; A manda un mensaje y B y C invocan <code>receive()</code> en el puerto P al mismo tiempo?.
La respuesta correcta dependerÃ¡ de la elecciÃ³n de los los diseÃ±adores del sistema:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>No permitir que cada enlace de comunicaciÃ³n ây por tanto cada puertoâ estÃ© asociado a mÃ¡s de dos procesos.</p>
</li>
<li>
<p>No permitir que mÃ¡s de un proceso puedan ejecutar <code>receive()</code> al mismo tiempo.
Por ejemplo, en algunos sistemas solo el proceso que crea el puerto tiene permisos para recibir de Ã©l.
Los sistemas que optan por esta soluciÃ³n suelen disponer de algÃºn mecanismo para que un proceso pueda transferir el permiso de recibir a otros procesos.</p>
</li>
<li>
<p>Permitir que el sistema operativo escoja arbitrariamente quiÃ©n recibe el mensaje si dos o mÃ¡s procesos ejecutan <code>receive()</code> al mismo tiempo.
La elecciÃ³n puede ser aleatoria, mediante algÃºn algoritmo, por ejemplo, por turnos o el siguiente proceso en obtener la CPU, a criterio del planificador de la CPU.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_buffering_2">10.3. Buffering</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Los mensajes intercambiados por enlace de comunicaciÃ³n se almacenan en una cola temporal, a la espera de ser enviados o, tras recibirlos, a la espera de que los reclame el proceso.</p>
</div>
<div class="paragraph">
<p>BÃ¡sicamente hay tres formas de implementar dicha cola:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Con <strong>capacidad cero</strong> o <strong>sin buffering</strong> la cola tiene una capacidad mÃ¡xima de 0 mensajes, por lo que no puede haber ningÃºn mensaje esperando en el enlace.
En este caso el proceso transmisor se bloquea en espera hasta que el receptor recibe el mensaje.</p>
</li>
<li>
<p>Con <strong>buffering automÃ¡tico</strong>, dÃ³nde existe dos opciones:</p>
<div class="ulist">
<ul>
<li>
<p>Con <strong>capacidad limitada</strong> la cola tiene una capacidad mÃ¡xima de \$N\$ mensaje, por lo que si la cola se llena el proceso transmisor se bloquea a la espera de que haya espacio en la cola.
Obviamente, mientras la cola no se llene en transmisor puede seguir metiendo mensajes sin bloquearse.</p>
</li>
<li>
<p>Con <strong>capacidad ilimitada</strong> la cola es de longitud potencialmente infinita, lo que permite que el transmisor nunca espere.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Las colas de longitud infinita son imposibles, puesto que los recursos son limitados.
En realidad este tÃ©rmino hace referencia a colas de longitud variable cuyo mÃ¡ximo viene determinado por la memoria principal disponible, que suele ser lo suficientemente grande como para que podamos considerar que las colas son infinitas.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Buffering en las colas de mensajes POSIX</div>
<div class="paragraph">
<p>Las colas de mensajes en sistemas POSIX tienen capacidad limitada.
Los lÃ­mites se configuran al crear la cola, a travÃ©s del Ãºltimo argumento de <a href="https://man7.org/linux/man-pages/man3/mq_open.3.html">mq_open()</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="k">struct</span> <span class="n">mq_attr</span> <span class="n">attr</span> <span class="o">=</span> <span class="p">{</span>  <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="p">.</span><span class="n">mq_maxmsg</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>      <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="p">.</span><span class="n">mq_msgsize</span> <span class="o">=</span> <span class="mi">2049</span>   <i class="conum" data-value="3"></i><b>(3)</b>
<span class="p">};</span>

<span class="n">mqd_t</span> <span class="n">mqueue</span> <span class="o">=</span> <span class="n">mq_open</span><span class="p">(</span>
    <span class="s">"/foo-queue"</span><span class="p">,</span>
    <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_RDWR</span><span class="p">,</span>
    <span class="mo">0644</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">attr</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Estructura con propiedades para la cola cuando Ã©sta se crea nueva.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Una de las propiedades es el nÃºmero mÃ¡ximo de mensajes en la cola al mismo tiempo.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Otra de las propiedades es el tamaÃ±o mÃ¡ximo de cada mensaje.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Estos limites tienen unos valores por defecto por si en el lugar de <code>attr</code> en <a href="https://man7.org/linux/man-pages/man3/mq_open.3.html">mq_open()</a> se indica <code>NULL</code>.
El estÃ¡ndar POSIX indica que esos valores por defecto dependen de cada sistema operativo, por lo que es necesario ir a la documentaciÃ³n para desarrolladores de cada sistema para conocer los detalles en cada caso concreto.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, en Linux los valores por defecto son 10 mensajes y 8 KiB por mensaje, siendo estos, ademÃ¡s, los valores mÃ¡ximos que admiten esas propiedades.
Estos valores mÃ¡ximos y por defecto se pueden cambiar de forma global para todo el sistema, por si tuviÃ©ramos interÃ©s en valores mÃ¡s altos.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_operaciones_sÃ­ncronas_y_asÃ­ncronas">10.4. Operaciones sÃ­ncronas y asÃ­ncronas</h3>
<div class="paragraph">
<p>La comunicaciÃ³n entre dos procesos tiene lugar por medio de las llamadas <code>send()</code> y <code>receive()</code>; de tal forma que generalmente la primera se bloquea cuando la cola de transmisiÃ³n se llena âen funciÃ³n del tipo de <em>buffering</em>â mientras que la segunda lo hace cuando la cola de recepciÃ³n estÃ¡ vacÃ­a.</p>
</div>
<div class="paragraph">
<p>Sin embargo, en lugar de bloquearse, puede que aun proceso le interese ejecutar otras tareas en la CPU.
A fin de cuentas las comunicaciones son bastante lentas, por lo que en caso de bloquearse podrÃ­a estar dejando de aprovechar bastante tiempo de CPU.
Incluso puede darse el caso que tengan conexiÃ³n con otros procesos y que quiera aprovechar para intentar comunicarse con alguno de ellos.</p>
</div>
<div class="paragraph">
<p>Por eso existen diferentes opciones de diseÃ±o a la hora de implementar las llamadas anteriores en funciÃ³n de si se pueden bloquear o no.
Concretamente, el paso de mensajes puede ser <strong>sÃ­ncrono</strong> âcon bloqueoâ o <strong>asÃ­ncrono</strong> âsin bloqueoâ.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Cuando el envÃ­o es asÃ­ncrono</strong>, el proceso transmisor nunca se bloquea.
Si se llama a <code>send()</code> cuando la cola de mensajes estÃ© llena, lo mÃ¡s comÃºn es que retorne con un cÃ³digo de retorno que indique que el proceso debe volver a intentar el envÃ­o mÃ¡s tarde.</p>
</li>
<li>
<p><strong>Cuando el envÃ­o es sÃ­ncrono</strong>, el proceso transmisor se bloquea cuando no queda espacio en la cola de mensajes y hasta que pueda depositar el mensaje en la misma.</p>
</li>
<li>
<p><strong>Cuando la recepciÃ³n es asÃ­ncrona</strong>, el proceso receptor nunca se bloquea.
En caso de que la cola de mensajes estÃ© vacÃ­a, el sistema operativo puede indicar al proceso que lo intente mÃ¡s tarde a travÃ©s de un cÃ³digo de retorno o devolviendo un mensaje vacÃ­o.</p>
</li>
<li>
<p><strong>Cuando la recepciÃ³n es con bloqueo</strong>, el receptor se bloquea cuando no hay mensajes en la cola y hasta que llegue alguno.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Algunos sistemas de paso de mensajes son claramente sÃ­ncronos o asÃ­ncronos.
Mientras que otros permiten activar un modo u otro segÃºn las necesidades del aplicaciÃ³n.
E incluso los hay que soportan que transmisiÃ³n y recepciÃ³n sean sÃ­ncronas o asÃ­ncronas de manera totalmente independiente.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Comunicaciones asÃ­ncronas con colas de mensajes POSIX</div>
<div class="paragraph">
<p>Por defecto las colas de mensajes son sÃ­ncronas, tanto en envÃ­o como en recepciÃ³n.
Es decir, si al enviar un mensaje la cola estÃ¡ llena, el proceso transmisor quedarÃ¡ bloqueado en estado <strong>esperando</strong> hasta que haya un hueco libre para depositar el nuevo mensaje.
Si al recibir un mensaje la cola estÃ¡ vacÃ­a, el proceso receptor quedarÃ¡ bloqueado hasta que otro proceso deposite un mensaje.</p>
</div>
<div class="paragraph">
<p>Sin embargo, si en el argumento <code>oflag</code> de <a href="https://man7.org/linux/man-pages/man3/mq_open.3.html">mq_open()</a> un proceso indica la opciÃ³n <code>O_NONBLOCK</code> estas operaciones para ese proceso en esa cola serÃ¡n asÃ­ncronas:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">mqd_t</span> <span class="n">mqueue</span> <span class="o">=</span> <span class="n">mq_open</span><span class="p">(</span>
    <span class="s">"foo-mqueue"</span><span class="p">,</span>
    <span class="n">O_RDONLY</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span><span class="p">,</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="mo">0644</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">attr</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Abrir la cola de mensajes para solo lectura âcon <code>O_RDONLY</code>â y para comunicaciones asÃ­ncronas âcon <code>O_NONBLOCK</code>â.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Eso quiere decir que las funciones <a href="https://man7.org/linux/man-pages/man3/mq_send.3.html">mq_send()</a> y <a href="https://man7.org/linux/man-pages/man3/mq_receive.3.html">mq_receive()</a>, en lugar de bloquear el proceso en estado de esperando, devolverÃ¡n -1 y el valor de <a href="https://man7.org/linux/man-pages/man3/errno.3.html">errno</a> serÃ¡ <code>EAGAIN</code>.
AsÃ­ el proceso puede aprovechar el tiempo de CPU del que dispone para realizar otras tareas mientras tanto y volver a intentarlo mÃ¡s tarde.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="n">return_code</span> <span class="o">=</span> <span class="n">mq_receive</span><span class="p">(</span><span class="n">mqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">message</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">msg_prio</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">return_code</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="p">{</span>
    <span class="c1">// AquÃ­ va cÃ³digo para usar el mensaje recibido...</span>
<span class="p">}</span>
<span class="k">else</span> <span class="nf">if</span><span class="p">(</span> <span class="n">return_code</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">errno</span> <span class="o">!=</span> <span class="n">EAGAIN</span><span class="p">)</span> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">{</span>
    <span class="c1">// AquÃ­ va cÃ³digo para manejar el error de mq_receive()...</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Si todo va bien, <a href="https://man7.org/linux/man-pages/man3/mq_receive.3.html">mq_receive()</a> devuelve el tamaÃ±o en bytes del mensaje.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Si devuelve -1, es que ha ocurrido un error. Pero solo serÃ¡ un error eal si el cÃ³digo de error en <a href="https://man7.org/linux/man-pages/man3/errno.3.html">errno</a> no es <code>EAGAIN</code>.
Si es <code>EAGAIN</code>, se pueden ejecutar otras partes del programa y volver a intentar la recepciÃ³n mÃ¡s adelante.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Si un proceso debe comunicarse mediante varias colas de mensajes, la comunicaciÃ³n asÃ­ncrona tambiÃ©n sirve para intentar recibir y enviar de varias colas sin bloquearse en ninguna.
Para este caso algunos sistemas ofrece una alternativa mÃ¡s sencilla y eficiente, que veremos en el <a href="#_colas_de_mensajes_posix">Apartado 10.5.1</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ejemplos_de_sistemas_de_paso_de_mensajes">10.5. Ejemplos de sistemas de paso de mensajes</h3>
<div class="sect3">
<h4 id="_colas_de_mensajes_posix">10.5.1. Colas de mensajes POSIX</h4>
<div class="paragraph">
<p>Como hemos comentado a lo largo de capÃ­tulo, las colas de mensajes POSIX son un caso de <strong>comunicaciÃ³n indirecta</strong>, con <strong>tamaÃ±o de mensaje variable</strong>, <em>buffering</em> con <strong>capacidad limitad</strong> y que soporta operaciones <strong>asÃ­ncronas</strong>.</p>
</div>
<div class="paragraph">
<p>Las colas de mensajes son Ãºtiles para enviar mensajes de pequeÃ±o tamaÃ±o entre procesos que se ejecutan en el mismos sistema.
AdemÃ¡s tienen la posibilidad de asociar a cada mensaje una prioridad, de tal forma que se reciban primero los mensajes de prioridad mÃ¡s alta.
Su uso es relativamente comÃºn en sistemas de tiempo real, aunque lo mÃ¡s frecuente en los sistemas de propÃ³sito general es usar <em>sockets</em>.</p>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/message_queue.hpp">message_queue.hpp</a> se puede ver un ejemplo de una clase desarrollada en C&#43;&#43; para utilizar colas de mensajes POSIX.
En los distintos mÃ©todos se puede ver como se utilizan las funciones de la librerÃ­a del sistema para crear la cola y enviar y recibir mensajes.</p>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/mqueue-server.cpp">mqueue-server.cpp</a> y <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/mqueue-client.cpp">mqueue-client.cpp</a> se puede ver un ejemplo de cÃ³mo se utiliza la clase en <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/message_queue.hpp">message_queue.hpp</a>.
El primero es un programa que muestra la hora del sistema periÃ³dicamente.
El segundo se puede comunicar con el primero a travÃ©s de una cola de mensajes para controlarlo.
En ejemplo es muy sencillo, asÃ­ que, por el momento, lo Ãºnico que puede hacer <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/mqueue-client.cpp">mqueue-client.cpp</a> es pedirle a <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/mqueue-server.cpp">mqueue-server.cpp</a> que termine.
Aunque no costarÃ­a nada aÃ±adir otras Ã³rdenes, como pedir que cambie la hora del sistema o la periodicidad con la que la muestra.</p>
</div>
<div class="paragraph">
<p>En Linux los descriptores de colas de mensajes son descriptores de archivo âcomo tambiÃ©n lo son los descriptores de <em>sockets</em>, tuberÃ­as y los de archivos abiertos con <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a>, entre otrosâ. Esta particularidad implica que en Linux, mediante las funciones <a href="https://man7.org/linux/man-pages/man2/select.2.html">select()</a>, <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a> o <a href="https://man7.org/linux/man-pages/man7/epoll.7.html">epoll()</a>, se pueden monitorizar al mismo tiempo varios descriptores de colas de mensajes, para asÃ­ saber cuÃ¡ndo se puede enviar o recibir por ellas sin que el proceso se bloquee.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Este comportamiento es especÃ­fico de Linux.
No estÃ¡ contemplado en el estÃ¡ndar POSIX, por lo que otros sistemas POSIX no tienen por quÃ© soportarlo.
AsÃ­ que no es portable.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A continuaciÃ³n se puede ver un ejemplo especÃ­fico con <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a>, aunque las tres funciones se utilizan empleando un patrÃ³n similar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">mqd_t</span> <span class="n">mqueue1</span> <span class="o">=</span> <span class="n">mq_open</span><span class="p">(</span> <span class="s">"/foo-queue"</span><span class="p">,</span> <span class="cm">/* ... */</span> <span class="p">);</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="n">mqd_t</span> <span class="n">mqueue2</span> <span class="o">=</span> <span class="n">mq_open</span><span class="p">(</span> <span class="s">"/bar-queue"</span><span class="p">,</span> <span class="cm">/* ... */</span> <span class="p">);</span>

<span class="k">struct</span> <span class="n">pollfd</span> <span class="n">fds</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">{</span>
        <span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">mqueue1</span><span class="p">,</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">POLLIN</span><span class="p">,</span> <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="p">.</span><span class="n">revents</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">},</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">mqueue2</span><span class="p">,</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLOUT</span><span class="p">,</span> <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="p">.</span><span class="n">revents</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">while</span> <span class="p">(</span> <span class="o">!</span><span class="n">quit_app</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">return_code</span> <span class="o">=</span> <span class="n">poll</span><span class="p">(</span> <span class="n">fds</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">);</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="k">if</span> <span class="p">(</span><span class="n">return_code</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <i class="conum" data-value="5"></i><b>(5)</b>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">revents</span> <span class="o">&amp;</span> <span class="n">POLLIN</span><span class="p">)</span> <i class="conum" data-value="7"></i><b>(7)</b>
        <span class="p">{</span>
            <span class="n">mq_receive</span><span class="p">(</span> <span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">fd</span><span class="p">,</span> <span class="cm">/* ... */</span> <span class="p">);</span>

            <span class="c1">// AquÃ­ va cÃ³digo para usar el mensaje recibido...</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">fds</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">revents</span> <span class="o">&amp;</span> <span class="n">POLLIN</span><span class="p">)</span> <i class="conum" data-value="7"></i><b>(7)</b>
        <span class="p">{</span>
            <span class="n">mq_receive</span><span class="p">(</span> <span class="n">fds</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">fd</span><span class="p">,</span> <span class="cm">/* ... */</span> <span class="p">);</span>

            <span class="c1">// AquÃ­ va cÃ³digo para usar el mensaje recibido...</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">fds</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">revents</span> <span class="o">&amp;</span> <span class="n">POLLOUT</span><span class="p">)</span> <i class="conum" data-value="7"></i><b>(7)</b>
        <span class="p">{</span>
            <span class="c1">// AquÃ­ va cÃ³digo para preparar el mensaje a enviar...</span>

            <span class="n">mq_send</span><span class="p">(</span> <span class="n">fds</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">fd</span><span class="p">,</span> <span class="cm">/* ... */</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">return_code</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <i class="conum" data-value="6"></i><b>(6)</b>
    <span class="p">{</span>
        <span class="c1">// Error en poll().</span>
        <span class="c1">// AquÃ­ va cÃ³digo para leer errno y manejar el error...</span>

        <span class="n">quit_app</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Abrimos o creamos las colas que vamos a utilizar.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Creamos un <em>array</em> de la estructura <code>pollfd</code> con un elemento por cola que vamos a monitorizar con <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a>.
En cada estructura, en el campo <code>fd</code>, se indica el descriptor de cada una de las cola de mensajes.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Para cada cola hay que utilizar el campo <code>events</code> para indicar quÃ© queremos que monitorice <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a>.
<code>events</code> es una mÃ¡scara de bit donde a cada evento monitorizable le corresponde un bit.
Si queremos monitorizar un evento, debemos poner su bit a 1.
<div class="paragraph">
<p>Para eso nos podemos ayudar de macros como <code>POLLIN</code> y <code>POLLOUT</code>.
Por ejemplo, para <code>mqueue1</code> se quiere monitorizar cuÃ¡ndo hay mensajes para recibir, por lo que se activa <code>POLLIN</code>.
Mientras que para <code>mqueue2</code> se quiere saber tanto cuÃ¡ndo hay mensajes para recibir como cuÃ¡ndo hay un hueco en la cola para enviar sin bloqueos, por lo que se activan <code>POLLIN</code> y <code>POLLOUT</code>.</p>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Iterativamente se llama a <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a> âmientras no queramos que termine la aplicaciÃ³nâ que pondrÃ¡ el proceso en estado <strong>esperando</strong> hasta que ocurra alguno de los eventos que nos interesan.
<a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a> necesita <code>fds</code> âel <em>array</em> de la estructura <code>pollfd</code> que hemos inicializado previamenteâ el nÃºmero de elementos en el <em>array</em> y el tiempo mÃ¡ximo que debe mantener bloqueado el proceso esperando a que ocurra alguno de los eventos.
Con un nÃºmero negativo en este Ãºltimo campo, se indica que queremos que espere indefinidamente.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Si <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a> tiene Ã©xito, devuelve un numero positivo que indica en cuÃ¡ntos descriptores se ha detectado un evento.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Si <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a> devuelve un valor negativo, es que ha ocurrido algÃºn error.
El motivo del error se puede conocer comprobando el valor de la variable global <a href="https://man7.org/linux/man-pages/man3/errno.3.html">errno</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>El campo <code>revents</code> es una mÃ¡scara de bits similar a <code>events</code>, pero al retornar de <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a> indica quÃ© eventos se han detectado, para cada cola de mensajes en <code>fds</code>.
<div class="paragraph">
<p>Por ejemplo, en ambas colas se comprueba si <code>POLLIN</code> estÃ¡ activo.
En caso afirmativo, sabemos que podemos leer un mensaje sin que <a href="https://man7.org/linux/man-pages/man3/mq_receive.3.html">mq_receive()</a> se bloquee.
Igualmente, sabemos si <code>mqueue2</code> tiene hueco para enviar un mensaje comprobando si <code>POLLOUT</code> estÃ¡ activo.
En caso afirmativo, podemos enviar un mensaje con <a href="https://man7.org/linux/man-pages/man3/mq_send.3.html">mq_send()</a> sabiendo que no se bloquearÃ¡.</p>
</div></td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_seÃ±ales_en_sistemas_operativos_posix">10.5.2. SeÃ±ales en sistemas operativos POSIX</h4>
<div class="paragraph">
<p>En los sistemas POSIX, una forma mÃ¡s sencilla de comunicar dos procesos del mismo sistema es mediante el envÃ­o de una <strong>seÃ±al</strong> de uno al otro.</p>
</div>
<div class="paragraph">
<p>Los procesos pueden mandar seÃ±ales utilizando la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/kill.2.html">kill()</a>, que sÃ³lo requiere el identificador del proceso de destino y el nÃºmero que identifica la seÃ±al.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">kill</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">SIGTERM</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Como se usa el identificado del proceso, estamos hablando de un mecanismo de <strong>comunicaciÃ³n directa</strong>.</p>
</div>
<div class="paragraph">
<p>El <strong>tamaÃ±o y formato del mensaje es fijo</strong>.
Las seÃ±ales solo pueden portar la informaciÃ³n de que ha ocurrido un evento, indicado quÃ© evento es a travÃ©s del nÃºmero que identifica la seÃ±al.</p>
</div>
<div class="paragraph">
<p>Cada seÃ±al tiene un efecto particular por defecto âque por lo general es matar al procesoâ en el proceso que las recibe.
Sin embargo, cada proceso puede declarar un <strong>manejador de seÃ±al</strong>.
Una funciÃ³n del programa que serÃ¡ invocada por el sistema operativo para tratar una seÃ±al determinada, interrumpiendo lo que estÃ© haciendo el proceso en ese momento.
En ese sentido las seÃ±ales en POSIX puede interpretarse como una forma de interrupciÃ³n por software.</p>
</div>
<div class="paragraph">
<p>El <strong>manejador de seÃ±al</strong> se puede configurar usando la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/signal.2.html">signal()</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">signal</span><span class="p">(</span>
    <span class="n">SIGTERM</span><span class="p">,</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="o">&amp;</span><span class="n">mi_manejador_de_sigterm</span> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Identificador de la seÃ±al a recibir.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Puntero al manejador de seÃ±al.
Es decir, la del programa que serÃ¡ llamada por el sistema operativo cuando llegue la seÃ±al <code>SIGTERM</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>El problema de <a href="https://man7.org/linux/man-pages/man2/signal.2.html">signal()</a> es que el estÃ¡ndar POSIX permite diferencias que hacen que se pueda comportar de forma distinta en diferentes sistemas operativos.
Para resolverlo, el estÃ¡ndar recomienda usar <a href="https://man7.org/linux/man-pages/man2/sigaction.2.html">sigaction()</a> en su lugar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="k">struct</span> <span class="n">sigaction</span> <span class="n">act</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mi_manejador_de_sigterm</span><span class="p">,</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="p">.</span><span class="n">sa_sigaction</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>   <i class="conum" data-value="5"></i><b>(5)</b>
    <span class="p">.</span><span class="n">sa_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>           <i class="conum" data-value="6"></i><b>(6)</b>
    <span class="p">.</span><span class="n">sa_flags</span> <span class="o">=</span> <span class="n">SA_RESTART</span><span class="p">,</span> <i class="conum" data-value="7"></i><b>(7)</b>
<span class="p">}</span>

<span class="n">sigaction</span><span class="p">(</span>
    <span class="n">SIGTERM</span><span class="p">,</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="o">&amp;</span><span class="n">act</span><span class="p">,</span>    <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="nb">NULL</span>     <i class="conum" data-value="3"></i><b>(3)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Identificador de la seÃ±al a recibir.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Puntero a una estructura de tipo <code>sigaction</code> que describe los detalles de como tratar la seÃ±al cuando llega al proceso.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Puntero a una estructura de tipo <code>sigaction</code> donde <a href="https://man7.org/linux/man-pages/man2/sigaction.2.html">sigaction()</a> guarda la configuraciÃ³n anterior sobre como tratar la seÃ±al indicada.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Puntero al manejador de seÃ±al para la seÃ±al indicada.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Puntero a un manejador de seÃ±al alternativo al de <code>sa_handler</code>.
Este manejador recibe mÃ¡s informaciÃ³n sobre la seÃ±al cuando es llamado.
Para activar es necesario indicar <code>SA_SIGINFO</code> en el campo <code>sa_flags</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>MÃ¡scara de bits de seÃ±ales a bloquear durante el manejo de la seÃ±al.
Cada bit de la mÃ¡scara identifica a una seÃ±al.
Deben ponerse a 1 aquellas seÃ±ales que queremos que estÃ©n bloqueadas âes decir, que no se puedan recibirâ mientras se ejecuta el manejador de seÃ±al porque ha llegado una.
Es especialmente Ãºtil si se va a usar el mismo manejador para varias seÃ±ales.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Opciones de configuraciÃ³n.
Por ejemplo, <code>SA_RESTART</code> indica que si la seÃ±al llega durante una llamada al sistema, la llamada debe continuar una vez se haya salido del manejador de seÃ±al.
El comportamiento por defecto, sin esta opciÃ³n, es que la llamada al sistema interrumpida falle con el error <code>EINTR</code> en <a href="https://man7.org/linux/man-pages/man3/errno.3.html">errno</a>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Las seÃ±ales fueron diseÃ±adas originalmente como un mecanismo para que el sistema operativo notificara a los programas ciertos errores y sucesos crÃ­ticos.
Por ejemplo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La seÃ±al <code>HUP</code> o <code>SIGHUP</code> es enviada a cada proceso iniciado desde una sesiÃ³n de terminal cuando dicha sesiÃ³n termina âo cuando se usa la combinaciÃ³n de teclas <span class="keyseq"><kbd>CTRL</kbd>+<kbd>D</kbd></span>, que tiene el mismo efectoâ.</p>
<div class="paragraph">
<p>En el caso de los servicios del sistema âque, como no son interactivos, no estÃ¡n conectados a ninguna terminarâ esta seÃ±al suele usarse para indicarles que deben reiniciarse, volviendo a leer sus archivos de configuraciÃ³n, o para que guarden su estado interno en algÃºn sitio conocido del almacenamiento.</p>
</div>
</li>
<li>
<p>La seÃ±al <code>INT</code> o <code>SIGINT</code> es enviada al proceso que estÃ¡ enganchado a la consola cuando el usuario pulsa el carÃ¡cter de interrupciÃ³n âfrecuentemente la combinaciÃ³n de teclas <span class="keyseq"><kbd>CTRL</kbd>+<kbd>C</kbd></span>â.</p>
</li>
<li>
<p>La seÃ±al <code>TERM</code> o <code>SIGTERM</code> es enviada al proceso cuando debe terminar.
Por ejemplo, el sistema operativo envÃ­a esta seÃ±al a todos los procesos cuando se estÃ¡ apagando el sistema.</p>
</li>
<li>
<p>La seÃ±al <code>SEGV</code> o <code>SIGSEGV</code> es enviada a un proceso cuando intenta acceder a una zona de memoria a la que no tiene permiso.
Si no se maneja esta seÃ±al, el programa termina con el conocido mensaje de <strong>violaciÃ³n de segmento</strong>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Obviamente hay muchas mÃ¡s seÃ±ales.
Entre todas, el estÃ¡ndar POSIX incluye dos seÃ±ales â<code>USR1</code> y <code>USR2</code>â especialmente indicadas para usarlas con el significado que nosotros queramos.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Se puede consultar una lista de las seÃ±ales del estÃ¡ndar POSIX en <a href="https://es.wikipedia.org/wiki/Se%C3%B1al_(inform%C3%A1tica)">Â«SeÃ±ales (informÃ¡tica)&#8201;&#8212;&#8201;WikipediaÂ»</a>.
Mientras que la lista completa de seÃ±ales soportadas en Linux se puede consultar en <a href="https://man7.org/linux/man-pages/man7/signal.7.html#:~:text=Standard%20signals">Â«signal(7)&#8201;&#8212;&#8201;Linux ManualÂ»</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>El ejemplo en <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/mqueue-server.cpp">mqueue-server.cpp</a> y en otros ejemplos de este capÃ­tulo, utiliza seÃ±ales para manejar <code>SIGINT</code>, <code>SIGTERM</code> y para mostrar la hora periÃ³dicamente.
El cÃ³digo dedicado a eso estÃ¡ en <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/common/timeserver.c">timeserver.c</a> y se comparte entre todos los ejemplos.</p>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/signals.c">signals.c</a> hay un programa de ejemplo que muestra cÃ³mo manejar las seÃ±ales del sistema y que sirve para ver como funcionan.
Solo hay que ejecutarlo y luego enviarle seÃ±ales con el comando <code>kill</code> desde otra terminal.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tuberÃ­as">10.5.3. TuberÃ­as</h4>
<div class="paragraph">
<p>Las <strong>tuberÃ­as</strong> son un mecanismo de paso de mensajes de <strong>comunicaciÃ³n indirecta</strong>, <strong>orientada a flujos</strong>, <strong>capacidad limitada</strong> y, generalmente, <strong>comunicaciÃ³n sÃ­ncrona</strong> âaunque en algunos sistema operativos tambiÃ©n puede soportar asÃ­ncronaâ.</p>
</div>
<div class="paragraph">
<p>Conceptualmente cada tuberÃ­a tiene dos extremos en los que se puede leer y escribir mediante las operaciones bÃ¡sicas de lectura y escritura de archivos <code>read()</code> y <code>write()</code>.
Un extremo permite a los procesos en ese extremo escribir en la tuberÃ­a, mientras el otro extremo permite a los procesos leer de la tuberÃ­a los datos escritos desde el otro extremo.</p>
</div>
<div class="paragraph">
<p>Existen dos tipos de tuberÃ­as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Las <strong>tuberÃ­as anÃ³nimas</strong> que sÃ³lo existen en el espacio de direcciones del proceso que las crea, de tal forma que debe heredarse de padres a hijos para que otros procesos puedan tener acceso.</p>
</li>
<li>
<p>Las <strong>tuberÃ­as con nombre</strong> son pÃºblicas al resto del sistema, por lo que teÃ³ricamente cualquier proceso con permisos puede abrir una para comunicarse con otros procesos.
Por eso se suele utilizar en aplicaciones cliente-servidor, dÃ³nde un proceso servidor ofrece algÃºn servicio a otros procesos cliente a travÃ©s de la tuberÃ­a.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En los sistemas POSIX las <strong>tuberÃ­as con nombre</strong> se denominan <em>FIFO</em> y tienen presencia en el sistema de archivos como archivos especiales.</p>
</div>
</td>
</tr>
</table>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 3. Funciones de la API para manipular tuberÃ­as.</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">POSIX API</th>
<th class="tableblock halign-left valign-top">Windows API</th>
</tr>
</thead>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Crear tuberÃ­a anÃ³nima</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/pipe.2.html">pipe()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-createpipe">CreatePipe()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Crear tuberÃ­a con nombre</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/mkfifo.3.html">mkfifo()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea">CreateNamedPipe()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Abrir tuberÃ­a con nombre</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Leer</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile">ReadFile()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Escribir</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile">WriteFile()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Cerrar</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/close.2.html">close()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle">CloseHandle()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Destruir tuberÃ­a con nombre</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/unlink.2.html">unlink()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="lightcell">[AutomÃ¡tico]</span></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Con <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> es muy sencillo lanzar otros procesos para que ejecuten tareas en paralelo.
El proceso hijo tiene acceso a los datos del padre por la forma en la que funciona <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> y gracias a las tuberÃ­as anÃ³nimas puede comunicar los resultados al padre.
En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/master/src/cap10/fork-pipe.cpp">fork-pipe.cpp</a> se puede observar un ejemplo de esto.</p>
</div>
<div class="paragraph">
<p>AdemÃ¡s, el hecho de que cada extremo se comporte como un archivo âuno en modo solo lectura y el otro en modo solo escrituraâ hace posible redirigir la E/S estÃ¡ndar del proceso hijo.
Es decir, conectar la entrada, la salida estÃ¡ndar o la salida de error a una tuberÃ­a, desde la que leer lo que el proceso intenta imprimir por la pantalla de la terminal o proporcionarle lo que debe leer, como si fuera desde el teclado.
En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/fork-redir.c">fork-redir.c</a> se puede ver un ejemplo de como ejecutar el comando <code>ls</code> y redirigir su salida al proceso padre para contar el nÃºmero de lÃ­neas en lo que el comando querÃ­a mostrar por pantalla.</p>
</div>
<div class="paragraph">
<p>Por otro lado, las tuberÃ­as con nombre permiten que un proceso se comunique con cualquier otro, solo con conocer la ruta de la tuberÃ­a.
En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/fifo-client.c">fifo-server.c</a> tenemos un ejemplo de un programa que muestra la hora del sistema de forma periÃ³dica, mientras espera Ã³rdenes de una tuberÃ­a que sirve de canal de control remoto.
Los programas en <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/fifo-client.c">fifo-client.c</a> y <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/fifo-client.cpp">fifo-client.cpp</a> pueden conectarse a esa tuberÃ­a y mandar el comando que hace terminar <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/fifo-client.c">fifo-server.c</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_sockets">10.5.4. Sockets</h4>
<div class="paragraph">
<p>Mientras que las tuberÃ­as son conceptualmente un enlace de comunicaciÃ³n unidireccional que tiene dos extremos, un <strong><em>socket</em></strong> representa un solo extremo en un enlace de comunicaciÃ³n bidireccional.
Para que una pareja de procesos se pueda comunicar son necesarios dos <em>sockets</em> âuno en cada procesoâ de manera que cada uno de ellos es el medio por el que el proceso accede al enlace de comunicaciÃ³n.</p>
</div>
<div class="paragraph">
<p>La API de <em>sockets</em> fue creada por la Universidad de Berkeley para abstraer el acceso a la familia de protocolos de Internet en el UNIX desarrollado por esa misma universidad.
Sin embargo, rÃ¡pidamente se convirtiÃ³ en el estÃ¡ndar de facto para la comunicaciÃ³n en red, por lo que todos los sistemas operativos modernos âincluidos los sistemas POSIX y Microsoft Windowsâ tienen una implementaciÃ³n de la misma.</p>
</div>
<div class="paragraph">
<p>Pese a sus orÃ­genes en Internet, los <em>sockets</em> se diseÃ±aron para ser independientes de la tecnologÃ­a de red subyacente con la que se implementa el enlace de comunicaciÃ³n.
En Linux, por ejemplo, se puede utilizar como interfaz de programaciÃ³n para utilizar dos decenas de familias de protocolos y tecnologÃ­as diferentes.</p>
</div>
<div class="paragraph">
<p>Para crear un <em>socket</em> te utiliza la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/socket.2.html">socket()</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">AF_UNIX</span><span class="p">,</span>         <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="n">SOCK_DGRAM</span><span class="p">,</span>      <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="mi">0</span>
<span class="p">)</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>En sistemas POSIX la funciÃ³n devuelve un <code>int</code> con el descriptor del socket mientras que en Microsoft Windows devuelve un <code>HANDLE</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>En el primer argumento se especifica la familia de protocolos.
<code>AF_UNIX</code> son un tipo de <em>socket</em> que solo sirve para comunicar procesos en el mismo sistema, denominado <strong>socket de dominio UNIX</strong>.
Otras familias muy comunes son <code>AF_INET</code>, que corresponde a la la familia de protocolos TCP/IP y <code>AF_INET6</code> para los protocolos IPv6.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>En el segundo argumento se especifica el tipo del <em>socket</em>.
Cada tipo suele corresponde con un protocolo concreto de la familia elegida.
Por ejemplo, los <em>sockets</em> <code>SOCK_DGRAM</code> son Â«no orientados a conexiÃ³nÂ», no fiables y de longitud mÃ¡xima fija, asÃ­ que en la familia <code>AF_INET</code> estos <em>sockets</em> utiliza UDP.
Mientras que los <em>sockets</em> <code>SOCK_STREAM</code> son orientados a conexiÃ³n, fiables, bidireccionales y orientados a flujo, por lo que en la familia <code>AF_INET</code> utilizan TCP.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Un <em>socket</em> reciÃ©n creado no tiene un nombre que otro proceso pueda usar para identificarlo y comunicarse con Ã©l.
Para asignar ese nombre o direcciÃ³n se utiliza <a href="https://man7.org/linux/man-pages/man2/bind.2.html">bind()</a>.
La dificultad es que cada familia de protocolos tiene un formato de direcciones diferente, asÃ­ que hay que tener cuidado de usar el adecuado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="k">struct</span> <span class="n">sockaddr_un</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">sun_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">,</span>        <i class="conum" data-value="5"></i><b>(5)</b>
    <span class="p">.</span><span class="n">sun_path</span> <span class="o">=</span> <span class="s">"/tmp/foo-socket"</span> <i class="conum" data-value="6"></i><b>(6)</b>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">result_code</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">sockfd</span><span class="p">,</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <i class="conum" data-value="4"></i><b>(4)</b>
<span class="p">)</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Como en el resto de llamadas al sistema, en caso de error se devuelve un nÃºmero negativo y <a href="https://man7.org/linux/man-pages/man3/errno.3.html">errno</a> contendrÃ¡ el cÃ³digo del error.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>El descriptor del <em>socket</em> al que se le quiere cambiar la direcciÃ³n.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>La nueva direcciÃ³n del <em>socket</em> especificada como una estructura adecuada para la familia del <em>socket</em>.
En <em>socket</em> de tipo <code>AF_UNIX</code> la estructura debe ser de tipo <code>sockaddr_un</code> mientras que en los de tipo <code>AF_INET</code> es del tipo <code>sockaddr_in</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>El tamaÃ±o en bytes de la estructura con la nueva direcciÃ³n.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>En la estructura con la direcciÃ³n, el primero campo siempre es para
indicar la familia.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>En los <em>sockets</em> de dominio UNIX la direcciÃ³n es una ruta en el sistema de archivos.
Para otras familias, la direcciones se indica de otra manera, por lo que es necesario consultar la documentaciÃ³n.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>La API de <em>sockets</em> incluye muchas otras funciones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://man7.org/linux/man-pages/man2/listen.2.html">listen()</a>, para poner <em>sockets</em> tipo <code>SOCK_STREAM</code> a la espera de conexiones.</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man2/connect.2.html">connect()</a>, para conectar un <em>socket</em> tipo <code>SOCK_STREAM</code> con otro que estÃ© a la espera de conexiones.</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man2/accept.2.html">accept()</a> para que un <em>socket</em> tipo <code>SOCK_STEAM</code> a la espera de conexiones acepte una solicitud de conexiÃ³n.</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man2/shutdown.2.html">shutdown()</a> para cerrar uno de los sentidos de una conexiÃ³n.</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man2/close.2.html">close()</a> para destruir un <em>socket</em>.</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man2/send.2.html">send()</a>, <a href="https://man7.org/linux/man-pages/man2/send.2.html">sendto()</a> y <a href="https://man7.org/linux/man-pages/man2/send.2.html">sendmsg()</a> para enviar mensajes.
<a href="https://man7.org/linux/man-pages/man2/send.2.html">send()</a> sÃ³lo se puede utilizar con <em>sockets</em> conectados.
Mientras que <a href="https://man7.org/linux/man-pages/man2/send.2.html">sendto()</a> permiten indicar la direcciÃ³n del <em>socket</em> de destino, por lo que es Ãºtil en <em>sockets</em> no orientados a conexiÃ³n <code>SOCK_DGRAM</code>.</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man2/recv.2.html">recv()</a>, <a href="https://man7.org/linux/man-pages/man2/recvfrom.2.html">recvfrom()</a> y <a href="https://man7.org/linux/man-pages/man2/recvmsg.2.html">recvmsg()</a> para recibir mensajes.
<a href="https://man7.org/linux/man-pages/man2/recvfrom.2.html">recvfrom()</a> permite obtener la direcciÃ³n del <em>socket</em> del que llegÃ³ el mensaje.
Por eso es Ãºtil en <em>sockets</em> no orientados a conexiÃ³n <code>SOCK_DGRAM</code>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="k">struct</span> <span class="n">sockaddr_un</span> <span class="n">addr</span><span class="p">;</span>
<span class="n">socklen_t</span> <span class="n">addrlen</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">result_code</span> <span class="o">=</span> <span class="n">recvfrom</span><span class="p">(</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">sockfd</span><span class="p">,</span>          <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="o">&amp;</span><span class="n">message</span><span class="p">,</span>        <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">message</span><span class="p">),</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="mi">0</span><span class="p">,</span>               <i class="conum" data-value="5"></i><b>(5)</b>
    <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <i class="conum" data-value="6"></i><b>(6)</b>
    <span class="o">&amp;</span><span class="n">addrlen</span>         <i class="conum" data-value="7"></i><b>(7)</b>
<span class="p">)</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>En caso de Ã©xito devuelve nÃºmero de bytes del mensaje recibido.
En caso de error, un -1 y <a href="https://man7.org/linux/man-pages/man3/errno.3.html">errno</a> contiene el cÃ³digo del error.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>El descriptor del <em>socket</em> al que se le quiere cambiar la direcciÃ³n.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Puntero a la direcciÃ³n de memoria donde estÃ¡ el mensaje.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>TamaÃ±o del mensaje en bytes.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Opciones adicionales de configuraciÃ³n.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Estructura de direcciÃ³n vacÃ­a donde se copiarÃ¡ la direcciÃ³n del <em>socket</em> que remite el mensaje.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Puntero donde la llamada al sistema copiarÃ¡ el tamaÃ±o de la estructura copiada en <code>addr</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Las operaciones con <em>sockets</em> son sÃ­ncronas por defecto.
Sin embargo, es posible configurarlos en modo asÃ­ncrono, para que asÃ­ cualquiera de estas funciones falle, retornando -1 y cÃ³digo de error <code>EAGAIN</code> o <code>EWOULDBLOCK</code>, antes de poner el proceso en estado <strong>esperando</strong>.</p>
</div>
<div class="paragraph">
<p>TambiÃ©n se pueden utilizar las funciones <a href="https://man7.org/linux/man-pages/man2/select.2.html">select()</a> y <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a> para monitorizar varios <em>sockets</em> al mismo tiempo, de forma similar a como se hace para colas de mensajes POSIX (vÃ©ase el <a href="#_colas_de_mensajes_posix">Apartado 10.5.1</a>).</p>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/socket-server.cpp">socket-server.cpp</a> y <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/socket-client.cpp">socket-client.cpp</a> se puede observar un ejemplo similar al que usamos con las tuberÃ­as y las colas de mensajes, pero empleando <em>sockets</em> de dominio UNIX.
Ambos programas utilizan la cabecera <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap10/socket.hpp">socket.hpp</a> que incluye un ejemplo de clase en C&#43;&#43; para comunicaciones mediante <em>sockets</em>.
En los distintos mÃ©todos se puede ver como se utilizan las funciones de la librerÃ­a del sistema para crear <em>sockets</em>, asignarles direcciÃ³n y usarlos para enviar y recibir mensajes.</p>
</div>
<div class="paragraph">
<p>En resumen, los <strong><em>sockets</em></strong> son un mecanismo de paso de mensajes de <strong>comunicaciÃ³n indirecta</strong>, que admite tanto comunicaciÃ³n <strong>orientada a flujos</strong> como <strong>mensajes de tamaÃ±o variable</strong>, <em>buffering</em> de <strong>capacidad limitada</strong> y tanto <strong>comunicaciÃ³n sÃ­ncrona</strong> como <strong>asÃ­ncrona</strong>, aunque el comportamiento real final de la interfaz depende de la tecnologÃ­a de red utilizada.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_memoria_compartida">11. Memoria compartida</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>5 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>La <strong>memoria compartida</strong> es una estrategia para comunicar procesos dÃ³nde uno de ellos gana acceso a regiones de la memoria del otro; algo que por lo general el sistema operativo siempre intenta evitar.
Por eso, para que pueda haber memoria compartida es necesario que los dos procesos estÃ©n de acuerdo en eliminar dicha restricciÃ³n.</p>
</div>
<div class="paragraph">
<p>Dos procesos que comparten una regiÃ³n de la memoria pueden intercambiar informaciÃ³n simplemente leyendo y escribiendo datos en la misma.
Sin embargo debemos tener en cuenta que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La estructura de los datos y su localizaciÃ³n dentro de la regiÃ³n compartida la determinan los procesos en comunicaciÃ³n y no el sistema operativo, a diferencia de lo que ocurre en los sistemas de paso de mensajes.</p>
</li>
<li>
<p>Los procesos son responsables de sincronizarse para no escribir y leer en el mismo sitio de la memoria al mismo tiempo, pues esto puede generar inconsistencias (vÃ©ase el <a href="#_sincronizaciÃ³n">CapÃ­tulo 13</a>) .</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Las principales ventajas de la memoria compartida frente a otros mecanismos de comunicaciÃ³n son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Eficiencia</strong>.
Puesto que la comunicaciÃ³n tiene lugar a la velocidad de la memoria principal, se trata de un mecanismo tremendamente rÃ¡pido.</p>
</li>
<li>
<p><strong>Conveniencia</strong>.
Puesto que el mecanismo de comunicaciÃ³n sÃ³lo requiere leer y escribir de la memoria, se trata de un sistema muy sencillo y fÃ¡cil de utilizar.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Como ocurre con las tuberÃ­as (vÃ©ase el <a href="#_tuberÃ­as">Apartado 10.5.3</a>) la memoria compartida puede ser anÃ³nima o con nombre.</p>
</div>
<div class="sect2">
<h3 id="_memoria_compartida_anÃ³nima">11.1. Memoria compartida anÃ³nima</h3>
<div class="paragraph">
<p>La <strong>memoria compartida anÃ³nima</strong> solo existe para el proceso que la crea y para sus procesos hijos, que heredan el acceso.
Es por tanto, una forma eficiente de comunicar procesos padres e hijos.</p>
</div>
<div class="paragraph">
<p>En lo sistemas POSIX, las funciones y operadores de reserva de memoria como <a href="https://en.cppreference.com/w/c/memory/malloc">malloc()</a> y <a href="https://en.cppreference.com/w/cpp/language/new">new</a>, utilizan internamente la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a>.
Esta funciÃ³n se puede llamar de la siguiente manera para reservar <code>length</code> bytes de memoria.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">void</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="n">length</span><span class="p">,</span>     <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>      <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="n">MAP_ANONYMOUS</span> <span class="o">|</span> <span class="n">MAP_PRIVATE</span><span class="p">,</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="mi">0</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Si todo va bien, <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a> devuelve un puntero al primer byte de la memoria reservada.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Cantidad de memoria a reservar en bytes.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Permisos de acceso para la memoria reservada.
En este caso, se solicita permitir la lectura y la escritura de la memoria.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>MAP_ANONYMOUS</code> indica que la memoria no estÃ¡ respaldada por ningÃºn archivo, por lo que su contenido inicial serÃ¡ cero.
Mientras que <code>MAP_PRIVATE</code> establece que la regiÃ³n de memoria es privada.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Lo interesante es que si se cambia <code>MAP_PRIVATE</code> por <code>MAP_SHARED</code> la regiÃ³n de memoria reservada es memoria compartida:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">void</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="n">length</span><span class="p">,</span>
    <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
    <span class="n">MAP_ANONYMOUS</span> <span class="o">|</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="mi">0</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Memoria anÃ³nima y compartida.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Es decir, que al crear un hijo con <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> este tendrÃ¡ una copia de toda la memoria del proceso padre, excepto esta regiÃ³n en particular, que serÃ¡ la misma que la del padre.
Por lo tanto, escribiendo y leyendo en esa regiÃ³n, ambos procesos pueden comunicarse.</p>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap11/anom-shared-memory.cpp">anom-shared-memory.cpp</a> se puede ver un ejemplo muy simple, similar a <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/master/src/cap10/fork-pipe.cpp">fork-pipe.cpp</a> pero utilizando memoria compartida para comunicar ambos procesos.
Como se puede apreciar, la versiÃ³n que usa memoria compartida es bastante mÃ¡s sencilla que la que utiliza tuberÃ­as.</p>
</div>
<div class="paragraph">
<p>En Microsoft Windows se puede hacer algo similar con <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga">CreateFileMapping()</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">HANDLE</span> <span class="n">hMapFile</span> <span class="o">=</span> <span class="n">CreateFileMapping</span><span class="p">(</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="n">INVALID_HANDLE_VALUE</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="n">PAGE_READWRITE</span><span class="p">,</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="mi">0</span><span class="p">,</span>
    <span class="n">length</span><span class="p">,</span>         <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="nb">NULL</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Permisos de acceso para la memoria reservada.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Cantidad de memoria a reservar en bytes.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A diferencia de <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a>, <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga">CreateFileMapping()</a> crea un objeto de memoria compartida pero no hace visible esa memoria para nuestro proceso.
Para eso hay que llamar a <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile">MapViewOfFile()</a> pasÃ¡ndole el manejador <code>hMapFile</code> devuelto por <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga">CreateFileMapping()</a>.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_memoria_compartida_con_nombre">11.2. Memoria compartida con nombre</h3>
<div class="paragraph">
<p>La <strong>memoria compartida con nombre</strong> es pÃºblica para el resto del sistema, por lo que teÃ³ricamente cualquier proceso con permisos puede acceder a ella para comunicarse con otros procesos.</p>
</div>
<div class="paragraph">
<p>Como ocurre en las tuberÃ­as con nombre, los <strong>objetos de memoria compartida con nombre</strong> hay que crearlos antes de comenzar a utilizarlos.
Para eso los sistemas POSIX ofrecen la funciÃ³n <a href="https://www.man7.org/linux/man-pages/man3/shm_open.3.html">shm_open()</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="n">shmfd</span> <span class="o">=</span> <span class="n">shm_open</span><span class="p">(</span>   <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="s">"/foo-shm"</span><span class="p">,</span>         <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_CREAT</span><span class="p">,</span>   <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="mi">666</span>                 <i class="conum" data-value="3"></i><b>(3)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Nombre que identifica al objeto de memoria compartida.
Como ocurre con los archivos, varios procesos pueden acceder al mismo objeto indicando el mismo nombre.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Valores que indican diferentes opciones a la hora de abrir el objeto.
Por ejemplo, usando <code>O_RDWR</code> indicamos que se abra para lectura y escritura.
Mientras que con <code>O_CREAT</code> se indica que el objeto debe crearse si no existÃ­a previamente.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Indica los permisos del objeto de memoria compartida al crearlo nuevo, de forma similar a los permisos que se aplican a los archivos en el sistema de archivos.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>El valor devuelto por <a href="https://www.man7.org/linux/man-pages/man3/shm_open.3.html">shm_open()</a> es el descriptor del objeto de memoria compartida, que utilizaremos posteriormente con <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a> al reservar una regiÃ³n de la memoria de nuestro proceso donde ese objeto de memoria compartida serÃ¡ visible:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">void</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="n">length</span><span class="p">,</span>                 <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
    <span class="n">MAP_SHARED</span><span class="p">,</span>             <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">shmfd</span><span class="p">,</span>                  <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="mi">0</span>                       <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Al pasar el descriptor del objeto de memoria compartida, ya no se puede indicar <code>MAP_ANONYMOUS</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Se puede hacer visible para el proceso todo el objeto de memoria compartida o solo una parte.
Para esto Ãºltimo se indica el tamaÃ±o de la regiÃ³n y el desplazamiento dentro del objeto, que es el Ãºltimo argumento de <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Un objeto de memoria compartida reciÃ©n creado tiene tamaÃ±o 0.
Para redimensionarlo se utiliza <a href="https://linux.die.net/man/2/ftruncate">ftruncate()</a>, que lo que necesita es el descriptor del objeto y el nuevo tamaÃ±o.</p>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap11/shared-memory-server.c">shared-memory-server.c</a> y <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap11/shared-memory-client.cpp">shared-memory-client.cpp</a> se puede ver el ejemplo de un programa que muestra periÃ³dicamente la hora del sistema.
En este caso controlado por otro mediante memoria compartida.
Ambos programas usan la clase definida en <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap11/shared_memory.hpp">shared_memory.hpp</a> para gestionar el objeto de memoria compartida.
Sus mÃ©todos muestran de forma prÃ¡ctica cÃ³mo utilizar las llamadas al sistema comentadas.</p>
</div>
<div class="paragraph">
<p>En Microsoft Windows tambiÃ©n se utiliza <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga">CreateFileMapping()</a> para crear el objeto de memoria compartida con nombre.
Simplemente hay que indicar el nombre en el Ãºltimo argumento de la funciÃ³n.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">HANDLE</span> <span class="n">hMapFile</span> <span class="o">=</span> <span class="n">CreateFileMapping</span><span class="p">(</span>
    <span class="n">INVALID_HANDLE_VALUE</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="n">PAGE_READWRITE</span><span class="p">,</span>
    <span class="mi">0</span><span class="p">,</span>
    <span class="n">length</span><span class="p">,</span>
    <span class="s">"Global</span><span class="se">\\</span><span class="s">FooMemoriaCompartida"</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Nombre del nuevo objeto de memoria compartida.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hilos">12. Hilos</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>35 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>En el modelo de proceso que hemos descrito hasta el momento, cada proceso tiene una Ãºnica secuencia de instrucciones que se ejecuta en la CPU.
Si los procesos solo pueden tener una Ãºnica secuencia de instrucciones, solo pueden realizar una tarea a la vez.
Por ejemplo, en un procesador de textos en un sistema operativo con este modelo de procesos, el usuario nunca podrÃ­a escribir al mismo tiempo que se comprueba la ortografÃ­a.
Si queremos hacer varias tareas al mismo tiempo, estamos obligados a crear varios procesos y seleccionar un mecanismo de comunicaciÃ³n para que Ã©stos colaboren.</p>
</div>
<div class="paragraph">
<p>Por eso muchos sistemas operativos modernos han extendido el concepto de proceso para permitir que cada uno tenga mÃºltiples secuencias de instrucciones para ejecutarse en la CPU.
A cada una de estas secuencias de instrucciones se las conoce como <strong>hilo</strong> de ejecuciÃ³n.
Los procesos con varios hilos pueden realizar varias tareas a la vez.</p>
</div>
<div class="sect2">
<h3 id="_introducciÃ³n_2">12.1. IntroducciÃ³n</h3>
<div class="paragraph">
<p>Desde que introducimos el concepto de <strong>proceso</strong> hemos considerado que es la unidad bÃ¡sica de uso de la CPU.
Es decir, que la CPU se asignaba a los procesos, que la usaban para ejecutar sus instrucciones.
Sin embargo, en los <strong>sistemas operativos multihilo</strong> es el <strong>hilo</strong> la unidad bÃ¡sica de uso de la CPU.</p>
</div>
<div id="multihilo" class="imageblock">
<div class="content">
<img src="C12-hilos/media/procesos_multihilo.svg" alt="procesos multihilo">
</div>
<div class="title">Figura 30. ComparaciÃ³n entre procesos monohilo y proceso multihilo.</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Cada hilo tiene una serie de recursos propios dentro del proceso (vÃ©ase la <a href="#multihilo">Figura 30</a>):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>El identificador del hilo</strong>, que es Ãºnico para cada hilo y sirve para identificarlos, de la misma manera que lo hace el identificador de proceso con cada proceso.</p>
</li>
<li>
<p><strong>El contador de programa</strong>, que es el registro de la CPU que indica la direcciÃ³n de la prÃ³xima instrucciÃ³n del hilo que debe ser ejecutada por la CPU.</p>
</li>
<li>
<p><strong>Los registros de la CPU</strong>, cuyos valores son diferentes en cada hilo puesto que, aunque todos los hilos ejecutan el mismo programa, pueden ejecutar diferentes partes del mismo.</p>
</li>
<li>
<p><strong>La pila</strong>, que contiene datos temporales como argumentos y direcciones de retorno de las funciones y variables locales.
Al igual que ocurre con los registros de la CPU, cada hilo necesita su pila porque recorre el programa de manera diferente.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Sin embargo hay otros recursos del proceso que se comparten entre todos los hilos del mismo (vÃ©ase la <a href="#multihilo">Figura 30</a>):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>El cÃ³digo del programa</strong>.
El programa es el mismo para todos los hilos.</p>
</li>
<li>
<p><strong>Los segmentos BSS y de datos y el montÃ³n</strong>.
Las secciones de datos diferentes de la pila son accesibles a todos los hilos.
Eso quiere decir, por ejemplo, que cualquier hilo puede acceder y modificar una variable global o una asignada dinÃ¡micamente mediante <a href="https://en.cppreference.com/w/c/memory/malloc">malloc()</a> o <a href="https://en.cppreference.com/w/cpp/language/new">new</a>.</p>
</li>
<li>
<p><strong>Otros recursos del proceso</strong> como archivos, <em>sockets</em>, tuberÃ­as y dispositivos abiertos, regiones de memoria compartida, seÃ±ales, directorio actual de trabajo, entre muchos otros recursos.</p>
</li>
</ul>
</div>
</div>
</div>
<div id="proceso_multihilo_en_memoria" class="imageblock">
<div class="content">
<img src="C12-hilos/media/proceso_multihilo_en_memoria.svg" alt="proceso multihilo en memoria">
</div>
<div class="title">Figura 31. AnatomÃ­a de un proceso multihilo en memoria.</div>
</div>
<div class="paragraph">
<p>En la <a href="#proceso_multihilo_en_memoria">Figura 31</a> se puede observar como cambia la disposiciÃ³n de los elementos de un proceso en la memoria cuando es multihilo, respecto a lo que vimos en el <a href="#_el_proceso">Apartado 9.1</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_beneficios">12.2. Beneficios</h3>
<div class="paragraph">
<p>Son muchos los beneficios que aporta la programaciÃ³n multihilo:</p>
</div>
<div class="sect3">
<h4 id="_tiempo_de_respuesta">12.2.1. Tiempo de respuesta</h4>
<div class="paragraph">
<p>Una aplicaciÃ³n multihilo interactiva puede continuar ejecutando tareas aunque uno o varios hilos de la misma estÃ©n bloqueados o realizando operaciones muy lentamente, mejorando asÃ­ el tiempo de respuesta al usuario.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, un navegador web multihilo puede gestionar la interacciÃ³n del usuario a travÃ©s de un hilo, mientras el contenido solicitado se descarga en otro.
Para hacer lo mismo en un navegador monohilo habrÃ­a que utilizar comunicaciones asÃ­ncronas, de lo contrario, mientras el proceso estÃ¡ en estado <strong>esperando</strong>, a la espera de que lleguen los datos a travÃ©s de la red, no puede atender las acciones del usuario.</p>
</div>
</div>
<div class="sect3">
<h4 id="_comparticiÃ³n_de_recursos">12.2.2. ComparticiÃ³n de recursos</h4>
<div class="paragraph">
<p>En sistemas operativos monohilo se pueden crear varios procesos y comunicarlos mediante memoria compartida para conseguir algo similar a lo que ofrecen los sistemas multihilo.
Sin embargo, al utilizar hilos, las tareas ejecutadas en ellos comparten los recursos automÃ¡ticamente, sin que tengamos que hacer nada.
AdemÃ¡s, los hilos no solo comparten la memoria, sino tambiÃ©n otros muchos recursos del proceso.
Por lo que los hilos son una forma mÃ¡s conveniente de tener procesos que realizan diferentes actividades al mismo tiempo.</p>
</div>
</div>
<div class="sect3">
<h4 id="_economÃ­a">12.2.3. EconomÃ­a</h4>
<div class="paragraph">
<p>Reservar memoria y otros recursos para la creaciÃ³n de un proceso es muy costoso.
Por eso los sistemas operativos modernos han desarrollado diversas tÃ©cnicas para que sea lo mÃ¡s eficaz posible.</p>
</div>
<div class="paragraph">
<p>Aun asÃ­, puesto que los hilos comparten los recursos de los procesos a los que pertenecen, son mucho mÃ¡s econÃ³micos de crear.
TambiÃ©n es mÃ¡s econÃ³mico el cambio de contexto entre ellos ya que hay que guardar y recuperar menos informaciÃ³n al cambiar entre dos hilos de un mismo proceso.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, en Microsoft Windows crear un procesos puede ser 300 veces mÃ¡s costoso que un hilo. Mientras que en sistemas Linux es 3 veces mÃ¡s lento, por la eficiencia de <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_aprovechamiento_de_las_arquitecturas_multiprocesador">12.2.4. Aprovechamiento de las arquitecturas multiprocesador.</h4>
<div class="paragraph">
<p>En los sistemas multiprocesador diferentes hilos pueden ejecutarse en paralelo en distintos procesadores.
Por el contrario, un proceso monohilo sÃ³lo se puede ejecutar en una CPU a la vez, independientemente de cuantas CPU estÃ©n disponibles para ejecutarlo.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_soporte_multihilo">12.3. Soporte multihilo</h3>
<div class="paragraph">
<p>Las <strong>librerÃ­as de hilos</strong> proporcionan al programador la interfaz de programaciÃ³n para crear y gestionar los hilos de su proceso.
Hay dos formas de implementar una librerÃ­a de hilos: en el espacio de usuario o en el nÃºcleo.</p>
</div>
<div class="sect3">
<h4 id="_librerÃ­a_de_hilos_en_el_espacio_de_usuario">12.3.1. LibrerÃ­a de hilos en el espacio de usuario</h4>
<div class="paragraph">
<p>La librerÃ­a de hilos se puede implementar en el espacio de usuario, junto al cÃ³digo y los datos del proceso, sin requerir ningÃºn soporte especial por parte del nÃºcleo.</p>
</div>
<div class="paragraph">
<p>Estos hilos no existen para el nÃºcleo del sistema operativo, solo para el proceso que los ha creado.
Por ese motivo se los denomina <strong>hilos de usuario</strong> o <strong>hilos del nivel de usuario</strong>.</p>
</div>
<div class="paragraph">
<p>Como el cÃ³digo y los datos de la librerÃ­a residen en el espacio de usuario, invocar una funciÃ³n de la misma se reduce a una simple llamada a una funciÃ³n, evitando el coste de hacer llamadas al sistema.</p>
</div>
</div>
<div class="sect3">
<h4 id="_librerÃ­a_de_hilos_en_el_nÃºcleo">12.3.2. LibrerÃ­a de hilos en el nÃºcleo</h4>
<div class="paragraph">
<p>Si la librerÃ­a de hilos se implementa en el nÃºcleo, es el nÃºcleo del sistema el que se encarga de darles soporte.
Por ese motivo se los denomina <strong>hilos de nÃºcleo</strong> o <strong>hilos del nivel de nÃºcleo</strong>.</p>
</div>
<div class="paragraph">
<p>Aparte del <strong>PCB</strong> que vimos en el <a href="#_bloque_de_control_de_proceso">Apartado 9.3</a>, cada hilo tiene una estructura llamada <strong>bloque de control del hilo</strong> o TCB (<em>Thread Control Block</em>) que representa a cada hilo en el sistema operativo y que guarda informaciÃ³n sobre su estado de actividad actual.</p>
</div>
<div class="paragraph">
<p>En estos sistemas, es el hilo la unidad bÃ¡sica de uso de la CPU.
Son los hilos los que se mueven por los estados del <a href="#diagrama_estado_proceso">Figura 27</a> y las colas de la <a href="#colas_de_planificaciÃ³n_procesos">Figura 28</a> y no los procesos.
El planificador de la CPU selecciona un hilo para ejecutarse en la CPU de entre todos los que estÃ¡n en el estado <strong>preparado</strong> en el sistema y el <strong>cambio de contexto</strong> asigna la CPU a un hilo distinto al que la tiene asignada en el momento actual.</p>
</div>
<div class="paragraph">
<p>Por tanto, es en <strong>TCB</strong> ây no en el <strong>PCB</strong>â donde se guarda la informaciÃ³n privada del hilo necesaria para la gestiÃ³n de los estados y para el cambio de contexto, como: los valores de los registros de la CPU y el contador de programa, el estado o la informaciÃ³n de planificaciÃ³n de la CPU; ademÃ¡s de un puntero al <strong>PCB</strong> al que pertenece el hilo con el resto de la informaciÃ³n privada del proceso.</p>
</div>
<div class="paragraph">
<p>Como el cÃ³digo y los datos de la librerÃ­a residen en el espacio del nÃºcleo, invocar una funciÃ³n de la misma requiere frecuentemente hacer una llamada al sistema.
Obviamente, la librerÃ­a del sistema ofrece funciones para no tener que hacer la llamada al sistema directamente.</p>
</div>
<div class="paragraph">
<p>En la actualidad, en los diferentes sistemas operativos se pueden encontrar librerÃ­as de ambos tipos.
Por ejemplo, la librerÃ­a de hilos de Windows API se implementa en el nÃºcleo (vÃ©ase <a href="https://docs.microsoft.com/en-us/windows/win32/procthread/using-processes-and-threads">Â«Using Processes and Threads&#8201;&#8212;&#8201;Microsoft DocsÂ»</a>) mientras que la librerÃ­a de hilos <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a> âfrecuentemente utilizada en los sistemas POSIXâ puede ser de ambos tipos, dependiendo solamente del sistema donde se implemente. En Linux y en la mayor parte de los UNIX modernos, POSIX Threads se implementa en el nÃºcleo del sistema.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_modelos_multihilo">12.4. Modelos multihilo</h3>
<div class="paragraph">
<p>Las distintas formas de implementar los hilos comentadas anteriormente âen espacio de usuario o en el nÃºcleoâ no son excluyentes, ya que en un sistema operativo concreto se pueden implementar ambas, una de las dos o ninguna.</p>
</div>
<div class="paragraph">
<p>A continuaciÃ³n veremos los modelos a los que han dado lugar las distintas combinaciones.</p>
</div>
<div class="sect3">
<h4 id="_muchos_a_uno">12.4.1. Muchos a uno</h4>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>En el modelo <strong>muchos a uno</strong> los hilos que ve el proceso se mapean en un Ãºnica Â«entidad planificable en la CPUÂ» del nÃºcleo.</p>
</div>
<div class="paragraph">
<p>Ãste, por lo general, es el modelo utilizado cuando el nÃºcleo no soporta mÃºltiples hilos de ejecuciÃ³n.
En ese caso, la Ãºnica entidad planificable en la CPU que conoce el nÃºcleo es el proceso, la librerÃ­a de hilos se implementa en el espacio de usuario âdentro del procesoâ y los hilos que ve el proceso son <strong>hilos de usuario</strong> (vÃ©ase la <a href="#modelo_muchos_a_uno">Figura 32</a>).</p>
</div>
<div id="modelo_muchos_a_uno" class="imageblock">
<div class="content">
<img src="C12-hilos/media/modelo_muchos_a_uno.svg" alt="modelo muchos a uno">
</div>
<div class="title">Figura 32. Modelo muchos a uno.</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Las principales caracterÃ­sticas de este modelo son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La gestiÃ³n de hilos se hace con una librerÃ­a en el espacio de usuario, por lo que los hilos se pueden crear de forma rÃ¡pida y con poco coste.
Como hemos visto anteriormente, la invocaciÃ³n de las funciones de la librerÃ­a se hace por medio de simples llamadas a funciones.</p>
</li>
<li>
<p>Si uno de los hilos solicita al sistema operativo una operaciÃ³n que deba ser bloqueada a la espera âpor ejemplo, operaciones de E/S sobre archivos, comunicaciones o esperar a que otro proceso termineâ todo el proceso es bloqueado, no pudiendo ejecutarse otros hilos del mismo proceso mientras tanto.
Eso significa que si nuestros hilos hacen ese tipo de operaciones, el resultado es como si no tuviÃ©ramos hilos.</p>
</li>
<li>
<p>Como sÃ³lo un hilo puede ser asignado al proceso, los hilos de un mismo proceso no se pueden ejecutar en paralelo en sistemas multiprocesador.
El planificador de la librerÃ­a de hilos es el encargado de determinar quÃ© hilo de usuario es asignado al proceso y Ã©ste solo puede ejecutarse en una Ãºnica CPU al mismo tiempo.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>El problema del bloqueo de procesos puede ser evitado interceptando las llamadas a funciones de la librerÃ­a del sistema, para evitar el uso de llamadas al sistema que se puedan bloquear y sustituirlas por versiones equivalentes pero asÃ­ncronas.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, si un hilo llamase a las funciones <a href="https://man7.org/linux/man-pages/man2/recv.2.html">recv()</a> o <a href="https://man7.org/linux/man-pages/man2/send.2.html">send()</a> de la librerÃ­a del sistema, habrÃ­a que hacer que realmente se invocase una versiÃ³n diferente que utilizase estas funciones de forma asÃ­ncrona.
Mientras la operaciÃ³n es ejecutada por el sistema operativo, en lugar de retornar de la funciÃ³n, se llama al planificador de la librerÃ­a de hilos para que la ejecuciÃ³n continÃºe con otro hilo del proceso, dejando suspendido el que tiene pendiente la operaciÃ³n.
Obviamente, el planificador de la librerÃ­a de hilos debe estar al tanto de cuÃ¡ndo las operaciones asÃ­ncronas son completadas para poder volver a planificar los <strong>hilos de usuario</strong> suspendidos.</p>
</div>
<div class="paragraph">
<p>Este procedimiento es a todas luces bastante complejo y requiere versiones no bloqueantes de todas las llamadas al sistema âque no siempre existenâ asÃ­ como modificar o interceptar de alguna forma las funciones bloqueantes de la librerÃ­a del sistema para implementar el comportamiento descrito.</p>
</div>
<div class="sect4">
<h5 id="_implementaciones">Implementaciones</h5>
<div class="paragraph">
<p>A este modelo de hilos frecuentemente se lo llama <a href="https://en.wikipedia.org/wiki/Green_threads">Green Threads</a>.
En Java 1.1 era el Ãºnico modelo soportado, pero debido a sus limitaciones se implementÃ³ el soporte del modelo <strong>uno a uno</strong> en versiones posteriores.</p>
</div>
<div class="paragraph">
<p>Otras implementaciones de este modelo son las <a href="https://docs.microsoft.com/en-us/windows/win32/procthread/fibers">fibras</a> de Windows API, <a href="http://www.stackless.com/">Stackless Python</a> y <a href="http://www.gnu.org/software/pth/">GNU Portable Threads</a>.
Estas implementaciones son muy Ãºtiles en los sistemas monohilo, de cara a poder ofrecer cierto soporte de hilos a las aplicaciones.
Pero tambiÃ©n lo son en los sistemas multihilo, ya que debido a su bajo coste en recursos y a su alta eficiencia son ideales cuando la cantidad de hilos a crear âel nivel de concurrenciaâ va a ser previsiblemente muy alta.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_uno_a_uno">12.4.2. Uno a uno</h4>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>En el modelo <strong>uno a uno</strong> cada hilo que ve el proceso se mapea en una Â«entidad planificable en la CPUÂ» diferente del nÃºcleo.</p>
</div>
<div class="paragraph">
<p>Ãste, por lo general, es el modelo utilizado cuando el nÃºcleo del sistema operativo soporta hilos de ejecuciÃ³n.
En este caso, la librerÃ­a de hilos se implementa en el nÃºcleo, por lo que las entidades que planifica el nÃºcleo en la CPU son los <strong>hilos de nÃºcleo</strong> y los procesos pueden gestionar estos hilos mediante llamadas al sistema.</p>
</div>
<div id="modelo_uno_a_uno" class="imageblock">
<div class="content">
<img src="C12-hilos/media/modelo_uno_a_uno.svg" alt="modelo uno a uno">
</div>
<div class="title">Figura 33. Modelo uno a uno.</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Las principales caracterÃ­sticas de este modelo son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Permite a otros hilos del mismo proceso ejecutarse aun cuando uno de ellos haga una llamada al sistema que debe bloquearse.
El nÃºcleo se encarga de ponerlo en espera y planificar en la CPU a otro de los hilos preparados para ejecutarse de entre todos los existentes en el sistema.</p>
</li>
<li>
<p>Permite paralelismo en sistemas multiprocesador, ya que diferentes hilos pueden ser planificados por el nÃºcleo en distintos procesadores.</p>
</li>
<li>
<p>Crear un hilo para un proceso implica crear ciertas estructuras de datos en el nÃºcleo.
Debido a que la cantidad de memoria disponible para el nÃºcleo suele estar limitada, muchos sistemas restringen la cantidad mÃ¡xima de <strong>hilos de nÃºcleo</strong> soportados.</p>
</li>
<li>
<p>La gestiÃ³n de los hilos se hace con una librerÃ­a en el espacio de nÃºcleo, lo que requiere que el proceso haga llamadas al sistema para gestionarlos.
Esto siempre es mÃ¡s lento que invocar simplemente una funciÃ³n, como ocurre en el modelo <strong>muchos a uno</strong>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Este modelo se utilizar en la mayor parte de los sistemas operativos multihilo modernos.
Linux, Microsoft Windows âdesde Windows 95â <a href="https://es.wikipedia.org/wiki/Solaris_(sistema_operativo)">Solaris</a> 9 y superiores, macOS y la familia de UNIX BSD; son ejemplos de sistemas operativos que utiliza el modelo <strong>uno a uno</strong>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_muchos_a_muchos">12.4.3. Muchos a muchos</h4>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>En teorÃ­a deberÃ­a ser posible aprovechar lo mejor de los dos modelos anteriores con una librerÃ­a de hilos en el nÃºcleo, para crear <strong>hilos de nÃºcleo</strong>, y otra en el espacio de usuario, para crear <strong>hilos de usuario</strong>.
AsÃ­ los desarrolladores pueden utilizar la librerÃ­a de hilos en el espacio de usuario para crear tantos hilos como quieran y que se ejecuten sobre los <strong>hilos de nÃºcleo</strong>.</p>
</div>
<div class="paragraph">
<p>El planificador de la librerÃ­a de hilos se encarga de determinar quÃ© hilo de usuario es asignado a quÃ© hilo de nÃºcleo.
Mientras que el planificador de la CPU asigna la CPU a alguno de los <strong>hilos de nÃºcleo</strong> del sistema.</p>
</div>
<div id="modelo_muchos_a_muchos" class="imageblock">
<div class="content">
<img src="C12-hilos/media/modelo_muchos_a_muchos.svg" alt="modelo muchos a muchos">
</div>
<div class="title">Figura 34. Modelo muchos a muchos.</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>En el modelo <strong>muchos a muchos</strong> se mapean los <strong>hilos de usuario</strong> en un menor o igual nÃºmero de <strong>hilos de nÃºcleo</strong> del proceso (vÃ©ase la <a href="#modelo_muchos_a_muchos">Figura 34</a>).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Permite paralelismo en sistemas multiprocesador, ya que diferentes <strong>hilos de nÃºcleo</strong> pueden ser planificados en distintos procesadores y en cada uno puede ejecutarse cualquier hilo de usuario.</p>
</li>
<li>
<p>Permite a otro hilo de usuario del mismo proceso ejecutarse cuando un hilo hace una llamada al sistema que debe bloquearse, puesto que si esto ocurre el correspondiente hilo de nÃºcleo queda bloqueado.
Sin embargo, el resto de los <strong>hilos de usuario</strong> pueden seguir ejecutÃ¡ndose en los otros <strong>hilos de nÃºcleo</strong> del proceso.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Este modelo se soportada en sistemas <a href="https://es.wikipedia.org/wiki/FreeBSD">FreeBSD</a> y versiones antiguas de <a href="https://es.wikipedia.org/wiki/NetBSD">NetBSD</a>, asÃ­ como en UNIX comerciales, como: <a href="https://es.wikipedia.org/wiki/Solaris_(sistema_operativo)">Solaris</a> 8 y anteriores, {irixnix, <a href="https://es.wikipedia.org/wiki/HP-UX">HP-UX</a> y <a href="https://es.wikipedia.org/wiki/Tru64">Tru64 UNIX</a>.
TambiÃ©n Microsoft Windows âa partir de Windows 7â soporta este modelo gracias a incorporar un mecanismo denominado planificaciÃ³n en modo usuario (vÃ©ase <a href="https://docs.microsoft.com/en-us/windows/win32/procthread/user-mode-scheduling">Â«User-Mode Scheduling&#8201;&#8212;&#8201;Microsoft DocsÂ»</a>).</p>
</div>
<div class="paragraph">
<p>Algunos lenguajes de programaciÃ³n implementan el modelo <strong>muchos a muchos</strong> sobre el modelo <strong>uno a uno</strong> soportado por la mayorÃ­a de sistemas operativos modernos.
Ese es el caso de <a href="https://es.wikipedia.org/wiki/Go_(lenguaje_de_programaci%C3%B3n)">Go</a>, <a href="https://es.wikipedia.org/wiki/Erlang">Erlang</a> y <a href="https://es.wikipedia.org/wiki/Elixir_(lenguaje_de_programaci%C3%B3n)">Elixir</a>.</p>
</div>
<div class="sect4">
<h5 id="_activaciÃ³n_del_planificador">ActivaciÃ³n del planificador</h5>
<div class="paragraph">
<p>Tanto en el modelo <strong>muchos a muchos</strong> como en el de <strong>dos niveles</strong> es necesario cierto grado de coordinaciÃ³n entre el nÃºcleo y la librerÃ­a de hilos del espacio de usuario.
Dicha comunicaciÃ³n tiene como objeto ajustar dinÃ¡micamente el nÃºmero de <strong>hilos de nÃºcleo</strong> para garantizar la mÃ¡xima eficiencia.</p>
</div>
<div class="paragraph">
<p>Uno de los esquemas de comunicaciÃ³n se denomina <strong>activaciÃ³n del planificador</strong> y consiste en que el nÃºcleo informa a la librerÃ­a de hilos en espacio de usuario que una llamada al sistema va a bloquear un hilo de un proceso.
Antes de dicha notificaciÃ³n, el nÃºcleo se encarga de crear un nuevo hilo de nÃºcleo en el proceso y se lo pasa la librerÃ­a de hilos en la notificaciÃ³n.
AsÃ­, el planificador de la librerÃ­a puede asignarle alguno de los otros <strong>hilos de usuario</strong>, evitando el bloqueo completo del proceso y ajustando el nÃºmero de <strong>hilos de nÃºcleo</strong> dinÃ¡micamente.</p>
</div>
<div class="paragraph">
<p>Debido a la complejidad del mecanismo descrito anteriormente y a la dificultad de coordinar el planificador de la librarÃ­a de hilos con el de la CPU para obtener un rendimiento Ã³ptimo, sistemas como Linux y <a href="https://es.wikipedia.org/wiki/Solaris_(sistema_operativo)">Solaris</a> âa partir de la versiÃ³n 9â han optado finalmente por el modelo <strong>uno a uno</strong>.</p>
</div>
<div class="paragraph">
<p>Con el objetivo de evitar los problemas derivados del coste de dicho modelo, los desarrolladores de Linux han preferido concentrar sus esfuerzos en conseguir un planificador de CPU mÃ¡s eficiente, asÃ­ como en reducir los costes de la creaciÃ³n de <strong>hilos de nÃºcleo</strong>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_dos_niveles">12.4.4. Dos niveles</h4>
<div class="paragraph">
<p>Existe una variaciÃ³n del modelo <strong>muchos a muchos</strong> donde, ademÃ¡s de funcionar de la forma comentada anteriormente, se permite que un hilo de usuario quede ligado indefinidamente a un Ãºnico hilo de nÃºcleo, como en el modelo <strong>uno a uno</strong>.</p>
</div>
<div class="paragraph">
<p>Esta variaciÃ³n se denomina, en ocasiones, modelo de <strong>dos niveles</strong> (vÃ©ase la <a href="#modelo_de_dos_niveles">Figura 35</a>).</p>
</div>
<div id="modelo_de_dos_niveles" class="imageblock">
<div class="content">
<img src="C12-hilos/media/modelo_de_dos_niveles.svg" alt="modelo de dos niveles">
</div>
<div class="title">Figura 35. Modelo muchos a uno.</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_operaciones_sobre_los_hilos">12.5. Operaciones sobre los hilos</h3>
<div class="paragraph">
<p>Como ocurre con los procesos, es necesario que los hilos pueden ser creados y eliminados dinÃ¡micamente, por lo que los sistemas operativos deben proporcionar servicios para la creaciÃ³n y cancelaciÃ³n de los mismos.</p>
</div>
<div class="sect3">
<h4 id="_creaciÃ³n_de_hilos">12.5.1. CreaciÃ³n de hilos</h4>
<div class="paragraph">
<p>En un sistema operativo con librerÃ­a de hilos implementada en el nÃºcleo, todo proceso se crea con un hilo, denominado <strong>hilo principal</strong>.
Ãste es con el que comienza a ejecutarse el programa al entrar en <a href="https://en.cppreference.com/w/c/language/main_function">main()</a> y el que provoca la terminaciÃ³n de todo el proceso âincluida la terminaciÃ³n de los otros hilos que existanâ al retornar de dicha funciÃ³n.</p>
</div>
<div class="paragraph">
<p>El <strong>hilo principal</strong> puede crear otros hilos y estos, a su vez, crear los hilos que necesiten.
Pero, a diferencia de lo que ocurre con los procesos, no existe una relaciÃ³n de padres a hijos ni se crea un Ã¡rbol del hilos.
Excepto por la caracterÃ­sticas especial del <strong>hilo principal</strong> de que su finalizaciÃ³n significa la terminaciÃ³n del proceso, todos los hilos son iguales entre sÃ­.</p>
</div>
<div class="paragraph">
<p>En el <a href="#ejemplo_pthread">Ejemplo 5</a> se puede ver como se usa <a href="https://man7.org/linux/man-pages/man3/pthread_create.3.html">pthread_create()</a> en sistemas POSIX que implementan <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a> para crear varios hilos y esperar a que terminen con <a href="https://man7.org/linux/man-pages/man3/pthread_join.3.html">pthread_join()</a>.</p>
</div>
<div id="ejemplo_pthread" class="exampleblock">
<div class="title">Ejemplo 5. Calcular el factorial de un nÃºmero con <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a>.</div>
<div class="content">
<div class="paragraph">
<p>Vamos a calcular el factorial de 122 repartiendo la tarea entre dos hilos con el objeto de paralelizar los cÃ¡lculos en procesadores multinÃºcleo.</p>
</div>
<div class="paragraph">
<p>El cÃ³digo fuente completo de este ejemplo estÃ¡ disponible en <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap12/pthreads.cpp">pthreads.cpp</a> y, ademÃ¡s, permite indicar el nÃºmero que queramos para calcularle el factorial.
En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap12/threads.cpp">threads.cpp</a> se puede estudiar un ejemplo equivalente pero usando <a href="https://en.cppreference.com/w/cpp/thread/thread">std::thread</a> de la librerÃ­a estÃ¡ndar de C&#43;&#43;, por lo que tambiÃ©n compila en sistemas no POSIX, como Microsoft Windows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">struct</span> <span class="nc">factorial_thread_args</span> <i class="conum" data-value="9"></i><b>(9)</b>
<span class="p">{</span>
    <span class="n">BigInt</span> <span class="n">number</span><span class="p">;</span>
    <span class="n">BigInt</span> <span class="n">lower_bound</span><span class="p">;</span>
    <span class="n">BigInt</span> <span class="n">result</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">factorial_thread</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span>   <i class="conum" data-value="7"></i><b>(7)</b> <i class="conum" data-value="8"></i><b>(8)</b> <i class="conum" data-value="9"></i><b>(9)</b>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">fmt</span><span class="o">::</span><span class="n">format</span><span class="p">(</span> <span class="s">"Hilo creado: 0x{:x}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pthread_self</span><span class="p">()</span> <span class="p">);</span>    <i class="conum" data-value="10"></i><b>(10)</b>

    <span class="n">factorial_thread_args</span><span class="o">*</span> <span class="n">args</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">factorial_thread_args</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span> <i class="conum" data-value="9"></i><b>(9)</b>
    <span class="n">args</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">calculate_factorial</span><span class="p">(</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">lower_bound</span> <span class="p">);</span>

    <span class="k">return</span> <span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">;</span> <i class="conum" data-value="12"></i><b>(12)</b>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">return_code</span><span class="p">;</span>
    <span class="n">pthread_t</span> <span class="n">thread1</span><span class="p">,</span> <span class="n">thread2</span><span class="p">;</span>  <i class="conum" data-value="1"></i><b>(1)</b> <i class="conum" data-value="2"></i><b>(2)</b>

    <span class="n">factorial_thread_args</span> <span class="n">thread1_args</span> <span class="p">{</span>
        <span class="mi">122</span><span class="p">,</span>    <span class="c1">// El primer hilo calcula el factorial multiplicando</span>
        <span class="mi">61</span><span class="p">,</span>     <span class="c1">// desde 122 a 61.</span>
        <span class="mi">0</span>
    <span class="p">};</span>

    <span class="n">factorial_thread_args</span> <span class="n">thread2_args</span> <span class="p">{</span>
        <span class="mi">60</span><span class="p">,</span>     <span class="c1">// El segundo hilo calcula el factorial multiplicando</span>
        <span class="mi">2</span><span class="p">,</span>      <span class="c1">// desde 60 a 2</span>
        <span class="mi">0</span>
    <span class="p">};</span>

    <span class="kt">int</span> <span class="n">return_code</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span> <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="o">&amp;</span><span class="n">thread1</span><span class="p">,</span>           <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="nb">nullptr</span><span class="p">,</span>            <i class="conum" data-value="6"></i><b>(6)</b>
        <span class="n">factoria_thread</span><span class="p">,</span>    <i class="conum" data-value="7"></i><b>(7)</b>
        <span class="o">&amp;</span><span class="n">thread_args</span> <span class="p">);</span>      <i class="conum" data-value="8"></i><b>(8)</b> <i class="conum" data-value="9"></i><b>(9)</b>

    <span class="k">if</span> <span class="p">(</span><span class="n">return_code</span><span class="p">)</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">fmt</span><span class="o">::</span><span class="n">format</span><span class="p">(</span> <span class="s">"Error ({}) al crear el hilo: {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="n">return_code</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">return_code</span><span class="p">)</span> <span class="p">);</span> <i class="conum" data-value="5"></i><b>(5)</b>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">return_code</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">thread2</span><span class="p">,</span> <span class="cm">/* ... */</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">return_code</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="n">BigInt</span><span class="o">*</span> <span class="n">thread1_result</span><span class="p">,</span> <span class="o">*</span><span class="n">thread2_result</span><span class="p">;</span>
    <span class="n">pthread_join</span><span class="p">(</span> <i class="conum" data-value="11"></i><b>(11)</b>
        <span class="n">thread1</span><span class="p">,</span>
        <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">**&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread1_result</span><span class="p">)</span> <span class="p">);</span> <i class="conum" data-value="13"></i><b>(13)</b>
    <span class="n">pthread_join</span><span class="p">(</span> <span class="n">thread2</span><span class="p">,</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">**&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread2_result</span><span class="p">)</span> <span class="p">);</span>

    <span class="c1">// Multiplicar ambos resultados para obtener el factorial</span>
    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="o">*</span><span class="n">thread1_result</span> <span class="o">*</span> <span class="o">*</span><span class="n">thread2_result</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">fmt</span><span class="o">::</span><span class="n">format</span><span class="p">(</span> <span class="s">"El factorial de {} es {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
        <span class="n">number</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span> <span class="n">result</span><span class="p">.</span><span class="n">to_string</span><span class="p">()</span> <span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>En <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a> se usa <a href="https://man7.org/linux/man-pages/man3/pthread_create.3.html">pthread_create()</a> para crear hilos.
Devuelve un manejador de tipo <code>pthread_t</code> que podemos usar con otras funciones de la API para indicar el hilo que queremos gestionar.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>pthread_t</code> no es el equivalente al PID de los hilos.
Si el sistema implementa la librerÃ­a de hilos en el nÃºcleo, por lo general, cada hilo tiene un identificador Ãºnico; pero <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a> no ofrece una forma de obtenerlo.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>La variable <code>pthread_t</code> se pasa a <a href="https://man7.org/linux/man-pages/man3/pthread_create.3.html">pthread_create()</a> como puntero para que al retornar, si todo ha ido bien, contenga el manejador del hilo.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Si el hilo se puede crear, <a href="https://man7.org/linux/man-pages/man3/pthread_create.3.html">pthread_create()</a> devuelve 0.
En caso contrario devuelve un cÃ³digo de error.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Los cÃ³digos de error son los mismos que hasta ahora veÃ­amos en <a href="https://man7.org/linux/man-pages/man3/errno.3.html">errno</a>.
AsÃ­ que podemos llamar a <a href="https://man7.org/linux/man-pages/man3/strerror.3.html">strerror()</a> pasando el valor retornado, para obtener un texto descriptivo del error.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Es opcional pasar a <a href="https://man7.org/linux/man-pages/man3/pthread_create.3.html">pthread_create()</a> una estructura con atributos tales como: tamaÃ±o y posiciÃ³n de la pila, polÃ­tica y parÃ¡metros de planificaciÃ³n, entre otros.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Todo hilo tiene una funciÃ³n principal que serÃ¡ dÃ³nde comience la ejecuciÃ³n del hilo.
Cuando esa funciÃ³n termine, el hilo finalizarÃ¡.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Los hilos pueden recibir un argumento en la forma de un puntero a <code>void*</code>.
Si queremos pasar varios, lo mÃ¡s sencillo es crear una estructura.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>En este ejemplo definimos <code>factorial_thread_args</code> para pasar los argumentos a los hilos y lo pasamos como <code>void *</code> a la funciÃ³n principal.
AllÃ­ hacemos un <em>typecast</em> para recuperar el puntero a la estructura <code>factorial_thread_args</code> y poder acceder a sus campos.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>En cualquier momento se puede llamar a <a href="https://man7.org/linux/man-pages/man3/pthread_self.3.html">pthread_self()</a> para obtener el manejador <code>pthread_t</code> del hilo actual.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>El hilo que invoca <a href="https://man7.org/linux/man-pages/man3/pthread_join.3.html">pthread_join()</a> se queda dormido hasta que el hilo indicado en el primer argumento termine.
Si el hilo principal sale de <a href="https://en.cppreference.com/w/c/language/main_function">main()</a> sin esperar a que todos los hilos del proceso terminen, Ã©stos mueren inmediatamente, junto con el proceso.</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>El hilo puede retornar un resultado mediante un puntero 'void*'.
Ãste se indica en la sentencia <code>return</code> de la funciÃ³n principal del hilo o invocando <a href="https://man7.org/linux/man-pages/man3/pthread_exit.3.html">pthread_exit()</a> para terminar.</td>
</tr>
<tr>
<td><i class="conum" data-value="13"></i><b>13</b></td>
<td>La funciÃ³n <a href="https://man7.org/linux/man-pages/man3/pthread_join.3.html">pthread_join()</a> acepta un puntero a <code>void*</code> para devolver ese valor de retorno al hilo que la invoca.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Como los hilos de <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a> devuelven punteros, es importante no intentar devolver variables locales, ya que se destruirÃ¡n cuando el hilo termine y el punto devuelto no serÃ¡ vÃ¡lido.</p>
</div>
<div class="paragraph">
<p>Una alternativa es devolver los resultados a travÃ©s de la estructura pasada como argumento.
Por ejemplo, el campo <code>result</code> de la estructura <code>factorial_thread_args</code> ofrece una manera mÃ¡s cÃ³moda de obtener el resultado del cÃ¡lculo de cada hilo.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_cancelaciÃ³n_de_hilos">12.5.2. CancelaciÃ³n de hilos</h4>
<div class="paragraph">
<p>La <strong>cancelaciÃ³n</strong> es la operaciÃ³n de terminar un hilo antes de que termine su trabajo.
Por ejemplo, en un navegador web un hilo se puede encargar de la interfaz de usuario mientras otros hilos se encargan de descargar las pÃ¡ginas y las imÃ¡genes de la misma.
Si el usuario pulsa el botÃ³n <strong>Cancelar</strong> es necesario que todos los hilos que intervienen en la descarga sean cancelados.</p>
</div>
<div class="paragraph">
<p>Esto puede ocurrir de dos maneras:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En la <strong>cancelaciÃ³n asÃ­ncrona</strong> el hilo termina inmediatamente.
Esto puede causar problemas al no liberarse los recursos reservados en el proceso por parte del hilo
Por ejemplo, antes de terminar no se cierran archivos abiertos ni se libera memoria de los que solo este hilo tiene los descriptores de archivo y los punteros, respectivamente.</p>
<div class="paragraph">
<p>AdemÃ¡s, si el hilo que termina estaba modificando datos que compartÃ­a con otros hilos, estos cambios podrÃ­an quedar a medias.
Esto puede dejar las estructuras de datos compartidas en un estado inconsistente, causando problemas en otros hilos.</p>
</div>
</li>
<li>
<p>En la <strong>cancelaciÃ³n en diferido</strong> el hilo comprueba periÃ³dicamente cuando debe terminar.
Si no se tiene cuidado, los problemas pueden ser similares a los de la <strong>cancelaciÃ³n asÃ­ncrona</strong>.
La diferencia es que ahora el desarrollador conoce de antemano los puntos donde podrÃ­a terminar el hilo, lo que da una oportunidad de introducirlos solo dÃ³nde sea seguro terminar.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Se denomina <strong>fuga de memoria</strong> al error que ocurre cuando un bloque de memoria reservada no se libera durante la ejecuciÃ³n del programa.
TambiÃ©n pueden ocurrir fugas con otros recursos del sistema operativo, como: archivos, <em>sockets</em>, colas de mensajes o regiones de memoria compartida.</p>
</div>
<div class="paragraph">
<p>Generalmente ocurre porque se pierden todas las referencias a un recurso, por lo que ya no hay oportunidad de liberarlo.
Por ejemplo, cuando se cancela un hilo que es el Ãºnico que tiene algunas referencias, sin liberar antes esos recursos.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_cancelaciÃ³n_en_posix_threads">12.5.3. CancelaciÃ³n en POSIX Threads</h4>
<div class="paragraph">
<p>En <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a> un hilo puede solicitar la cancelaciÃ³n de otro hilo usando [pthread_cancel()].</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="n">return_code</span> <span class="o">=</span> <span class="n">pthread_cancel</span><span class="p">(</span><span class="kr">thread</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>El hilo identificado por el manejador <code>thread</code> serÃ¡ cancelado si estÃ¡ configurado como cancelable.
Por defecto todos los hilos son cancelables, pero eso lo puede cambiar el propio hilo llamando a <a href="https://man7.org/linux/man-pages/man3/pthread_setcancelstate.3.html">pthread_setcancelstate()</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="n">return_code</span> <span class="o">=</span> <span class="n">pthread_setcancelstate</span><span class="p">(</span>
    <span class="n">PTHREAD_CANCEL_DISABLE</span><span class="p">,</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="o">&amp;</span><span class="n">oldstate</span>               <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Con <code>PTHREAD_CANCEL_DISABLE</code> se desactiva la cancelaciÃ³n en el hilo que llama la funciÃ³n.
El otro valor posible es <code>PTHREAD_CANCEL_ENABLE</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>La funciÃ³n devuelve a travÃ©s de un puntero a <code>int</code> el valor anterior del estado de cancelaciÃ³n.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>El tipo de cancelaciÃ³n se puede configurar con <a href="https://www.man7.org/linux/man-pages/man3/pthread_setcanceltype.3.html">pthread_setcanceltype()</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="n">return_code</span> <span class="o">=</span> <span class="n">pthread_setcanceltypr</span><span class="p">(</span>
    <span class="n">PTHREAD_CANCEL_DEFERRED</span><span class="p">,</span>    <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="o">&amp;</span><span class="n">oldtype</span>                    <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Con <code>PTHREAD_CANCEL_DEFERRED</code> se activa la <strong>cancelaciÃ³n en diferido</strong>, que de todas formas es el tipo de cancelaciÃ³n por defecto. El otro valor posible es <code>PTHREAD_CANCEL_ASYNCHRONOUS</code>, que corresponde con la <strong>cancelaciÃ³n asÃ­ncrona</strong>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>La funciÃ³n devuelve a travÃ©s de un puntero a <code>int</code> el valor anterior del tipo de cancelaciÃ³n.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Se pueden cambiar entre estado y tipo de cancelaciÃ³n en cualquier momento, segÃºn lo que encaje mejor con las caracterÃ­sticas de las distintas parte del cÃ³digo.</p>
</div>
<div class="sect4">
<h5 id="_cancelaciÃ³n_asÃ­ncrona">CancelaciÃ³n asÃ­ncrona</h5>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Por los motivos comentados anteriormente, no es recomendable la <strong>cancelaciÃ³n asÃ­ncrona</strong>, a menos que estemos muy seguros de que no puede causar problemas.
Uno de los pocos casos con los que es compatible es en bucles 100% dedicados a ejecutar cÃ¡lculos en la CPU, como el siguiente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="n">factorial</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">number</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">factorial</span> <span class="o">=</span> <span class="n">factorial</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>La <strong>cancelaciÃ³n asÃ­ncrona</strong> no se debe usar si el cÃ³digo reserva memoria dinÃ¡micamente o solicita otros recurso del sistema operativo, porque el hilo podrÃ­a terminar en cualquier momento sin liberarlos.
Tampoco si se modifican estructuras de datos, porque los cambios pueden quedar a medias.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, si la cancelaciÃ³n ocurre en medio de una llamada a <a href="https://en.cppreference.com/w/c/memory/malloc">malloc()</a> o <a href="https://en.cppreference.com/w/cpp/language/new">new</a> no hay forma de saber si ocurriÃ³ antes de que la memoria fuera reservada o despuÃ©s.
Incluso puede haber ocurrido en medio de la operaciÃ³n, dejando en estado inconsistente las estructuras de datos que sirven para seguir la pista de las zonas de memoria reservadas y libres.</p>
</div>
<div class="paragraph">
<p>El estÃ¡ndar POSIX solo indica que las funciones <a href="https://man7.org/linux/man-pages/man3/pthread_setcancelstate.3.html">pthread_setcancelstate()</a> y <a href="https://www.man7.org/linux/man-pages/man3/pthread_setcanceltype.3.html">pthread_setcanceltype()</a> deben ser seguras frente a la <strong>cancelaciÃ³n asÃ­ncrona</strong> del hilo.
En general, no se puede llamar a otras funciones de la librerÃ­a del sistema de forma segura en un hilo cancelable asÃ­ncronamente.</p>
</div>
</div>
<div class="sect4">
<h5 id="_cancelaciÃ³n_en_diferido">CancelaciÃ³n en diferido</h5>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Por tanto, la <strong>cancelaciÃ³n en diferido</strong> es la mejor alternativa.
Con este tipo de cancelaciÃ³n, la terminaciÃ³n del hilo ocurre en puntos concretos del cÃ³digo.</p>
</div>
<div class="paragraph">
<p>En la terminologÃ­a de <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a> a estos puntos se los denomina <strong>puntos de cancelaciÃ³n</strong> y la inmensa mayorÃ­a de las llamadas al sistema que puede poner el hilo en estado <strong>esperando</strong> lo son por si mismas.
Por ejemplo, <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a>, <a href="https://man7.org/linux/man-pages/man2/close.2.html">close()</a>, <a href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a>, <a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a>, <a href="https://man7.org/linux/man-pages/man2/recv.2.html">recv()</a>, <a href="https://man7.org/linux/man-pages/man2/send.2.html">send()</a>, <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a> y <a href="https://man7.org/linux/man-pages/man3/sleep.3.html">sleep()</a>, entre muchas otras (vÃ©ase la lista en la secciÃ³n Â«<em>Cancellation points</em>Â» de la documentaciÃ³n de <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a>).
Eso significa que seguramente tambiÃ©n sean <strong>puntos de cancelaciÃ³n</strong>, las funciones de la librerÃ­a del sistema y de la librerÃ­a estÃ¡ndar del lenguaje que utilizan esas llamadas al sistema.</p>
</div>
<div class="paragraph">
<p>Sabiendo esto, se puede estudiar cada caso.
Si no es seguro permitir la cancelaciÃ³n de un hilo en la invocaciÃ³n de una de estas funciones en nuestro cÃ³digo, se puede usa <a href="https://man7.org/linux/man-pages/man3/pthread_setcancelstate.3.html">pthread_setcancelstate()</a> para desactivar temporalmente el mecanismo de cancelaciÃ³n.
Por ejemplo, una llamada a <a href="https://en.cppreference.com/w/c/io/fprintf">printf()</a> como ayuda para depurar, en medio de los pasos para modificar una estructura de datos âcomo una lista enlazada o una colaâ introduce un <strong>punto de cancelaciÃ³n</strong> en lugar poco seguro; porque
si el hilo se cancela en ese punto, la estructura de datos quedarÃ¡ en estado inconsistente.
La soluciÃ³n es eliminar la llamada a <a href="https://en.cppreference.com/w/c/io/fprintf">printf()</a> o desactivar temporalmente el mecanismo de cancelaciÃ³n.</p>
</div>
<div class="paragraph">
<p>De forma inversa, se pueden introducir manualmente puntos de cancelaciÃ³n llamando a <a href="https://man7.org/linux/man-pages/man3/pthread_testcancel.3.html">pthread_testcancel()</a>.
Por ejemplo, el siguiente bucle no hace llamadas al sistema, por lo que no tiene puntos de cancelaciÃ³n:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="n">factorial</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">number</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">factorial</span> <span class="o">=</span> <span class="n">factorial</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Eso significa que ese cÃ³digo para calcular el factorial de <code>number</code> podrÃ­a ejecutarse durante bastante tiempo sin ofrecer una oportunidad para cancelar el hilo; incluso aunque es un cÃ³digo muy seguro desde el punto de vista de la cancelaciÃ³n.
La soluciÃ³n es introducir manualmente un punto de cancelaciÃ³n:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="n">factorial</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">number</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">factorial</span> <span class="o">=</span> <span class="n">factorial</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">pthread_testcancel</span><span class="p">();</span>   <i class="conum" data-value="1"></i><b>(1)</b>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Comprobar si se ha solicitado la cancelaciÃ³n del hilo y si es asÃ­, cancelar el hilo.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>La <strong>cancelaciÃ³n en diferido</strong> tambiÃ©n presenta retos desde el punto de visto de evitar las fugas de memoria y de otros recursos cuando un hilo es cancelado.
Por ejemplo, supongamos que tenemos una funciÃ³n que abre una tuberÃ­a, crea un hilo para gestionar los mensajes que llegan y devuelve un puntero a una estructura de datos que se puede usar en otras funciones de la librerÃ­a âde forma similar a <a href="https://en.cppreference.com/w/c/io/fopen">fopen()</a> y <code>FILE*</code>â:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">CONN</span><span class="o">*</span> <span class="nf">conn_open</span><span class="p">(</span> <span class="cm">/* ... */</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">CONN</span><span class="o">*</span> <span class="n">handler</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CONN</span><span class="p">)</span> <span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">handler</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">handler</span><span class="o">-&gt;</span><span class="n">fifofd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span> <span class="cm">/* ... */</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fifofd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">free</span><span class="p">(</span> <span class="n">handler</span> <span class="p">);</span> <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">return_code</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handler</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">,</span> <span class="cm">/* ... */</span><span class="p">,</span> <span class="n">handler</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">return_code</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">close</span><span class="p">(</span> <span class="n">handler</span><span class="o">-&gt;</span><span class="n">fifofd</span> <span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="n">free</span><span class="p">(</span> <span class="n">handler</span> <span class="p">);</span> <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">handler</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Evitar la <strong>fuga de memoria</strong> si <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a> o <a href="https://man7.org/linux/man-pages/man3/pthread_create.3.html">pthread_create()</a> fallan.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Evitar la fuga del <em>socket</em> si <a href="https://man7.org/linux/man-pages/man3/pthread_create.3.html">pthread_create()</a> falla.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Este cÃ³digo y la forma en que maneja los errores funciones bien en programas monohilo, porque estamos seguro de que al salir de la funciÃ³n o se completaron todas las etapas o ninguna.
Es decir, si alguna de las peticiones al sistema falla, las hechas anteriormente se Â«deshacenÂ» para evitar la fuga de recursos.</p>
</div>
<div class="paragraph">
<p>Pero no es correcto en programas multihilo porque <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a> y <a href="https://man7.org/linux/man-pages/man2/close.2.html">close()</a> son <strong>puntos de cancelaciÃ³n</strong>.
Si <code>conn_open()</code> es llamada desde un hilo y ese hilo es cancelado, el hilo podrÃ­a terminar a mitad de la funciÃ³n, sin liberar <code>handler</code>, creando un <strong>fuga de memoria</strong> que no se liberarÃ¡ hasta que el proceso termine.
Si <code>conn_open()</code> es llamada en mÃºltiples ocasiones, cada una es una oportunidad para perder memoria.</p>
</div>
<div class="paragraph">
<p>El cÃ³digo anterior se puede mejorar usando <strong>manejadores de limpieza</strong>.
Esos manejadores se organizan en una pila de la que se pueden insertar o extraer llamando a <a href="https://man7.org/linux/man-pages/man3/pthread_cleanup_push.3.html">pthread_cleanup_push()</a> y <a href="https://man7.org/linux/man-pages/man3/pthread_cleanup_pop.3.html">pthread_cleanup_pop()</a>, respectivamente.
Cuando el hilo es cancelado, la librerÃ­a extrae los manejadores de la pila y los va ejecutando en orden, antes de terminar.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">CONN</span><span class="o">*</span> <span class="nf">conn_open</span><span class="p">(</span> <span class="cm">/* ... */</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">CONN</span><span class="o">*</span> <span class="n">handler</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CONN</span><span class="p">)</span> <span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">handler</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">pthread_cleanup_push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span> <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="n">handler</span><span class="o">-&gt;</span><span class="n">fifofd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span> <span class="cm">/* ... */</span> <span class="p">);</span>  <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="k">if</span> <span class="p">(</span><span class="n">fifofd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">pthread_cleanup_pop</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>     <span class="c1">// free(handler) </span><i class="conum" data-value="3"></i><b>(3)</b>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">pthread_cleanup_push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cleanup_fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">fifofd</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">return_code</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handler</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">,</span> <span class="cm">/* ... */</span><span class="p">,</span> <span class="n">handler</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">return_code</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">close</span><span class="p">(</span> <span class="n">handler</span><span class="o">-&gt;</span><span class="n">fifofd</span> <span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="n">pthread_cleanup_pop</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>     <span class="c1">// free(handler) </span><i class="conum" data-value="3"></i><b>(3)</b>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">pthread_cleanup_pop</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <i class="conum" data-value="4"></i><b>(4)</b>

    <span class="k">return</span> <span class="n">handler</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Nada mÃ¡s reservar la memoria de <code>CONN</code> se aÃ±ade un <strong>manejador de limpieza</strong> que llamarÃ¡ a <code>free(handler)</code> si el hilo va a ser cancelado.
AsÃ­ nos aseguramos que <code>handler</code> serÃ¡ liberado si el hilo es cancelado.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>La cancelaciÃ³n solo puede ocurrir en los <strong>puntos de cancelaciÃ³n</strong> que son las llamadas a <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a> y <a href="https://man7.org/linux/man-pages/man2/close.2.html">close()</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>En caso de error, el <strong>manejador de limpieza</strong> ya no hace falta, asÃ­ que se extrae antes de salir de la funciÃ³n.
Se llama a <a href="https://man7.org/linux/man-pages/man3/pthread_cleanup_pop.3.html">pthread_cleanup_pop()</a> con valor distinto de 0 porque asÃ­ la funciÃ³n extrae el manejador y lo invoca.
A fin de cuentas se sale a causa de un error, por lo que sigue siendo necesario ejecutar <code>free(handler)</code> para evitar una <strong>fuga de memoria</strong>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Al termina la funciÃ³n se extraen todos los manejadores de seÃ±al, puesto que ya no hacen falta.
El argumento 0 hace que <a href="https://man7.org/linux/man-pages/man3/pthread_cleanup_pop.3.html">pthread_cleanup_pop()</a> no ejecute el manejador de limpieza extraido.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Ahora <code>conn_open()</code> maneja correctamente la cancelaciÃ³n del hilo donde se ejecuta, por lo que puede usarse sin problemas en aplicaciones multihilo.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_cancelaciÃ³n_de_hilos_en_lenguajes_de_alto_nivel">12.5.4. CancelaciÃ³n de hilos en lenguajes de alto nivel</h4>
<div class="paragraph">
<p>El mecanismo de cancelaciÃ³n de hilos descrito funciona razonablemente bien en C, pero no con lenguajes de mÃ¡s alto nivel, como C&#43;&#43;, Java o C#.
Las librerÃ­as de hilos suelen ser librerÃ­as en C, que no conocen nada de objetos ni de otras particularidades de esos lenguajes.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, en C&#43;&#43;, antes de terminar un hilo, deberÃ­an ser llamados todos los destructores de los objetos locales, para evitar <strong>fugas de memoria</strong> y de otros recursos, datos sin escribir y otro problemas derivados de tener objetos que no se destruyen adecuadamente.
Lamentablemente, el mecanismo de cancelaciÃ³n de <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a> ây el de otras librerÃ­as de hilos, como la de Windows APIâ no sabe hacer nada de eso.
Cada lenguaje debe implementar su propia soluciÃ³n.</p>
</div>
<div class="paragraph">
<p>En Java y C#, por ejemplo, cuando un punto de cancelaciÃ³n detecta una peticiÃ³n de cancelaciÃ³n emite la excepciÃ³n <code>Thread.Interrupt</code>, que retrocede por la pila de llamadas, liberando las variables locales hasta salir por el mÃ©todo principal del hilo.
A este mecanismo se lo denomina <strong>cancelaciÃ³n coordinada</strong>.</p>
</div>
<div class="paragraph">
<p>En C&#43;&#43; no se ha incluido un mecanismo de cancelaciÃ³n en el estÃ¡ndar hasta C&#43;&#43;20.
Antes de C&#43;&#43;20, la forma recomendada de implementar la cancelaciÃ³n es pasando a los hilos una variable de tipo <code>bool</code> con la que seÃ±alarles cuÃ¡ndo deben terminar.
El cÃ³digo de los hilos debe comprobar frecuentemente el valor de dicha variable y, llegado el momento, terminar retornando ordenadamente por la funciÃ³n principal del hilo.</p>
</div>
<div class="paragraph">
<p>En C&#43;&#43;20 esta estrategia de <strong>cancelaciÃ³n cooperativa</strong> se ha formalizado e incluido en el estÃ¡ndar al introducir la clase <a href="https://en.cppreference.com/w/cpp/thread/jthread">std::jthread</a>.
Esta nueva clase de hilo puede pasar a la funciÃ³n principal lo que se llama un <strong><em>token</em> de cancelaciÃ³n</strong> âen lugar de una variable tipo <code>bool</code>â que se debe comprobar regularmente para saber si hay que terminar el hilo prematuramente.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, la funciÃ³n del factorial podrÃ­a hacer uso de esa funcionalidad para terminar cuando se lo indiquen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="kt">void</span> <span class="nf">compute_factorial</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">stop_token</span> <span class="n">stoken</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">factorial</span><span class="p">,</span> <span class="kt">int</span> <span class="n">number</span><span class="p">)</span> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">{</span>
    <span class="n">factorial</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">number</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">stoken</span><span class="p">.</span><span class="n">stop_requested</span><span class="p">())</span> <span class="k">return</span><span class="p">;</span> <i class="conum" data-value="4"></i><b>(4)</b>
        <span class="n">factorial</span> <span class="o">=</span> <span class="n">factorial</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="kt">int</span> <span class="n">factorial</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">jthread</span> <span class="kr">thread</span><span class="p">(</span><span class="n">compute_factorial</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">factorial</span><span class="p">),</span> <span class="mi">122</span><span class="p">);</span>  <i class="conum" data-value="1"></i><b>(1)</b> <i class="conum" data-value="2"></i><b>(2)</b>

    <span class="c1">// ...</span>

    <span class="kr">thread</span><span class="p">.</span><span class="n">request_stop</span><span class="p">();</span> <i class="conum" data-value="3"></i><b>(3)</b>

    <span class="c1">// ...</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Crear e iniciar el hilo con <a href="https://en.cppreference.com/w/cpp/thread/jthread">std::jthread</a> para calcular el factorial de 122.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Al crear el hilo se pasa a la funciÃ³n el <strong><em>token</em> de cancelaciÃ³n</strong> <code>stoken</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>En algÃºn momento de la ejecuciÃ³n del programa pedimos al hilo que se detenga antes de terminar los cÃ¡lculos.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>El cÃ³digo del hilo debe comprobar el <strong><em>token</em> de cancelaciÃ³n</strong> regularmente.
Si se ha pedido la cancelaciÃ³n, se termina el hilo retornando desde la funciÃ³n principal.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Java y C# han terminado incluyendo tambiÃ©n este tipo de <strong>cancelaciÃ³n cooperativa</strong> usando un <strong><em>token</em> de cancelaciÃ³n</strong>, debido a los problemas que tienen los desarrolladores para recordar usar correctamente la excepciÃ³n de la <strong>cancelaciÃ³n coordinada</strong>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_otras_consideraciones_sobre_los_hilos">12.6. Otras consideraciones sobre los hilos</h3>
<div class="sect3">
<h4 id="_las_llamadas_al_sistema_fork_y_exec_en_procesos_multihilo">12.6.1. Las llamadas al sistema fork() y exec() en procesos multihilo</h4>
<div class="paragraph">
<p>La llamada al sistema <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> de los sistemas POSIX es anterior a la existencia del concepto de <strong>hilo</strong>.
AsÃ­ que cuando estos aparecieron surgiÃ³ el problema de si al llamar a <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> en un proceso multihilo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>El nuevo proceso debÃ­a tener un duplicado de todos los hilos.</p>
</li>
<li>
<p>O el nuevo proceso debÃ­a tener un Ãºnico hilo copia del que invocÃ³ a <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Como hemos comentado anteriormente, la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> sustituye el programa en ejecuciÃ³n con un nuevo programa e inicia su ejecuciÃ³n en <a href="https://en.cppreference.com/w/c/language/main_function">main()</a>.
Esto incluye liberar toda la memoria reservada y la destrucciÃ³n de todos los hilos del programa original, por lo que duplicar los hilos en el proceso hijo creado por <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>, si luego se va a llamar a <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> parece algo innecesario.</p>
</div>
<div class="paragraph">
<p>El estÃ¡ndar POSIX establece que si se utiliza <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> en un programa multihilo, el nuevo proceso debe ser creado con un sÃ³lo hilo, que serÃ¡ una rÃ©plica del que hizo la llamada, asÃ­ como un duplicado completo del espacio de direcciones del proceso.</p>
</div>
<div class="paragraph">
<p>Sin embargo, algunos sistemas UNIX tienen una segunda llamada no estÃ¡ndar denominada <code>forkall()</code>, capaz de duplicar todos los hilos del proceso padre.
Obviamente solo resulta conveniente emplearla si no se va a utilizar la llamada <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> a continuaciÃ³n.
La inclusiÃ³n de <code>forkall()</code> en el estÃ¡ndar POSIX fue considerada y rechazada.</p>
</div>
</div>
<div class="sect3">
<h4 id="_manejo_de_seÃ±ales_en_procesos_multihilo">12.6.2. Manejo de seÃ±ales en procesos multihilo</h4>
<div class="paragraph">
<p>En el <a href="#_seÃ±ales_en_sistemas_operativos_posix">Apartado 10.5.2</a> hablamos del uso de las seÃ±ales como mecanismo de comunicaciÃ³n, pero en general sirven para informar a un proceso del suceso de ciertos eventos.</p>
</div>
<div class="paragraph">
<p>Existen dos tipos de seÃ±ales:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Las <strong>seÃ±ales sÃ­ncronas</strong> se deben a alguna acciÃ³n del propio proceso.
Ejemplos de seÃ±ales de este tipo son <code>SIGSEV</code> y <code>SIGFE</code>, originadas por accesos ilegales a memoria o divisiones por 0, respectivamente.</p>
<div class="paragraph">
<p>Las seÃ±ales sÃ­ncronas son enviadas al mismo proceso que las origina.</p>
</div>
</li>
<li>
<p>Las <strong>seÃ±ales asÃ­ncronas</strong> son debidas a acciones externas.
Un ejemplo de este tipo de seÃ±ales es la terminaciÃ³n de procesos con teclas especiales como <span class="keyseq"><kbd>CTRL</kbd>+<kbd>C</kbd></span> o <kbd>CTRL-D</kbd>, que envÃ­an al proceso las seÃ±ales <code>SIGINT</code> y <code>SIGHUP</code> respectivamente.
TambiÃ©n lo son las seÃ±ales enviadas desde otro proceso, como cuando el proceso <strong>init</strong> envÃ­a <code>SIGTERM</code> al resto de procesos para informales que deben terminar porque el sistema se va a apagar.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Como hemos visto, las seÃ±ales que llegan a un proceso pueden ser interceptadas por una funciÃ³n definida por el programador llamada <strong>manejador de seÃ±al</strong>.</p>
</div>
<div class="paragraph">
<p>Las seÃ±ales tambiÃ©n son anteriores a los hilos, por lo que cuando aparecieron los hilos se tuvieron que tomar decisiones sobre como iban a encajar ambos conceptos.
Por ejemplo, decidir cuÃ¡l de los hilos del proceso, serÃ¡ interrumpido cuando llegue una seÃ±al, para ejecutar el manejador de seÃ±ales.</p>
</div>
<div class="sect4">
<h5 id="_seÃ±ales_enviadas_por_otros_hilos">SeÃ±ales enviadas por otros hilos</h5>
<div class="paragraph">
<p>En los sistemas POSIX multihilo se pueden enviar seÃ±ales a un proceso:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">kill</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">SIGTERM</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>En ese caso uno cualquiera de los hilos podrÃ¡ ser interrumpido para ejecutar el manejador de seÃ±al.</p>
</div>
<div class="paragraph">
<p>Cada hilo puede enmascarar las seÃ±ales que considere llamando a <a href="https://man7.org/linux/man-pages/man3/pthread_sigmask.3.html">pthread_sigmask()</a>
Es decir, cada hilo puede elegir que seÃ±ales quiere bloquear para no tener que atenderlas:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">sigset_t</span> <span class="n">set</span><span class="p">;</span>               <i class="conum" data-value="1"></i><b>(1)</b>

<span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="p">);</span>          <i class="conum" data-value="2"></i><b>(2)</b>
<span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="p">,</span> <span class="n">SIGINT</span><span class="p">);</span>    <i class="conum" data-value="3"></i><b>(3)</b>
<span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="p">,</span> <span class="n">SIGUSR1</span><span class="p">);</span>   <i class="conum" data-value="4"></i><b>(4)</b>

<span class="n">pthread_sigmask</span><span class="p">(</span><span class="n">SIG_BLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">set</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Las mÃ¡scaras de seÃ±ales se definen mediante <em>sets</em> de seÃ±ales.
El tipo de los <em>sets</em> de seÃ±ales es <code>sigset_t</code>, de cuyo tipo real no deberÃ­amos preocuparnos, por portabilidad.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Para manipular los <em>sets</em> se proporcionan una serie de funciones.
<a href="https://man7.org/linux/man-pages/man3/sigemptyset.3.html">sigemptyset()</a> es para asegurar que el <em>set</em> estÃ¡ vacÃ­o.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>AÃ±adimos al <em>set</em> la seÃ±al <code>SIGINT</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>AÃ±adimos al <em>set</em> la seÃ±al <code>SIGINT</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Bloqueamos en el hilo actual las seÃ±ales en el <em>set</em> <code>set</code>,es decir, <code>SIGINT</code> y <code>SIGUSR1</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>AsÃ­ una seÃ±al enviada a un proceso interrumpirÃ¡ a uno de los hilos que no la haya bloqueado.</p>
</div>
<div class="paragraph">
<p>TambiÃ©n se puede enviar una seÃ±al a un hilo en concreto usando <a href="https://man7.org/linux/man-pages/man3/pthread_kill.3.html">pthread_kill()</a>.
El hilo serÃ¡ interrumpido si no la ha bloqueado.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">pthread_kill</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span> <span class="n">SIGTERM</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Sin embargo, hay que tener en cuenta que el manejo de seÃ±ales es un recurso del proceso, compartido por todos sus hilos.
Esto quiere decir que si seÃ±al estÃ¡ configurada para ser manejada usando la acciÃ³n por defecto y dicha acciÃ³n es terminar, terminarÃ¡ todo el proceso, aunque la seÃ±al haya sido dirigida a un hilo en concreto.</p>
</div>
</div>
<div class="sect4">
<h5 id="_seÃ±ales_enviadas_por_el_sistema">SeÃ±ales enviadas por el sistema</h5>
<div class="paragraph">
<p>Lo que queda por ver es a quiÃ©n va dirigida una seÃ±al, cuando es el sistema quiÃ©n la envÃ­a para notificar un evento:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Las seÃ±ales sÃ­ncronas son causadas por un error en la ejecuciÃ³n, que en un proceso multihilo es debido a la fallida ejecuciÃ³n de un hilo en particular.
Por eso estas seÃ±ales se dirigen al hilo que las causa.</p>
</li>
<li>
<p>Las seÃ±ales asÃ­ncronas llegan por causas externas, asÃ­ que se dirigen al proceso, pudiendo ser entregada a uno de los hilos que no la tenga bloqueada.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>La recomendaciÃ³n es elegir un hilo para el manejo de seÃ±ales asÃ­ncronas, de tal forma que sea el Ãºnico que no las tenga bloqueadas.
El resto de hilos deberÃ­an bloquear estas seÃ±ales nada mÃ¡s iniciar su ejecuciÃ³n.</p>
</div>
<div class="paragraph">
<p>Si el hilo que debe manejar las seÃ±ales no tiene otras responsabilidades, puede utilizar <a href="https://man7.org/linux/man-pages/man3/sigwait.3.html">sigwait()</a> para bloquearse hasta que llegue una seÃ±al.
Cuando eso ocurra, la funciÃ³n <a href="https://man7.org/linux/man-pages/man3/sigwait.3.html">sigwait()</a> retornarÃ¡, indicando el nÃºmero de seÃ±al recibida âsin necesitar <strong>manejadores de seÃ±al</strong>â.
AsÃ­, por ejemplo, el hilo puede solicitar la cancelaciÃ³n de los otros hilos.
Esta estrategia facilita el diseÃ±o del programa para que manejen las seÃ±ales adecuadamente.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sincronizaciÃ³n">13. SincronizaciÃ³n</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>30 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>En el <a href="#_memoria_compartida">CapÃ­tulo 11</a> vimos que varios procesos pueden compartir regiones de la memoria con el objeto de cooperar en las tareas que deben desempeÃ±ar.
AdemÃ¡s, en el <a href="#_hilos">CapÃ­tulo 12</a> vimos que en los procesos multihilo todos los hilos comparten el espacio de direcciones del proceso al que pertenecen, lo que significa que pueden acceder al mismo tiempo a las variables globales y a la memoria reservada dinÃ¡micamente.</p>
</div>
<div class="paragraph">
<p>Ambas posibilidades introducen algunos riesgos, puesto que el acceso simultÃ¡neo a los datos compartidos puede ocasionar inconsistencias.
AsÃ­ que ha llegado el momento de discutir cÃ³mo se puede asegurar la ejecuciÃ³n ordenada de hilos o procesos cooperativos que comparten regiones de la memoria, con el fin de mantener la consistencia de los datos.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En este capÃ­tulo hablaremos de hilos y de procesos que comparten memoria indistintamente.
En ambos casos el problema es el mismo y las soluciones similares.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_el_problema_de_las_secciones_crÃ­ticas">13.1. El problema de las secciones crÃ­ticas</h3>
<div class="paragraph">
<p>Llamamos <strong>condiciÃ³n de carrera</strong> a la situaciÃ³n en la que varios procesos o hilos pueden acceder y manipular los mismos datos al mismo tiempo âes decir, de forma <strong>concurrente</strong>â y donde el resultado de la ejecuciÃ³n depende del orden particular en el que tienen lugar dichos accesos.
Estas situaciones ocurren frecuentemente en los sistemas operativos, puesto que diferentes componentes del mismo manipulan los mismos recursos interfiriendo unos con otros.</p>
</div>
<div class="sect3">
<h4 id="_problema_del_productor_consumidor">13.1.1. Problema del productor-consumidor</h4>
<div class="paragraph">
<p>Para ilustrarlo, veamos un problema clÃ¡sico de concurrencia: el <strong>problema del productor-consumidor</strong>.</p>
</div>
<div class="paragraph">
<p>Supongamos que dos hilos o procesos comparten una regiÃ³n de la memoria que contiene un vector de elementos y un contador con el nÃºmero de elementos del vector.</p>
</div>
<div class="paragraph">
<p>El primer hilo realiza varias tareas, que no entraremos a describir.
Lo importante es que, como resultado de esas tareas, en ocasiones aÃ±ade un elemento al vector e incrementa el contador que indica el nÃºmero de elementos en el vector.
Es decir, el primer hilo actÃºa como un <strong>productor</strong> de elementos del vector.</p>
</div>
<div class="paragraph">
<p>A continuaciÃ³n mostramos una porciÃ³n de la funciÃ³n del productor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">while</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">item</span> <span class="o">=</span> <span class="n">produce_item</span><span class="p">();</span>

    <span class="c1">// Si el vector estÃ¡ lleno, esperar</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">VECTOR_SIZE</span><span class="p">);</span>

    <span class="c1">// AÃ±adir el elemento al vector</span>
    <span class="n">vector</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
    <span class="o">++</span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>El segundo hilo tambiÃ©n realiza varias tareas que no describiremos.
Pero para realizar esas tareas en ocasiones debe tomar un elemento del vector compartido, decrementando el contador para indicar que ahora hay un elemento menos en el vector.
Es decir, el segundo hilo actÃºa como un <strong>consumidor</strong> de elementos del vector.</p>
</div>
<div class="paragraph">
<p>A continuaciÃ³n mostramos una porciÃ³n de la funciÃ³n del consumidor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">while</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Si el vector estÃ¡ vacio, esperar</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// Extraer un elemento del vector</span>
    <span class="o">--</span><span class="n">count</span><span class="p">;</span>
    <span class="n">item</span> <span class="o">=</span> <span class="n">vector</span><span class="p">[</span><span class="n">count</span><span class="p">];</span>

    <span class="n">consume_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Aunque el <strong>problema del productor-consumidor</strong> parezca artificial, lo cierto es que es muy comÃºn.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, en una herramienta de grabaciÃ³n de audio, el <strong>productor</strong> es un hilo dedicado a obtener bloques de muestras grabadas a travÃ©s de la API multimedia del sistema operativo.
Mientras tanto, otro hilo puede dedicarse a tomar las muestras y realizar diversas transformaciones, como: reducir el ruido, mezclar con otras fuentes de sonido o aplicar algÃºn tipo de efecto digital.
Este segundo hilo es el <strong>consumidor</strong>.
La manera de conectar ambos es tener un vector compartido, donde se depositan los bloques de muestras cuando llegan y de dÃ³nde se extraen para su tratamiento.
AsÃ­, ambos hilos pueden trabajar a su propio ritmo, de forma casi independiente.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Aunque el cÃ³digo anterior del productor y del consumidor es correcto cuando no coinciden en el tiempo al ejecutarse, no funciona adecuadamente cuando sÃ­ lo hacen.
El motivo es que los dos hilos comparten la variable <code>count</code> y tanto las sentencias <code>++count</code> y como <code>--count</code> pueden interrumpirse a medias para dejar paso a la ejecuciÃ³n del otro hilo.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, <code>++count</code> podrÃ­a dividirse por el compilador en las siguiente operaciones, al generar las instrucciones del procesador:</p>
</div>
<div class="listingblock">
<div class="title">++count</div>
<div class="content">
<pre>registro1 = count;
registro1 = registro1 + 1;
count = registro1;</pre>
</div>
</div>
<div class="paragraph">
<p>Donde <code>registro1</code> representa un registro de la CPU.
De forma parecida la sentencia <code>--count</code> podrÃ­a ser implementada de la siguiente manera:</p>
</div>
<div class="listingblock">
<div class="title">--count</div>
<div class="content">
<pre>registro2 = count;
registro2 = registro2 - 1;
count = registro2;</pre>
</div>
</div>
<div class="paragraph">
<p>Donde nuevamente <code>registro2</code> representa un registro de la CPU.
Realmente, aunque <code>registro1</code> y <code>registro2</code> pueden ser el mismo registro fÃ­sico, el contenido de los registros se guarda y se recupera durante los cambios de contexto de un hilo al otro, por lo que cada uno ve sus propios valores y no los del otro.</p>
</div>
<div class="paragraph">
<p>El que las sentencias <code>++count</code> y <code>--count</code> se ejecute de forma concurrente, es similar a que las instrucciones de lenguaje mÃ¡quina de ambas sentencias en ambos hilos o procesos se entrelacen en algÃºn orden aleatorio.</p>
</div>
<div class="paragraph">
<p>Un posible entrelazado de las instrucciones en lenguaje mÃ¡quina entre hilos, suponiendo que inicialmente <code>count = 5</code>, podrÃ­a ser el siguiente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="c1">// Entra ++count</span>
<span class="n">registro1</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>          <span class="c1">// registro1 = 5</span>
<span class="n">registro1</span> <span class="o">=</span> <span class="n">registro1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// registro1 = 6</span>
<span class="c1">// Sale ++count y entra --count</span>
<span class="n">registro2</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>          <span class="c1">// registro2 = 5</span>
<span class="n">registro2</span> <span class="o">=</span> <span class="n">registro2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// registro2 = 4</span>
<span class="c1">// Sale --count y entra ++count</span>
<span class="n">count</span> <span class="o">=</span> <span class="n">registro1</span><span class="p">;</span>          <span class="c1">// count = 6 </span><i class="conum" data-value="2"></i><b>(2)</b>
<span class="c1">// Entra --count</span>
<span class="n">count</span> <span class="o">=</span> <span class="n">registro2</span><span class="p">;</span>          <span class="c1">// count = 4 </span><i class="conum" data-value="1"></i><b>(1)</b> <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>AsÃ­ llegamos al resultado incorrecto <code>count = 4</code>, indicando que hay 4 elementos en el vector cuando realmente hay 5.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Si invertimos el orden de las sentencias obtendrÃ­amos el resultado, tambiÃ©n incorrecto, <code>count = 6</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Como se puede apreciar, hemos llegado a estos valores incorrectos porque hemos permitido la manipulaciÃ³n concurrente de la variable <code>count</code>.
SegÃºn como se entrelacen las instrucciones de <code>++count</code> y <code>--count</code> en la CPU, el resultado final podrÃ­a ser: 4, 5 o 6.
Pero el Ãºnico resultado correcto es 5, que es el que obtendrÃ­amos si ejecutamos las sentencias secuencialmente, sin mezclar las operaciones en las que se dividen.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Ambos hilos se ejecutan de forma concurrente porque o bien, tenemos un sistema multiprocesador o multinÃºcleo, donde ambos hilos se ejecutan a la vez en procesadores diferentes, o bien, porque tenemos un sistema operativo donde uno de los hilos puede ver interrumpida su ejecuciÃ³n en cualquier momento para asignar la CPU a otro (vÃ©ase el <a href="#_planificaciÃ³n_expropiativa">Apartado 14.1</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_manipular_estructuras_de_datos">13.1.2. Manipular estructuras de datos</h4>
<div class="paragraph">
<p>Obviamente, el problema comentado no aparece solo en sentencias simples, sino tambiÃ©n en bloques de cÃ³digo destinados a hacer tareas complejas, como manipular estructuras de datos.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, supongamos que <code>vector</code> no es un simple <em>array</em> de elementos, sino un lista enlazada, de tal forma que ahora extraer un elemento serÃ­a asÃ­:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="o">--</span><span class="n">count</span><span class="p">;</span>
<span class="n">item</span> <span class="o">=</span> <span class="n">vector</span><span class="p">.</span><span class="n">extract</span><span class="p">(</span><span class="n">count</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>y el mÃ©todo <code>extract()</code> tendrÃ­a que dar los siguientes pasos:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Iterar sobre la lista para buscar el nodo en la posiciÃ³n <code>count</code>.</p>
</li>
<li>
<p>Al encontrarlo, preservar en variables locales el puntero a ese nodo y al previo.</p>
</li>
<li>
<p>Cambiar en el nodo previo el puntero al siguiente nodo, para que apunte al nodo tras el que queremos extraer.
En este momento el nodo a extraer ya no pertenece a la lista enlazada.</p>
</li>
<li>
<p>Extrae el <code>item</code> del campo que lo contiene en el nodo.</p>
</li>
<li>
<p>Destruir el nodo.</p>
</li>
<li>
<p>Salir del mÃ©todo retornando el elemento.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Esto genera varios momentos cruciales entorno al paso 3, que puedan dar lugar a <strong>condiciones de carrera</strong>.
Por ejemplo, si el hilo es interrumpido tras guardar el puntero al nodo en una variable local y llega otro hilo que extrae ây destruyeâ antes ese mismo nodo, el puntero ya no es vÃ¡lido âes un <em>dangling pointer</em> o referencia colganteâ al continuar la ejecuciÃ³n del primer hilo.
Y lo mismo ocurre con el puntero al nodo previo o al siguiente, si el hilo es interrumpido y otro hilo destruye antes alguno de ellos.</p>
</div>
<div class="paragraph">
<p>Los problemas que Ã©sto puede causar son diversos, segÃºn el momento exacto en el que ocurra.
Puede haberlos al intentar leer el elemento guardado en el nodo en el paso 4, porque este Ãºltimo ya no exista.
TambiÃ©n, al intentar actualizar, en el paso 3, el puntero al siguiente nodo en el nodo previo, porque el nodo previo no exista.
Incluso puede que la funciÃ³n termine con aparente normalidad pero dejando que el nodo previo apunte a un nodo siguiente que no existe.
En este Ãºltimo supuesto, la lista quedarÃ­a en estado inconsistente y asÃ­ el problema se lo encontrarÃ­a el prÃ³ximo hilo que intente usarla.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exclusiÃ³n_mutua">13.1.3. ExclusiÃ³n mutua</h4>
<div class="paragraph">
<p>Para evitar que estas situaciones lleven a la corrupciÃ³n de datos y a caÃ­das de servicios y sistemas, debemos asegurarnos que sÃ³lo un hilo en cada momento puede manipular recursos y variables compartidas.
Por tanto, necesitamos algÃºn tipo de mecanismo de sincronizaciÃ³n para que mientras se ejecuta <code>++count</code> no se pueda ejecutar <code>--count</code> en otro hilo, ni viceversa.
O para que mientras un hilo haga un <code>insert()</code> o un <code>extract()</code> en una lista, otro no pueda utilizar ni estas ni otras funciones de las misma clase.</p>
</div>
<div class="paragraph">
<p>Para resolver Ã©sto, debemos empezar buscando las <strong>secciones crÃ­ticas</strong> de nuestro cÃ³digo.
Una <strong>secciÃ³n crÃ­tica</strong> es una porciÃ³n del cÃ³digo dÃ³nde se accede a variables, tablas, listas, archivos y otros recursos compartidos.</p>
</div>
<div class="paragraph">
<p>Para evitar <strong>condiciones de carrera</strong>, el acceso a las <strong>secciones crÃ­ticas</strong> debe ser controlado, de manera que cuando un hilo se estÃ© ejecutando en una secciÃ³n de este tipo ningÃºn otro pueda hacerlo en la suya correspondiente para manipular los mismos recursos.
En estos casos se dice que existe <strong>exclusiÃ³n mutua</strong> entre las <strong>secciones crÃ­ticas</strong>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_eventos">13.1.4. Eventos</h4>
<div class="paragraph">
<p>Las <strong>condiciones de carrera</strong> son el principal problema del cÃ³digo anterior del productor y el consumidor, pero no el Ãºnico.
En ambos ejemplos se usan bucles para que el hilo espere si el vector estÃ¡ lleno o vacÃ­o, antes de continuar.
A esta tÃ©cnica se la denomina <strong>espera ocupada</strong> o <strong>espera activa</strong> y estÃ¡ completamente desaconsejada usarla en cÃ³digo del espacio de usuario, porque contribuye a gastar tiempo de CPU inÃºtilmente.</p>
</div>
<div class="paragraph">
<p>En su lugar, se recomienda usar mecanismos de sincronizaciÃ³n ofrecidos por el sistema operativo; diseÃ±ados para que un hilo o proceso notifique eventos a otro, de tal forma que hasta que eso ocurre, el que espera permanezca en estado <strong>esperando</strong>, dejando la CPU para los hilos que la necesitan.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sincronizaciÃ³n_por_hardware">13.2. SincronizaciÃ³n por hardware</h3>
<div class="paragraph">
<p>Las soluciones ofrecidas por el sistema operativo, para resolver los problemas anteriores, suelen tener que apoyarse en caracterÃ­sticas del hardware.
A continuaciÃ³n veremos algunas de esas caracterÃ­sticas, antes de profundizar en los mecanismos ofrecidos por el sistema operativo.</p>
</div>
<div class="sect3">
<h4 id="_bloque_de_las_interrupciones">13.2.1. Bloque de las interrupciones</h4>
<div class="paragraph">
<p>El problema de la secciÃ³n crÃ­tica puede ser resuelto de forma sencilla en un sistema monoprocesador.</p>
</div>
<div class="paragraph">
<p>Como el nÃºcleo del sistema operativo es un software controlado mediante interrupciones, basta con que los hilos bloqueen las interrupciones mientras se estÃ¡ dentro de la secciÃ³n crÃ­tica.
AsÃ­, el sistema operativo no puede tomar el control y asignar otro hilo a la CPU, lo que impide que se ejecute otra secuencia de instrucciones que podrÃ­a modificar los datos compartidos.</p>
</div>
<div class="paragraph">
<p>Indudablemente esta soluciÃ³n no es prÃ¡ctica en sistema multiprocesador, donde hay varios procesadores ejecutÃ¡ndose a la vez.</p>
</div>
</div>
<div class="sect3">
<h4 id="_instrucciones_atÃ³micas">13.2.2. Instrucciones atÃ³micas</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Todas las CPU modernas disponen de instrucciones para comparar y modificar el
contenido de una variable o intercambiar el contenido de dos variables, de forma <strong>atÃ³mica</strong>.
El tÃ©rmino <strong>atÃ³mico</strong> hace referencia a que las operaciones se ejecutan como una unidad
ininterrumpible.
No importa que varias CPU ejecuten estas instrucciones simultÃ¡neamente, puesto el hardware se encargarÃ¡ de que sean ejecutadas secuencialmente en algÃºn orden arbitrario.</p>
</div>
<div class="paragraph">
<p>Estas instrucciones estÃ¡n disponibles para los programadores de C y C&#43;&#43; a travÃ©s de tipos especiales.
Por ejemplo, en C11 <a href="https://en.cppreference.com/w/c/atomic">&lt;stdatomic.h&gt;</a> define tipos como: <code>atomic_bool</code>, <code>atomic_uint</code> o <code>atomic_char</code> para declarar variables atÃ³micas de los tipos <code>bool</code>, <code>unsigned int</code> y <code>char</code>, respectivamente.
TambiÃ©n declara funciones para inicializar, leer, guardar, intercambiar, sumar, restar y realizar operaciones lÃ³gicas, de forma atÃ³mica sobre estas variables:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">atomic_int</span> <span class="n">count</span><span class="p">;</span>
<span class="n">atomic_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="kt">int</span> <span class="n">old_count</span> <span class="o">=</span> <span class="n">atomic_fetch_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Inicializar el valor de la variable atÃ³mica.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Como un <code>count++</code> atÃ³mico: incrementa la variable devolviendo el valor previo.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>En C&#43;&#43;11, <a href="https://en.cppreference.com/w/cpp/header/atomic">&lt;atomic&gt;</a> declara la plantilla <a href="https://en.cppreference.com/w/cpp/atomic/atomic">std::atomic</a> que ofrece una funcionada similar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">count</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>  <i class="conum" data-value="1"></i><b>(1)</b> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="kt">int</span> <span class="n">old_count</span> <span class="o">=</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>    <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>TambiÃ©n hay un tipo <code>std::atomic_int</code> que es equivalente.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Se usa el constructor para inicializar la variable atÃ³mica.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>AdemÃ¡s de soportar los operadores '++' y '--', soporta los mÃ©todos <a href="https://en.cppreference.com/w/cpp/atomic/atomic/fetch_add">std::atomic::fetch_add()</a> y <a href="https://en.cppreference.com/w/cpp/atomic/atomic/fetch_sub">std::atomic::fetch_sub()</a> para sumar y restar devolviendo el valor previo.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>La importancia de estas instrucciones estÃ¡ en que pueden ser utilizadas por el sistema operativo para ofrecer soluciones sencillas al problema de la secciÃ³n critica.
Por ejemplo, <strong>semÃ¡foros</strong> o <strong><em>mutex</em></strong>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_semÃ¡foros">13.3. SemÃ¡foros</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>La exclusiÃ³n mutua en las secciones crÃ­ticas se asegura utilizando adecuadamente una serie de recursos que para ese fin proporciona el sistema operativo.
Estos recursos utilizan internamente instrucciones y otras caracterÃ­sticas de la CPU, incluidas por los diseÃ±adores para resolver este tipo de problemas, que hemos comentado anteriormente.
Ese es el caso de los <strong>semÃ¡foros</strong>.</p>
</div>
<div class="paragraph">
<p>Los <strong>semÃ¡foros</strong> son un tipo de objetos del sistema operativo que nos permiten controlar el acceso a una secciÃ³n crÃ­tica, por medio de dos primitivas: <strong>acquire</strong> y <strong>release</strong> âo <strong>wait</strong> y <strong>signal</strong>, segÃºn el libro de texto que consultemosâ.
A continuaciÃ³n describimos el mecanismo de funcionamiento:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">semaphore</span> <span class="nf">S</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>    <i class="conum" data-value="1"></i><b>(1)</b>

<span class="n">S</span><span class="p">.</span><span class="n">acquire</span><span class="p">()</span>         <i class="conum" data-value="2"></i><b>(2)</b>

<span class="c1">// CÃ³digo de la secciÃ³n crÃ­tica... </span><i class="conum" data-value="3"></i><b>(3)</b>

<span class="n">S</span><span class="p">.</span><span class="n">signal</span><span class="p">();</span>         <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Crear el <strong>semÃ¡foro</strong> <code>S</code> inicializado a 10.
Un <strong>semÃ¡foro</strong> contiene fundamentalmente un contador con el nÃºmero mÃ¡ximo de hilos que pueden estar ejecutando el cÃ³digo de la secciÃ³n crÃ­tica al mismo tiempo.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Intentar entrar en la secciÃ³n crÃ­tica:
<div class="ulist">
<ul>
<li>
<p>Si el contador interno del <strong>semÃ¡foro</strong> es mayor que 0, <code>acquire()</code> lo decrementa y retorna para que la ejecuciÃ³n continÃºe.</p>
</li>
<li>
<p>Si el contador interno del <strong>semÃ¡foro</strong> es igual a 0, <code>acquire()</code> saca al hilo de la CPU y lo pone en una cola de espera, suspendiendo asÃ­ su ejecuciÃ³n.
BÃ¡sicamente, es que hay demasiados hilos dentro de la secciÃ³n crÃ­tica.</p>
</li>
</ul>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>AquÃ­ irÃ­a el cÃ³digo protegido con el <strong>semÃ¡foro</strong>.
Es decir, el cÃ³digo de la secciÃ³n crÃ­tica en sÃ­.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Salir de la secciÃ³n crÃ­tica:
<div class="ulist">
<ul>
<li>
<p>Si el contador interno del <strong>semÃ¡foro</strong> es mayor que 0, <code>release()</code> lo incrementa y retorna para que la ejecuciÃ³n continÃºe.</p>
</li>
<li>
<p>Si el contador interno del <strong>semÃ¡foro</strong> es igual a 0, <code>release()</code> lo incrementa y saca a uno de los hilos en la cola de espera âdonde los puso su <code>acquire()</code>â para meterlo en la cola de preparados, dejÃ¡ndolo listo para entrar en la CPU.
Cuando eso ocurra, ese hilo decrementarÃ¡ el contador interno del <strong>semÃ¡foro</strong> y saldrÃ¡ de su <code>acquire()</code>, donde hasta a hora estaba atrapado.
Mientras tanto <code>release()</code> retorna y la ejecuciÃ³n del hilo que sale del secciÃ³n crÃ­tica continÃºa.</p>
</li>
</ul>
</div></td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Para que funcione correctamente, el <strong>semÃ¡foro</strong> <code>S</code> debe ser el mismo para todos los hilos que tengan secciones crÃ­ticas en cuya ejecuciÃ³n deber haber <strong>exclusiÃ³n mutua</strong>.
Es decir, el <strong>semÃ¡foro</strong> <code>S</code> debe estar compartido entre los hilos de la misma manera que las estructuras de datos, variables y otros recursos que protege.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_tipos_de_semÃ¡foros">13.3.1. Tipos de semÃ¡foros</h4>
<div class="paragraph">
<p>Tanto el estÃ¡ndar POSIX como Windows API soportan semÃ¡foros y ambos admiten dos tipos de semÃ¡foros:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Los <strong>semÃ¡foros anÃ³nimos</strong> que sÃ³lo existen en el espacio de direcciones del proceso que los crea, de tal forma que estÃ¡n disponibles para sincronizar hilos del mismo proceso.</p>
<div class="paragraph">
<p>La forma de usarlos para sincronizar procesos diferentes o hilos en procesos diferentes depende del sistema operativo.
Con Windows API se pueden heredar de padres a hijos.
Mientras que en sistemas POSIX es necesario crear el <strong>semÃ¡foro</strong> en una regiÃ³n de <strong>memoria compartida</strong>, que hayamos creado previamente, e indicar un valor distinto de 0 en el argumento <code>pshared</code> de <a href="https://man7.org/linux/man-pages/man3/sem_init.3.html">sem_init()</a>.</p>
</div>
</li>
<li>
<p>Las <strong>semÃ¡foros con nombre</strong> son pÃºblicos al resto del sistema, por lo que teÃ³ricamente cualquier proceso con permisos puede abrirlos para utilizarlos.</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 4. Funciones de la API para manipular semÃ¡foros.</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">POSIX API</th>
<th class="tableblock halign-left valign-top">Windows API</th>
</tr>
</thead>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Crear semÃ¡foro anÃ³nimo</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/sem_init.3.html">sem_init()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsemaphorea">CreateSemaphore()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Crear semÃ¡foro con nombre</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/sem_open.3.html">sem_open()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsemaphorea">CreateSemaphore()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Abrir semÃ¡foro con nombre</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/sem_open.3.html">sem_open()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-opensemaphorew">OpenSemaphore()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">OperaciÃ³n acquire</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/sem_wait.3.html">sem_wait()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject">WaitForSingleObject()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">OperaciÃ³n release</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/sem_post.3.html">sem_post()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-releasesemaphore">ReleaseSemaphore()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Cerrar semÃ¡foro con nombre</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/sem_close.3.html">sem_close()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle">CloseHandle()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Destruir semÃ¡foro anÃ³nimo</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/sem_destroy.3.html">sem_destroy()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="lightcell">[AutomÃ¡tico]</span></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Destruir semÃ¡foro con nombre</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/sem_unlink.3.html">sem_unlink()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="lightcell">[AutomÃ¡tico]</span></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_ejemplos_del_uso_de_semÃ¡foros">13.3.2. Ejemplos del uso de semÃ¡foros</h4>
<div class="paragraph">
<p>En el ejemplo <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap11/anom-shared-memory.cpp">anom-shared-memory.cpp</a> de comunicaciÃ³n mediante memoria compartida, se usa un <strong>semÃ¡foro</strong> para que el proceso hijo indique al proceso padre que ha terminado de calcular el factorial y el resultado ya estÃ¡ en la memoria.</p>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap11/shared-memory-server.c">shared-memory-server.c</a> estÃ¡ el ejemplo completo de un programa que muestra periÃ³dicamente la hora del sistema y que puede ser controlado remotamente, mediante memoria compartida, con un cliente como el de <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap11/shared-memory-client.cpp">shared-memory-client.cpp</a>.</p>
</div>
<div class="paragraph">
<p>Para enviar los mensajes entre el cliente y el servidor, en la memoria compartida se reserva hueco para un bÃºfer en el que el cliente copia el comando que quiere enviar y para dos <strong>semÃ¡foros</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="k">struct</span> <span class="n">memory_content</span>
<span class="p">{</span>
    <span class="n">sem_t</span> <span class="n">empty</span><span class="p">;</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">sem_t</span> <span class="n">ready</span><span class="p">;</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="kt">char</span> <span class="n">command_buffer</span><span class="p">[</span><span class="n">MAX_COMMAND_SIZE</span><span class="p">];</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Indica cuÃ¡ndo <code>command_buffer</code> estÃ¡ vacÃ­o, asÃ­ que se inicializa a 1.
El cliente usa <a href="https://man7.org/linux/man-pages/man3/sem_wait.3.html">sem_wait()</a> en este <strong>semÃ¡foro</strong> antes de escribir un nuevo comando en <code>command_buffer</code>:
<div class="ulist">
<ul>
<li>
<p>Si el <strong>semÃ¡foro</strong> estÃ¡ a 0, el cliente pasa y escribe el comando.
DespuÃ©s llama a <a href="https://man7.org/linux/man-pages/man3/sem_post.3.html">sem_post()</a> en <code>ready</code>.</p>
</li>
<li>
<p>Si el <strong>semÃ¡foro</strong> estÃ¡ a 1, el cliente queda bloqueado y tiene que espera a que el servidor use <a href="https://man7.org/linux/man-pages/man3/sem_post.3.html">sem_post()</a> sobre el mismo <strong>semÃ¡foro</strong>.
El servidor lo hace despuÃ©s de leer el comando para interpretarlo.</p>
</li>
</ul>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Indica cuÃ¡ndo <code>command_buffer</code> tiene un comando, asÃ­ que se inicializa a 0.
El servidor usa <a href="https://man7.org/linux/man-pages/man3/sem_wait.3.html">sem_wait()</a> en este <strong>semaforo</strong> antes de leer el comando en <code>command_buffer</code> para interpretarlo:
<div class="ulist">
<ul>
<li>
<p>Si el <strong>semÃ¡foro</strong> estÃ¡ a 0, el cliente pasa y lee el comando.
DespuÃ©s llama a <a href="https://man7.org/linux/man-pages/man3/sem_post.3.html">sem_post()</a> en <code>empty</code>.</p>
</li>
<li>
<p>Si el <strong>semÃ¡foro</strong> estÃ¡ a 1, el servidor queda bloqueado y tiene que esperar a que el cliente use <a href="https://man7.org/linux/man-pages/man3/sem_post.3.html">sem_post()</a> sobre el mismo <strong>semÃ¡foro</strong>.
El cliente lo hace despuÃ©s de escribir un nuevo comando en <code>command_buffer</code>.</p>
</li>
</ul>
</div></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>El detalle de cÃ³mo cliente y servidor usan ambos semÃ¡foros, se puede ver en el cÃ³digo de <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap11/shared-memory-client.cpp">shared-memory-client.cpp</a> y <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap11/shared-memory-server.c">shared-memory-server.c</a>, respectivamente.</p>
</div>
<div class="paragraph">
<p>Finalmente, para resolver el <strong>problema del productor-consumidor</strong> tenemos que considerar que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Necesitamos un semÃ¡foro para haya <strong>exclusiÃ³n mutua</strong> entre ambos al insertar y extraer elementos del vector.</p>
</li>
<li>
<p>Necesitamos una forma de que el productor espere cuando el vector estÃ© lleno y que el consumidor haga lo mismo cuando el vector estÃ© vacÃ­o.
Una soluciÃ³n es usar dos semÃ¡foros, uno para que cuente el nÃºmero de elementos en el vector y otro para contar el nÃºmero de huecos libres:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">sem_t</span> <span class="n">mutex</span><span class="p">;</span>       <i class="conum" data-value="1"></i><b>(1)</b>
<span class="n">sem_t</span> <span class="n">fill_count</span><span class="p">;</span>  <i class="conum" data-value="2"></i><b>(2)</b>
<span class="n">sem_t</span> <span class="n">empty_count</span><span class="p">;</span> <i class="conum" data-value="3"></i><b>(3)</b>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">item_t</span><span class="o">&gt;</span> <span class="n">buffer</span><span class="p">(</span> <span class="n">VECTOR_SIZE</span> <span class="p">);</span>

<span class="kt">void</span> <span class="nf">initialize</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">sem_init</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>  <i class="conum" data-value="1"></i><b>(1)</b> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="n">sem_init</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>  <i class="conum" data-value="2"></i><b>(2)</b> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="n">sem_init</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">VECTOR_SIZE</span> <span class="p">);</span>  <i class="conum" data-value="3"></i><b>(3)</b> <i class="conum" data-value="4"></i><b>(4)</b>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">productor</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="k">while</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">item_t</span> <span class="n">item</span> <span class="o">=</span> <span class="n">produce_item</span><span class="p">();</span>

        <span class="n">sem_wait</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">empty_count</span> <span class="p">);</span> <i class="conum" data-value="5"></i><b>(5)</b>
        <span class="n">sem_wait</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">mutex</span> <span class="p">);</span>       <i class="conum" data-value="7"></i><b>(7)</b>

        <span class="n">vector</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>

        <span class="n">sem_post</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">mutex</span> <span class="p">);</span>       <i class="conum" data-value="7"></i><b>(7)</b>
        <span class="n">sem_post</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">fill_count</span> <span class="p">);</span>  <i class="conum" data-value="6"></i><b>(6)</b>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">consumer</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="k">while</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">sem_wait</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">fill_count</span> <span class="p">);</span>  <i class="conum" data-value="6"></i><b>(6)</b>
        <span class="n">sem_wait</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">mutex</span> <span class="p">);</span>       <i class="conum" data-value="7"></i><b>(7)</b>

        <span class="n">item_t</span> <span class="n">item</span> <span class="o">=</span> <span class="n">vector</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
        <span class="n">vector</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>

        <span class="n">sem_post</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">mutex</span> <span class="p">);</span>       <i class="conum" data-value="7"></i><b>(7)</b>
        <span class="n">sem_post</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">empty_count</span> <span class="p">);</span> <i class="conum" data-value="5"></i><b>(5)</b>

        <span class="n">consume_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><strong>SemÃ¡foro</strong> que se encarga de la exclusiÃ³n mutua.
Se inicializa a 1, para que el primer hilo que use <a href="https://man7.org/linux/man-pages/man3/sem_wait.3.html">sem_wait()</a> pueda entrar.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><strong>SemÃ¡foro</strong> que se encarga de contar huecos ocupados en el vector.
Se inicializa a 0, porque al principio no hay ningÃºn elemento.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><strong>SemÃ¡foro</strong> que se encarga de contar los huecos libres en el vector.
Se inicializa a VECTOR_SIZE, porque estÃ¡n todos vacÃ­os.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>El segundo argumento de <a href="https://man7.org/linux/man-pages/man3/sem_init.3.html">sem_init()</a> es <code>pshared</code>.
Se pone a 0 para indicar que este <strong>semaforo</strong> no se va a compartir entre procesos diferentes.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Antes de insertar un elemento se decrementa <code>empty_count</code>.
AsÃ­, si vale 0, es que el vector estÃ¡ lleno y el productor se bloquea.
El consumidor incrementa <code>empty_count</code> tras extraer un elemento y dejar hueco, despertando al productor.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Antes de extraer un elemento se decrementa <code>fill_count</code>.
AsÃ­, si vale 0, es que el vector estÃ¡ vacÃ­o y el consumidor se bloquea.
El productor incrementa <code>fill_count</code> tras insertar un elemento nuevo, despertando al consumidor.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>El acceso al vector con los elementos es en <strong>exclusiÃ³n mutua</strong>, asÃ­ que tanto productor como consumidor deben usar <a href="https://man7.org/linux/man-pages/man3/sem_wait.3.html">sem_wait()</a> sobre <code>mutex</code> antes de acceder a Ã©l.
Esto decrementa el semÃ¡foro, asÃ­ que solo uno de los dos pasa y ejecuta las lÃ­neas siguientes, mientras el otro queda bloqueado.
Cuando el que haya pasado termine, debe usar <a href="https://man7.org/linux/man-pages/man3/sem_post.3.html">sem_post()</a> sobre <code>mutex</code> para incrementar el semÃ¡foro y permitir que el otro hilo entre en su <strong>secciÃ³n crÃ­tica</strong>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mutex">13.4. Mutex</h3>
<div class="paragraph">
<p>Los semÃ¡foros inicializados a 1 se denominan <strong><em>mutex</em></strong> o <strong>semÃ¡foros binarios</strong>.
Por tanto, aunque un sistema o lenguaje solo soporte <strong>semÃ¡foros</strong>, es directo implementar <strong><em>mutex</em></strong>.
A la inversa ocurre igual.
Si un sistema o lenguaje soporta <strong><em>mutex</em></strong>, es muy sencillo hacer una implementaciÃ³n <strong>semÃ¡foros</strong>, si nos hiciera falta.</p>
</div>
<div class="paragraph">
<p>El estÃ¡ndar POSIX soporta <strong><em>mutex</em></strong> a travÃ©s de <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a>.
Por defecto solo se pueden utilizar para sincronizar hilos del mismo proceso; pero tienen un atributo para permitir la sincronizaciÃ³n entre procesos diferentes, aunque para eso deben ser creados en una regiÃ³n de memoria compartida por dichos procesos.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>La API de <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a> no soporta <strong>semÃ¡foros</strong> porque, como vimos antes, ya eran parte del estÃ¡ndar POSIX.</p>
</div>
</td>
</tr>
</table>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 5. Funciones de la API para manipular <em>mutex</em>.</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">C&#43;&#43;</th>
<th class="tableblock halign-left valign-top">POSIX API</th>
<th class="tableblock halign-left valign-top" colspan="2">Windows API</th>
</tr>
</thead>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Crear</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.cppreference.com/w/cpp/thread/mutex">std::mutex</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/pthread_mutex_init.3p.html">pthread_mutex_init()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-initializecriticalsection">InitializeCriticalSection()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createmutexa">CreateMutex()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Abrir</p></th>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-openmutexw">OpenMutex()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">OperaciÃ³n acquire</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.cppreference.com/w/cpp/thread/mutex/lock">std::mutex:::lock()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/pthread_mutex_lock.3p.html">pthread_mutex_lock()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-entercriticalsection">EnterCriticalSection()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject">WaitForSingleObject()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">OperaciÃ³n release</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.cppreference.com/w/cpp/thread/mutex/unlock">std::mutex::unlock()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/pthread_mutex_unlock.3p.html">pthread_mutex_unlock()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-leavecriticalsection">LeaveCriticalSection()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-releasemutex">ReleaseMutex()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Destruir</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="lightcell">[Destructor]</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/pthread_mutex_destroy.3p.html">pthread_mutex_destroy()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-deletecriticalsection">DeleteCriticalSection()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle">CloseHandle()</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>En Windows API hay dos tipo de objetos equiparables a los <strong><em>mutex</em></strong>: los <strong><em>mutex</em></strong> y las <strong>secciones crÃ­ticas</strong>.
Las <strong>secciones crÃ­ticas</strong> son mÃ¡s ligeras, pero solo se pueden utilizar para sincronizar hilos del mismo proceso.
Mientras que los <strong><em>mutex</em></strong> de Windows API son objetos mÃ¡s costosos, pero se pueden compartir entre procesos sin utilizar memoria compartida; ya sea mediante herencia al crear un proceso hijo o asignando un nombre al <strong><em>mutex</em></strong>, como ocurre con los <strong>semÃ¡foros</strong>.</p>
</div>
<div class="sect3">
<h4 id="_ejemplos_del_uso_de_mutex">13.4.1. Ejemplos del uso de mutex</h4>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap13/pthreads-sync.cpp">pthreads-sync.cpp</a> se puede estudiar el cÃ³digo completo de un ejemplo similar a <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap12/pthreads.cpp">pthreads.cpp</a>, donde se calculaba el factorial de un nÃºmero, repartiendo la tarea entre dos hilos, usando el API de <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a>.
La diferencia es que ahora los hilos no retornan el resultado, sino que cada uno lo mete en un vector compartido.
Al terminar, el hilo principal recorre el vector multiplicando los resultados parciales.</p>
</div>
<div class="paragraph">
<p>Como ahora ambos hilos acceden a una estructura de datos compartida, esta debe ir protegida por un <strong><em>mutex</em></strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">pthread_mutex_t</span> <span class="n">mutex</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BigInt</span><span class="o">&gt;</span> <span class="n">partials</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Antes de meter un nuevo valor, cada hilo debe adquirir el <code>mutex</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// Bloquear el mutex y guardar el resultado</span>
<span class="n">pthread_mutex_lock</span><span class="p">(</span> <span class="n">mutex</span> <span class="p">);</span>   <i class="conum" data-value="1"></i><b>(1)</b>
<span class="n">partials</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">result</span> <span class="p">);</span>
<span class="n">pthread_mutex_unlock</span><span class="p">(</span> <span class="n">mutex</span> <span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Adquirir <code>mutex</code> antes de entrar en la <strong>secciÃ³n crÃ­tica</strong>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Liberar <code>mutex</code> para salir de la <strong>secciÃ³n crÃ­tica</strong>.
Es importante no olvidarnos de liberar el <strong><em>mutex</em></strong> al terminar o de lo contrario uno de los hilos quedarÃ¡ dormido indefinidamente, al no poder entrar en la <strong>secciÃ³n crÃ­tica</strong>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap13/threads-sync.cpp">threads-sync.cpp</a> se puede ver un ejemplo equivalente pero usando <a href="https://en.cppreference.com/w/cpp/thread/thread">std::thread</a> y <a href="https://en.cppreference.com/w/cpp/thread/mutex">std::mutex</a>, de la librerÃ­a estÃ¡ndar de C&#43;&#43;.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_variables_de_condiciÃ³n">13.5. Variables de condiciÃ³n</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>En la soluciÃ³n que dimos al <strong>problema del productor-consumidor</strong> usando <strong>semÃ¡foros</strong> (vÃ©ase el <a href="#_ejemplos_del_uso_de_semÃ¡foros">Apartado 13.3.2</a>) empleamos <strong>semÃ¡foros</strong> para implementar las esperas del productor y el consumidor cuando el vector estÃ¡ lleno o vacÃ­o, respectivamente.
Lamentablemente, los <em>mutex</em> no se pueden usar de la misma manera para seÃ±alar eventos.
En su lugar necesitamos otro tipo de objeto llamado <strong>variable de condiciÃ³n</strong>.</p>
</div>
<div class="paragraph">
<p>Las <strong>variables de condiciÃ³n</strong> soportan tres primitivas principales:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">wait( mutex )</dt>
<dd>
<p>Es llamada por un hilo que desea esperar a que ocurra el evento que representa la variable de condiciÃ³n.
El hilo debe haber adquirido antes el <strong><em>mutex</em></strong>, es liberado en el momento de poner al hilo en estado <strong>esperando</strong>.
Varios hilos pueden llamar a <strong>wait</strong> sobre la misma variable de condiciÃ³n, a la espera de que alguno use <strong>notify</strong>.</p>
</dd>
<dt class="hdlist1">notify</dt>
<dd>
<p>Es llamada por un hilo que quiere notificar el suceso de un evento a los hilos que esperan en la variable de condiciÃ³n.
Uno de esos hilos es despertado, adquiere el <strong><em>mutex</em></strong> que liberÃ³ al llamar a <strong>wait</strong> y, finalmente, retorna de <strong>wait</strong> para seguir ejecutÃ¡ndose.</p>
</dd>
<dt class="hdlist1">notifyAll</dt>
<dd>
<p>Es llamada por un hilo que quiere notificar el suceso de un evento a los hilos que esperan en la variable de condiciÃ³n.
Todos los hilos son despertados e intentan adquirir el <strong><em>mutex</em></strong> que liberaron al llamar a <strong>wait</strong>.
Cuando lo consiguen, retornan de <strong>wait</strong> para seguir ejecutÃ¡ndose.
Obviamente, si todos hicieron <strong>wait</strong> sobre el mismo <strong><em>mutex</em></strong>, irÃ¡n retornando de <strong>wait</strong> de uno en uno, porque solo un hilo puede tener el <strong><em>mutex</em></strong> al mismo tiempo.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Tanto Windows API como el estÃ¡ndar POSIX, a travÃ©s de <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a>, soportan <strong>variables de condiciÃ³n</strong>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 6. Funciones de la API para manipular variables de condiciÃ³n.</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">C&#43;&#43;</th>
<th class="tableblock halign-left valign-top">POSIX API</th>
<th class="tableblock halign-left valign-top">Windows API</th>
</tr>
</thead>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Crear</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.cppreference.com/w/cpp/thread/condition_variable">std::condition_variable</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/pthread_cond_init.3p.html">pthread_cond_init()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-initializeconditionvariable">InitializeConditionVariable()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">OperaciÃ³n wait</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.cppreference.com/w/cpp/thread/condition_variable/wait">std::condition_variable::wait()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/pthread_cond_wait.3p.html">pthread_cond_wait()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleepconditionvariablecs">SleepConditionVariableCS()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">OperaciÃ³n notify</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.cppreference.com/w/cpp/thread/condition_variable/notify_one">std::condition_variable::notify_one()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/pthread_cond_signal.3p.html">pthread_cond_signal()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-wakeconditionvariable">WakeConditionVariable()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">OperaciÃ³n notifyAll</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.cppreference.com/w/cpp/thread/condition_variable/notify_all">std::condition_variable::notify_all()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/pthread_cond_broadcast.3p.html">pthread_cond_broadcast()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-wakeallconditionvariable">WakeAllConditionVariable()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Destruir</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="lightcell">[Destructor]</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/pthread_cond_destroy.3p.html">pthread_cond_destroy()</a></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Por defecto, las <strong>variables de condiciÃ³n</strong> de <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a> solo se pueden utilizar para sincronizar hilos del mismo proceso; pero tienen un atributo para permitir la sincronizaciÃ³n entre procesos diferentes.
Obviamente, para eso deben ser creadas en una regiÃ³n de memoria compartida por dichos procesos.</p>
</div>
<div class="paragraph">
<p>Las <strong>variables de condiciÃ³n</strong> de Windows API solo se pueden utilizar en hilos del mismo procesos.
Como alternativa, Windows API soporta <strong>eventos</strong>, que son un tipo de objeto similar a las <strong>variables de condiciÃ³n</strong> pero que sÃ­ se puede utilizar entre hilos de procesos diferentes (vÃ©ase <a href="https://docs.microsoft.com/en-us/windows/win32/sync/using-event-objects">Â«Using Event Objects&#8201;&#8212;&#8201;Microsoft DocsÂ»</a>).</p>
</div>
<div class="paragraph">
<p>A los <strong>eventos</strong> se les puede asignar un nombre, para que sean accesibles por otros procesos, o heredarse de padres a hijos.
AdemÃ¡s son mÃ¡s pesados que las <strong>variables de condiciÃ³n</strong> de Windows API, no exigen un <strong><em>mutex</em></strong> para liberar al invocar su operaciÃ³n <strong>wait</strong>, ni admiten la operaciÃ³n <strong>notifyAll</strong>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 7. Funciones de la API para manipular eventos de Windows API.</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">Windows API</th>
</tr>
</thead>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Crear</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createeventa">CreateEvent()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Abrir</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-openeventa">OpenEvent()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">OperaciÃ³n wait</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject">WaitForSingleObject()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">OperaciÃ³n notify</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-setevent">SetEvent()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Resetear evento</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-resetevent">ResetEvent()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Destruir</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle">CloseHandle()</a></p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="_ejemplos_del_uso_de_variables_de_condiciÃ³n">13.5.1. Ejemplos del uso de variables de condiciÃ³n</h4>
<div class="paragraph">
<p>Vamos a intentar resolver el <strong>problema del productor-consumidor</strong> sin usar <strong>semÃ¡foros</strong>.
Para lo que, nuevamente, tenemos que considerar que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Necesitamos <strong>exclusiÃ³n mutua</strong> entre ambos hilos al insertar y extraer elementos del vector para evitar <strong>condiciones de carrera</strong>, por tanto usamos un <strong><em>mutex</em></strong> para proteger la <strong>secciÃ³n crÃ­tica</strong>.</p>
</li>
<li>
<p>Necesitamos una forma de que el productor espere cuando el vector estÃ¡ lleno y que el consumidor haga lo mismo cuando el vector estÃ¡ vacÃ­o.
Para seÃ±alar estos eventos necesitamos dos <strong>variables de condiciÃ³n</strong>:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">mutext</span> <span class="n">mutex</span><span class="p">;</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">no_full</span><span class="p">;</span>  <i class="conum" data-value="2"></i><b>(2)</b>
<span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">no_empty</span><span class="p">;</span> <i class="conum" data-value="3"></i><b>(3)</b>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">item_t</span><span class="o">&gt;</span> <span class="n">buffer</span><span class="p">(</span> <span class="n">VECTOR_SIZE</span> <span class="p">);</span>

<span class="kt">void</span> <span class="nf">productor</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="k">while</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">item_t</span> <span class="n">item</span> <span class="o">=</span> <span class="n">produce_item</span><span class="p">();</span>

        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span> <span class="n">lock</span><span class="p">{</span> <span class="n">mutex</span> <span class="p">};</span>  <i class="conum" data-value="4"></i><b>(4)</b> <i class="conum" data-value="5"></i><b>(5)</b>

        <span class="k">while</span><span class="p">(</span> <span class="n">buffer</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">VECTOR_SIZE</span> <span class="p">)</span>  <i class="conum" data-value="6"></i><b>(6)</b> <i class="conum" data-value="10"></i><b>(10)</b>
        <span class="p">{</span>
            <span class="n">no_full</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span> <span class="n">mutex</span> <span class="p">);</span> <i class="conum" data-value="11"></i><b>(11)</b>
        <span class="p">}</span>

        <span class="n">vector</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">item</span> <span class="p">);</span>  <i class="conum" data-value="11"></i><b>(11)</b>

        <span class="n">no_empty</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span> <i class="conum" data-value="7"></i><b>(7)</b>
    <span class="p">}</span> <i class="conum" data-value="6"></i><b>(6)</b>

    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">consumer</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="k">while</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span> <span class="n">lock</span><span class="p">{</span> <span class="n">mutex</span> <span class="p">};</span>  <i class="conum" data-value="4"></i><b>(4)</b> <i class="conum" data-value="5"></i><b>(5)</b>

        <span class="k">while</span><span class="p">(</span> <span class="n">buffer</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>  <i class="conum" data-value="8"></i><b>(8)</b> <i class="conum" data-value="10"></i><b>(10)</b>
        <span class="p">{</span>
            <span class="n">no_empty</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span> <span class="n">mutex</span> <span class="p">);</span>  <i class="conum" data-value="11"></i><b>(11)</b>
        <span class="p">}</span>

        <span class="n">item_t</span> <span class="n">item</span> <span class="o">=</span> <span class="n">vector</span><span class="p">.</span><span class="n">back</span><span class="p">();</span> <i class="conum" data-value="11"></i><b>(11)</b>
        <span class="n">vector</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>

        <span class="n">no_full</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span> <i class="conum" data-value="9"></i><b>(9)</b>

        <span class="n">consume_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
    <span class="p">}</span> <i class="conum" data-value="6"></i><b>(6)</b>

    <span class="c1">// ...</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><strong><em>Mutex</em></strong> que se encarga de la exclusiÃ³n mutua.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><strong>Variable de condiciÃ³n</strong> que se encarga de indicar cuando el vector no estÃ¡ lleno.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><strong>Variable de condiciÃ³n</strong> que se encarga de indicar cuando el vector no estÃ¡ vacÃ­o.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Antes de acceder al vector es necesario bloquear <code>mutex</code>.
Ni si quiera es seguro preguntar por el nÃºmero de elementos guardados en <code>vector</code> sin antes adquirir el <strong><em>mutex</em></strong>, puesto que el otro hilo puede estar modificando <code>vector</code> al mismo tiempo.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Los <strong><em>mutex</em></strong> se pueden adquirir y liberar con <a href="https://en.cppreference.com/w/cpp/thread/mutex/lock">std::mutex:::lock()</a> y  cpp_mutex_unlock} pero esa no es la forma recomendada.
Lo recomendando es crear alguno de los objetos <em>lock</em> incluidos en la librerÃ­a estÃ¡ndar.
Estos objetos bloquean el <strong><em>mutex</em></strong> al crearse y lo desbloquean automÃ¡ticamente al destruirse.
AsÃ­ es complicado que nos olvidemos de desbloquearlo al salir de la funciÃ³n.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Antes de insertar un elemento se comprueba si hay algÃºn hueco disponible.
Si no lo hay, se pone el hilo a la espera en la <strong>variable de condiciÃ³n</strong> <code>no_full</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>El consumidor despierta al productor de esa espera tras extraer un elemento, porque es seguro que al hacerlo habrÃ¡ dejado un hueco.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Antes de extraer un elemento se comprueba si hay alguno en el vector.
Si no lo hay, se pone el hilo a la espera en la <strong>variable de condiciÃ³n</strong> <code>no_empty</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>El productor despierta al consumidor de esta espera tras insertar un nuevo elemento.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>El estÃ¡ndar de C&#43;&#43; indica que las esperas en las <strong>variables de condiciÃ³n</strong> son susceptibles de despertar de forma espuria.
Es decir, que el hilo puede salir de <a href="https://en.cppreference.com/w/cpp/thread/condition_variable/wait">std::condition_variable::wait()</a> sin que haya habido notificaciÃ³n.
Por eso hay que volver a comprobar la condiciÃ³n antes de continuar ejecutando sentencias en la <strong>secciÃ³n crÃ­tica</strong>.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>Cuando los hilos se bloquean en <a href="https://en.cppreference.com/w/cpp/thread/condition_variable/wait">std::condition_variable::wait()</a>, <code>mutex</code> es liberado para que el otro hilo pueda entrar y extraer o insertar un elemento.
De lo contrario, no podrÃ­a hacerlo y ambos se quedarÃ­an bloqueados indefinidamente âen una situaciÃ³n que se denomina <strong>interbloqueo</strong> o <strong><em>deadlock</em></strong>â.
Pero antes de salir de <a href="https://en.cppreference.com/w/cpp/thread/condition_variable/wait">std::condition_variable::wait()</a>, el hilo adquiere de nuevo el <code>mutex</code>.
AsÃ­ que el cÃ³digo que inserta y extrae elementos se ejecuta en <strong>exclusiÃ³n mutua</strong>, tal y como nos interesa.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_esperas">13.6. Esperas</h3>
<div class="paragraph">
<p>Muchos de los objetos de sincronizaciÃ³n que hemos visto necesitan algÃºn mecanismo para poner en espera a los hilos que los usan.
Existen dos alternativas desde el punto de vista de como implementar esta espera:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>El sistema operativo puede cambiar el estado del hilo o proceso a <strong>esperado</strong> y moverlo a una cola de espera asociada al objeto de sincronizaciÃ³n, tal y como hemos comentado en varias ocasiones.
Entonces el planificador de la CPU escogerÃ¡ a otro proceso para ser ejecutado.</p>
</li>
<li>
<p>El hilo puede iterar comprobando constantemente la condiciÃ³n hasta que se cumple.
A esa tÃ©cnica se la denomina <strong>espera ocupada</strong>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Este tipo de <strong>espera ocupada</strong> desperdicia tiempo de CPU que otro hilo podrÃ­a utilizar de forma mÃ¡s productiva, por lo que sÃ³lo se utiliza en el caso de esperas previsiblemente cortas.
Para evitar que las esperas ocupadas sean demasiado largas, los sistema operativos nunca expulsan de la CPU a hilos que se estÃ©n ejecutando dentro de secciones crÃ­ticas controladas por objetos de sincronizaciÃ³n con este tipo de espera, con la idea de que salgan de la secciÃ³n crÃ­tica los antes posible.</p>
</div>
<div class="paragraph">
<p>En Windows API, por ejemplo, se puede utilizar <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-initializecriticalsectionandspincount">InitializeCriticalSectionAndSpinCount()</a> para inicializar un objeto de <strong>secciÃ³n crÃ­tica</strong> donde el hilo que la intenta adquirir itera el nÃºmero especificado de veces en una <strong>espera ocupada</strong>, comprobando si la secciÃ³n es liberada, antes de bloquearse en el estado <strong>esperando</strong> si eso no ocurre.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>La <strong>espera ocupada</strong> de estos objetos <strong>secciÃ³n crÃ­tica</strong> de Windows API solo ocurre en sistemas multiprocesador, donde el hilo que tiene adquirida la secciÃ³n puede estar ejecutÃ¡ndose en otro hilo y terminar rÃ¡pidamente.
En sistemas monoprocesador nunca hay <strong>espera ocupada</strong>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A los <strong><em>mutex</em></strong> con <strong>espera ocupada</strong> tambiÃ©n se los denomina <strong><em>(spinlock)</em></strong>.
Los <strong><em>spinlocks</em></strong> son utilizados frecuentemente para proteger las estructuras del nÃºcleo en los sistemas multiprocesador, cuando la tarea a realizar dentro de la secciÃ³n crÃ­tica en el nÃºcleo requiere poco tiempo y los diseÃ±adores calculan que se desperdicia mÃ¡s tiempo sacando de la CPU al hilo en espera para ejecutar otro en su lugar.</p>
</div>
</div>
<div class="sect2">
<h3 id="_funciones_reentrantes_y_seguras_en_hilos">13.7. Funciones reentrantes y seguras en hilos</h3>
<div class="paragraph">
<p>Todas estas cuestiones sobre la sincronizaciÃ³n no solo afectan al cÃ³digo que escribimos sino tambiÃ©n a las librerÃ­as que podemos utilizar.
A la hora de decidir utilizar una librerÃ­a en un programa multihilo es necesario que tengamos en cuenta los conceptos de <strong>reentrante</strong> y <strong>seguridad de hilos</strong>.</p>
</div>
<div class="sect3">
<h4 id="_funciones_reentrantes">13.7.1. Funciones reentrantes</h4>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>Una funciÃ³n es <strong>reentrante</strong> puede ser interrumpida en medio de su ejecuciÃ³n y, mientras espera, volver a ser llamada con total seguridad.
Obviamente las funciones recursivas deben ser reentrantes para poder llamarse a sÃ­ mismas una y otra vez con seguridad.</p>
</div>
<div class="paragraph">
<p>En el contexto de la programaciÃ³n multihilo, ocurre una reentrada cuando durante la ejecuciÃ³n de una funciÃ³n por parte de un hilo, este es interrumpido por el sistema operativo para planificar posteriormente a otro del mismo proceso que invoca la misma funciÃ³n.</p>
</div>
<div class="paragraph">
<p>En general una funciÃ³n es reentrante, si:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>No modifica variables estÃ¡ticas o globales.
Si lo hiciera sÃ³lo puede hacerlo mediante operaciones <strong>leer-modificar-escribir</strong> que sean ininterrumpibles âes decir, atÃ³micasâ.</p>
</li>
<li>
<p>No modifica su propio cÃ³digo y no llama a otras funciones que no sean reentrantes.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_seguridad_en_hilos">13.7.2. Seguridad en hilos</h4>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>Una funciÃ³n es <strong>segura en hilos</strong> o <strong>thread-safe</strong> si al manipular estructuras compartidas de datos lo hace de tal manera que se garantiza la ejecuciÃ³n segura de la misma por mÃºltiples hilos al mismo tiempo.
Obviamente estamos hablando de un problema de secciones crÃ­ticas, por lo que las funciones lo  resuelven sincronizando el acceso a estos datos mediante el uso de <strong>semÃ¡foros</strong>, <strong><em>mutex</em></strong> u otros recursos similares ofrecidos por el sistema operativo.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En ocasiones, ambos conceptos se confunden porque es bastante comÃºn que el cÃ³digo reentrante tambiÃ©n sea seguro en hilos.
Sin embargo es posible crear cÃ³digo reentrante que no sea seguro en hilos y viceversa.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A la hora de usar una funciÃ³n o librerÃ­a que va a ser llamada desde mÃºltiples hilos, primero debemos consultar la documentaciÃ³n para averiguar si es <strong>segura en hilos</strong>.
Si no lo fuera, tendrÃ­amos que buscar funciones alternativas o recordar proteger las llamadas a las funciones no seguras con mecanismos de sincronizaciÃ³n, para asegurar que solo son invocadas desde un hilo al mismo tiempo.</p>
</div>
<div class="paragraph">
<p>Esto se aplica tanto a librerÃ­as de otros desarrolladores como a la librerÃ­a estÃ¡ndar del lenguaje que estemos usando y a la librerÃ­a del sistema.</p>
</div>
<div class="sect4">
<h5 id="_seguridad_en_hilos_en_c">Seguridad en hilos en C++</h5>
<div class="paragraph">
<p>La norma general es que las clases de la librerÃ­a estÃ¡ndar de C&#43;&#43; son seguras frente a mÃºltiples accesos de lectura desde diferentes hilos.
Pero si un hilo modifica un objeto, todas las lecturas y escrituras en el mismo objeto por ese y otros hilos deben estar protegidas.</p>
</div>
<div class="paragraph">
<p>Obviamente, las clases de mecanismos de sincronizaciÃ³n y gestiÃ³n de hilos generalmente ofrecen mayores garantÃ­as, para lo que hay que consultar la documentaciÃ³n.</p>
</div>
</div>
<div class="sect4">
<h5 id="_seguridad_en_hilos_en_c_2">Seguridad en hilos en C</h5>
<div class="paragraph">
<p>El estÃ¡ndar de C no menciona nada sobre <strong>seguridad en hilos</strong>, por lo que se debe suponer que las funciones de la librerÃ­a estÃ¡ndar no lo son o consultar la documentaciÃ³n ofrecida por el proveedor de la librerÃ­a.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, todas las versiones de la librerÃ­a estÃ¡ndar de C en Windows actualmente son <strong>seguras en hilos</strong> (vÃ©ase <a href="https://docs.microsoft.com/en-us/cpp/parallel/multithreading-with-c-and-win32?view=vs-2019">Â«Multithreading with C and Win32&#8201;&#8212;&#8201;Microsoft DocsÂ»</a>).
Pero hasta hace uno aÃ±os Microsoft ofrecÃ­a varias versiones de la librerÃ­a, algunas <strong>seguras en hilos</strong>, para usar en aplicaciones multihilo, y otras no seguras para usar en aplicaciones monohilo.</p>
</div>
</div>
<div class="sect4">
<h5 id="_seguridad_en_hilos_en_posix">Seguridad en hilos en POSIX</h5>
<div class="paragraph">
<p>La API POSIX es un superconjunto de la API de la librerÃ­a estÃ¡ndar de C.
Por lo que en esos sistemas el estÃ¡ndar POSIX es el que marca quÃ© funciones de la librerÃ­a estÃ¡ndar de C y del resto del API POSIX son <strong>seguras en hilos</strong>.</p>
</div>
<div class="paragraph">
<p>En los sistemas POSIX, el estÃ¡ndar establece que todas las funciones son seguras excepto algunas muy concretas, que se pueden consultar en el apartado <a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_09_01_">Â«2.9.1 Thread-SafetyÂ»</a> de la especificaciÃ³n.
Muchas de esas funciones no se especifican como <strong>seguras en hilos</strong> porque existe alguna alternativa que sÃ­ lo es.
Por ejemplo, <a href="https://man7.org/linux/man-pages/man3/strerror.3.html">strerror()</a> no es <strong>segura en hilos</strong>, pero <a href="https://man7.org/linux/man-pages/man3/strerror.3.html">strerror_r()</a> tiene una funcionalidad equivalente y sÃ­ lo es.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_planificaciÃ³n_de_la_cpu">14. PlanificaciÃ³n de la CPU</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>30 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>El <strong>planificador de la CPU</strong> o <strong>planificador de corto plazo</strong> tiene la misiÃ³n de seleccionar de la <strong>cola de preparados</strong> el siguiente proceso o hilo de nÃºcleo a ejecutar.
En dicha cola suelen estar los PCB âo TCBâ de todos los procesos âo hilos de nÃºcleoâ que esperan una oportunidad para usar la CPU.
Aunque se suele pensar en la <strong>cola de preparados</strong> como una cola FIFO, no tiene por quÃ© ser asÃ­, como veremos mÃ¡s adelante, ya que existen mejores estrategias para seleccionar la prÃ³xima tarea a ejecutar.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En este capÃ­tulo hablaremos de procesos y de cÃ³mo son seleccionados por el planificador de la CPU.
Sin embargo, debemos tener en cuenta que en los sistemas operativos multihilo con la librerÃ­a de hilos implementada en el nÃºcleo âcategorÃ­a a la que pertenecen todos los sistemas modernosâ la unidad de trabajo de la CPU es el hilo.
AsÃ­ que todo lo que comentemos a partir de ahora sobre la planificaciÃ³n de procesos en la CPU, realmente se aplica a los hilos y no a los procesos en los sistemas operativos modernos.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>En cualquier caso, sea cual sea el algoritmo de planificaciÃ³n utilizado, Ã©ste debe ser muy rÃ¡pido, ya que es ejecutado con mucha frecuencia âaproximadamente una vez cada 100 milisegundosâ.</p>
</div>
<div class="sect2">
<h3 id="_planificaciÃ³n_expropiativa">14.1. PlanificaciÃ³n expropiativa</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El planificador deben ser invocado necesariamente en los siguientes casos, dado que en ellos la CPU queda libre y es conveniente aprovecharla planificando otro proceso, en lugar de dejarla desocupada:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Cuando un proceso pasa de <strong>ejecutando</strong> a <strong>esperando</strong>.
Por ejemplo, por solicitar una operaciÃ³n de E/S, esperar a que un hijo termine, esperar en un semÃ¡foro, etc.</p>
</li>
<li>
<p>Cuando un proceso termina.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Cuando el planificador de la CPU es invocado solo en los casos anteriores, decimos que tenemos un sistema operativo con <strong>planificaciÃ³n cooperativa</strong> o <strong>no expropiativa</strong>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>En la <strong>planificaciÃ³n cooperativa</strong> cuando la CPU es asignada a un proceso, Ã©ste la acapara hasta terminar o hasta pasar al estado de <strong>esperando</strong>.</p>
</div>
<div class="paragraph">
<p>La <strong>planificaciÃ³n cooperativa</strong> no requiere de ningÃºn hardware especial, por lo que en algunas plataformas puede ser la Ãºnica opciÃ³n.
Por ello estaba presente en los sistemas operativos mÃ¡s antiguos, como <a href="https://es.wikipedia.org/wiki/Windows_3.1x">Windows 3.x</a> y <a href="https://es.wikipedia.org/wiki/Mac_OS">Mac OS</a> âque no debemos confundir con el actual <a href="https://es.wikipedia.org/wiki/MacOS">macOS</a>â.</p>
</div>
<div class="paragraph">
<p>Sin embargo, las decisiones de planificaciÃ³n tambiÃ©n pueden ser tomadas en otros dos casos:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Cuando ocurre una interrupciÃ³n del temporizador, lo que permite detectar si un proceso lleva demasiado tiempo ejecutÃ¡ndose.</p>
</li>
<li>
<p>Cuando un proceso pasa de <strong>esperando</strong> a <strong>preparado</strong>.
Por ejemplo, porque para un proceso ha terminado la operaciÃ³n de E/S por la que estaba esperando.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Cuando el planificador es invocado en los cuatro casos decimos que tenemos <strong>planificaciÃ³n expropiativa</strong> o <strong>apropiativa</strong>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>La <strong>planificaciÃ³n expropiativa</strong> sÃ­ requiere de un soporte adecuado por parte del hardware, por lo que se utiliza en los sistemas operativos modernos.
Ejemplos de estos sistemas son Microsoft Windows âdesde Windows 95â, Linux, macOS, y todos los UNIX modernos.</p>
</div>
<div class="paragraph">
<p>La utilizaciÃ³n de un <strong>planificador expropiativo</strong> introduce algunas dificultades adicionales:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Puesto que un proceso puede ser expropiado en cualquier momento âsin que pueda hacer nada para evitarloâ el sistema operativo debe proporcionar <em>mecanismos de sincronizaciÃ³n</em> (vÃ©ase el <a href="#_sincronizaciÃ³n">CapÃ­tulo 13</a>) para coordinar el acceso a datos compartidos que podrÃ­an estar siendo modificados por el proceso que abandona la CPU y que puede necesitar el que entra en ella.</p>
</li>
<li>
<p>Â¿QuÃ© ocurre si un proceso va a ser expropiado en el preciso momento en el que se estÃ¡ ejecutando una llamada al sistema? No debemos olvidar que
dentro del nÃºcleo se manipulan datos importantes, compartidos por todo el sistema, que deben permanecer consistentes en todo momento.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Para resolver esta cuestiÃ³n la soluciÃ³n mÃ¡s sencilla es impedir la expropiaciÃ³n dentro del nÃºcleo.
Es decir, el cambio de contexto âque sacarÃ­a al proceso actual de la CPU y meterÃ­a al siguienteâ no ocurre inmediatamente, sino que se retrasa hasta que la llamada al sistema se completa o se bloquea poniendo al proceso en el estado de <em>esperando</em>.
Esto permite nÃºcleos simples y garantiza que las estructuras del mismo permanezcan consistentes, pero es una estrategia muy pobre para sistemas de tiempo real o multiprocesador.
Exploraremos otras soluciones mÃ¡s adelante (vÃ©ase el <a href="#_planificaciÃ³n_de_tiempo_real">Apartado 14.6</a>).</p>
</div>
</div>
<div class="sect2">
<h3 id="_el_asignador">14.2. El asignador</h3>
<div class="paragraph">
<p>El <strong>asignador</strong> es el componente que da el control de la CPU al proceso seleccionado por el planificador de corto plazo.
Esta tarea implica realizar las siguientes funciones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cambiar el contexto.</p>
</li>
<li>
<p>Cambiar al modo usuario.</p>
</li>
<li>
<p>Saltar al punto adecuado del programa para continuar la ejecuciÃ³n del proceso.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Puesto que el <strong>asignador</strong> es invocado para cada intercambio de procesos en la CPU, es necesario que el tiempo que tarda en detener un proceso e iniciar otro sea lo mÃ¡s corto posible.
Al tiempo que transcurre desde que un proceso es escogido para ser planificado en la CPU hasta que es asignado a la misma se lo denomina <strong>latencia de asignaciÃ³n</strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_criterios_de_planificaciÃ³n">14.3. Criterios de planificaciÃ³n</h3>
<div class="paragraph">
<p>Los diferentes algoritmos de planificaciÃ³n de la CPU tienen diversas propiedades que pueden favorecer a una clase de procesos respecto a otra.
Por ello es interesante disponer de algÃºn criterio para poder comparar los algoritmos y determinar cual es el mejor.</p>
</div>
<div class="paragraph">
<p>Se han sugerido muchos criterios para comparar los algoritmos de planificaciÃ³n de CPU.
La elecciÃ³n de uno u otro puede suponer una diferencia sustancial a la hora de juzgar quÃ© algoritmo es el mejor.</p>
</div>
<div class="paragraph">
<p>A continuaciÃ³n presentamos los criterios mÃ¡s comunes.</p>
</div>
<div class="sect3">
<h4 id="_criterios_a_maximizar">14.3.1. Criterios a maximizar</h4>
<div class="paragraph">
<p>Los algoritmos de planificaciÃ³n son mejores cuanto mayor es su valor para los siguientes criterios.</p>
</div>
<div class="sect4">
<h5 id="_uso_de_cpu">Uso de CPU</h5>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Un buen planificador deberÃ­a mantener la CPU lo mÃ¡s ocupada posible.
El <strong>uso de CPU</strong> es la proporciÃ³n de tiempo que se usa la CPU en un periodo de tiempo determinado.
Se suele indicar en tanto por ciento.</p>
</div>
<div class="stemblock">
<div class="content">
\$"Uso de CPU" = 100 "Tiempo que la CPU permanece ocupada" / "Tiempo durante el que se toma la medida" "%"\$
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tasa_de_procesamiento">Tasa de procesamiento</h5>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Cuando la CPU estÃ¡ ocupada es porque el trabajo se estÃ¡ haciendo.
Por tanto, una buena medida del volumen de trabajo realizado puede ser el nÃºmero de tareas o procesos terminados por unidad de tiempo.
A dicha magnitud es a la que denominamos como <strong>tasa de procesamiento</strong>.</p>
</div>
<div class="stemblock">
<div class="content">
\$"Tasa de procesamiento" = "Numero de procesos terminados" / "Tiempo durante el que se toma la medida" "procesos/s"\$
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_criterios_a_minimizar">14.3.2. Criterios a minimizar</h4>
<div class="paragraph">
<p>Los algoritmos de planificaciÃ³n son mejores cuanto menor es su valor para los siguientes criterios.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Tiempo de ejecuciÃ³n</dt>
<dd>
<p>Es el intervalo de tiempo que transcurre desde que el proceso es cargado hasta que termina.</p>
</dd>
<dt class="hdlist1">Tiempo de espera</dt>
<dd>
<p>Es la suma de tiempos que el proceso permanece a la espera en la <strong>cola de preparados</strong>.
Esta medida de tiempo no incluye el tiempo de espera debido a las operaciones de E/S.</p>
</dd>
<dt class="hdlist1">Tiempo de respuesta</dt>
<dd>
<p>Es el intervalo de tiempo que transcurre desde que se le lanza un evento âse pulsa una tecla, se hace clic con el ratÃ³n o llega un paquete por la interfaz de redâ hasta que se produce la primera respuesta del proceso.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>El <strong>tiempo de respuesta</strong> mide el tiempo que se tarda en responder y no el tiempo de E/S.
Mientras que el <strong>tiempo de ejecuciÃ³n</strong> sÃ­ incluye el tiempo que consumen las operaciones de E/S, por lo que suele estar limitado por la velocidad de los dispositivos E/S.</p>
</div>
</div>
<div class="sect3">
<h4 id="_elecciÃ³n_del_criterio_adecuado">14.3.3. ElecciÃ³n del criterio adecuado</h4>
<div class="paragraph">
<p>En funciÃ³n del tipo de sistema o de la clase de trabajos que se van a ejecutar puede ser conveniente medir la eficiencia del sistema usando un criterio u otro.
Esto a su vez beneficiarÃ¡ a unos algoritmos de planificaciÃ³n frente a otros, indicÃ¡ndonos cuÃ¡les son los mÃ¡s eficientes para nuestra clase de trabajos en particular.</p>
</div>
<div class="paragraph">
<p>En general podemos encontrar dos clases de trabajos para los que puede ser necesario evaluar la eficiencia del sistema de manera diferente: los trabajos interactivos y los que no lo son.</p>
</div>
<div class="sect4">
<h5 id="_sistemas_interactivos">Sistemas interactivos</h5>
<div class="paragraph">
<p>En los sistemas interactivos âya sean sistemas de escritorio o <em>mainframes</em> de tiempo compartidoâ los procesos pasan la mayor parte del tiempo esperando algÃºn tipo de entrada por parte de los usuarios.</p>
</div>
<div class="paragraph">
<p>En este tipo de sistemas, el <strong>tiempo de ejecuciÃ³n</strong> no suele ser el mejor criterio para determinar la bondad de un algoritmo de planificaciÃ³n, ya que viene determinado en gran medida por la velocidad de la entrada de los usuarios.
Por el contrario, se espera que el sistema reaccione lo antes posible a las Ã³rdenes recibidas, lo que hace que el <strong>tiempo de respuesta</strong> sea un criterio mÃ¡s adecuado para evaluar al planificador de la CPU.</p>
</div>
<div class="paragraph">
<p>Generalmente, el <strong>tiempo de respuesta</strong> se reduce  cuando el tiempo que pasan los procesos interactivos en la <strong>cola de preparados</strong> tambiÃ©n lo hace âtras haber sido puestos ahÃ­ por la ocurrencia de algÃºn eventoâ por lo que tambiÃ©n puede ser una buena idea utilizar como criterio el <strong>tiempo de espera</strong>.</p>
</div>
<div class="paragraph">
<p>Esta selecciÃ³n de criterios no sÃ³lo es adecuada para los sistemas interactivos, ya que existen muchos otros casos donde es interesante seleccionar un planificador de la CPU que minimice el tiempo de respuesta.
Esto, por ejemplo, ocurre con algunos servicios en red, como: sistemas de mensajerÃ­a instantÃ¡nea, videoconferencia, servidores de videojuegos, etc.</p>
</div>
</div>
<div class="sect4">
<h5 id="_sistemas_no_interactivos">Sistemas no interactivos</h5>
<div class="paragraph">
<p>Por el contrario, en los antiguos <em>mainframes</em> de procesamiento por lotes y multiprogramados, en los superordenadores que realizan complejas simulaciones fÃ­sicas y en los grandes centros de datos de proveedores de Internet como Google, lo de menos es el tiempo de respuesta y lo realmente importante es completar cada tarea en el menor tiempo posible.
Por eso en ese tipo de sistemas es aconsejable utilizar criterios tales como el <strong>tiempo de ejecuciÃ³n</strong> o la <strong>tasa de procesamiento</strong>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_promedio_o_varianza_del_criterio">Promedio o varianza del criterio</h5>
<div class="paragraph">
<p>Obviamente estos criterios varÃ­an de un proceso a otro, por lo que normalmente lo que se busca es optimizar los valores promedios en el sistema.</p>
</div>
<div class="paragraph">
<p>Sin embargo no debemos olvidar que en muchos casos puede ser mÃ¡s conveniente optimizar el mÃ¡ximo y mÃ­nimo de dichos valores antes que el promedio.
Por ejemplo, en los sistemas interactivos es mÃ¡s importante minimizar la <strong>varianza en el tiempo de respuesta</strong> que el <strong>tiempo de respuesta promedio</strong>, puesto que para los usuarios un sistema con un tiempo de respuesta predecible es mÃ¡s deseable que uno muy rÃ¡pido en promedio pero con una varianza muy alta.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ciclo_de_rÃ¡fagas_de_cpu_y_de_es">14.4. Ciclo de rÃ¡fagas de CPU y de E/S</h3>
<div class="paragraph">
<p>El Ã©xito de la planificaciÃ³n de CPU depende en gran medida de la siguiente propiedad que podemos observar en hilos o procesos:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><em>La ejecuciÃ³n de un hilo o proceso consiste en ciclos de CPU y esperas de E/S, de forma que alternan entre estos dos estados.</em></p>
</div>
<div class="paragraph">
<p><em>La ejecuciÃ³n empieza con una rÃ¡faga de CPU, seguida por una rÃ¡faga de E/S, que a su vez es seguida por otra de CPU y asÃ­ sucesivamente.</em>
<em>Finalmente, la Ãºltima rÃ¡faga de CPU finaliza con una llamada al sistema âgeneralmente <a href="https://www.man7.org/linux/man-pages/man3/exit.3.html">exit()</a>â para terminar la ejecuciÃ³n del proceso.</em></p>
</div>
</div>
</div>
<div id="rÃ¡fagas_de_cpu" class="imageblock">
<div class="content">
<img src="C14-planificaciÃ³n_de_CPU/media/histogramas_tiempo_de_rÃ¡fagas.svg" alt="histogramas tiempo de rÃ¡fagas">
</div>
<div class="title">Figura 36. Histograma de los tiempos de las rÃ¡fagas de CPU..</div>
</div>
<div class="paragraph">
<p>La curva que relaciona la frecuencia de las rÃ¡fagas de CPU con la duraciÃ³n de las mismas tiende a ser exponencial o hiper-exponencial (vÃ©ase la <a href="#rÃ¡fagas_de_cpu">Figura 36</a>) aunque varÃ­a enormemente entre tipos de tareas y sistemas informÃ¡ticos distintos.
Esto significa que los procesos se pueden clasificar entre aquellos que presentan un gran nÃºmero de rÃ¡fagas de CPU cortas o aquellos con un pequeÃ±o nÃºmero de rÃ¡fagas de CPU largas.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Concretamente:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Decimos que un proceso es <strong>limitado por la E/S</strong> cuando presenta muchas rÃ¡fagas de CPU cortas, debido a que si es asÃ­, es porque pasa la mayor parte del tiempo esperando por la E/S.</p>
</li>
<li>
<p>Decimos que un proceso estÃ¡ <strong>limitado por la CPU</strong> cuando presenta pocas rÃ¡fagas de CPU largas, debido a que si es asÃ­, es porque hace un uso intensivo de la misma y a penas pasa tiempo esperando por la E/S.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Esta distinciÃ³n entre tipos de procesos puede ser importante en la selecciÃ³n de un algoritmo de planificaciÃ³n de CPU adecuado, puesto que, por lo general el algoritmo escogido debe planificar antes a los procesos limitados por la E/S, evitando asÃ­ que los procesos limitados por la CPU âque son los que tienden a usarla mÃ¡s tiempoâ la acaparen.</p>
</div>
<div class="paragraph">
<p>Si esto Ãºltimo ocurriera, los procesos limitados por la E/S se acumularÃ­an en la <strong>cola de preparados</strong>, dejando vacÃ­as las colas de dispositivos.
Este fenÃ³meno, que provoca una infrautilizaciÃ³n de los dispositivos de E/S, se denomina <strong>efecto convoy</strong>.</p>
</div>
<div class="paragraph">
<p>Planificar primero a los procesos limitados por la E/S tiene ademÃ¡s dos efectos muy positivos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Los procesos interactivos son generalmente procesos limitados por la E/S, por lo que planificarlos primero hace que mejore el tiempo de respuesta.</p>
</li>
<li>
<p>Generalmente el tiempo de espera promedio se reduce cuando se planifican primero los procesos con rÃ¡fagas de CPU cortas.
SegÃºn las definiciones anteriores, estos procesos son precisamente los limitados por la E/S.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_algoritmos_de_planificaciÃ³n_de_la_cpu">14.5. Algoritmos de planificaciÃ³n de la CPU</h3>
<div class="paragraph">
<p>A continuaciÃ³n ilustraremos algunos de los algoritmos de planificaciÃ³n de CPU mÃ¡s comunes.
Lo haremos considerando que cada proceso tiene una Ãºnica rÃ¡faga de CPU.
Sin embargo, no debemos olvidar que para ser precisos necesitarÃ­amos utilizar muchos mÃ¡s procesos, donde cada uno estuviera compuesto de una secuencia de miles de rÃ¡fagas alternativas de CPU y de E/S.</p>
</div>
<div class="sect3">
<h4 id="_planificaciÃ³n_fcfs">14.5.1. PlanificaciÃ³n FCFS</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>En la planificaciÃ³n <strong>FCFS</strong> (<em>First Come, First Served</em>) o <strong>primero que llega, primero servido</strong> la cola es FIFO:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Los procesos que llegan se colocan al final de la cola que les corresponde.</p>
</li>
<li>
<p>El proceso asignado a la CPU se coge siempre del principio de la cola seleccionada.</p>
</li>
<li>
<p>Es un algoritmo <strong>cooperativo</strong>, puesto que un proceso mantiene la CPU hasta que decide liberarla voluntariamente ârecordemos que la rÃ¡faga de CPU llega a su fin porque el proceso termina o solicita alguna operaciÃ³n que lo lleva el estado <strong>esperando</strong>â.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ilustremos el algoritmo con un ejemplo.
Supongamos que 4 procesos llegan a la <strong>cola de preparados</strong> en los tiempos indicados en la <a href="#tabla_problema_fcfs">Tabla 8</a>.
AdemÃ¡s, aunque es difÃ­cil tener un conocimiento a priori del tiempo de la rÃ¡faga de CPU de cada proceso, vamos a suponer que tambiÃ©n son conocidos.</p>
</div>
<table id="tabla_problema_fcfs" class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 8. Problema de planificaciÃ³n de la CPU mediante algoritmo FCFS.</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Proceso</th>
<th class="tableblock halign-center valign-top">Tiempo de llegada (ms.)</th>
<th class="tableblock halign-center valign-top">Tiempo de rÃ¡faga de CPU (ms.)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">24</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>En la siguiente figura podemos ver el <a href="https://es.wikipedia.org/wiki/Diagrama_de_Gantt">diagrama de Gantt</a> de la planificaciÃ³n considerando que se utiliza el algoritmo <strong>FCFS</strong>:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="C14-planificaciÃ³n_de_CPU/media/fcfs1.svg" alt="fcfs1">
</div>
</div>
<div class="paragraph">
<p>Utilizando el diagrama anterior, podemos calcular fÃ¡cilmente los <strong>tiempos de espera y de ejecuciÃ³n promedio</strong>:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2858%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Proceso</th>
<th class="tableblock halign-center valign-top">Instante de finalizaciÃ³n (ms.)</th>
<th class="tableblock halign-center valign-top" colspan="2">Tiempo de espera (ms.)</th>
<th class="tableblock halign-center valign-top" colspan="2">Tiempo de ejecuciÃ³n (ms.)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">24</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(0-0)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(24-0)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">24</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">27</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(24-1)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">23</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(27-1)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">26</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">30</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(27-2)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">25</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(30-2)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">28</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">32</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(30-3)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">27</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(32-3)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">29</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Tiempos promedio (ms.)</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">18,75</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">26,75</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph">
<p>Lo interesante es que el resultado cambia si los procesos llegan en otro orden.
Por ejemplo, P1 podrÃ­a llegar el Ãºltimo:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Proceso</th>
<th class="tableblock halign-center valign-top">Tiempo de llegada (ms.)</th>
<th class="tableblock halign-center valign-top">Tiempo de rÃ¡faga de CPU (ms.)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">24</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Entonces el resultado de la planificaciÃ³n serÃ­a el que se muestra en la siguiente figura:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="C14-planificaciÃ³n_de_CPU/media/fcfs2.svg" alt="fcfs2">
</div>
</div>
<div class="paragraph">
<p>Y los <strong>tiempos de espera y ejecuciÃ³n promedio</strong> correspondientes serÃ­an:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2858%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Proceso</th>
<th class="tableblock halign-center valign-top">Instante de finalizaciÃ³n (ms.)</th>
<th class="tableblock halign-center valign-top" colspan="2">Tiempo de espera (ms.)</th>
<th class="tableblock halign-center valign-top" colspan="2">Tiempo de ejecuciÃ³n (ms.)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(0-0)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(3-0)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(3-1)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(6-1)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(6-2)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(8-2)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">32</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(8-3)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(32-3)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">29</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Tiempos promedio (ms.)</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2,75</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10,75</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph">
<p>Aunque el tiempo total necesario para ejecutar los rÃ¡fagas de los 4 procesos, los criterios utilizados reflejan que el algoritmo se comporta mucho mejor en el segundo caso.
Por tanto, el algoritmo <strong>FCFS</strong> no garantiza ni <strong>tiempos de espera</strong> ni de <strong>ejecuciÃ³n</strong> mÃ­nimos, ya que pueden cambiar variar considerablemente con el orden en el que llegan los procesos.</p>
</div>
<div class="paragraph">
<p>AdemÃ¡s, el algoritmo <strong>FCFS</strong> sufre el llamado <strong>efecto convoy</strong>.
Para entenderlo, analicemos lo que estÃ¡ pasando en el ejemplo de la <a href="#tabla_problema_fcfs">Tabla 8</a>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Al proceso P1 se la asigne la CPU.
Durante el tiempo que P1 utiliza la CPU todos los otros procesos terminan sus operaciones de E/S y pasan a la <strong>cola de preparados</strong>.
Por tanto, mientras los procesos esperan para utilizar la CPU, los dispositivos de E/S permanecen
desocupados.</p>
</li>
<li>
<p>El proceso P1 termina de usar la CPU y pasa a una cola de dispositivos.</p>
</li>
<li>
<p>El resto de procesos P, que tienen rÃ¡fagas de CPU cortas, se ejecutan rÃ¡pidamente y pasan a las colas de dispositivos.
Por tanto, la CPU permanecerÃ¡ vacÃ­a hasta que algÃºn proceso termine la operaciÃ³n de E/S solicitada.</p>
</li>
<li>
<p>El proceso P1 pasa a la <strong>cola de preparados</strong> y se le asigna la CPU.
Con el tiempo el resto de procesos terminaran sus operaciones y, nuevamente, tienen que esperar en la <strong>cola de preparados</strong> a que el proceso P1 termine de utilizarla.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Esto nos permite llegar a la conclusiÃ³n de que en cierto orden de llegada la mayor parte
de los procesos esperan constantemente detrÃ¡s de uno para poder realizar su trabajo.
Esto reduce la utilizaciÃ³n de la CPU y de los dispositivos de E/S por debajo de lo que serÃ­a posible, si los
procesos mas cortos se ejecutasen primero.</p>
</div>
</div>
<div class="sect3">
<h4 id="_planificaciÃ³n_sjf">14.5.2. PlanificaciÃ³n SJF</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>La planificaciÃ³n <strong>SJF</strong> (<em>Shortest-Job First</em>) o <strong>primero el mÃ¡s corto</strong>, consiste en:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Se asocia con cada proceso la longitud de tiempo de su siguiente rÃ¡faga de CPU.</p>
</li>
<li>
<p>Cuando la CPU estÃ¡ disponible, se pone <strong>ejecutando</strong> el proceso de menor rÃ¡faga de CPU.</p>
</li>
<li>
<p>Si dos procesos tienen rÃ¡fagas de una misma longitud, se utiliza el algoritmo <strong>FCFS</strong> âentre ellos, el que lleva mÃ¡s tiempo en la <strong>cola de preparados</strong>â.</p>
</li>
<li>
<p>Es un algoritmo <strong>cooperativo</strong>, puesto que un proceso mantiene la CPU hasta que decide liberarla voluntariamente.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Ilustremos el algoritmo con un ejemplo:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Proceso</th>
<th class="tableblock halign-center valign-top">Tiempo de llegada (ms.)</th>
<th class="tableblock halign-center valign-top">Tiempo de rÃ¡faga de CPU (ms.)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Considerando que se utiliza el algoritmo <strong>SJF</strong> obtendremos el siguiente diagrama de Gantt:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="C14-planificaciÃ³n_de_CPU/media/sjf.svg" alt="sjf">
</div>
</div>
<div class="paragraph">
<p>Con los <strong>tiempos de espera y ejecuciÃ³n promedio</strong> correspondientes:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2858%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Proceso</th>
<th class="tableblock halign-center valign-top">Instante de finalizaciÃ³n (ms.)</th>
<th class="tableblock halign-center valign-top" colspan="2">Tiempo de espera (ms.)</th>
<th class="tableblock halign-center valign-top" colspan="2">Tiempo de ejecuciÃ³n (ms.)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(0-0)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(6-0)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">24</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(16-1)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">15</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(24-1)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">23</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">16</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(9-2)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(16-2)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">14</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(6-3)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(9-3)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Tiempos promedio (ms.)</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6,25</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">12,25</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph">
<p>Sin embargo, si hubiÃ©ramos utilizado el algoritmo <strong>FCFS</strong> los tiempos hubieran sido mucho peores:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2858%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Proceso</th>
<th class="tableblock halign-center valign-top">Instante de finalizaciÃ³n (ms.)</th>
<th class="tableblock halign-center valign-top" colspan="2">Tiempo de espera (ms.)</th>
<th class="tableblock halign-center valign-top" colspan="2">Tiempo de ejecuciÃ³n (ms.)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(0-0)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(6-0)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">14</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(6-1)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(14-1)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">13</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">21</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(14-2)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">12</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(21-2)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">19</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">24</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(21-3)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">18</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(24-3)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">21</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Tiempos promedio (ms.)</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8,75</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">14,75</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph">
<p>El algoritmo <strong>SJF</strong> es Ã³ptimo en el sentido de que el <strong>tiempo de espera promedio</strong> es mÃ­nimo, porque reduce mÃ¡s el tiempo de espera de los procesos cortos y aumenta el de los procesos largos.
AdemÃ¡s, asÃ­ se evita el <strong>efecto convoy</strong>.</p>
</div>
<div class="paragraph">
<p>Sin embargo, la pregunta que debemos hacernos es cÃ³mo podemos conocer de antemano la longitud de las rÃ¡fagas de CPU de un proceso, para usar esa informaciÃ³n durante la planificaciÃ³n.
Sin analizar el cÃ³digo, el sistema operativo no puede conocer el tiempo de una rÃ¡faga hasta que esta no termina de ejecutarse.</p>
</div>
<div class="paragraph">
<p>Por eso el algoritmo SJF se utiliza frecuente como planificador de la <strong>cola de trabajos</strong>, donde se puede obligar al usuario a especificar un tiempo de ejecuciÃ³n mÃ¡ximo, al enviar el trabajo a dicha cola.
En este caso, los usuarios tenderÃ¡n a ajustar la estimaciÃ³n de tiempo de ejecuciÃ³n, puesto que los que tengan tiempos mÃ¡s cortos serÃ¡n priorizados para ser ejecutados antes, frente a los de tiempos mÃ¡s largos.</p>
</div>
<div class="paragraph">
<p>Para evitar que los usuarios hagan trampas indicando un tiempo de ejecuciÃ³n mÃ¡s corto que el real, con el fin de que se planifique antes su trabajo, se puede utilizar un temporizador para abortar los trabajos que excedan el tiempo de ejecuciÃ³n indicado por el usuario.
El error puede ser notificado al usuario para que vuelva a enviar el trabajo con una estimaciÃ³n mÃ¡s realista.</p>
</div>
<div class="paragraph">
<p>Para utilizar el algoritmo <strong>SJF</strong> en el planificador de la CPU, lo Ãºnico que se puede hacer es intentar predecir el tiempo de la siguiente rÃ¡faga de CPU.
Por ejemplo, se puede utilizar un promedio ponderado exponencial de los tiempos de las de rÃ¡fagas de CPU pasadas:</p>
</div>
<div class="stemblock">
<div class="content">
\[\tau_{n+1} = \alpha{}t_n + (1 - \alpha)\tau_n,\; 0 \leq \alpha \leq 1\]
</div>
</div>
<div class="paragraph">
<p>donde:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\$\tau_{n+1}\$ es la estimaciÃ³n de tiempo de la siguiente rÃ¡faga de CPU</p>
</li>
<li>
<p>\$t_{n}\$ es el tiempo real de la Ãºltima rÃ¡faga</p>
</li>
<li>
<p>\$\alpha\$ es el peso relativo del tiempo real de la Ãºltima rÃ¡faga.</p>
</li>
<li>
<p>\$\tau_{n}\$ es la estimaciÃ³n de tiempo de la Ãºltima rÃ¡faga.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>La expresiÃ³n es recursiva, dado que \$\tau_{n}\$ se calcula usando la ecuaciÃ³n con \$t_{n-1}\$ y \$\tau_{n-1}\$; que a su vez depende de \$t_{n-2}\$ y \$\tau_{n-2}\$, y asÃ­ sucesivamente.</p>
</div>
<div class="paragraph">
<p>Si desarrollamos la formula sustituyendo los valores, veremos que \$t_{n}\$ se pondera con \$\alpha\$, \$t_{n-1}\$ con \$(1 - \alpha)\alpha\$, \$t_{n-2}\$ con \$(1 - \alpha)^2\alpha\$, y asÃ­ sucesivamente:</p>
</div>
<div class="stemblock">
<div class="content">
\[\tau_{n+1}=\alpha{}t_n + (1 - \alpha)\alpha{}t_{n-1} + (1 - \alpha)^2\alpha{}t_{n-2} + \ldots\]
</div>
</div>
<div class="paragraph">
<p>Si \$\alpha = 1\$, \$\tau_{n+1} = \alpha\t_n\$, ignorando el resto del histÃ³rico.
En otro caso, dado que tanto \$\alpha\$ como \$1 -\alpha\$ son menores de 1, cada tÃ©rmino sucesivo tiene menor peso que su predecesor, haciendo que los \$t_{n}\$ contribuyan menos cuanto mÃ¡s alejados del tiempo actual.</p>
</div>
<div class="paragraph">
<p>El problema es que todos estos cÃ¡lculos consumen tiempo de CPU, cuando el planificador debe ser lo mÃ¡s rÃ¡pido posible, dado que se ejecuta con mucha frecuencia.</p>
</div>
</div>
<div class="sect3">
<h4 id="_planificaciÃ³n_srtf">14.5.3. PlanificaciÃ³n SRTF</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El algoritmo <strong>SJF</strong> es <strong>cooperativo</strong>, pero se puede implementar de forma <strong>expropiativa</strong>, en cuyo caso se llama <strong>SRTF</strong> (Shortest-Remaing-Time First).
La diferencia estÃ¡ en lo que ocurre cuando un nuevo proceso llega a la <strong>cola de preparados</strong>.</p>
</div>
<div class="paragraph">
<p>En <strong>SRTF</strong> se compara el tiempo de la siguiente rÃ¡faga de CPU del nuevo
proceso, con el tiempo de rÃ¡faga que le queda al proceso en ejecuciÃ³n.
Si la primera magnitud es inferior, el proceso que tiene la CPU es expropiado y sustituido por el nuevo proceso.
Mientras que en <strong>SJF</strong> no se hace nada.
Se espera a que el proceso que actualmente se estÃ¡ ejecutando termine su rÃ¡faga de CPU voluntariamente.</p>
</div>
<div class="paragraph">
<p>Ilustremos el algoritmo con un ejemplo:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Proceso</th>
<th class="tableblock halign-center valign-top">Tiempo de llegada (ms.)</th>
<th class="tableblock halign-center valign-top">Tiempo de rÃ¡faga de CPU (ms.)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">9</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>El resultado es el que se muestra en el siguiente diagrama de Gantt:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="C14-planificaciÃ³n_de_CPU/media/srtf.svg" alt="srtf">
</div>
</div>
<div class="paragraph">
<p>Y los tiempos de espera y ejecuciÃ³n promedio correspondientes serÃ­an:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2858%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Proceso</th>
<th class="tableblock halign-center valign-top">Instante de finalizaciÃ³n (ms.)</th>
<th class="tableblock halign-center valign-top" colspan="2">Tiempo de espera (ms.)</th>
<th class="tableblock halign-center valign-top" colspan="2">Tiempo de ejecuciÃ³n (ms.)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">17</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(0-0) + (10-1)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(17-0)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">17</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(1-1)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(5-1)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">26</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(17-2)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">15</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(26-2)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">24</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(5-3)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(10-3)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Tiempos promedio (ms.)</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6,50</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">13,00</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph">
<p>Es muy complicado predecir cuÃ¡l de los dos algoritmos serÃ¡ mejor para un conjunto concreto de procesos.
Sin embargo, debemos tener en cuenta que âaunque no lo estemos considerando en estos problemasâ un algoritmo expropitativo, por lo general, provocarÃ¡ mÃ¡s cambios de contexto en los que se perderÃ¡ tiempo de CPU.</p>
</div>
<div class="paragraph">
<p>Los algoritmos expropiativos tambiÃ©n suelen ofrecer mejores tiempos de respuesta, puesto que un proceso que llega a la <strong>cola de preparados</strong> puede ser asignado a la CPU sin esperar a que el proceso que se ejecuta en ella actualmente termine su rÃ¡faga de CPU.</p>
</div>
</div>
<div class="sect3">
<h4 id="_planificaciÃ³n_con_prioridades">14.5.4. PlanificaciÃ³n con prioridades</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>En la <strong>planificaciÃ³n con prioridades</strong> se asocia una prioridad a cada proceso, de tal forma que el de prioridad mÃ¡s alta es asignado a la CPU.
En caso de igual prioridad, se utiliza <strong>FCFS</strong>.</p>
</div>
<div class="paragraph">
<p>Las prioridades se suelen indicar con nÃºmeros enteros en un rango fijo. Por ejemplo [0-7], [0-31],
[0-139] o [0-4095].
En algunos sistemas operativos los nÃºmeros mÃ¡s grandes representan mayor prioridad, mientras que en otros son los procesos con nÃºmeros mÃ¡s pequeÃ±os los que se planifican primero.
En Ã©ste curso utilizaremos la convenciÃ³n de que a menor valor, mayor prioridad.</p>
</div>
<div class="paragraph">
<p>Si las prioridades se asignan en base al tiempo de la prÃ³xima rÃ¡faga de CPU, su comportamiento es el mismo que el del <strong>SJF</strong>; por lo que se considera a este Ãºltimo un caso particular de algoritmo de <strong>planificaciÃ³n con prioridades</strong>.</p>
</div>
<div class="paragraph">
<p>El algoritmo de planificaciÃ³n con prioridades puede ser <strong>expropiativo</strong> o <strong>cooperativo</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En el caso <strong>expropiativo</strong>, cuando un proceso llega a la <strong>cola de preparados</strong> su prioridad es comparada con la
del proceso en ejecuciÃ³n.
Se expropia la CPU si la prioridad del nuevo proceso es superior a la prioridad del proceso que se ejecuta.</p>
</li>
<li>
<p>En el caso <strong>cooperativo</strong>, no se toma ninguna decisiÃ³n cuando llega un proceso a la <strong>cola de preparados</strong>, solo cuando el que tiene asignada la CPU la abandona.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Supongamos que 5 procesos llegan a la cola de preparados en los tiempos indicados en la <a href="#tabla_problema_prioridad">Tabla 9</a>.
Como en los ejemplos anteriores, aunque es difÃ­cil tener un conocimiento a priori del tiempo
de las rÃ¡fagas de CPU, vamos a suponer que son conocidos.
Y tambiÃ©n que a cada proceso se le asigna, de alguna forma, una prioridad cuando llega a la <strong>cola de preparados</strong>.</p>
</div>
<table id="tabla_problema_prioridad" class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 9. Problema de planificaciÃ³n de la CPU mediante algoritmo de planificaciÃ³n con prioridades.</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Proceso</th>
<th class="tableblock halign-center valign-top">Tiempo de llegada (ms.)</th>
<th class="tableblock halign-center valign-top">Tiempo de rÃ¡faga de CPU (ms.)</th>
<th class="tableblock halign-center valign-top">Prioridad</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P5</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>En las condiciones anteriores, si utilizamos el algoritmo de planificaciÃ³n por prioridades expropiativo, obtendremos el diagrama de Gantt de la siguiente figura:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="C14-planificaciÃ³n_de_CPU/media/prioridad.svg" alt="prioridad">
</div>
</div>
<div class="paragraph">
<p>Con los <strong>tiempos de espera y ejecuciÃ³n promedio</strong> correspondientes:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2858%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Proceso</th>
<th class="tableblock halign-center valign-top">Instante de finalizaciÃ³n (ms.)</th>
<th class="tableblock halign-center valign-top" colspan="2">Tiempo de espera (ms.)</th>
<th class="tableblock halign-center valign-top" colspan="2">Tiempo de ejecuciÃ³n (ms.)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(0-0) + (3-1) + (9-4)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(17-0)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">17</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(1-1)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(3-1)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">20</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(17-2)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">15</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(20-2)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">18</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">22</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(20-3)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">17</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(22-3)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">19</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P5</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(4-4)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(9-4)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Tiempos promedio (ms.)</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7,80</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">12,20</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph">
<p>Que estos algoritmos ofrezcan mejores o peores resultados que otros, obviamente depende de los criterios utilizados para asignar las prioridades.</p>
</div>
<div class="sect4">
<h5 id="_prioridades_definidas_internamente_o_externamente">Prioridades definidas internamente o externamente</h5>
<div class="paragraph">
<p>Hay dos maneras de asignar las prioridades:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Internamente</strong>.
Se utiliza una cualidad medible del proceso para calcular su prioridad.
Por ejemplo, lÃ­mites de tiempo, necesidades de memoria, nÃºmero de archivos abiertos, tiempo estimado de rÃ¡faga de CPU âcomo en <strong>SJF</strong>â o la proporciÃ³n entre esta y el tiempo estimado de rÃ¡faga de E/S.</p>
</li>
<li>
<p><strong>Externamente</strong>.
Las prioridades son fijadas por criterios externos al sistema operativo.
Por ejemplo, la importancia del proceso para los usuarios, la cantidad de dinero pagada para el uso del sistema u otros factores polÃ­ticos.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Algunas de estas formas de asignar las prioridades pueden ser fijas, mientras que otras pueden ser variables.
Es decir, un criterio externo como es la importancia del proceso para los usuarios, puede dar lugar a una prioridad que se asigna al crear el proceso y que no cambia durante toda su ejecuciÃ³n.
Por el contrario, un criterio como el tiempo de rÃ¡faga de CPU pueda dar lugar un una prioridad variable, que se ajusta cada vez que se tiene una estimaciÃ³n mejor.</p>
</div>
</div>
<div class="sect4">
<h5 id="_muerte_por_inaniciÃ³n">Muerte por inaniciÃ³n</h5>
<div class="paragraph">
<p>El mayor problema de Ã©ste tipo de planificaciÃ³n es el <strong>bloqueo indefinido</strong> o <strong>muerte por inaniciÃ³n</strong>.
Si hay un conjunto de procesos de alta prioridad demandando CPU continuamente, el algoritmo puede dejar a algunos procesos de menor prioridad esperando indefinidamente.</p>
</div>
<div class="paragraph">
<p>Una soluciÃ³n a este problema es aplicar mecanismos de <strong>envejecimiento</strong>.
Consisten en aumentar gradualmente la prioridad de los procesos que esperan âpor ejemplo, 1 unidad cada 15
minutosâ.
De esta manera los proceso de baja prioridad tarde o temprano tendrÃ¡n una oportunidad para ejecutarse.
Una vez se les asigna la CPU, se restablece su prioridad al valor original.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_planificaciÃ³n_rr">14.5.5. PlanificaciÃ³n RR</h4>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>El algoritmo <strong>RR</strong> (<em>Round-Robin</em>) es similar al <strong>FCFS</strong> pero aÃ±adiendo la expropiaciÃ³n para conmutar
entre procesos cuando llevan cierta cantidad de tiempo ejecutÃ¡ndose en la CPU.</p>
</div>
<div class="paragraph">
<p>Este algoritmo requiere los siguientes elementos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Definir una <strong>ventana de tiempo</strong> o <strong>cuanto</strong>, generalmente entre 10 y 100 ms.</p>
</li>
<li>
<p>Definir la <strong>cola de preparados</strong> como una cola circular, dÃ³nde el planificador asigna la CPU a cada proceso en intervalos de tiempo de hasta un <strong>cuanto</strong>, como mÃ¡ximo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Cuando un proceso estÃ¡ en la CPU pueden darse diversos casos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Que la rÃ¡faga de CPU sea menor que un cuanto.
Entonces el proceso liberarÃ¡ la CPU voluntariamente, al terminar la rÃ¡faga.</p>
</li>
<li>
<p>Que la rÃ¡faga de CPU sea mayor que un cuanto.
El temporizador interrumpirÃ¡ el proceso al terminar el cuanto e informarÃ¡ al sistema operativo.
Ãste harÃ¡ el cambio de contexto para asignar la CPU al siguiente proceso y el que abandona la CPU es insertado al final de la <strong>cola de preparados</strong>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Este algoritmo es <strong>expropiativo</strong> puesto que los procesos son expropiados por la interrupciÃ³n del temporizador.
Como se puede intuir, originalmente fue diseÃ±ado para los <strong>sistemas de tiempo compartido</strong>, para repartir la CPU por igual entre los procesos de los usuarios del sistema.</p>
</div>
<div class="paragraph">
<p>Ilustremos el algoritmo con un ejemplo con cuanto de 4 ms.:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Proceso</th>
<th class="tableblock halign-center valign-top">Tiempo de llegada (ms.)</th>
<th class="tableblock halign-center valign-top">Tiempo de rÃ¡faga de CPU (ms.)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">24</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>El resultado es el que se muestra en el siguiente diagrama de Gantt:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="C14-planificaciÃ³n_de_CPU/media/rr.svg" alt="rr">
</div>
</div>
<div class="paragraph">
<p>Y los <strong>tiempos de espera y ejecuciÃ³n promedio</strong> correspondientes serÃ­an:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2858%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Proceso</th>
<th class="tableblock halign-center valign-top">Instante de finalizaciÃ³n (ms.)</th>
<th class="tableblock halign-center valign-top" colspan="2">Tiempo de espera (ms.)</th>
<th class="tableblock halign-center valign-top" colspan="2">Tiempo de ejecuciÃ³n (ms.)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">30</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(0-0) + (10-4)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(30-0)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">24</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(4-1)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(7-1)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">P3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(7-2)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><span class="lightcell">(10-2)=</span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Tiempos promedio (ms.)</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4,67</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">12,67</p></td>
</tr>
</tfoot>
</table>
<div class="sect4">
<h5 id="_rendimiento_2">Rendimiento</h5>
<div class="paragraph">
<p>Cuando se utilizar la planificaciÃ³n <strong>RR</strong> el tamaÃ±o del cuanto es un factor clave en la eficiencia del planificador:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cuando se reduce el <strong>cuanto</strong>, el <strong>tiempo de respuesta</strong> y el <strong>tiempo de espera promedio</strong> tienden a mejorar.
Sin embargo el nÃºmero de cambios de contexto serÃ¡ mayor, por lo que la ejecuciÃ³n de los procesos serÃ¡ mas lenta.</p>
<div class="paragraph">
<p>Es importante tener en cuenta que interesa que el <strong>cuanto</strong> sea mucho mayor que el tiempo del cambio de contexto.
Si, por ejemplo, el tiempo de cambio de contexto es un 10% del <strong>cuanto</strong>, entonces alrededor del 10% del tiempo de CPU se pierde en cambios de contexto.</p>
</div>
</li>
<li>
<p>Cuando se incrementa el <strong>cuanto</strong>, el <strong>tiempo de espera promedio</strong> tambiÃ©n se incrementa.
En el caso extremo en el que el <strong>cuanto</strong> es tan grande que ningÃºn proceso lo agota, el <strong>RR</strong> se convierte en <strong>FCFS</strong>, que suele tener grandes <strong>tiempos de espera promedio</strong>.</p>
<div class="paragraph">
<p>Por otro lado, puede observarse experimentalmente que el <strong>tiempo de ejecuciÃ³n promedio</strong> generalmente mejora cuantos mÃ¡s procesos terminan su prÃ³xima rÃ¡faga de CPU dentro de su <strong>cuanto</strong>.
Por lo tanto, nos interesa un cuanto grande para que mÃ¡s procesos terminen su siguiente rÃ¡faga dentro del mismo.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Dados tres procesos con una duraciÃ³n cada uno de ellos de 10 unidades de tiempo y cuanto igual a 1, el tiempo de ejecuciÃ³n promedio serÃ¡ de 29 unidades.
Sin embargo, si el cuanto de tiempo fuera 10, el tiempo de ejecuciÃ³n promedio caerÃ­a a 20 unidades de tiempo.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>La regla general que siguen los diseÃ±adores es intentar que el 80% de las rÃ¡fagas de CPU sean menores que el tiempo de <strong>cuanto</strong>.
Se busca asÃ­ equilibrar los criterios anteriores, evitando que el tiempo de cuanto sea demasiado grande o demasiado corto.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Actualmente se utilizan tiempos de cuanto de entre 10 y 100 ms.
Estos tiempos son mucho mayores que los tiempos de cambios de contexto, que generalmente son inferiores a 10Âµs.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_reparto_equitativo_del_tiempo_de_cpu">Reparto equitativo del tiempo de CPU</h5>
<div class="paragraph">
<p>Uno de los inconvenientes del algoritmo <strong>RR</strong> es que no garantiza el reparto equitativo del tiempo de
CPU entre los procesos limitados por la E/S y los limitados por la CPU âaunque es mejor que <strong>FCFS</strong>â.</p>
</div>
<div class="paragraph">
<p>Esto es debido a que los primeros utilizan el procesador durante periodos cortos de tiempo, para bloquearse posteriormente a la espera de que se realice la operaciÃ³n de E/S que han solicitado.
Cuando la espera termina, vuelven a la <strong>cola de preparados</strong> donde aguardan a que se les asigne la CPU.
Sin embargo, eso no va a ocurrir rÃ¡pidamente si en el sistema hay procesos limitados por la CPU, pues estos generalmente agotan el <strong>cuanto</strong> antes de ser forzados a volver a la <strong>cola de preparados</strong>.</p>
</div>
<div class="paragraph">
<p>AsÃ­, los procesos limitados por la CPU hacen un mayor uso de la misma, mientras que los limitados por la E/S pueden tener que esperar durante bastante tiempo âaunque menos que si el algoritmo fuera <strong>FCFS</strong>, donde no hay <strong>cuanto</strong>â en la <strong>cola de preparados</strong> antes entrar en la CPU para solicitar una nueva operaciÃ³n de E/S.
Esto hace que se desaprovechen los dispositivos de E/S y genera un incremento de la varianza del tiempo de respuesta.
Para evitarlo se puede optar por un <strong>planificador de colas multinivel</strong> âpara resolver el problema combinando el algoritmo <strong>RR</strong> con otro que priorice adecuadamente los procesos limitados por la E/S (vÃ©ase el <a href="#_planificaciÃ³n_con_colas_multinivel">Apartado 14.5.7</a>)â o por la <strong>planificaciÃ³n equitativa</strong> que veremos a continuaciÃ³n.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_planificaciÃ³n_equitativa">14.5.6. PlanificaciÃ³n equitativa</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Hasta el momento hemos hablado de planificadores que se centran en cuÃ¡l es el proceso mÃ¡s importante para ejecutarlo a continuaciÃ³n.
Sin embargo otra opciÃ³n, desde el punto de vista de la planificaciÃ³n, es dividir directamente el tiempo de CPU entre los procesos.
Esto es precisamente lo que hace la <strong>planificaciÃ³n equitativa</strong> (<em>Fair Scheduling</em>) que intenta repartir por igual el tiempo de CPU entre los procesos de la cola de preparados.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, si 4 procesos compitieran por el uso de la CPU, el planificador asignarÃ­a un 25% del tiempo de la misma a cada uno.
Si a continuaciÃ³n un usuario iniciase un nuevo proceso, el planificador tendrÃ­a que ajustar el reparto asignando un 20% del tiempo a cada uno, ya que ahora habrÃ­an 5 procesos compitiendo por el tiempo de CPU.</p>
</div>
<div class="paragraph">
<p>El algoritmo de planificaciÃ³n equitativa es muy similar al algoritmo <strong>RR</strong>. Pero, mientras que en este Ãºltimo se utiliza un cuanto de tamaÃ±o fijo, en la planificaciÃ³n equitativa la ventana de tiempo se calcula de dinÃ¡micamente para garantizar el reparto equitativo de la CPU.</p>
</div>
<div class="paragraph">
<p>Al igual que en los algoritmos anteriores, en ocasiones puede ser interesante priorizar unos procesos frente a otros, tanto por motivos ajenos al sistema operativo como por motivos internos.
Por ejemplo, se puede querer favorecer a los procesos limitados por la E/S para mejorar la eficiencia del sistema, tal y como comentamos en el apartado <a href="#_ciclo_de_rÃ¡fagas_de_cpu_y_de_es">Apartado 14.4</a>.
La <strong>planificaciÃ³n equitativa</strong> resuelve este problema permitiendo que a los procesos se les asignen pesos y repartiendo proporcionalmente mÃ¡s tiempo de CPU a los procesos con mayor peso.
A esta generalizaciÃ³n del planificador equitativo se la conoce como <strong>planificador equitativo ponderado</strong>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Desde la versiÃ³n 2.6.23 de Linux se utiliza un tipo de <strong>planificador equitativo ponderado</strong> denominado <strong>CFS</strong> (<em>Completely Fair Scheduler</em>) o <strong>planificador completamente equitativo</strong>.
Otro ejemplo es Zircon, el <em>microkernel</em> de <a href="https://es.wikipedia.org/wiki/Google_Fuchsia">Google Fuchsia</a>, que estÃ¡ inmerso en migrar a una implementaciÃ³n de  <strong>planificador equitativo ponderado</strong>.</p>
</div>
<div class="paragraph">
<p>Para mÃ¡s informaciÃ³n vÃ©ase <a href="https://developer.ibm.com/technologies/linux/tutorials/l-completely-fair-scheduler/">Â«Inside the Linux 2.6 Completely Fair Schedule&#8201;&#8212;&#8201;IBM DeveloperÂ»</a> y <a href="https://fuchsia.dev/fuchsia-src/concepts/kernel/fair_scheduler">Â«Zircon Fair Scheduler&#8201;&#8212;&#8201;Fuchsia ProjectÂ»</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Si durante un periodo de tiempo \$T\$, un proceso \$P_i\$ tiene peso \$w_i\$, a ese proceso le corresponde un tiempo de CPU \$t_i\$:</p>
</div>
<div class="stemblock">
<div class="content">
\$t_i = w_i/W T\$
</div>
</div>
<div class="paragraph">
<p>donde \$W\$ es la suma de los pesos de todos los procesos en la <strong>cola de preparados</strong> durante \$T\$.</p>
</div>
</div>
<div class="sect3">
<h4 id="_planificaciÃ³n_con_colas_multinivel">14.5.7. PlanificaciÃ³n con colas multinivel</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Los diseÃ±adores recurren a la <strong>planificaciÃ³n de colas multinivel</strong> cuando quieren combinar las caracterÃ­sticas de varios algoritmos.</p>
</div>
<div class="paragraph">
<p>En la planificaciÃ³n con colas multinivel se divide la cola de preparados en colas separadas.
Los procesos son asignados permanentemente a alguna de dichas colas, cada una de las cuales puede
tener un algoritmo de planificaciÃ³n distinto.</p>
</div>
<div class="paragraph">
<p>La asignaciÃ³n de un proceso a una cola se hace en base a alguna una caracterÃ­stica del proceso.
Por ejemplo, si es interactivo o no, su prioridad o su tamaÃ±o en memoria.
Se hace de esta manera porque se supone que los procesos se pueden clasificar, y que cada clase tiene diferentes requerimientos.
Por ejemplo, si los procesos se clasifican en interactivos o no interactivos, los primeros puede ir a una cola con planificaciÃ³n <strong>RR</strong> mientras los segundos van a una con <strong>FCFS</strong>.</p>
</div>
<div id="esquema_colas_multinivel" class="imageblock">
<div class="content">
<img src="C14-planificaciÃ³n_de_CPU/media/planificaciÃ³n_colas_multinivel.svg" alt="planificaciÃ³n colas multinivel">
</div>
<div class="title">Figura 37. Ejemplo de planificaciÃ³n con colas multinivel.</div>
</div>
<div class="paragraph">
<p>Una cuestiÃ³n interesante es como seleccionar la cola que debe escoger al siguiente proceso a ejecutar:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Un opciÃ³n comÃºn en los sistemas actuales es utilizar un <strong>planificador con prioridades</strong>.
Es decir, que cada cola tenga una prioridad y asÃ­ el planificador solo tiene que escoger la cola de prioridad mÃ¡s alta que no estÃ© vacÃ­a.</p>
<div class="paragraph">
<p>Por ejemplo, en la <a href="#esquema_colas_multinivel">Figura 37</a>, mientras un proceso de prioridad 1 estÃ© preparado, no se escoge ningÃºn otro de prioridad inferior.
Si este planificador se implementa de forma expropiativa, el proceso que tiene asignada la CPU es expulsado si un proceso entra en una de las colas que tiene mayor prioridad que la suya.</p>
</div>
</li>
<li>
<p>Otra opciÃ³n es usar cuantos sobre las colas.
Es decir, que a cada cola se le asigne una porciÃ³n del tiempo de la CPU que debe repartirse entre los distintos procesos en la misma.</p>
<div class="paragraph">
<p>Por ejemplo, un 80% de CPU para la cola de procesos interactivos, con planificaciÃ³n <strong>RR</strong>, y el 20% de CPU restante para la cola de procesos no interactivos, con planificador <strong>FCFS</strong>.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>La <strong>planificaciÃ³n de colas multinivel</strong> con una <strong>planificador con prioridades</strong> para escoger la cola adecuada, es con diferencia la opciÃ³n mÃ¡s comÃºn en lo sistemas operativos modernos.
Sin embargo, en este tipo de <strong>colas multinivel</strong> la asignaciÃ³n de los procesos a las colas es permanente âsi la asignaciÃ³n se hace por prioridad, significa que la prioridad es fijaâ.
Mientras que hoy en dÃ­a es comÃºn que los procesos se muevan entre colas segÃºn las caracterÃ­sticas del proceso.</p>
</div>
</div>
<div class="sect3">
<h4 id="_planificaciÃ³n_con_colas_multinivel_realimentadas">14.5.8. PlanificaciÃ³n con colas multinivel realimentadas</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Para aumentar la flexibilidad de la planificaciÃ³n con colas multinivel se puede permitir a los procesos pasar de una cola a otra.
AsÃ­ se pueden clasificar en colas distintas procesos con diferente tiempos de rÃ¡faga de CPU.
Por ejemplo, para situar los procesos interactivos o limitados por la E/S en las colas de mÃ¡s alta prioridad, lo que ya hemos discutido que mejora los tiempos de espera y de respuesta y evita el <strong>efecto convoy</strong>.</p>
</div>
<div id="esquema_planificaciÃ³n_colas_multinivel_realimentadas" class="imageblock">
<div class="content">
<img src="C14-planificaciÃ³n_de_CPU/media/planificaciÃ³n_colas_multinivel_realimentadas.svg" alt="planificaciÃ³n colas multinivel realimentadas">
</div>
<div class="title">Figura 38. Ejemplo de planificaciÃ³n con colas multinivel realimentadas.</div>
</div>
<div class="paragraph">
<p>Por ejemplo, supongamos un <strong>planificador de colas multinivel</strong> donde cada cola tiene una prioridad, asÃ­ que se usa la <strong>planificaciÃ³n con prioridades</strong> para seleccionar la cola.
En las colas se usa el algoritmo <strong>RR</strong> para seleccionar el siguiente proceso, siendo el <strong>cuanto</strong> de la cola mayor cuanto menos prioritaria es la cola (vÃ©ase la <a href="#esquema_planificaciÃ³n_colas_multinivel_realimentadas">Figura 38</a>).
Los procesos que llegan nuevos o desde el estado <strong>esperando</strong> lo hacen con la prioridad mÃ¡s alta âque por convenciÃ³n hemos decidido que sea 0â asÃ­ que se insertan en la cola correspondiente.
Mientras que los procesos expropiados por vencimiento del <strong>cuanto</strong> pierde un punto de prioridad, siendo insertados en una cola de prioridad menor.</p>
</div>
<div class="paragraph">
<p>Con ese algoritmo los procesos limitados por E/S suelen ejecutarse la mayor parte del tiempo con prioridades mÃ¡s altas que los limitados por CPU.
Por ejemplo, usando los valores del esquema de la <a href="#esquema_planificaciÃ³n_colas_multinivel_realimentadas">Figura 38</a>, los procesos de rÃ¡fagas de CPU entre 20 y 80 ms. acaban cayendo a la cola de prioridad 1 tras 20 ms. de ejecuciÃ³n.
AsÃ­ dejan paso a los procesos con rÃ¡fagas menores de 20 ms., que siempre se ejecutan con prioridad 0.
Finalmente, los procesos de rÃ¡fagas mayores de 80 ms. van a la cola FCFS, desde donde sÃ³lo tendrÃ¡n acceso a la CPU cuando no haya ningÃºn proceso de los otros tipos en la <strong>cola de preparados</strong></p>
</div>
<div class="paragraph">
<p>La <strong>planificador de colas multinivel realimentadas</strong> tambiÃ©n se puede utilizar para pasar a colas superiores los procesos que han esperado mucho tiempo en colas inferiores, evitando la <strong>muerte por inaniciÃ³n</strong>, que puede afecta a los sistemas de <strong>planificaciÃ³n de colas multinivel</strong> con <strong>prioridad fija</strong>.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, el algoritmo <strong>RR virtual</strong> es un caso de <strong>planificador de colas multinivel realimentadas</strong> que resuelve los problemas del <strong>RR</strong>, en cuanto al reparto de la CPU entre procesos limitados por la E/S y limitados por la CPU (vÃ©ase el <a href="#_reparto_equitativo_del_tiempo_de_cpu">Apartado 14.5.5.2</a>).</p>
</div>
<div id="esquema_planificaciÃ³n_rr_virtual" class="imageblock">
<div class="content">
<img src="C14-planificaciÃ³n_de_CPU/media/vrr.svg" alt="vrr">
</div>
<div class="title">Figura 39. Ejemplo de planificaciÃ³n con RR virtual.</div>
</div>
<div class="paragraph">
<p>Tal y como se ilustra en la <a href="#esquema_planificaciÃ³n_rr_virtual">Figura 39</a>, en el <strong>RR virtual</strong> los procesos por lo general tienen prioridad 1.
Sin embargo, aquellos que vuelven al estado <strong>preparado</strong> desde <strong>esperando</strong> despuÃ©s de una operaciÃ³n de E/S, obtienen una bonificaciÃ³n en la propiedad que los lleva a tener prioridad 0.
Por tanto, los procesos que usan con mÃ¡s frecuencia la E/S, usan mÃ¡s la cola de prioridad mÃ¡s alta, por lo que se les asigna antes la CPU mayor frecuencia.</p>
</div>
<div class="paragraph">
<p>Esta soluciÃ³n puede llevar a que si hay muchos procesos limitados por la E/S, Ã©stos acaparen la CPU y no den oportunidad de ejecutarse a los procesos en la cola de prioridad 1.
Para evitarlo, el algoritmo <strong>RR</strong> de la cola de prioridad 0 tiene un <strong>cuanto</strong> variable, de tal forma que cada proceso recibe lo que le queda del <strong>cuanto</strong> de la cola de prioridad 1 tras haber consumido parte en la CPU en la rÃ¡faga anterior.
Esto hace que incluso los procesos con rÃ¡fagas de CPU mÃ¡s cortas acaben consumiendo su <strong>cuanto</strong> en la cola de prioridad 0 y terminen cayendo a la cola de prioridad 1, dando oportunidad de ejecutarse a otros procesos.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">PlanificaciÃ³n en Microsoft Windows</div>
<div class="paragraph">
<p>Para ilustrar los visto hasta el momento sobre la planificaciÃ³n de la CPU en sistemas operativos modernos, vamos a comentar las principales caracterÃ­sticas de las Ãºltimas versiones de Microsoft Windows a este respecto.</p>
</div>
<div class="paragraph">
<p>Las actuales versiones de sistemas operativos Windows pertenecen a la familia de Microsoft Windows NT; que naciÃ³ con el sistema operativo Windows NT 3.1 en 1993 y que llega hasta hoy en dÃ­a con Microsoft Windows 10 y Windows Server 2019 âque se corresponden con la versiÃ³n 10.0 de dicha familia Windows NTâ</p>
</div>
<div class="paragraph">
<p>El nÃºcleo de la familia Windows NT es multihilo e internamente implementa un algoritmo de planificaciÃ³n expropiativa con colas multinivel realimentadas basado en prioridades.</p>
</div>
<div class="paragraph">
<p>En Windows las prioridades de los hilos se pueden ver desde dos perspectivas: la de Windows API y la del nÃºcleo.
Ambas tienen una organizaciÃ³n muy diferente pero, en Ãºltima instancia, las primeras deben traducirse en las segundas.</p>
</div>
<table id="win32_clases_prioridad" class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 10. Clases de prioridad en Windows API.</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Clase</th>
<th class="tableblock halign-center valign-top">Valor</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">REALTIME_PRIORITY_CLASS</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0x00000100</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">HIGH_PRIORITY_CLASS</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0x00000080</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">ABOVE_NORMAL_PRIORITY_CLASS</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0x00008000</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">NORMAL_PRIORITY_CLASS</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0x00000020</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">BELOW_NORMAL_PRIORITY_CLASS</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0x00004000</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">IDLE_PRIORITY_CLASS</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0x00000040</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Desde el punto de vista de Windows API, todo proceso pertenece a alguna de las 6 clases de prioridad de la <a href="#win32_clases_prioridad">Tabla 10</a>.
La clase de prioridad de un proceso se puede indicar durante la creaciÃ³n del proceso, a travÃ©s del argumento <code>dwCreationFlags</code> de la funciÃ³n <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a>, o sea puede obtener y cambiar con las funciones <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getpriorityclass">GetPriorityClass()</a> y <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setpriorityclass">SetPriorityClass()</a>, respectivamente.
Por lo general, la clase de prioridad <code>NORMAL_PRIORITY_CLASS</code> es la clase por defecto de cualquier proceso nuevo, excepto que se indique otra cosa durante su creaciÃ³n.</p>
</div>
<div id="windows_task_manager" class="imageblock">
<div class="content">
<img src="C14-planificaciÃ³n_de_CPU/media/administrador_de_tareas.jpg" alt="administrador de tareas">
</div>
<div class="title">Figura 40. Cambiar la prioridad de un proceso en el <strong>Administrador de tareas</strong>.</div>
</div>
<div class="paragraph">
<p>Con el <strong>Administrador de tareas</strong> de Windows podemos alterar fÃ¡cilmente la clase de prioridad de un proceso durante su ejecuciÃ³n (vÃ©ase la <a href="#windows_task_manager">Figura 40</a>).</p>
</div>
<table id="win32_prioridad_hilos" class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 11. Clases de prioridad en Windows API.</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Prioridad</th>
<th class="tableblock halign-center valign-top">Valor</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">THREAD_PRIORITY_TIME_CRITICAL</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">15</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">THREAD_PRIORITY_HIGHEST</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">THREAD_PRIORITY_ABOVE_NORMAL</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">THREAD_PRIORITY_NORMAL</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">THREAD_PRIORITY_BELOW_NORMAL</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">THREAD_PRIORITY_LOWEST</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-2</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">THREAD_PRIORITY_IDLE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">15</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Al mismo tiempo, cada hilo del sistema tiene alguno de las prioridades de la <a href="#win32_prioridad_hilos">Tabla 11</a>.
La prioridad de un hilo reciÃ©n creado es <code>THREAD_PRIORITY_NORMAL</code>, pero se puede cambiar
usando la funciÃ³n <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadpriority">SetThreadPriority()</a>.</p>
</div>
<div class="paragraph">
<p>El nÃºcleo de Windows tiene 32 prioridades, siendo 31 la prioridad mÃ¡s alta y 0 la mÃ¡s baja.
Estos valores se dividen en dos rangos.
El rango de prioridades de tiempo real va de 16 a 31 y solo estÃ¡ disponible para hilos en procesos en la clase de prioridad <code>REALTIME_PRIORITY_CLASS</code>.
Mientras que el rango de prioridades dinÃ¡micas va de 1 a 15.
El nivel 0 estÃ¡ reservado para el sistema y se usa para una rutina especializada en limpiar zonas de memoria liberada por los procesos, poniÃ©ndolas a 0.</p>
</div>
<div class="paragraph">
<p>La prioridad base âo prioridad estÃ¡ticaâ de cada hilo que ve el nÃºcleo se calcula combinando la prioridad del hilo y la clase de prioridad del proceso al que pertenece.</p>
</div>
<table id="win32_prioridad_estÃ¡tica" class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 12. Clases de prioridad base en Windows API.</caption>
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2858%;">
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-center valign-top"></th>
<th class="tableblock halign-center valign-top" colspan="6"><p class="tableblock">Clase de prioridad del proceso</p></th>
</tr>
<tr>
<th class="tableblock halign-center valign-top"></th>
<th class="tableblock halign-center valign-top"><p class="tableblock">REALTIME</p></th>
<th class="tableblock halign-center valign-top"><p class="tableblock">HIGH</p></th>
<th class="tableblock halign-center valign-top"><p class="tableblock">ABOVE NORMAL</p></th>
<th class="tableblock halign-center valign-top"><p class="tableblock">NORMAL</p></th>
<th class="tableblock halign-center valign-top"><p class="tableblock">BELOW NORMAL</p></th>
<th class="tableblock halign-center valign-top"><p class="tableblock">IDLE</p></th>
</tr>
<tr>
<th class="tableblock halign-center valign-top"><p class="tableblock">TIME CRITICAL</p></th>
<td class="tableblock halign-center valign-top"><p class="tableblock">31</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">15</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">15</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">15</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">15</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">15</p></td>
</tr>
<tr>
<th class="tableblock halign-center valign-top"><p class="tableblock">HIGHEST</p></th>
<td class="tableblock halign-center valign-top"><p class="tableblock">26</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">15</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">12</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
</tr>
<tr>
<th class="tableblock halign-center valign-top"><p class="tableblock">ABOVE NORMAL</p></th>
<td class="tableblock halign-center valign-top"><p class="tableblock">25</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">15</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">11</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
</tr>
<tr>
<th class="tableblock halign-center valign-top"><p class="tableblock">NORMAL</p></th>
<td class="tableblock halign-center valign-top"><p class="tableblock">24</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
</tr>
<tr>
<th class="tableblock halign-center valign-top"><p class="tableblock">BELOW NORMAL</p></th>
<td class="tableblock halign-center valign-top"><p class="tableblock">23</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">12</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
</tr>
<tr>
<th class="tableblock halign-center valign-top"><p class="tableblock">LOWEST</p></th>
<td class="tableblock halign-center valign-top"><p class="tableblock">22</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">11</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
</tr>
<tr>
<th class="tableblock halign-center valign-top"><p class="tableblock">IDLE</p></th>
<td class="tableblock halign-center valign-top"><p class="tableblock">16</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Esta prioridad base es la prioridad real del hilo, si Ã©ste tiene una prioridad en el rango de tiempo real âes decir, si el proceso al que pertenece estÃ¡ en la clase de prioridad <code>REALTIME_PRIORITY_CLASS</code>â.
Mientras que para el resto de hilos, el sistema suma ciertas bonificaciones a la prioridad base para calcular la prioridad dinÃ¡mica, que es con la que realmente serÃ¡ planificado el hilo.
Estas bonificaciones se truncan para que nuncan puedan hacer que el hilo se meta en el rango de tiempo real.</p>
</div>
<div class="paragraph">
<p>La prioridad real la usa el sistema para determinar a quÃ© cola va el hilo cuando va a ser insertado en la <strong>cola de preparados</strong>.
Para cada nivel de prioridad hay una cola con algoritmo <strong>RR</strong>, de tal forma que el planificador escoge primero a los hilos con prioridad mÃ¡s alta. Dentro de la misma prioridad la CPU se asigna en turno, dÃ¡ndoles un <strong>cuanto</strong> de tiempo de CPU.</p>
</div>
<div class="paragraph">
<p>Cuando llega un hilo a la cola de preparados, expropia la CPU al hilo que la tiene asignada si Ã©ste tiene menor prioridad.
Esto puede ocurrir incluso si el hilo a expropiar estÃ¡ en medio de una llamada al sistema ya que, como cualquier sistema operativo moderno, el nÃºcleo de Windows es expropiable âlo que veremos en el <a href="#_nÃºcleo_expropiable">Apartado 14.6.4.2</a> que ofrece latencias de asignaciÃ³n mÃ¡s bajas que si no lo fueraâ.</p>
</div>
<div class="paragraph">
<p>Respecto al <strong>cuanto</strong>, desde Windows Vista âNT 6.0â no se usa el temporizador para controlarlo sino el contador de ciclos de reloj de la CPU.
AsÃ­ el sistema puede determinar con precisiÃ³n el tiempo que se ha estado ejecutando un hilo, excluyendo los tiempos dedicados a otras cuestiones, como por ejemplo a manejar interrupciones.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Desde el Intel Pentium las CPU de la familia x86 incorporan un contador de marca de tiempo (<em>Time Stamp Counter</em> o TSC) de 64 bits que indica el nÃºmero de ciclos transcurridos desde el Ãºltimo reinicio del procesador.</p>
</div>
<div class="paragraph">
<p>Para mÃ¡s informaciÃ³n vÃ©ase <a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">Â«Time Stamp Counter&#8201;&#8212;&#8201;WikipediaÂ»</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Una caracterÃ­stica curiosa, es que los hilos expropiados se insertan en la cabeza de su cola âno en el finalâ y conservan lo que les queda de <strong>cuanto</strong>.
Mientras que se insertan por el final con el valor de <strong>cuanto</strong> reiniciado cuando abandonan la CPU por haber agotado el cuanto anterior.
Estos Ãºltimos, ademÃ¡s, pierden un nivel de prioridad si se ejecutaban con una prioridad superior a su prioridad base, a causa de alguna modificaciÃ³n.</p>
</div>
<div class="paragraph">
<p>Los bonificaciones a los hilos en el rango de prioridades dinÃ¡micas vienen determinadas por distintos criterios, escogidos para mejorar el <strong>tiempo respuesta</strong> y el <strong>tiempo de espera</strong> âpriorizando los procesos limitados por E/Sâ, evitar la <strong>muerte por inaniciÃ³n</strong> y la <strong>inversiÃ³n de prioridad</strong>.</p>
</div>
<div class="paragraph">
<p>Se bonifican los hilos que despiertan tras completar operaciones de E/S con una cantidad que depende del tipo de dispositivo.
Por ejemplo, la bonificaciÃ³n es mejor para hilos que han esperado por el teclado o el ratÃ³n que para los que esperaron por dispositivos del almacenamiento.
TambiÃ©n son bonificados los hilos que despierta de eventos, semÃ¡foros y de otros objetos de sincronizaciÃ³n.
En este Ãºltimo caso, incluso se les ofrece mÃ¡s tiempo de <strong>cuanto</strong> si es el hilo asociado a la ventana de primer plano, con el objetivo de mejorar la respuesta de las aplicaciones interactivas.
TambiÃ©n se bonifica cualquier hilo que gestione elementos de la interfaz grafica cuando despierta para responder a eventos del sistema de ventanas.</p>
</div>
<div class="paragraph">
<p>Para evitar la <strong>muerte por inaniciÃ³n</strong>, el planificador escoge cada segundo unos pocos hilos que lleven esperando aproximadamente 4 segundos, les triplica el <strong>cuanto</strong> y les aumenta la prioridad a 15.
Estos hilos recuperan su prioridad base y el cuanto anterior cuando agotan el tiempo de cuanto actual o son expropiados de la CPU</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_planificaciÃ³n_de_tiempo_real">14.6. PlanificaciÃ³n de tiempo real</h3>
<div class="paragraph">
<p>En el <a href="#_sistemas_de_tiempo_real">Apartado 2.7</a> discutimos la importancia de los sistemas de tiempo real.
A continuaciÃ³n, describiremos las funcionalidades necesarias para soportar la ejecuciÃ³n de procesos en tiempo real dentro de un sistema operativo de propÃ³sito general.</p>
</div>
<div class="sect3">
<h4 id="_tiempo_real_estricto">14.6.1. Tiempo real estricto</h4>
<div class="paragraph">
<p>

</p>
</div>
<div class="paragraph">
<p>Los sistemas de <strong>tiempo real estricto</strong> son necesarios para realizar tareas crÃ­ticas que deben ser completadas dentro de unos mÃ¡rgenes de tiempo preestablecidos.</p>
</div>
<div class="paragraph">
<p>Generalmente las tareas son entregas al sistema operativo junto con una declaraciÃ³n de las restricciones de tiempo âperiodicidad y lÃ­mite de tiempoâ y la cantidad de tiempo que necesitan para ejecutarse.
El planificador sÃ³lo admitirÃ¡ las tareas si puede garantizar el cumplimiento de las restricciones de tiempo, rechazÃ¡ndolas en caso contrario.</p>
</div>
<div class="paragraph">
<p>El ofrecer estas garantÃ­as requiere que el planificador conozca exactamente el tiempo mÃ¡ximo que se tarda en realizar todas y cada una de las funciones del sistema operativo.
Esto es imposible en sistemas con almacenamiento secundario o memoria virtual, ya que introducen variaciones no controladas en la cantidad de tiempo necesario para ejecutar una tarea.
Por tanto, el <strong>tiempo real estricto</strong> no es compatible con los sistemas operativos de propÃ³sito general, como los sistemas operativos de escritorio modernos.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tiempo_real_flexible">14.6.2. Tiempo real flexible</h4>
<div class="paragraph">
<p>

</p>
</div>
<div class="paragraph">
<p>La ejecuciÃ³n de procesos de <strong>tiempo real flexible</strong> es menos restrictiva.
Tan sÃ³lo requiere que los procesos crÃ­ticos reciban mayor prioridad que los que no lo son.
Esto puede generar excesos en la cantidad de recursos asignados a los procesos de tiempo real, asÃ­ como inaniciÃ³n y grandes retardos en la ejecuciÃ³n del resto de los procesos, pero es compatible con los sistemas de propÃ³sito general.</p>
</div>
<div class="paragraph">
<p>AdemÃ¡s nos permite conseguir sistemas de propÃ³sito general que soporten multimedia, videojuegos y otras tareas que no funcionarÃ­an de manera aceptable en un entorno que no implementara tiempo real flexible.
Por ello, la mayor parte de los sistemas operativos modernos soportan este tipo de tiempo real.</p>
</div>
</div>
<div class="sect3">
<h4 id="_implementaciÃ³n_del_soporte_de_tiempo_real">14.6.3. ImplementaciÃ³n del soporte de tiempo real</h4>
<div class="paragraph">
<p>Implementar el soporte de tiempo real flexible en un sistema operativo de propÃ³sito general requiere:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Sistema operativo con planificaciÃ³n con prioridades</strong>.
Los procesos de tiempo real deben tener la mayor prioridad y ser fija.
Es decir, no deben ser afectados por ningÃºn mecanismo de envejecimiento o bonificaciÃ³n, que pueda usarse con los procesos de tiempo no real.</p>
</li>
<li>
<p><strong>Baja latencia de asignaciÃ³n</strong>.
Cuanto menor es la latencia, mÃ¡s rÃ¡pido comenzarÃ¡ a ejecutarse el proceso de tiempo real despuÃ©s de ser seleccionado por el planificador de la CPU.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Mientras que el primer requerimiento es bastante sencillo de conseguir, el segundo es mucho mÃ¡s complejo.</p>
</div>
</div>
<div class="sect3">
<h4 id="_reducir_la_latencia_de_asignaciÃ³n">14.6.4. Reducir la latencia de asignaciÃ³n</h4>
<div class="paragraph">
<p>Muchos sistemas operativos tienen un nÃºcleo no expropiable.
Estos nÃºcleos no pueden realizar un cambio de contexto mientras se estÃ¡ ejecutando cÃ³digo del nÃºcleo âpor ejemplo, debido a una llamada al sistemaâ por lo que se ven obligados a esperar hasta que la operaciÃ³n que se estÃ© realizando termine, antes de asignar la CPU a otro proceso.
Esto aumenta la <strong>latencia de asignaciÃ³n</strong>, dado que algunas llamadas al sistema pueden ser muy
complejas y requerir mucho tiempo para completarse.</p>
</div>
<div class="paragraph">
<p>Con el objetivo de resolver este problema se han desarrollado diversas alternativas para que el cÃ³digo del nÃºcleo sea expropiable.</p>
</div>
<div class="sect4">
<h5 id="_puntos_de_expropiaciÃ³n">Puntos de expropiaciÃ³n</h5>
<div class="paragraph">
<p>Una posibilidad es introduciendo <strong>puntos de expropiaciÃ³n</strong> en diversos lugares Â«segurosÂ» dentro del cÃ³digo.
En dichos puntos se comprueba si algÃºn proceso de prioridad mÃ¡s alta estÃ¡ en la cola de preparados.
En caso de que sea asÃ­, se expropia la CPU al proceso actual y se le asigna al proceso de mÃ¡s alta prioridad.</p>
</div>
<div class="paragraph">
<p>Debido a la funciÃ³n que realizan los puntos de expropiaciÃ³n, sÃ³lo pueden ser colocados en lugares seguros del cÃ³digo del nÃºcleo.
Es decir, lugares donde no se interrumpe la modificaciÃ³n de estructuras de datos.
Sin embargo, esto limita el nÃºmero de puntos que pueden ser colocados, por lo que la latencia de asignaciÃ³n puede seguir siendo muy alta para algunas operaciones muy complejas del nÃºcleo.</p>
</div>
</div>
<div class="sect4">
<h5 id="_nÃºcleo_expropiable">NÃºcleo expropiable</h5>
<div class="paragraph">
<p>Otra posibilidad es diseÃ±ar un <strong>nÃºcleo completamente expropiable</strong>.</p>
</div>
<div class="paragraph">
<p>Puesto que en este caso la ejecuciÃ³n de cualquier operaciÃ³n en el nÃºcleo puede ser interrumpida en cualquier momento por procesos de mayor prioridad que el que actualmente tiene asignada la CPU, es necesario proteger las estructuras de datos del nÃºcleo con mecanismos de sincronizaciÃ³n.
Esto hace que el diseÃ±o de un nÃºcleo de estas caracterÃ­sticas sea mucho mÃ¡s complejo.</p>
</div>
<div class="paragraph">
<p>Microsoft Windows âdesde Windows NTâ, Linux âdesde la versiÃ³n 2.6â, <a href="https://es.wikipedia.org/wiki/Solaris_(sistema_operativo)">Solaris</a> y <a href="https://es.wikipedia.org/wiki/NetBSD">NetBSD</a> son algunos ejemplos de sistemas operativos con nÃºcleos expropiables.
En el caso concreto de Solaris la latencia de asignaciÃ³n es inferior a 1 ms., mientras que con la expropiaciÃ³n del nÃºcleo desactivada Ã©sta puede superar los 100 ms.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">ExpropiaciÃ³n en el nÃºcleo de Linux</div>
<div class="paragraph">
<p>Lamentablemente, conseguir baja latencia de asignaciÃ³n no tiene coste cero.
El hecho de que el nÃºcleo sea expropiable aumenta el nÃºmero de cambios de contexto, lo que reduce el rendimiento del sistema a cambio de un menor tiempo de respuesta.
Esto resulta muy interesante para aplicaciones de tiempo real, multimedia y sistemas de escritorio, pero es poco adecuado para servidores y computaciÃ³n de altas prestaciones.</p>
</div>
<div class="paragraph">
<p>Por eso desde Linux 2.6 se puede compilar el nÃºcleo con diferentes niveles, de lo expropiable que es el nÃºcleo.</p>
</div>
<div class="paragraph">
<p>En la configuraciÃ³n por defecto <code>PREEMPT_NONE</code>, el nÃºcleo tiene algunos <strong>puntos de expropiaciÃ³n</strong>, de tal forma que es ideal para servidores y sistemas cÃ³mputo de altas prestaciones.
Con <code>PREEMPT_VOLUNTARY</code> âel siguiente nivelâ se aÃ±aden muchos mÃ¡s <strong>puntos de expropiaciÃ³n</strong> con el objeto de reducir la latencia, mejorando el tiempo de respuesta en sistemas de escritorio.</p>
</div>
<div class="paragraph">
<p>Finalmente, activando <code>PREEMPT</code> el nÃºcleo se vuelve <strong>completamente expropiable</strong> âexcepto en algunas secciones crÃ­ticasâ.
Esto es ideal para sistemas de escritorio o sistemas empotrados con requisitos de latencia en el rango de los milisegundos.</p>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_inversiÃ³n_de_prioridad">InversiÃ³n de prioridad</h6>
<div class="paragraph">
<p>Supongamos que en un nÃºcleo completamente expropiable, un proceso de baja prioridad es interrumpido porque hay un proceso de alta prioridad en la cola de preparados.
Y que esto ocurre mientras el primero accede a una importante estructura de datos del nÃºcleo.</p>
</div>
<div class="paragraph">
<p>Durante su ejecuciÃ³n, el proceso de alta prioridad podrÃ­a intentar acceder a la misma estructura que trataba de manipular el proceso de baja prioridad cuando fue interrumpido.
Debido al uso de mecanismos de sincronizaciÃ³n, el proceso de alta prioridad se quedarÃ­a bloqueado y tendrÃ­a que abandonar la CPU a la espera de que el de baja, libere el acceso al recurso.
Sin embargo, este Ãºltimo tardarÃ¡ en ser asignado a la CPU mientras haya algÃºn otro proceso de alta prioridad en la cola de preparados.</p>
</div>
<div class="paragraph">
<p>Al hecho de que un proceso de alta prioridad tenga que esperar por uno de baja se le conoce como <strong>inversiÃ³n de la prioridad</strong>.
Para resolverlo se utiliza un <strong>protocolo de herencia de la prioridad</strong>, dÃ³nde un proceso de baja prioridad hereda la prioridad del proceso de mÃ¡s alta prioridad que espera por un recurso al que el primero estÃ¡ accediendo.
En el momento en que el proceso de baja prioridad libere el acceso a dicho recurso, su prioridad retornarÃ¡ a su valor original.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_planificaciÃ³n_en_sistemas_multiprocesador">14.7. PlanificaciÃ³n en sistemas multiprocesador</h3>
<div class="paragraph">
<p>Para tratar el problema de la planificaciÃ³n en los sistemas multiprocesador nos limitaremos al caso de los <strong>sistemas homogÃ©neos</strong>.
En dichos sistemas los procesadores son idÃ©nticos, por lo que, en cualquiera de ellos, puede ejecutar cualquier proceso.
Esto es bastante comÃºn y simplifica el problema de la planificaciÃ³n.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Un ejemplo de lo contrario a un sistema homogÃ©neo âun sistema heterogÃ©neoâ se puede observar en los PC modernos, donde muchos disponen tanto de una CPU como de una GPU, especializada en el procesamiento de grÃ¡ficos y en las operaciones vectoriales con nÃºmeros enteros y de coma flotante.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Aun asÃ­, no debemos olvidar que incluso en el caso de los sistemas homogÃ©neos pueden aparecer limitaciones en la planificaciÃ³n.
Por ejemplo, los procesadores SMT (<em>Simultaneous Multithreading</em>) permiten la ejecuciÃ³n concurrente de varios hilos de ejecuciÃ³n como si de varias CPU se tratara.
Sin embargo, al no disponer cada hilo de una CPU completa, es posible que algunos deban esperar a que algÃºn otro libere unidades de ejecuciÃ³n de la CPU que le son necesarias.
Eso debe ser tenido en cuenta por el planificador con el fin de optimizar el rendimiento del sistema.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>La tecnologÃ­a <em>Hyper-threading</em> disponible en algunos procesadores de Intel es una implementaciÃ³n de la tecnologÃ­a <em>Simultaneous Multithreading</em>.
Permite que cada nÃºcleo de procesador que estÃ¡ presente fÃ­sicamente, el sistema operativo lo gestione como dos nÃºcleos virtuales âo lÃ³gicosâ y repartir entre ellos las tareas cuando es posible.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Al margen de estas cuestiones, segÃºn el tipo de procesamiento, existen diversas posibilidades a la hora de enfrentar el problema de la planificaciÃ³n en un sistema multiprocesador (vÃ©ase el <a href="#_sistemas_multiprocesador">Apartado 2.4</a>).</p>
</div>
<div class="sect3">
<h4 id="_multiprocesamiento_asimÃ©trico">14.7.1. Multiprocesamiento asimÃ©trico</h4>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>Cuando utilizamos <strong>multiprocesamiento asimÃ©trico</strong> todas las decisiones de planificaciÃ³n, procesamiento de E/S y otras actividades son gestionadas por el nÃºcleo del sistema ejecutÃ¡ndose en un Ãºnico procesador: el <strong>servidor</strong> o <strong>maestro</strong>.
El resto de procesadores se limitan a ejecutar cÃ³digo de usuario, que les es asignado por ese procesador <strong>maestro</strong>.</p>
</div>
<div class="paragraph">
<p>Este esquema es sencillo, puesto que evita la necesidad de compartir estructuras de datos entre el cÃ³digo que se ejecuta en los diferentes procesadores.</p>
</div>
</div>
<div class="sect3">
<h4 id="_multiprocesamiento_simÃ©trico">14.7.2. Multiprocesamiento simÃ©trico</h4>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>Cuando utilizamos <strong>multiprocesamiento simÃ©trico</strong> o <strong>SMP</strong>, cada procesador ejecuta su propia copia del nÃºcleo del sistema operativo y se auto-planifica mediante su propio planificador de CPU.
En estos sistemas nos podemos encontrar con varias alternativas.</p>
</div>
<div class="sect4">
<h5 id="_con_una_cola_de_preparados_comÃºn">Con una cola de preparados comÃºn</h5>
<div class="paragraph">
<p>Algunos sistemas disponen de una cola de preparados comÃºn para todos los procesadores.
Puesto que se mira en una Ãºnica cola, todos los procesos pueden ser planificados en cualquier procesador.</p>
</div>
<div class="paragraph">
<p>Este esquema requiere el uso mecanismos de sincronizaciÃ³n para controlar el acceso concurrente de los nÃºcleos a las colas.
En caso contrario, varios procesadores podrÃ­an escoger y ejecutar el mismo proceso a la vez.</p>
</div>
<div class="paragraph">
<p>Muchos sistemas operativos modernos implementan el esquema SMP con una cola de preparados comÃºn.
Esto incluye Microsoft Windows NT/2000/XP, Solaris, macOS y versiones anteriores a Linux 2.6.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Es importante recordar que en esos sistemas operativos, lo que se planifica en las distintas CPU usando alguna de estas estrategias, son los hilos y no los procesos.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Sin embargo, esta soluciÃ³n presenta algunos inconvenientes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La posibilidad de que un proceso se pueda ejecutar en cualquier CPU âaunque parezca beneficiosaâ es negativa desde el punto de vista de que dejan de ser Ãºtiles las cachÃ©s de los procesadores, penalizando notablemente el rendimiento del sistema.
Por eso, la mayorÃ­a de los sistemas operativos de este tipo evitan, en lo posible, la migraciÃ³n de procesos de un procesador a otro.
A esto se lo conoce como asignar al proceso <strong>afinidad al procesador</strong>.</p>
</li>
<li>
<p>Los mecanismos de sincronizaciÃ³n requeridos para controlar el acceso a la cola de preparados pueden mantener a los procesadores mucho tiempo desocupados âmientras esperanâ en sistemas con un gran nÃºmero de procesadores y con muchos procesos en la cola de preparados.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_con_una_cola_para_cada_procesador">Con una cola para cada procesador</h5>
<div class="paragraph">
<p>Cada vez mÃ¡s sistemas modernos estÃ¡n optando por utilizar el esquema SMP con una cola de preparados por procesador.
De esta manera, al no utilizar mecanismos de sincronizaciÃ³n, se eliminan los tiempos de espera para acceder a la cola de preparados y escoger un nuevo proceso.</p>
</div>
<div class="paragraph">
<p>El mayor inconveniente de esta soluciÃ³n es que puede generar desequilibrios entre los procesadores, ya que un procesador puede acabar desocupado âcon su cola de preparados vacÃ­aâ mientras otro estÃ¡ muy ocupado.
Con el fin de que esto no suceda, es necesario que el sistema disponga de algunos mecanismos de <strong>balanceo de carga</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En la <strong>migraciÃ³n comandada</strong> o <em>push migration</em>, una tarea especÃ­fica âque se ejecuta con menor frecuencia que el planificador de la CPUâ estima la carga de trabajo de cada CPU y en caso de encontrar algÃºn desequilibrio mueve algunos procesos de la cola de preparados de unos procesadores a la de los otros.</p>
</li>
<li>
<p>En la <strong>migraciÃ³n solicitada</strong> o <em>pull migration</em>, un procesador inactivo extrae de la cola de preparados de un procesador ocupado alguna tarea que estÃ© esperando.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Tanto el planificador de Linux 2.6 y posteriores, como el planificador ULE de FreeBSD, implementan ambas tÃ©cnicas.
Mientras que en Microsoft Windows, a partir de Windows Vista tambiÃ©n se utiliza una cola de preparados por procesador, pero solo implementa la <strong>migraciÃ³n solicitada</strong>.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<h1 id="_gestiÃ³n_de_la_memoria" class="sect0">Parte IV: GestiÃ³n de la memoria</h1>
<div class="sect1">
<h2 id="_memoria_principal">15. Memoria principal</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>22 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>La memoria es un recurso central para el funcionamiento de un sistema operativo moderno, puesto que es el Ãºnico medio de almacenamiento al que la CPU puede acceder directamente.
Por ello, para que un programa pueda ser ejecutado, debe ser cargado en la memoria desde el disco y creadas o modificadas las estructuras internas del sistema operativo necesarias para convertirlo en un proceso.
AdemÃ¡s, dependiendo de la forma en la que se gestiona la memoria, los procesos âo partes de los mismosâ pueden moverse de la memoria al disco ây viceversaâ durante su ejecuciÃ³n, con el objetivo de ajustar las necesidades de memoria para mantener el la <strong>uso de la CPU</strong> lo mÃ¡s alto posible.</p>
</div>
<div class="paragraph">
<p>Como comentamos en el <a href="#_sistemas_multiprogramados">Apartado 2.1.2</a>, en los <strong>sistemas multiprogramados</strong> existe una <strong>cola de entrada</strong>, que se define como aquella formada por el conjunto de procesos en disco que esperan para ser cargados en la memoria para su ejecuciÃ³n.</p>
</div>
<div class="paragraph">
<p>Por tanto, el procedimiento normal de ejecuciÃ³n de un programa en dichos sistemas es:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Seleccionar un proceso de la cola de entrada y cargarlo en la memoria.</p>
</li>
<li>
<p>Mientras el proceso se ejecuta, Ã©ste accede a instrucciones y datos de la memoria.</p>
</li>
<li>
<p>Finalmente, el proceso termina y su espacio en memoria es marcado como disponible.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>En los sistemas de propÃ³sito general modernos âdesde los <strong>sistemas de tiempo compartido</strong> y los primeros <strong>sistemas de escritorio</strong>â no existe <strong>cola de entrada</strong>, por lo que los programas se cargan inmediatamente en memoria cuando los usuarios solicitan su ejecuciÃ³n.
Excepto por eso, el procedimiento normal de ejecuciÃ³n de un programa es similar al de los <strong>sistemas multiprogramados</strong>.</p>
</div>
<div class="sect2">
<h3 id="_etapas_de_un_programa_de_usuario">15.1. Etapas de un programa de usuario</h3>
<div class="paragraph">
<p>En la mayor parte de los casos, un programa de usuario debe pasar por diferentes etapas âalgunas de las cuales son opcionalesâ antes de ser ejecutado (vÃ©ase la <a href="#etapas_programas_de_usuario">Figura 41</a>).</p>
</div>
<div id="etapas_programas_de_usuario" class="imageblock">
<div class="content">
<img src="C15-memoria_principal/media/etapas_de_un_programa_de_usuario.svg" alt="etapas de un programa de usuario">
</div>
<div class="title">Figura 41. Etapas de procesamiento de un programa de usuario.</div>
</div>
<div class="paragraph">
<p>Los archivos de <strong>cÃ³digo fuente</strong> del programa son compilados por el compilador, generando un archivo de <a href="https://es.wikipedia.org/wiki/C%C3%B3digo_objeto"><strong>cÃ³digo objeto</strong></a> âcon extensiones <code>.o</code> u <code>.obj</code>â para cada uno.</p>
</div>
<div class="paragraph">
<p>Todos los archivos de <strong>cÃ³digo objeto</strong> son unidos por el enlazador para crear el archivo <strong>ejecutable</strong>, en una fase que se denomina <strong>enlazado estÃ¡tico</strong>.
En esta fase tambiÃ©n se pueden incorporar al ejecutable <strong>librerÃ­as de enlace estÃ¡tico</strong> âcon extensiones <code>.a</code> o <code>.lib</code>â con <strong>cÃ³digo objeto</strong> que ha sido empaquetado para ser reutilizado en mÃºltiples ejecutables.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>El compilador y el enlazador suelen ser dos programas independientes, aunque en ocasiones el compilador se haga cargo de ambas fases por comodidad.
Por ejemplo, en los sistemas GNU el compilador <a href="https://es.wikipedia.org/wiki/GNU_Compiler_Collection">gcc</a> por defecto genera el <strong>cÃ³digo objeto</strong> en archivos temporales, luego invoca al enlazador <a href="https://en.wikipedia.org/wiki/Linker_(computing)">ld</a> para crear el <strong>ejecutable</strong> y finalmente elimina los archivos temporales.</p>
</div>
<div class="paragraph">
<p>En proyectos grandes suele ser mÃ¡s interesante usar ambas herramientas por separado para reducir el tiempo de compilaciÃ³n.
El compilador genera los archivos de <strong>cÃ³digo objeto</strong>, que se conservan entre compilaciones.
AsÃ­, cada vez que se quiere generar una nueva versiÃ³n del ejecutable, solo es necesario compilar los archivos de <strong>cÃ³digo fuente</strong> que hayan cambiado y luego enlazar juntos todos los archivos de <strong>cÃ³digo objeto</strong>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Al crear el <strong>ejecutable</strong> se pueden guardar en Ã©l dependencias respecto a librerÃ­as que se enlazarÃ¡n posteriormente, durante la carga o ejecuciÃ³n del programa, en una fase denominada <strong>enlazado dinÃ¡mico</strong>.</p>
</div>
<div class="paragraph">
<p>En el momento en el que se va a ejecutar el programa, cuando estÃ¡ construyendo la imagen binaria del proceso en la memoria; el sistema operativo examina estas dependencias, carga las <strong>librerÃ­as de enlace dinÃ¡mico</strong> indicadas âcon extensiones <code>.so</code>, <code>dylib</code> o <code>.dll</code>â y resuelve las referencias del programa sus variables y funciones.
Las <strong>librerÃ­as de enlace dinÃ¡mico</strong> contienen <strong>cÃ³digo objeto</strong>, enlazado en un formato especial de <strong>ejecutable</strong> diseÃ±ado para contener partes compartidas entre archivos ejecutables.</p>
</div>
<div class="paragraph">
<p>Este proceso puede ocurrir mientras se carga el <strong>ejecutable</strong> âcomo se ha descritoâ o cuando el programa usa por primera vez un elemento de las <strong>librerÃ­as de enlace dinÃ¡mico</strong>.
TambiÃ©n es comÃºn que el sistema ofrezca funciones para que los programas puedan cargar manualmente e invocar funciones de <strong>librerÃ­as de enlace dinÃ¡mico</strong>.
Esto es muy Ãºtil para crear programas que se puedan mejorar por medio de extensiones o <em>plugins</em>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 13. Extensiones de archivos de programas.</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">UNIX, Linux y otros sistemas estilo UNIX</th>
<th class="tableblock halign-left valign-top">macOS</th>
<th class="tableblock halign-left valign-top">Microsoft Windows</th>
</tr>
</thead>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">CÃ³digo objeto</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>.o</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>.o</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>.obj</code></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">LibrerÃ­a de enlace estÃ¡tico</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>.a</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>.a</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>.lib</code></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Ejecutable</p></th>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>.exe</code></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">LibrerÃ­a de enlace dinÃ¡mico</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>.so</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>.so</code>, <code>.dylib</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>.dll</code></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Formato de ejecutables y librerÃ­as de enlace dinÃ¡mico</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://es.wikipedia.org/wiki/Executable_and_Linkable_Format">Executable and Linkable Format</a> (ELF)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.wikipedia.org/wiki/Mach-O">Mach-O</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://es.wikipedia.org/wiki/Portable_Executable">Portable Executable</a> (PE)</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_reubicaciÃ³n_de_las_direcciones">15.2. ReubicaciÃ³n de las direcciones</h3>
<div class="paragraph">
<p>La mayor parte de los sistemas permiten que un proceso de usuario resida en cualquier parte de la memoria fÃ­sica.
AsÃ­, aunque el espacio de direcciones del sistema comience en <code>0x00000000</code>, la primera direcciÃ³n del proceso de usuario no tiene porque ser esa.</p>
</div>
<div class="paragraph">
<p>En cada una de las etapas vistas en el <a href="#_etapas_de_un_programa_de_usuario">Apartado 15.1</a> las direcciones pueden representarse de formas distintas, por lo que en cada paso es necesario reasignar las direcciones usadas en una etapa en direcciones de la siguiente.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, en el cÃ³digo fuente de un programa las direcciones son generalmente simbÃ³licas, como los nombres de las variables y las funciones.
A continuaciÃ³n, un compilador suele reasignar esas direcciones simbÃ³licas en <strong>direcciones reubicables</strong> del estilo de Â«120 bytes desde el comienzo del mÃ³duloÂ».
Finalmente âel enlazadorâ que genera el ejecutableâ o el cargador âque carga el programa en la memoriaâ convierte esas <strong>direcciones reubicables</strong> en <strong>direcciones absolutas</strong>, como <code>0x00210243</code>.</p>
</div>
<div class="paragraph">
<p>Por tanto, en cada etapa se traducen las direcciones de un espacio de direcciones en el siguiente.
Sin embargo, para que al final el programa pueda ser ejecutado, es necesario que tanto a los datos como a las instrucciones se les reasignen en algÃºn momento a <strong>direcciones absolutas</strong> de la memoria.
Esto puede ocurrir en <strong>tiempo de compilaciÃ³n</strong>, <strong>tiempo de carga</strong> o <strong>tiempo de ejecuciÃ³n</strong></p>
</div>
<div class="sect3">
<h4 id="_reubicaciÃ³n_en_tiempo_de_compilaciÃ³n">15.2.1. ReubicaciÃ³n en tiempo de compilaciÃ³n</h4>
<div class="paragraph">
<p>Si durante la compilaciÃ³n o el enlazado se conoce el lugar de la memoria donde va a ser ejecutado el proceso, se puede generar directamente cÃ³digo con <strong>direcciones absolutas</strong> o <strong>cÃ³digo absoluto</strong>.</p>
</div>
<div class="paragraph">
<p>Eso significa que si en algÃºn momento la direcciÃ³n de inicio donde es cargado el programa cambia, es necesario recompilar el cÃ³digo fuente del programa para poder ejecutarlo en la nueva ubicaciÃ³n.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Un ejemplo son los ejecutables con formato <a href="https://es.wikipedia.org/wiki/Archivo_COM">COM</a> del sistema operativo MS-DOS.
Estos ejecutables no eran reubicables, aunque podÃ­an ponerse en distintas ubicaciones de la memoria gracias a la <a href="https://es.wikipedia.org/wiki/Segmentaci%C3%B3n_de_memoria_del_x86">segmentaciÃ³n de memoria de la familia Intel x86</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_reubicaciÃ³n_en_tiempo_de_carga">15.2.2. ReubicaciÃ³n en tiempo de carga</h4>
<div class="paragraph">
<p>Si no se conoce durante la compilaciÃ³n el lugar donde va a residir un programa cuando sea ejecutado, el compilador y el enlazador deben generar ejecutables con <strong>cÃ³digo reubicable</strong>.</p>
</div>
<div class="paragraph">
<p>En este tipo de cÃ³digo se utilizan <strong>direcciones reubicables</strong>, de manera que se retrasa su asignaciÃ³n a <strong>direcciones absolutas</strong> hasta el momento de la carga del programa.
Esto permite que un programa pueda residir en cualquier parte de la memoria fÃ­sica, cargando los procesos donde mÃ¡s convenga para maximizar el aprovechamiento de la misma.</p>
</div>
<div class="paragraph">
<p>Para generar <strong>cÃ³digo reubicable</strong>, por lo general, el compilador genera
<strong>cÃ³digo independiente de la posiciÃ³n</strong> o <strong>PIC</strong> (<em>Position-Independent Code</em>).
Este tipo de cÃ³digo se puede ejecutar adecuadamente y sin modificaciones independientemente del lugar de la memoria donde estÃ© ubicado, porque utiliza direcciones relativas.</p>
</div>
<div class="paragraph">
<p>Lamentablemente, esto puede limitar las caracterÃ­sticas de la CPU que puede utilizar el compilador o, a veces, las instrucciones que usan direcciones absolutas son mÃ¡s rÃ¡pidas que las que usan direcciones relativas, aunque en los procesadores modernos la diferencia apenas es perceptible.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, las CPU x86-64 soportan un modo de direccionamiento en el que las direcciones son relativas a la direcciÃ³n en el contador de programa.
Esto simplifica generar cÃ³digo reubicable eficiente.
Sin embargo, en las CPU x86 anteriores, las instrucciones de salto podÃ­an ser relativas al contador de programa, pero no ocurrÃ­a asÃ­ con aquellas destinadas a acceder a los datos del programa.</p>
</div>
<div class="paragraph">
<p>Cuando no se puede o no es eficiente generar <strong>cÃ³digo independiente de la posiciÃ³n</strong> se puede recurrir al uso de <strong>tablas de reubicaciÃ³n</strong> en tiempo de carga.
En este caso el compilador y el enlazador generan:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>CÃ³digo con direcciones relativas a cierta direcciÃ³n fija del ejecutable âcomo el comienzo de la secciÃ³n de cÃ³digoâ o direcciones absolutas calculadas bajo la suposiciÃ³n de que el ejecutable se va a poder cargar en cierta direcciÃ³n concreta de la memoria, que suele guardarse en la cabecera del ejecutable.</p>
</li>
<li>
<p>Una <strong>tabla de reubicaciones</strong> que se almacena en el mismo ejecutable.
Esta tabla contiene punteros a las ubicaciones en el cÃ³digo del ejecutable de las direcciones que deben reubicarse al cargarlo.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Durante la carga, el cargador del sistema operativo, una vez ha copiado a la memoria el contenido del ejecutable y conoce la ubicaciÃ³n definitiva del programa, recorre la <strong>tabla de reubicaciones</strong> para buscar las <strong>direcciones reubicables</strong> y actualizarlas.</p>
</div>
</div>
<div class="sect3">
<h4 id="_reubicaciÃ³n_en_tiempo_de_ejecuciÃ³n">15.2.3. ReubicaciÃ³n en tiempo de ejecuciÃ³n</h4>
<div class="paragraph">
<p>Si un proceso puede ser movido durante su ejecuciÃ³n de un lugar de la memoria a otro, la reubicaciÃ³n de direcciones debe ser retrasada hasta el momento de la ejecuciÃ³n de cada instrucciÃ³n del programa.</p>
</div>
<div class="paragraph">
<p>Para que esto sea posible, necesitamos disponer de hardware especial que suele estar presente en la mayor parte de las CPU modernas, por lo que la inmensa mayorÃ­a de los sistemas operativos de propÃ³sito general modernos utilizan este mÃ©todo.
De Ã©l hablaremos en el <a href="#_espacio_de_direcciones_virtual_frente_a_fÃ­sico">Apartado 15.3</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_espacio_de_direcciones_virtual_frente_a_fÃ­sico">15.3. Espacio de direcciones virtual frente a fÃ­sico</h3>
<div class="paragraph">
<p>En el <a href="#_protecciÃ³n_de_la_memoria">Apartado 7.3</a> vimos en los sistemas operativos modernos, como medida de protecciÃ³n, los procesos no tienen acceso libre a la memoria fÃ­sica.</p>
</div>
<div id="espacio_direcciones_virtual_frente_fÃ­sico" class="imageblock">
<div class="content">
<img src="C15-memoria_principal/media/protecciÃ³n_memoria.svg" alt="protecciÃ³n memoria">
</div>
<div class="title">Figura 42. Mapeo de la memoria fÃ­sica en el espacio de direcciones virtual de un proceso.</div>
</div>
<div class="paragraph">
<p>En lugar de eso el sistema operativo âasistido por la <strong>MMU</strong> (<em>Memory-Management Unit</em>)â proporciona a cada proceso un <strong>espacio de direcciones virtual</strong> que ofrece una Â«vistaÂ» privada de la memoria, similar a la que tendrÃ­an si cada uno de los procesos estuviera siendo ejecutando en solitario (vÃ©ase la <a href="#espacio_direcciones_virtual_frente_fÃ­sico">Figura 42</a>).
Es durante los accesos a la memoria principal en tiempo de ejecuciÃ³n, cuando estas <strong>direcciones virtuales</strong> son convertidas por la <strong>MMU</strong> en las <strong>direcciones fÃ­sicas</strong>, con las que realmente se accede a la memoria.
El <strong>espacio de direcciones fÃ­sico</strong> es el conjunto de direcciones fÃ­sicas que corresponden a todas las direcciones virtuales de un <strong>espacio de direcciones virtual</strong> dado.</p>
</div>
<div class="paragraph">
<p>El mecanismo de protecciÃ³n descrito es una forma muy comÃºn de <strong>reubicaciÃ³n de las direcciones en tiempo de ejecuciÃ³n</strong>, que estÃ¡ presente en la mayor parte de los sistemas operativos de propÃ³sito general modernos.
Pero, a parte de la protecciÃ³n de la memoria, algunas otras caracterÃ­sticas de dicho mecanismo son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Los procesos pueden ser cargados en cualquier zona libre de la memoria fÃ­sica e incluso movidos de una regiÃ³n a otra durante la ejecuciÃ³n de los procesos, puesto que la transformaciÃ³n de las <strong>direcciones virtuales</strong> en <strong>direcciones fÃ­sicas</strong> se realiza durante la ejecuciÃ³n de cada instrucciÃ³n.</p>
</li>
<li>
<p>El cÃ³digo generado por el compilador puede ser <strong>cÃ³digo absoluto</strong>, puesto que de antemano se sabe que todas las ubicaciones del espacio de direcciones virtual van a estar disponibles.</p>
<div class="paragraph">
<p>Lo comÃºn es que los programas se ubiquen en una direcciÃ³n fija en la parte baja del espacio de direcciones virtual.
Por ejemplo, empezando en la direcciÃ³n <code>0x00400000</code>, dejando libres los primeros 4 MiB del <strong>espacio de direcciones virtual</strong>.</p>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Los programas pueden ubicarse en cualquier lugar del <strong>especio de direcciones virtual</strong> pero no ocurre lo mismo con las <strong>librerÃ­as de enlace dinÃ¡mico</strong>, cuya posible ubicaciÃ³n va a depender del espacio ocupado por el programa y por otras <strong>librerÃ­as de enlace dinÃ¡mico</strong>.
Por tanto, como veremos en detalle mÃ¡s adelante, estas librerÃ­as deben ser reubicables en tiempo de carga.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>Se puede reducir el consumo de memoria principal compartiendo las regiones de memoria fÃ­sica asignadas al cÃ³digo y los datos de sÃ³lo lectura de los procesos de un mismo programa.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El cÃ³digo de un programa suele contener direcciones tanto para los saltos como para el acceso a los datos.
Al ubicar los programas en las mismas regiones de los espacios de direcciones virtuales de sus procesos, nos estamos asegurando de que el cÃ³digo en memoria de los procesos de un mismo programa es el mismo âpues todos usan las mismas direcciones virtuales absolutasâ por lo que se puede compartir la memoria fÃ­sica que ocupan.</p>
</div>
</div>
<div class="sect2">
<h3 id="_enlazado_dinÃ¡mico_y_librerÃ­as_compartidas">15.4. Enlazado dinÃ¡mico y librerÃ­as compartidas</h3>
<div class="paragraph">
<p>Como hemos comentado anteriormente, fundamentalmente existen dos tipos de enlazado:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En el <strong>enlazado estÃ¡tico</strong>, las librerÃ­as del sistema y otros mÃ³dulos son combinados por el enlazador para formar la imagen binaria del programa que es almacenada en disco.
Algunos sistemas operativos âcomo MS-DOSâ sÃ³lo soportan este tipo de enlazado.</p>
</li>
<li>
<p>En el <strong>enlazado dinÃ¡mico</strong>, Ã©ste se pospone hasta la carga o la ejecuciÃ³n_ (vÃ©ase la <a href="#etapas_programas_de_usuario">Figura 41</a>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Generalmente el enlazado dinÃ¡mico ocurre durante la carga del programa:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Durante la carga del ejecutable se comprueban las dependencias del mismo.
Ãstas se almacenan en el mismo archivo en disco que dicho ejecutable.</p>
</li>
<li>
<p>Las librerÃ­as a enlazar se cargar y ubican en el espacio de direcciones virtual creado para el nuevo proceso.</p>
</li>
<li>
<p>Finalmente, las referencias del programa a las funciones de cada una de las librerÃ­as cargadas se actualizan con la direcciÃ³n en memoria de las mismas.
AsÃ­ la invocaciÃ³n de las funciones por parte del programa se puede realizar de forma transparente, como si siempre hubieran formado parte del mismo.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Cuando el enlazado se va a realizar en tiempo de ejecuciÃ³n se habla de <strong>enlazado dinÃ¡mico con carga diferida</strong>.
En ese caso el procedimiento es el siguiente:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Durante el enlazado estÃ¡tico del ejecutable se pone un <em>stub</em> a cada referencia a alguna funciÃ³n de la librerÃ­a que va a ser enlazada dinÃ¡micamente.</p>
</li>
<li>
<p>Si durante la ejecuciÃ³n del programa alguna de dichas funciones es invocada, se ejecuta el <em>stub</em>.
El <em>stub</em> es una pequeÃ±a pieza de cÃ³digo que sabe como cargar la librerÃ­a, si no ha sido cargada previamente, y como localizar la funciÃ³n adecuada en la misma.</p>
</li>
<li>
<p>Finalmente, el <em>stub</em> se sustituye a sÃ­ mismo con la direcciÃ³n de la funciÃ³n y la invoca.
Esto permite que la siguiente ejecuciÃ³n de la funciÃ³n no incurra en ningÃºn coste adicional.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Sin esta habilidad, cada programa en el sistema deberÃ­a tener, por ejemplo, una copia de la librerÃ­a del sistema incluida en su ejecutable.
Esto significarÃ­a un desperdicio de espacio libre en disco y de memoria principal.
AdemÃ¡s, este esquema facilita la actualizaciÃ³n de las librerÃ­as, puesto que los programas pueden utilizar directamente las versiones actualizadas sin necesidad de volver a ser enlazados.</p>
</div>
<div class="sect3">
<h4 id="_reubicaciÃ³n_de_las_direcciones_2">15.4.1. ReubicaciÃ³n de las direcciones</h4>
<div class="paragraph">
<p>Durante la compilaciÃ³n de una <strong>librerÃ­a dinÃ¡mica</strong> no se conoce la regiÃ³n que va a ocupar, dentro de los espacios de direcciones virtuales de los distintos procesos que la van a utilizar, por lo que es necesario generar <strong>cÃ³digo reubicable</strong>.</p>
</div>
<div class="paragraph">
<p>Atendiendo a lo visto en <a href="#_reubicaciÃ³n_en_tiempo_de_carga">Apartado 15.2.2</a> existen fundamentalmente dos estrategias:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>El compilador puede generar <strong>cÃ³digo independiente de la posiciÃ³n</strong> (PIC).
Esto permite reducir el consumo de memoria principal compartiendo las regiones de memoria fÃ­sica asignadas al cÃ³digo de una misma librerÃ­a en los distintos procesos que la utilizan, pues en todas el cÃ³digo serÃ¡ exactamente el mismo.</p>
</li>
<li>
<p>En los sistemas operativos donde no se usa cÃ³digo PIC, el compilador debe generar cÃ³digo reubicable con <strong>tablas de reubicaciÃ³n</strong>, para que la reubicaciÃ³n de las direcciones virtuales se haga en tiempo de carga.
Esto aumenta el tiempo de carga de las librerÃ­as y sÃ³lo permite que compartan memoria fÃ­sica partes de la librerÃ­a que sigan siendo iguales tras la reubicaciÃ³n de las direcciones.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_librerÃ­as_compartidas">15.4.2. LibrerÃ­as compartidas</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Habitualmente las librerÃ­as incluyen informaciÃ³n acerca de su versiÃ³n.
Esta informaciÃ³n puede ser utilizada para evitar que los programas se ejecuten con versiones incompatibles de las mismas, o para permitir que haya mÃ¡s de una versiÃ³n de cada librerÃ­a en el sistema.
AsÃ­ los viejos programas se pueden ejecutar con las viejas versiones de las las librerÃ­as âo con versiones actualizadas pero compatiblesâ mientras los nuevos programas se ejecutan con las versiones mÃ¡s recientes e incompatibles con los viejos programas.</p>
</div>
<div class="paragraph">
<p>A este sistema se lo conoce como <strong>librerÃ­as compartidas</strong>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_asignaciÃ³n_contigua_de_memoria">15.5. AsignaciÃ³n contigua de memoria</h3>
<div class="paragraph">
<p>Como vimos en el <a href="#_protecciÃ³n_de_la_memoria">Apartado 7.3</a>, la memoria principal debe acomodar tanto el sistema operativo como a los diferentes procesos de los usuarios.</p>
</div>
<div class="paragraph">
<p>Normalmente queremos tener varios procesos en la memoria al mismo tiempo.
Por tanto, necesitamos considerar de que formas debemos asignar la memoria disponible a los procesos para que puedan ser cargados en ella.
En este apartado estudiaremos la tÃ©cnica mÃ¡s simple, denominada <strong>asignaciÃ³n contigua de memoria</strong>.
Mientras que en capÃ­tulos posteriores vemos tÃ©cnicas mÃ¡s avanzadas de hacer esta asignaciÃ³n.</p>
</div>
<div class="paragraph">
<p>En la <strong>asignaciÃ³n contigua de memoria</strong> a cada proceso se le asigna una Ãºnica secciÃ³n de memoria contigua.
Esto se puede hacer mediante <strong>particionado fijo</strong> o <strong>particionado dinÃ¡mico</strong></p>
</div>
<div class="sect3">
<h4 id="_particionado_fijo">15.5.1. Particionado fijo</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El <strong>particionado fijo</strong> la memoria se divide en varias secciones de tamaÃ±o fijo, cada una de las cuales contiene un proceso.
Cuando un proceso termina, se carga uno nuevo de la cola de entrada en la particiÃ³n libre.</p>
</div>
<div class="paragraph">
<p>Este mÃ©todo fue utilizado originalmente por el <a href="https://en.wikipedia.org/wiki/OS/360_and_successors">IBM OS/360</a>, pero ya no se utiliza</p>
</div>
</div>
<div class="sect3">
<h4 id="_particionado_dinÃ¡mico">15.5.2. Particionado dinÃ¡mico</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El <strong>particionado dinÃ¡mico</strong> es una generalizaciÃ³n del anterior:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>El sistema operativo mantiene una tabla indicando que partes de la memoria estÃ¡n libres y cuales ocupadas.
Inicialmente toda la memoria estÃ¡ libre por lo que es considerada como un gran hueco de memoria disponible.</p>
</li>
<li>
<p>Cuando un proceso llega y necesita memoria, se le busca un hueco lo suficientemente grande para alojarlo.
Si se encuentra, sÃ³lo se le asigna el espacio necesario, que es
marcado como ocupado.
El resto sigue siendo un hueco libre, aunque de menor tamaÃ±o.</p>
</li>
<li>
<p>Si un proceso termina y se crean dos huecos adyacentes, se funden en uno solo.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>El <strong>particionado dinÃ¡mico</strong> se utilizaba fundamentalmente en <strong>sistemas de procesamiento por lotes</strong> y <strong>multiprogramados</strong>.
En este Ãºltimo caso, el sistema operativo tenÃ­a una <strong>cola de entrada</strong> ordenada por el <strong>planificador de largo plazo</strong> y la recorrÃ­a asignando memoria a los procesos, hasta que no quedara
ningÃºn hueco libre con tamaÃ±o suficiente para alojar al siguiente en la cola.
Entonces el sistema operativo podÃ­a esperar hasta que algunos procesos terminarÃ¡n y hubiera un hueco lo suficientemente grande en la memoria, para el siguiente proceso, o podÃ­a seguir buscando en la cola de entrada procesos de menores requerimientos, aunque para ello tuviera que saltarse algunos procesos.</p>
</div>
<div class="paragraph">
<p>En general, en un momento dado el sistema operativo, debe satisfacer una peticiÃ³n de tamaÃ±o <em>N</em> con una lista de huecos libres de tamaÃ±o variable.
Esto no es mÃ¡s que un caso particular del problema clÃ¡sico de la
asignaciÃ³n dinÃ¡mica de almacenamiento, para el cual hay diversas soluciones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En el <strong>primer ajuste</strong> se escoge el primer hueco lo suficientemente grande como para satisfacer la peticiÃ³n.
La bÃºsqueda puede ser desde el principio de la lista o desde donde ha terminado la bÃºsqueda anterior.</p>
</li>
<li>
<p>En el <strong>mejor ajuste</strong> se escoge el hueco mÃ¡s pequeÃ±o que sea lo suficientemente grande para satisfacer la peticiÃ³n.
Indudablemente esto obliga a recorrer la lista de huecos completa o a tenerla ordenada por tamaÃ±o.</p>
</li>
<li>
<p>En el <strong>peor ajuste</strong> se escoge el hueco mÃ¡s grande.
Igualmente obliga a buscar en toda la lista de huecos o a tenerla ordenada por tamaÃ±o.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Para evaluar que estrategia es la mejor, se han realizado algunas simulaciones con los siguientes resultados:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>El <strong>primer y el mejor ajuste</strong> son mejores que el peor ajuste en tÃ©rminos de menor tiempo y mayor aprovechamiento del espacio de almacenamiento.</p>
</li>
<li>
<p>Si comparamos el <strong>primer y el mejor ajuste</strong> ninguno de ellos destaca sobre el otro en lo que a mejor aprovechamiento del espacio se refiere.</p>
</li>
<li>
<p>El <strong>primer ajuste</strong> es normalmente mÃ¡s rÃ¡pido que el <strong>mejor ajuste</strong>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_fragmentaciÃ³n">15.6. FragmentaciÃ³n</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Las estrategias de asignaciÃ³n de espacio de almacenamiento generalmente sufren de problemas de <strong>fragmentaciÃ³n</strong>.
Vamos a comentar brevemente como afecta la <strong>fragmentaciÃ³n</strong> a la <strong>asignaciÃ³n contigua de memoria</strong>.</p>
</div>
<div class="sect3">
<h4 id="_fragmentaciÃ³n_externa">15.6.1. FragmentaciÃ³n externa</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>La <strong>fragmentaciÃ³n externa</strong> ocurre cuando hay suficiente espacio libre para satisfacer una peticiÃ³n, pero el espacio no es contiguo.
Es decir, el espacio de almacenamiento estÃ¡ fraccionado en un gran nÃºmero de huecos de pequeÃ±o tamaÃ±o:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Afecta tanto a la estrategia del <strong>primer</strong> como del <strong>mejor ajuste</strong>. Siendo el primero mejor en algunos sistemas y el segundo mejor en otros.</p>
</li>
<li>
<p>Algunos anÃ¡lisis estadÃ­sticos realizados con el <strong>primer ajuste</strong> revelan que incluso con algunas optimizaciones, con \$N\$ bloques asignados se pierden \$0,5N\$ por <strong>fragmentaciÃ³n externa</strong> âes decir, un tercio de toda la memoria no es utilizableâ.
A esto se lo conoce como la regla del 50%.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Existen diversas soluciones a este problema:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Utilizar tÃ©cnicas de <strong>compactaciÃ³n</strong>, lo que consiste en mover los procesos para que toda la memoria libre quede en un Ãºnico hueco de gran tamaÃ±o.
Sin embargo, esto puede ser muy caro en tÃ©rminos de tiempo y sÃ³lo puede ser realizado cuando la <strong>asignaciÃ³n de direcciones absolutas se realiza en tiempo de ejecuciÃ³n</strong>.</p>
</li>
<li>
<p>La otra soluciÃ³n es permitir que el <strong>espacio de direcciones fÃ­sico</strong> de un proceso no sea contiguo.
Es decir, que la memoria puede ser asignada a un proceso independientemente de
donde estÃ© disponible.
Existen dos tÃ©cnicas complementarias que utilizan Ã©sta soluciÃ³n: la paginaciÃ³n
(vÃ©ase el <a href="#_paginaciÃ³n">CapÃ­tulo 16</a>) y la <a href="https://es.wikipedia.org/wiki/Segmentaci%C3%B3n_de_memoria">segmentaciÃ³n</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_fragmentaciÃ³n_interna">15.6.2. FragmentaciÃ³n interna</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>La <strong>fragmentaciÃ³n interna</strong> se origina por la diferencia entre el espacio solicitado y el espacio finalmente asignado.</p>
</div>
<div class="paragraph">
<p>Supongamos un hueco de espacio libre de 12987 bytes que se va a usar para satisfacer una peticiÃ³n de 12985 bytes.
Esto genera un hueco de 2 bytes, pero la cantidad de informaciÃ³n que debemos
guardar en la lista de huecos para saber que dicho hueco estÃ¡ ahÃ­, es mucho mayor que el tamaÃ±o del hueco en sÃ­ mismo.
Por lo tanto, no nos interesa tener huecos de tamaÃ±o arbitrario.</p>
</div>
<div class="paragraph">
<p>La soluciÃ³n mÃ¡s comÃºn es dividir la memoria fÃ­sica en unidades de tamaÃ±o fijo y asignarla en mÃºltiplos del tamaÃ±o de dichos bloques.
Esto hace que, en general, se asigne mÃ¡s memoria de la que realmente se ha solicitado y, por tanto, de la que realmente los procesos van a utilizar.
A esto se lo denomina <strong>fragmentaciÃ³n interna</strong>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_intercambio">15.7. Intercambio</h3>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>Un proceso debe estar en la memoria para ser ejecutado, pero en algunos sistemas operativos un proceso puede ser sacado de la memoria y copiado a un almacenamiento de respaldo de forma temporal âgeneralmente un dispositivo de almacenamiento secundario, como un discoâ y en algÃºn momento volver a ser traÃ­do a la memoria para continuar su ejecuciÃ³n.
Al procedimiento descrito se lo denomina <strong>intercambio</strong> o <strong><em>swapping</em></strong>.</p>
</div>
<div class="sect3">
<h4 id="_implementaciÃ³n">15.7.1. ImplementaciÃ³n</h4>
<div class="paragraph">
<p>El <strong>intercambio</strong> se puede implementar de la siguiente manera:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>La <strong>cola de preparados</strong> contiene todos los procesos que esperan para ser ejecutados en la CPU.</p>
</li>
<li>
<p>Cuando el <strong>planificador de la CPU</strong> decide ejecutar un proceso, llama al <strong>asignador</strong>.</p>
</li>
<li>
<p>El <strong>asignador</strong> comprueba si el siguiente proceso que debe ser ejecutado estÃ¡ en la memoria.
Si no lo estÃ¡ y no hay memoria libre, el <strong>asignador</strong> hace que el <strong>gestor de la memoria</strong> intercambie el proceso con alguno de los que si lo estÃ¡.</p>
</li>
<li>
<p>Finalmente, el <strong>asignador</strong> ejecuta el resto del cambio de contexto (vÃ©ase el <a href="#_cambio_de_contexto">Apartado 9.6</a>) para entregar la CPU al proceso seleccionado.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Por ejemplo, si a un sistema con <strong>planificaciÃ³n de CPU</strong> basado en prioridad llega a la <strong>cola de preparados</strong> un proceso de alta prioridad, el <strong>gestor de memoria</strong> intercambia algunos procesos de baja prioridad con el de alta prioridad y ejecuta este Ãºltimo.
Cuando el proceso de alta prioridad termina, los de baja prioridad pueden ser intercambiados para continuar su ejecuciÃ³n.</p>
</div>
</div>
<div class="sect3">
<h4 id="_limitaciones">15.7.2. Limitaciones</h4>
<div class="paragraph">
<p>Sin embargo el <strong>intercambio</strong> presenta algunas limitaciones importantes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Si un sistema <strong>reubica las direcciones en tiempo de compilaciÃ³n o carga</strong>, el
proceso sÃ³lo puede ser intercambiado en la misma regiÃ³n de la memoria.
Si embargo, si se utiliza <strong>reubicaciÃ³n en tiempo de ejecuciÃ³n</strong>, entonces el proceso puede ser intercambiado en cualquier regiÃ³n de la memoria, puesto que las <strong>direcciones fÃ­sicas</strong> son calculadas durante la ejecuciÃ³n.</p>
</li>
<li>
<p>El <strong>tiempo de cambio de contexto</strong> en un sistema con <strong>intercambio</strong> puede ser mucho mayor, puesto que incluye el tiempo que se tarda en hacer el intercambio.
La mayor parte del tiempo de intercambio es el tiempo de transferencia con el disco, que puede ser de varios cientos de milisegundos, incluso utilizando los discos mÃ¡s rÃ¡pidos.
Esto afecta al <strong>tiempo de cuanto</strong> que siempre debe ser mucho mayor que el tiempo de <strong>cambio de contexto</strong>.</p>
</li>
<li>
<p>Un proceso podrÃ­a disponer de un espacio en memoria de 120 MiB pero estar utilizando sÃ³lo 2 MiB.
Por tanto, es interesante que el sistema operativo conozca con exactitud la memoria utilizada por el proceso ây no la que podrÃ­a estar utilizando como mÃ¡ximoâ para reducir el tiempo de transferencia de los datos al disco durante el intercambio.</p>
<div class="paragraph">
<p>Para eso, el sistema operativo proporciona llamadas al sistema con las que un proceso con requerimientos dinÃ¡micos de memoria puede informar del cambio en su necesidad de memoria.
Por ejemplo, los sistemas operativos modernos proporcionan llamadas al sistema para reservar y liberar memoria âcomo <a href="https://en.cppreference.com/w/c/memory/malloc">malloc()</a> y <a href="https://en.cppreference.com/w/c/memory/free">free()</a> en los sistemas POSIXâ gracias a las que el sistema conoce las necesidades reales de los procesos.</p>
</div>
</li>
<li>
<p>El <strong>intercambio</strong> presenta dificultades cuando el proceso que va a ser sacado de la memoria estÃ¡ esperando por una operaciÃ³n de E/S que accede a la memoria del proceso para leer o escribir datos en ella.
La soluciones podrÃ­an ser:</p>
<div class="ulist">
<ul>
<li>
<p>No intercambiar procesos con operaciones de E/S sÃ­ncronas o asÃ­ncronas pendientes.</p>
</li>
<li>
<p>Utilizar bÃºferes del sistema operativo en las operaciones de E/S.
Por ejemplo, en una operaciÃ³n <strong>write</strong> a un archivo, el sistema operativo copiarÃ­a primero los datos a un bÃºfer interno y luego ordenarÃ­a la escritura de esos datos.
AsÃ­ el proceso podrÃ­a ser intercambiado sin problemas.
Las transferencias entre los bÃºferes del sistema y la memoria de los procesos serÃ­an realizadas, por el sistema operativo, solo cuando los procesos residen en la memoria.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Debido fundamentalmente a que el tiempo de intercambio es muy alto, no se utiliza el intercambio estÃ¡ndar en los sistemas operativos actuales.
Lo que si podemos encontrar en muchos sistemas son versiones modificadas de este mecanismo.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, en muchas versiones antiguas de UNIX y en los sistemas modernos, el intercambio permanece desactivado y solo se activa cuando la cantidad de memoria usada supera cierto lÃ­mite.
AdemÃ¡s, en los sistemas actuales no se intercambian procesos completos sino las porciones menos usadas de cada proceso, como veremos en el <a href="#_memoria_virtual">CapÃ­tulo 17</a>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_paginaciÃ³n">16. PaginaciÃ³n</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>22 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>La traducciÃ³n entre direcciones virtuales y fÃ­sicas puede realizarse de diversas maneras.
La forma mÃ¡s extendida es la <strong>paginaciÃ³n</strong>, que no es sino un esquema de gestiÃ³n de la memoria que permite que el espacio de direcciones fÃ­sico de un proceso no sea continuo, evitando el problema de la <strong>fragmentaciÃ³n externa</strong>.</p>
</div>
<div class="sect2">
<h3 id="_mÃ©todo_bÃ¡sico">16.1. MÃ©todo bÃ¡sico</h3>
<div class="paragraph">
<p>En la paginaciÃ³n la memoria fÃ­sica se divide en bloques de tamaÃ±o fijo denominados <strong>marcos</strong>, mientras que el espacio de direcciones virtual se divide en bloques del mismo tamaÃ±o que los marcos, denominados <strong>pÃ¡ginas</strong>.
Cuando un proceso va a ser ejecutado, sus pÃ¡ginas son cargadas desde el almacenamiento secundario en marcos libres de la memoria fÃ­sica.</p>
</div>
<div id="paginaciÃ³n" class="imageblock">
<div class="content">
<img src="C16-paginaciÃ³n/media/paginaciÃ³n.svg" alt="paginaciÃ³n">
</div>
<div class="title">Figura 43. Soporte del hardware para la paginaciÃ³n.</div>
</div>
<div class="paragraph">
<p>La paginaciÃ³n es una forma de <strong>reubicaciÃ³n de las direcciones en tiempo de ejecuciÃ³n</strong> donde la transformaciÃ³n de las direcciones virtuales en direcciones fÃ­sicas se realiza de la siguiente manera (vÃ©ase la <a href="#paginaciÃ³n">Figura 43</a>):</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Cada direcciÃ³n virtual generada por la CPU es divida en dos partes: un <strong>nÃºmero de pÃ¡gina</strong> \$p\$ y un <strong>desplazamiento</strong> \$d\$.</p>
</li>
<li>
<p>El <strong>nÃºmero de pÃ¡gina</strong> es utilizado por la MMU para indexar la <strong>tabla de pÃ¡ginas</strong>, que contiene el <strong>nÃºmero de marco</strong> \$f\$ de cada <strong>pÃ¡gina</strong> en la memoria fÃ­sica.</p>
</li>
<li>
<p>El <strong>nÃºmero de marco</strong> \$f\$ es combinado con el <strong>desplazamiento</strong> \$d\$ para generar la direcciÃ³n fÃ­sica que va a ser enviada por el bus de direcciones hacia la memoria.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>El tamaÃ±o de las <strong>pÃ¡ginas</strong> ây el de los <strong>marcos</strong>â viene definido por el hardware y normalmente es un nÃºmero entero potencia de 2 que puede variar entre 512 bytes y 16 MiB, dependiendo de la arquitectura.
Es decir, si el espacio de direcciones es de \$2^m\$ y el tamaÃ±o de pÃ¡gina es de \$2^n\$, los \$m - n\$ bits de mayor orden de las direcciones virtuales indican el <strong>nÃºmero de pÃ¡gina</strong>, mientras que los \$n\$ bits de menor orden indican el <strong>desplazamiento</strong> (vÃ©ase la <a href="#direcciÃ³n_virtual_paginaciÃ³n">Figura 44</a>).</p>
</div>
<div id="direcciÃ³n_virtual_paginaciÃ³n" class="imageblock">
<div class="content">
<img src="C16-paginaciÃ³n/media/direcciÃ³n_virtual_paginaciÃ³n.svg" alt="direcciÃ³n virtual paginaciÃ³n">
</div>
<div class="title">Figura 44. DescomposiciÃ³n de las direcciones virtuales en paginaciÃ³n.</div>
</div>
<div class="paragraph">
<p>Por ejemplo, en muchos sistemas operativos el tamaÃ±o de pÃ¡gina es de 4 KiB, por lo que el desplazamiento \$n\$ necesita:</p>
</div>
<div class="stemblock">
<div class="content">
\$n = log_2 4096 = 12\ text{bits}\$
</div>
</div>
<div class="paragraph">
<p>Si las direcciones virtuales son de 32 bits, eso deja para el nÃºmero de pÃ¡gina \$p\$:</p>
</div>
<div class="stemblock">
<div class="content">
\$p = 32 - 12 = 20\ text{bits}\$
</div>
</div>
<div class="paragraph">
<p>por lo que el espacio de direcciones virtual tiene \$2^20\$ pÃ¡ginas âes decir, 1.048.576 pÃ¡ginasâ.</p>
</div>
<div class="sect3">
<h4 id="_desde_el_punto_de_vista_de_los_procesos">16.1.1. Desde el punto de vista de los procesos</h4>
<div class="paragraph">
<p>Cada <strong>pÃ¡gina</strong> de un proceso requiere un <strong>marco</strong>.
Por tanto, cuando un proceso llega al sistema:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Si el proceso requiere \$n\$ <strong>pÃ¡ginas</strong>, el sistema operativo debe escoger \$n\$ <strong>marcos</strong>.
Estos <strong>marcos</strong> son tomados de la <strong>lista de marcos libres</strong> que debe mantener el sistema.
Puesto que son escogidos de allÃ­ donde los haya libres, el <strong>espacio de direcciones fÃ­sico</strong> puede no ser contiguo, aunque los procesos vean un <strong>espacio de direcciones virtual</strong> contiguo.</p>
</li>
<li>
<p>Los <strong>marcos</strong> seleccionados son asignados al proceso y cada <strong>pÃ¡gina</strong> del proceso es cargada en uno de dichos <strong>marcos</strong>.</p>
</li>
<li>
<p>La <strong>tabla de pÃ¡ginas</strong> es actualizada de manera que en la entrada de cada <strong>pÃ¡gina</strong> del proceso se pone el nÃºmero de <strong>marco</strong> correspondiente.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Un aspecto importante de la paginaciÃ³n es la diferencia entre como ven los procesos la memoria y como es realmente la memoria fÃ­sica.
Cada proceso ve la memoria como un espacio Ãºnico que lo contiene sÃ³lo a Ã©l.
Sin embargo, la realidad es que el programa estÃ¡ disperso por la memoria fÃ­sica, que ademÃ¡s puede almacenar a otros programas.
Esto es posible porque en cada momento la <strong>tabla de pÃ¡ginas</strong> sÃ³lo contiene las <strong>pÃ¡ginas</strong> del proceso en ejecuciÃ³n en la CPU.</p>
</div>
</div>
<div class="sect3">
<h4 id="_desde_el_punto_de_vista_del_sistema_operativo">16.1.2. Desde el punto de vista del sistema operativo</h4>
<div class="paragraph">
<p>Puesto que el sistema operativo es quiÃ©n gestiona la memoria fÃ­sica, Ã©ste debe saber:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Que <strong>marcos</strong> estÃ¡n asignados y a que <strong>pÃ¡gina</strong> de que proceso o procesos.</p>
</li>
<li>
<p>Que <strong>marcos</strong> estÃ¡n disponibles.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Toda esta informaciÃ³n generalmente se guarda en una estructura denominada la <strong>tabla de marcos</strong>, que tiene una entrada por cada <strong>marco</strong> de la memoria fÃ­sica.</p>
</div>
<div class="paragraph">
<p>AdemÃ¡s, el sistema operativo debe mantener una copia de la <strong>tabla de pÃ¡ginas</strong> para cada proceso en el <strong>PCB</strong>, igual que mantiene una copia del contador de programa y del contenido de los registros de la CPU.
Esta copia es utilizada:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Por el <strong>asignador</strong> para sustituir la <strong>tabla de pÃ¡ginas</strong> usada por la CPU cuando realiza un <strong>cambio de contexto</strong>.
Por lo tanto, el uso de la paginaciÃ³n incrementa el tiempo del cambio de contexto.</p>
</li>
<li>
<p>Para la traducciÃ³n manual de direcciones virtuales en fÃ­sicas.
Por ejemplo, cuando un proceso realiza una llamada al sistema para realizar una operaciÃ³n de E/S y proporciona una direcciÃ³n como parÃ¡metro, dicha direcciÃ³n debe ser traducida manualmente para producir la direcciÃ³n fÃ­sica correspondiente, que serÃ¡ comunicada al hardware para realizar la operaciÃ³n.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_tamaÃ±o_de_las_pÃ¡ginas">16.1.3. TamaÃ±o de las pÃ¡ginas</h4>
<div class="paragraph">
<p>Una decisiÃ³n de diseÃ±o importante es escoger el tamaÃ±o de las <strong>pÃ¡ginas</strong> adecuado:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Con <strong>pÃ¡ginas</strong> mÃ¡s pequeÃ±as esperamos tener menos <strong>fragmentaciÃ³n interna</strong>.</p>
</li>
<li>
<p>Con pÃ¡ginas mÃ¡s grande se pierde menos espacio en la <strong>tabla de pÃ¡ginas</strong>.
No olvidemos que cuanto mÃ¡s pequeÃ±as son las <strong>pÃ¡ginas</strong>, mÃ¡s <strong>pÃ¡ginas</strong> son necesarias y, por tanto, mÃ¡s entradas en la <strong>tabla de pÃ¡ginas</strong> se necesitan.
AdemÃ¡s, la E/S es mÃ¡s eficiente cuanto mÃ¡s datos son transferidos de cada vez.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Los tamaÃ±os de <strong>pÃ¡ginas</strong> tÃ­picos son 4 y 8 KiB.
En un sistema de 32 bits con pÃ¡ginas de 4 KiB âcomo del que hablamos antesâ el espacio de direcciones virtual tiene 1.048.576 pÃ¡ginas.
Si se utilizan 4 bytes para cada entrada de la <strong>tabla de pÃ¡ginas</strong> âaunque esto tambiÃ©n puede variarâ eso significa que cada <strong>tabla de pÃ¡ginas</strong> ocupa 4 MiB de espacio.
Mientras que con <strong>pÃ¡ginas</strong> de 8 KiB, la <strong>tabla de pÃ¡ginas</strong> ocuparÃ­a 2 MiB de espacios.</p>
</div>
<div class="paragraph">
<p>TambiÃ©n significa que si los 4 bytes de la <strong>tabla de pÃ¡ginas</strong> se utilizan para guardar Ãºnicamente el <strong>nÃºmero de marco</strong>, cada entrada puede direccionar a uno de \$2^32\$ âo 4 GiBâ <strong>marcos</strong> de la memoria fÃ­sica.
Si el tamaÃ±o de cada <strong>marco</strong> es de 4 KiB âdado que debe coincidir con el tamaÃ±o de las pÃ¡ginasâ podemos determinar que el sistema es capaz de direccionar \$2^44\$ bytes âo 16 TiBâ de memoria fÃ­sica, aunque el espacio de direcciones virtual de cada proceso solo le da acceso a un mÃ¡ximo de 4 GiB.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_soporte_hardware_de_la_tabla_de_pÃ¡ginas">16.2. Soporte hardware de la tabla de pÃ¡ginas</h3>
<div class="paragraph">
<p>La implementaciÃ³n en hardware de la <strong>tabla de pÃ¡ginas</strong> puede realizarse de diversas maneras.</p>
</div>
<div class="sect3">
<h4 id="_almacenada_en_registros_de_la_cpu">16.2.1. Almacenada en registros de la CPU</h4>
<div class="paragraph">
<p>La <strong>tabla de pÃ¡ginas</strong> del proceso actual en la CPU puede alojarse dentro de la propia CPU, en unos registros destinados a tal fin.</p>
</div>
<div class="paragraph">
<p>Debido a la velocidad de los registros de la CPU, la implementaciÃ³n en registros es la mÃ¡s eficiente.
Sin embargo, solo puede ser utilizado para <strong>tablas de pÃ¡ginas</strong> razonablemente pequeÃ±as, ya que alojar tablas de mÃ¡s de 256 entradas en registros es muy costoso.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, el DEC <a href="https://es.wikipedia.org/wiki/PDP-11">PDP-11</a> âpara el que se diseÃ±o el primer UNIXâ es un ejemplo de sistema con esta implementaciÃ³n.
Utilizaba un espacio de direcciones de 16 bits y un tamaÃ±o de <strong>pÃ¡ginas</strong> de 8 KiB, por lo que sÃ³lo necesitaba 8 registros dedicados para alojar toda la <strong>tabla de pÃ¡ginas</strong>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_almacenada_en_memoria">16.2.2. Almacenada en memoria</h4>
<div class="paragraph">
<p>La otra opciÃ³n es alojar la <strong>tabla de pÃ¡ginas</strong> del proceso actual en la memoria, normalmente en un formato definido por la CPU.</p>
</div>
<div class="paragraph">
<p>En los sistemas modernos se utilizan <strong>tablas de pÃ¡ginas</strong> de un millÃ³n de entradas o mÃ¡s, que difÃ­cilmente pueden alojarse en registros dentro de la CPU.
Por eso, los sistemas actuales almacenan la <strong>tabla de pÃ¡ginas</strong> del proceso actualmente en ejecuciÃ³n, en la memoria.
Eso permite disponer de <strong>tablas de pÃ¡ginas</strong> de gran tamaÃ±o, aunque a costa de necesitar dos accesos a la memoria fÃ­sica por cada acceso a una direcciÃ³n virtual.</p>
</div>
<div class="paragraph">
<p>Para que la MMU pueda conocer la ubicaciÃ³n de la <strong>tabla de pÃ¡ginas</strong> durante la traducciÃ³n de las direcciones, la CPU debe disponer de un registro âel <strong>PTBR</strong> (<em>Page-Table Base Register</em>)â donde se guarda la direcciÃ³n de la <strong>tabla de pÃ¡ginas</strong> actual.</p>
</div>
<div class="paragraph">
<p>AdemÃ¡s, esto tiene la ventaja de que el <strong>cambio de contexto</strong> es mÃ¡s rÃ¡pido ârespecto al uso de registros para almacenar la tabla de pÃ¡ginasâ puesto que sÃ³lo es necesario cargar un Ãºnico registro mÃ¡s âel <strong>PTBR</strong>â durante el mismo.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tlb">16.2.3. TLB</h4>
<div class="paragraph">
<p>La soluciÃ³n al retraso originado por el acceso a la tabla de pÃ¡ginas, cuando Ã©sta estÃ¡ en la
memoria, pasa por que el sistema disponga de una pequeÃ±a cachÃ© de traducciones en hardware llamada <strong>TLB</strong> (<em>Translation Look-aside Buffer</em>).</p>
</div>
<div class="paragraph">
<p>La <strong>TLB</strong> es una memoria asociativa de alta velocidad.
Cada entrada de la <strong>TLB</strong> tiene dos partes: la <strong>clave</strong> âo etiquetaâ y el valor.
Cuando a la <strong>TLB</strong> se le entrega un elemento, Ã©ste es comparado simultÃ¡neamente con todas las claves.
Si se produce alguna coincidencia, la memoria devuelve el valor de la entrada correspondiente.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Debido a la forma que tienen de operar, son rÃ¡pidas pero muy caras de fabricar.
Por ello, el nÃºmero de entradas es bajo, normalmente entre 64 y 1024.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_uso_bÃ¡sico_de_la_tlb">Uso bÃ¡sico de la TLB</h5>
<div class="paragraph">
<p>La <strong>TLB</strong> es utiliza con la <strong>tabla de pÃ¡ginas</strong> de la siguiente manera:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>La <strong>TLB</strong> contiene unas pocas entradas de la <strong>tabla de pÃ¡ginas</strong>.</p>
</li>
<li>
<p>Cuando la CPU genera una direcciÃ³n virtual, el <strong>nÃºmero de pÃ¡gina</strong> es entregado a la <strong>TLB</strong>.
La <strong>TLB</strong> utiliza los nÃºmeros de pÃ¡ginas como <strong>clave</strong>, por lo que si hay alguna coincidencia, devolverÃ¡ la entrada correspondiente de la <strong>tabla de pÃ¡ginas</strong>.</p>
</li>
<li>
<p>Si hay coincidencia, el <strong>nÃºmero de marco</strong> es extraÃ­do de la entrada devuelta por la <strong>TLB</strong> y es utilizado para generar la direcciÃ³n fÃ­sica.
Todo este proceso puede requerir un 10% mÃ¡s de tiempo que si no se hiciera la traducciÃ³n de las direcciones.</p>
</li>
<li>
<p>Si no hay coincidencia, es necesario acceder a la <strong>tabla de pÃ¡ginas</strong> para obtener la entrada correspondiente directamente de ella.
Indudablemente, este acceso puede beneficiarse de la existencia de diferentes niveles de cachÃ© en el acceso a la memoria principal.</p>
</li>
<li>
<p>En este Ãºltimo caso, la entrada recuperada debe ser aÃ±adida a la <strong>TLB</strong>, por lo que si estÃ¡ llena, se debe seleccionar una para ser sustituida.
Los algoritmos de reemplazo utilizados van, desde elegir una aleatoriamente, hasta el <strong>LRU</strong> (<em>Least Recently Used</em>).</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_borrado_de_la_tlb_en_el_cambio_de_contexto">Borrado de la TLB en el cambio de contexto</h5>
<div class="paragraph">
<p>Una cuestiÃ³n importante es quÃ© ocurre con las <strong>TLB</strong> cuando el sistema operativo realiza un <strong>cambio de contexto</strong>.</p>
</div>
<div class="paragraph">
<p>En general, es necesario que el asignador realice un borrado de la <strong>TLB</strong>.
De lo contrario, el nuevo proceso podrÃ­a utilizar las entradas de la <strong>tabla de pÃ¡ginas</strong> del viejo proceso, que estuvieran almacenadas en la <strong>TLB</strong>.
Sin embargo, un proceso no tiene porque utilizar todas las entradas de la <strong>TLB</strong>, por lo que serÃ­a mas interesante, no tener que borrar las entradas de procesos anteriores, mientras no sean necesarias, por si Ã©stos vuelven a ser ejecutados en la CPU.</p>
</div>
<div class="paragraph">
<p>El borrado se puede evitar si cada entrada de la <strong>TLB</strong> tiene un <strong>ASID</strong> (<em>Address-Space Identification</em>), que no es mÃ¡s que un identificador Ãºnico para cada proceso.
En este tipo de <strong>TLB</strong>, en la <strong>clave</strong> se buscan pares <strong>(nÃºmero de pÃ¡gina, ASID)</strong>, donde el primero proviene de la direcciÃ³n virtual y el segundo es el <strong>ASID</strong> del proceso actual.
De esta forma, si el <strong>nÃºmero de pÃ¡gina</strong> coincide pero no el <strong>ASID</strong>, se produce un fallo de la <strong>TLB</strong>.
Ãsto obliga a acceder a la <strong>tabla de pÃ¡ginas</strong> en memoria para recuperar la entrada, evitando que se lea por error la entrada de un proceso anterior.</p>
</div>
<div class="paragraph">
<p>Esta caracterÃ­stica estÃ¡ presente en los procesadores <a href="https://es.wikipedia.org/wiki/DEC_Alpha">DEC Alpha</a>, <a href="https://es.wikipedia.org/wiki/MIPS_(procesador)">MIPS</a>  y <a href="https://es.wikipedia.org/wiki/UltraSPARC">Sun UltraSPARC</a>.
Entre 2005 y 2006 tambiÃ©n comenzÃ³ a ser incluida en algunos procesadores de la familia x86, a travÃ©s de las extensiones de virtualizaciÃ³n Intel VT y AMD Pacifica.</p>
</div>
</div>
<div class="sect4">
<h5 id="_tiempos_de_acceso_a_la_memoria">Tiempos de acceso a la memoria</h5>
<div class="paragraph">
<p>El rendimiento de un sistema con paginaciÃ³n, estÃ¡ relacionado con el concepto de <strong>tiempo de acceso efectivo</strong> a la memoria \$T_(em)\$, que intenta estimar el tiempo que realmente se tarda en acceder a la memoria, teniendo en cuenta mecanismos del sistema operativo como el mÃ©todo de paginaciÃ³n o la existencia de <strong>TLB</strong>.</p>
</div>
<div class="paragraph">
<p>En muchos sistemas informÃ¡ticos, el <strong>tiempo de acceso</strong> a la memoria fÃ­sica \$T_m\$ es de unos pocos nanosegundos.
Por lo tanto, en el mÃ©todo de bÃ¡sico de paginaciÃ³n el <strong>tiempo de acceso efectivo</strong> es el doble del <strong>tiempo de acceso</strong> a la memoria:</p>
</div>
<div class="stemblock">
<div class="content">
\$T_(em)=2T_m\$
</div>
</div>
<div class="paragraph">
<p>Obviamente, en mÃ©todos de paginaciÃ³n donde hagan falta mÃ¡s accesos para obtener finalmente el <strong>nÃºmero de marco</strong>, el <strong>tiempo de acceso efectivo</strong> serÃ¡ mayor.</p>
</div>
<div class="paragraph">
<p>Supongamos que tenemos un sistema con <strong>TLB</strong> y que conocemos la probabilidad \$p\$ de que la entrada que consultamos estÃ© en la <strong>TLB</strong>.
Entonces, el <strong>tiempo de acceso efectivo</strong> se podrÃ­a calcular como la probabilidad \$(1-p)\$ de que la entrada no estÃ© en la <strong>TLB</strong>, por el <strong>tiempo de acceso</strong> necesario, en ese caso \$2T_m\$, mas la probabilidad de que la entrada sÃ­ estÃ© en la <strong>TLB</strong> \$p\$, por el <strong>tiempo de acceso</strong> \$T_m\$, porque solo hace falta acceder una vez a la memoria:</p>
</div>
<div class="stemblock">
<div class="content">
\$T_(em)=(1-p) 2T_m+pT_m=(2-p) T_m\$
</div>
</div>
<div class="paragraph">
<p>Como se puede observar, cuanto mÃ¡s se aproxima a 1 la probabilidad \$p\$ de que la entrada estÃ© en la <strong>TLB</strong>, mÃ¡s cerca estÃ¡ \$T_(em)\$ de \$T_m\$.</p>
</div>
<div class="paragraph">
<p>Para mejorar esta probabilidad:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Las <strong>TLB</strong> permiten marcar algunas entradas como insustituibles.
Esto normalmente se hace con las entradas de las <strong>pÃ¡ginas</strong> del cÃ³digo y los datos del nÃºcleo, ya que son pÃ¡ginas que se utilizan con muchÃ­sima frecuencia.</p>
</li>
<li>
<p>Si la MMU soporta pÃ¡ginas de mayor tamaÃ±o que el estÃ¡ndar, se utilizan para alojar el cÃ³digo y los datos del nÃºcleo.
De esta forma se minimiza el nÃºmero de entradas de la <strong>TLB</strong> que utilizan, con el fin de disponer de mÃ¡s entradas libres para los procesos en ejecuciÃ³n.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En la familia x86 el tamaÃ±o de pÃ¡gina estÃ¡ndar es de 4 KiB, pero tambiÃ©n se puede disponer de pÃ¡ginas de 4 MiB.
En x86-64 las pÃ¡ginas de gran tamaÃ±o son de 2 MiB, aunque algunos modelos tambiÃ©n soportan pÃ¡ginas de 1 GiB.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_protecciÃ³n_de_la_memoria_2">16.3. ProtecciÃ³n de la memoria</h3>
<div class="paragraph">
<p>La protecciÃ³n de las pÃ¡ginas se consigue mediante unos bits que indican las operaciones que se pueden realizar sobre ellas.
Normalmente, estos bits son almacenados en cada una de las entradas de la <strong>tabla de pÃ¡ginas</strong>.</p>
</div>
<div class="sect3">
<h4 id="_bits_de_protecciÃ³n">16.3.1. Bits de protecciÃ³n</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Los <strong>bits de protecciÃ³n</strong> pueden ser:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Solo lectura</strong>.</p>
</li>
<li>
<p><strong>Lectura&#8201;&#8212;&#8201;Escritura</strong>.
En algunos sistemas hay un bit especÃ­fico para este permiso, mientras que en otros se utilizan bits separados, como: <strong>lectura</strong>, <strong>escritura</strong> y <strong>ejecuciÃ³n</strong>; que se pueden combinar libremente.</p>
</li>
<li>
<p><strong>SÃ³lo ejecuciÃ³n</strong>.
Que no existen en todas las plataformas.
Por ejemplo, la familia x86 careciÃ³ de esta caracterÃ­stica hasta que AMD la incluyÃ³ en su arquitectura x86-64, lo que obligÃ³ a Intel a incluirla en las versiones mÃ¡s modernas de Pentium IV.
El bit âque para ser exacto indica <strong>no ejecuciÃ³n</strong>â fue introducido para evitar cierto tipo de ataques de seguridad.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Durante la traducciÃ³n de las direcciones, la MMU comprueba que el tipo de acceso sea vÃ¡lido.
Si no lo es, se genera una excepciÃ³n de violaciÃ³n de protecciÃ³n de memoria, dado que el acceso en un modo no autorizado se considera una instrucciÃ³n privilegiada.
Normalmente, el sistema operativo responde a dicha excepciÃ³n terminando el proceso que la generÃ³.</p>
</div>
</div>
<div class="sect3">
<h4 id="_bit_de_vÃ¡lido">16.3.2. Bit de vÃ¡lido</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>AdemÃ¡s de los <strong>bits de protecciÃ³n</strong> comentados, se suele aÃ±adir a cada entrada un <strong>bit de vÃ¡lido</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cuando una <strong>pÃ¡gina es vÃ¡lida</strong>, la pagina existe en el espacio de direcciones virtual del proceso.
Es decir, que la pÃ¡gina se puede utilizar.
Otro tÃ©rmino comÃºnmente utilizado, es que la pÃ¡gina es <strong>legal</strong>.</p>
</li>
<li>
<p>Cuando la <strong>pÃ¡gina es invÃ¡lida</strong>, la pÃ¡gina no existe en el espacio de direcciones virtual del proceso.
Es decir, que la pÃ¡gina no se puede utilizar.
El tÃ©rmino alternativo utilizado, es que la pÃ¡gina es <strong>ilegal</strong>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Al igual que con los <strong>bit de protecciÃ³n</strong>, los intentos de acceso a una pÃ¡gina ilegal generan una excepciÃ³n.</p>
</div>
<div class="paragraph">
<p>El sistema operativo puede utilizar este bit para permitir o denegar cualquier tipo de acceso a una <strong>pÃ¡gina</strong>.
Generalmente, porque no se le ha asignado un <strong>marco</strong> de memoria fÃ­sica, ya que esa pÃ¡gina no estÃ¡ siendo utilizada por el proceso.</p>
</div>
<div id="bit_de_vÃ¡lido_en_la_tabla_de_pÃ¡ginas" class="imageblock">
<div class="content">
<img src="C16-paginaciÃ³n/media/bit_de_vÃ¡lido_en_la_tabla_de_pÃ¡ginas.svg" alt="bit de vÃ¡lido en la tabla de pÃ¡ginas">
</div>
<div class="title">Figura 45. Bit de vÃ¡lido en la tabla de pÃ¡ginas.</div>
</div>
<div class="paragraph">
<p>Por ejemplo, en la <a href="#bit_de_vÃ¡lido_en_la_tabla_de_pÃ¡ginas">Figura 45</a>, vemos el espacio de direcciones virtual y la <strong>tabla de pÃ¡ginas</strong> de un proceso de 5096 bytes en un sistema con <strong>pÃ¡ginas</strong> de 1 KiB.
Puesto que el proceso no ocupa todo el espacio de direcciones, sÃ³lo las direcciones de la 0 a la 5119 son vÃ¡lidas.
En dicho ejemplo, podemos apreciar varios fenÃ³menos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Debido a la <strong>fragmentaciÃ³n interna</strong>, las direcciones de la 5097 a la 5119 son vÃ¡lidas, aunque el proceso solo ocupe hasta la 5096.
Es decir, se estÃ¡ asignando al proceso una porciÃ³n de memoria que no necesita.</p>
</li>
<li>
<p>Solo las <strong>pÃ¡ginas</strong> con datos y cÃ³digo del proceso son vÃ¡lidas.
Mientras que todas las <strong>pÃ¡ginas</strong> con direcciones por encima de la 5119 estÃ¡n marcadas como ilegales.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>En general, los procesos sÃ³lo necesitan una porciÃ³n muy pequeÃ±a de su espacio de direcciones virtual.
Por ejemplo, en un sistema de 32 bits, muy pocos procesos necesitan los 3 GiB disponibles como mÃ¡ximo para cada proceso âel 1 GiB restante suele estar ocupado por el nÃºcleo del sistemaâ.
Utilizando el <strong>bit de vÃ¡lido</strong>, el sistema operativo no tiene que asignar <strong>marcos</strong> a <strong>pÃ¡ginas</strong> no utilizadas por el proceso, ahorrando mucha memoria.</p>
</div>
<div class="paragraph">
<p>En el <a href="#_tamaÃ±o_de_las_pÃ¡ginas">Apartado 16.1.3</a>, vimos que el tamaÃ±o de la <strong>tabla de pÃ¡ginas</strong> se puede calcular como el nÃºmero mÃ¡ximo de pÃ¡ginas del espacio de direcciones virtual multiplicado por el tamaÃ±o de cada entrada de la tabla.
AsÃ­, en un sistema de 32 bits con pÃ¡ginas de 4 KiB y 4 bytes por entrada, se necesitan 4 MiB de memoria para almacenar la <strong>tabla de pÃ¡ginas</strong>.
Como un proceso suele ocupar muy poco de su espacio de direcciones virtual, suele ser un desperdicio de memoria crear y almacenar una <strong>tabla de pÃ¡ginas</strong> completa, con una entrada para cada <strong>pÃ¡gina</strong> del espacio de direcciones.</p>
</div>
<div class="paragraph">
<p>Para evÃ­tarlo, en algunas CPU existe el registro <strong>PTLR</strong> (<em>Page-Table Length Register</em>) que se utiliza para indicar el tamaÃ±o actual de la <strong>tabla de pÃ¡ginas</strong>.
Este valor es comparado por la MMU, durante la traducciÃ³n de las direcciones virtuales, con el <strong>nÃºmero de pÃ¡gina</strong> de cada direcciÃ³n virtual, de manera que las <strong>pÃ¡ginas</strong> con entradas mÃ¡s allÃ¡ de la Ãºltima almacenada en la tabla son consideradas ilegales.</p>
</div>
<div id="proceso_en_memoria_disperso" class="imageblock">
<div class="content">
<img src="C16-paginaciÃ³n/media/proceso_en_memoria.svg" alt="proceso en memoria">
</div>
<div class="title">Figura 46. AnatomÃ­a de un proceso en memoria.</div>
</div>
<div class="paragraph">
<p>En realidad, el registro <strong>PTLR</strong> no es de mucha utilidad en los sistemas operativos modernos porque, tal y como vimos en el <a href="#_el_proceso">Apartado 9.1</a>, lo mÃ¡s comÃºn es que los procesos tengan un espacio de direcciones virtual disperso como el de la <a href="#proceso_en_memoria_disperso">Figura 46</a>.
En ella, podemos observar, como el sistema operativo ubica los diferentes componentes del proceso de una forma particular dentro del espacio de direcciones virtual.
Este esquema permite que tanto el <strong>montÃ³n</strong> âa travÃ©s del mecanismo de asignaciÃ³n dinÃ¡mica de memoriaâ, como la <strong>pila</strong> puedan extenderse âen base a las necesidades de memoria que tenga el procesoâ, sobre la regiÃ³n de memoria no ocupada.
Esa regiÃ³n tambiÃ©n puede ser parcialmente ocupada por <strong>librerÃ­as de enlace dinÃ¡mico</strong> o regiones de <strong>memoria compartida</strong>, si son necesarias durante la ejecuciÃ³n del proceso.</p>
</div>
<div class="paragraph">
<p>En cualquier caso, las <strong>pÃ¡ginas</strong> de la regiÃ³n no ocupada, forman parte del espacio de direcciones virtual, pero no necesitan tener asignado ningÃºn <strong>marco</strong> de memoria fÃ­sica, en tanto en cuanto el proceso no las vaya a utilizar.
La falta de <strong>marco</strong> es indicada por el sistema operativo utilizando el <strong>bit de vÃ¡lido</strong> para denegar el acceso.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pÃ¡ginas_compartidas">16.4. PÃ¡ginas compartidas</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Una de las ventajas importantes de la paginaciÃ³n, es la posibilidad de compartir <strong>pÃ¡ginas</strong> entre procesos.
Para conseguir esto, basta con que las <strong>pÃ¡ginas compartidas</strong> de los distintos procesos tengan asignadas un mismo <strong>marco</strong>.
Esto permite, por ejemplo, que los procesos de un mismo programa puedan compartir las <strong>pÃ¡ginas</strong> de cÃ³digo o los datos de sÃ³lo lectura con el fin de ahorrar memoria.
TambiÃ©n permite compartir las <strong>pÃ¡ginas</strong> de cÃ³digo de una librerÃ­a compartida enlazada en diferentes procesos.</p>
</div>
<div class="paragraph">
<p>Compartir <strong>pÃ¡ginas</strong> no sÃ³lo permite ahorrar memoria, pues en los sistemas operativos modernos, la comunicaciÃ³n entre procesos mediante memoria compartida (vÃ©ase el <a href="#_memoria_compartida">CapÃ­tulo 11</a>), se implementa mediante <strong>pÃ¡ginas compartidas</strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_paginaciÃ³n_jerÃ¡rquica">16.5. PaginaciÃ³n jerÃ¡rquica</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Al mÃ©todo bÃ¡sico de paginaciÃ³n, se lo conoce como <strong>tabla de pÃ¡ginas lineal</strong>.
Sin embargo, las CPU comÃºnmente, utilizan otras tÃ©cnicas a la hora de estructurar la <strong>tabla de pÃ¡ginas</strong>.
Una de las mÃ¡s comunes es la <strong>paginaciÃ³n jerÃ¡rquica</strong>, utilizada en los procesadores de la familia x86 y en ARM, entre otros.</p>
</div>
<div class="paragraph">
<p>La mayor parte de los sistemas modernos soportan el uso de espacios de direcciones de gran tamaÃ±o.
Por ejemplo, supongamos un sistema con un espacio de direcciones virtual de 32 bits:</p>
</div>
<table class="tableblock frame-none grid-none stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>tamaÃ±o del espacio de direcciones</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">= \$2^32\$ = 4 GiB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>tamaÃ±o de pÃ¡gina</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">= \$2^12\$ = 4 KiB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>nÃºmero de pÃ¡ginas</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">= \$2^32 / 2^12\$ = \$2^{32-12}\$ = \$2^20\$ = 1.048.576 entradas</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Es decir, que si el tamaÃ±o de cada entrada fuera de 4 bytes, la <strong>tabla de pÃ¡ginas</strong> de un proceso podrÃ­a ocupar hasta 4 MiB; que debe ser alojada en una regiÃ³n continÃºa del espacio de direcciones fÃ­sico, por lo que podrÃ­a darse el caso de que en algÃºn momento no hubiera un hueco contiguo lo suficientemente grande.
Una forma de resolver este problema es partir la <strong>tabla de pÃ¡ginas</strong>, de manera que no sea necesario asignarle memoria de forma contigua.</p>
</div>
<div class="sect3">
<h4 id="_paginaciÃ³n_jerÃ¡rquica_de_dos_niveles">16.5.1. PaginaciÃ³n jerÃ¡rquica de dos niveles</h4>
<div class="paragraph">
<p>La <strong>paginaciÃ³n jerÃ¡rquica</strong> se basa en la idea de que un vector de gran tamaÃ±o puede ser mapeado en uno mÃ¡s pequeÃ±o, que a su vez, puede ser mapeado en un vector de menor tamaÃ±o.</p>
</div>
<div id="paginaciÃ³n_jerÃ¡rquica" class="imageblock">
<div class="content">
<img src="C16-paginaciÃ³n/media/paginaciÃ³n_jerÃ¡rquica.svg" alt="paginaciÃ³n jerÃ¡rquica">
</div>
<div class="title">Figura 47. Esquema de paginaciÃ³n jerÃ¡rquica de dos niveles.</div>
</div>
<div class="paragraph">
<p>Por ejemplo, si asumimos el caso anterior de un sistema con un espacio de direcciones de 32 bits y un tamaÃ±o de
pÃ¡gina de 4 KiB, entonces podemos dividir la tabla de pÃ¡ginas de 1.048.576 entradas â4 MiB si cada entrada necesita 4 bytesâ en 1024 porciones, cada una de las cuales cabrÃ­a en un <strong>marco</strong> de 4 KiB.</p>
</div>
<div class="paragraph">
<p>Estos <strong>marcos</strong>, a su vez, pueden ser mapeados por 1024 entradas con las direcciones fÃ­sicas de cada <strong>marco</strong>.
Si organizamos estas 1024 entradas en un vector lineal, obtendrÃ­amos una <strong>tabla de pÃ¡ginas externa</strong> de 4 KiB (vÃ©ase la <a href="#paginaciÃ³n_jerÃ¡rquica">Figura 47</a>).</p>
</div>
<div class="paragraph">
<p>Dado que 4 KiB es una cantidad de memoria muy pequeÃ±a, muchos sistemas operativos mantienen la <strong>tabla de pÃ¡ginas externa</strong> en la memoria mientras el proceso se estÃ¡ ejecutando.
Sin embargo, ahora la <strong>tabla de pÃ¡ginas</strong> estÃ¡ dividida en <strong>marcos</strong>, que no tienen porquÃ© ser asignados de forma contigua en la memoria.
Incluso podrÃ­an ser intercambiados al disco, en caso de necesitar memoria libre.</p>
</div>
<div class="paragraph">
<p>Para tener dos niveles de 1024 entradas, solo es necesario dividir el <strong>nÃºmero de pÃ¡gina</strong> \$p\$ de la direcciÃ³n virtual âque tenÃ­a \$2^20\$ bitsâ en dos <strong>nÃºmeros de pÃ¡gina</strong> de \$2^10\$ bits cada uno:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="C16-paginaciÃ³n/media/direcciÃ³n_virtual_paginaciÃ³n_jerÃ¡rquica.svg" alt="direcciÃ³n virtual paginaciÃ³n jerÃ¡rquica">
</div>
</div>
<div class="paragraph">
<p>Este es el mÃ©todo utilizado por la familia de procesadores x86.</p>
</div>
<div class="paragraph">
<p>Otra variaciÃ³n de la <strong>paginaciÃ³n jerÃ¡rquica de dos niveles</strong> es la utilizada por VAX.
Estos sistemas utilizaban un arquitectura de 32 bits con un tamaÃ±o de pÃ¡gina de 512 bytes.
Las direcciones virtuales eran divididas de la siguiente manera:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="C16-paginaciÃ³n/media/direcciÃ³n_virtual_vax.svg" alt="direcciÃ³n virtual vax">
</div>
</div>
<div class="paragraph">
<p>El espacio de direcciones de un proceso estaba dividido en 3 secciones.
Los 2 bits de orden mÃ¡s alto \$s\$ de las direcciones virtuales se utilizaban para indicar la <strong>secciÃ³n</strong>.
Cada <strong>secciÃ³n</strong> estaba dividida en <strong>pÃ¡ginas</strong> de 512 bytes, por lo que los siguientes 21 bits de las direcciones virtuales \$p\$ eran utilizadas para seleccionar la <strong>pÃ¡gina</strong> concreta.</p>
</div>
<div class="paragraph">
<p>Dividiendo el espacio de direcciones de esta manera, el sistema operativo podÃ­a mantener secciones sin utilizar mientras no fueran necesarias.
Esto era importante, puesto que la <strong>tabla de pÃ¡ginas</strong> de una
<strong>secciÃ³n</strong> tenÃ­a un tamaÃ±o de 8 MiB.</p>
</div>
</div>
<div class="sect3">
<h4 id="_paginaciÃ³n_jerÃ¡rquica_de_n_niveles">16.5.2. PaginaciÃ³n jerÃ¡rquica de N niveles</h4>
<div class="paragraph">
<p>En general, en la <strong>paginaciÃ³n jerÃ¡rquica</strong> de \$N\$ niveles el <strong>nÃºmero de pÃ¡gina</strong> \$p\$ de cada direcciÃ³n virtual es dividido en \$N\$ nÃºmeros: \${ p_1, p_2, p_3, \ldots, p_N}\$, donde:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>\$p_1\$ se utiliza para indexar la <strong>tabla de pÃ¡ginas externa</strong> âtambiÃ©n llamada <strong>directorio de pÃ¡ginas</strong> o <strong>tabla de pÃ¡ginas de nivel 0</strong>â cuya direcciÃ³n conoce la CPU mediante el <strong>PTBR</strong>.
La entrada obtenida de esta manera, contiene la direcciÃ³n en la memoria fÃ­sica de una porciÃ³n de la <strong>tabla de pÃ¡ginas</strong> en el siguiente nivel âel nivel 1â.</p>
</li>
<li>
<p>\$p_2\$ se utiliza para indexar la <strong>tabla de pÃ¡ginas de nivel 1</strong>.
E, igualmente, la entrada asÃ­ obtenida contiene la direcciÃ³n en la memoria fÃ­sica de una porciÃ³n de la <strong>tabla de pÃ¡ginas</strong> en el siguiente nivel âel nivel 2â.</p>
</li>
<li>
<p>El proceso continÃºa hasta que \$p_N\$, se utiliza para indexar la <strong>tabla de pÃ¡ginas de nivel N-1</strong>, con la que se obtiene el <strong>nÃºmero de marco</strong> que es utilizado, finalmente, para generar la direcciÃ³n fÃ­sica al combinarlo con el desplazamiento \$d\$ de la direcciÃ³n virtual.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Como se puede ver, resolver una direcciÃ³n virtual necesita tantos accesos a la memoria como niveles hay en la jerarquÃ­a.</p>
</div>
<div class="paragraph">
<p>Debido a que la traducciÃ³n funciona desde las <strong>tablas de pÃ¡ginas</strong> de nivel superior ânivel 0â hacia las de nivel inferior ânivel \$N-1\$â, a esta estructura tambiÃ©n se la conoce como <strong>tabla de pÃ¡ginas directa</strong>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Los procesadores <a href="https://es.wikipedia.org/wiki/DEC_Alpha">DEC Alpha</a> y <a href="https://es.wikipedia.org/wiki/MIPS_(procesador)">MIPS</a> utilizan una variante denominada <strong>tabla de pÃ¡ginas virtualizada</strong>.
En este esquema, el Ãºltimo nivel de la <strong>paginaciÃ³n jerÃ¡rquica</strong>, aunque estÃ© en marcos separados en el espacio de direcciones fÃ­sico, se mapea de manera continua en el espacio de direcciones virtual del proceso.</p>
</div>
<div class="paragraph">
<p>AsÃ­, si la consulta a la <strong>TLB</strong> falla, se indexa la <strong>tabla de pÃ¡ginas</strong> directamente con direcciones virtuales usando el <strong>nÃºmero de pÃ¡gina</strong> completo.
Esta consulta conlleva la traducciÃ³n de la direcciÃ³n virtual de la entrada indexada, que puede estar en la <strong>TLB</strong>.
Si no es asÃ­, se pasa a recorrer la <strong>tabla de pÃ¡ginas</strong> desde el nivel 0 y usando direcciones fÃ­sicas.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Existen algunos procesadores que utilizan mÃ¡s de dos niveles.
Por ejemplo, los procesadores x86-64 utilizan un esquema de 4 niveles de paginaciÃ³n.
Cada <strong>pÃ¡gina</strong> es de 4 KiB âcomo en el resto de la familia x86â pero como cada entrada en la <strong>tabla de pÃ¡ginas</strong> es de 8 bytes âcon el fin de poder almacenar direcciones de 64 bitsâ en cada una caben 512 entradas, por lo que los <strong>nÃºmeros de pÃ¡gina</strong> de cada nivel necesitan 9 bits.
Eso significa que de las direcciones virtuales se utilizan actualmente 48 bits âresultado de multiplicar 4 niveles por 9 bits cada uno mÃ¡s 12 bits de desplazamientoâ, aunque el limite de la arquitectura para las direcciones virtuales sea de 64 bits.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_memoria_virtual">17. Memoria virtual</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>1 horas y 5 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>La <strong>memoria virtual</strong> es una tÃ©cnica que permite la ejecuciÃ³n de procesos sin que Ã©stos tengan que ser cargados completamente en la memoria.</p>
</div>
<div class="paragraph">
<p>Los programas suelen tener partes de cÃ³digo que rara vez son ejecutadas.
Por ejemplo, las funciones para manejar condiciones de error que, aunque Ãºtiles, generalmente nunca son invocadas.
TambiÃ©n es frecuente que se reserve mÃ¡s memoria para datos de lo que realmente es necesario.
Por ejemplo, muchos programadores tienen la costumbre, de hacer cosas tales como declarar un <em>array</em> de 65536 elementos, cuando realmente sÃ³lo necesitan 255.
Teniendo todo esto en cuenta, y con el fin de mejorar el aprovechamiento de la memoria, parece que serÃ­a interesante no tener que cargar todas las porciones de los procesos y que, aun asÃ­, pudieran ejecutarse.
Eso es exactamente lo que proporciona la <strong>memoria virtual</strong>.</p>
</div>
<div class="paragraph">
<p>La habilidad de ejecutar un proceso cargado parcialmente en memoria proporciona algunos beneficios importantes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Un programa nunca mÃ¡s estarÃ­a limitado por la cantidad de memoria disponible.</p>
<div class="paragraph">
<p>Es decir, los desarrolladores pueden escribir programas considerando que disponen de un espacio de direcciones virtual extremadamente grande, sin considerar la cantidad de memoria realmente disponible.
No debemos olvidar que sin memoria virtual, para que un proceso pueda ser ejecutado, debe estar completamente cargado en la memoria.</p>
</div>
</li>
<li>
<p>Puesto que cada programa ocupa menos memoria, mÃ¡s programas se pueden ejecutar al mismo tiempo; con el correspondiente incremento en el uso de la CPU y en el rendimiento del sistema, pero sin efectos negativos en el tiempo de respuesta y en el de ejecuciÃ³n.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El concepto de <strong>memoria virtual</strong> no debe confundirse con el de <strong>espacio de direcciones virtual</strong>.
Sin embargo estÃ¡n relacionados, puesto que el que exista separaciÃ³n entre la memoria fÃ­sica y la manera en la que los procesos perciben la memoria es un requisito para poder implementar la memoria virtual.</p>
</div>
<div class="sect2">
<h3 id="_paginaciÃ³n_bajo_demanda">17.1. PaginaciÃ³n bajo demanda</h3>
<div class="paragraph">
<p>La <strong>paginaciÃ³n bajo demanda</strong> es la tÃ©cnica con la que frecuentemente se implementa la <strong>memoria virtual</strong> en los sistemas con paginaciÃ³n.</p>
</div>
<div class="paragraph">
<p>En la <strong>paginaciÃ³n bajo demanda</strong> las pÃ¡ginas individuales, en las que se dividen los espacios de direcciones virtuales de los diferentes procesos, pueden ser sacadas de la memoria de manera temporal y copiadas a un almacenamiento de respaldo, para posteriormente volver a ser traÃ­das a la memoria cuando son necesitadas por su proceso.
A este proceso de guardado y recuperaciÃ³n de las pÃ¡ginas sobre el almacenamiento de respaldo se lo denomina <strong>intercambio</strong> o <strong><em>swapping</em></strong> y es llevado a cabo por un componente del sistema operativo denominado el <strong>paginador</strong>.</p>
</div>
<div class="paragraph">
<p>Para que se puedan cargar las pÃ¡ginas cuando son necesitadas por su proceso, hace falta que el <strong>paginador</strong> sepa cuÃ¡ndo lo son.
Eso requiere que el hardware proporcione algÃºn tipo de soporte, por ejemplo, incorporando un <strong>bit de vÃ¡lido</strong> a la entrada de cada pÃ¡gina en la tabla de pÃ¡ginas, que se utiliza de la siguiente manera:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cuando el <strong>bit de vÃ¡lido</strong> estÃ¡ a 1 la pÃ¡gina es legal y estÃ¡ en la memoria.
Es decir, la pÃ¡gina existe en el espacio de direcciones virtual del proceso y tiene asignado un marco de memoria fÃ­sica.</p>
</li>
<li>
<p>Cuando el <strong>bit de vÃ¡lido</strong> estÃ¡ a 0, pueden ocurrir varias cosas:</p>
<div class="ulist">
<ul>
<li>
<p>La pÃ¡gina es legal pero estÃ¡ almacenada en disco y no en la memoria.</p>
</li>
<li>
<p>La pÃ¡gina no es legal.
Es decir, no existe en el espacio de direcciones virtual del proceso.</p>
<div class="paragraph">
<p>Esto puede ser debido a que la pÃ¡gina estÃ© en un hueco del espacio de direcciones âen una regiÃ³n que no estÃ¡ siendo utilizadaâ por lo que el sistema operativo no le ha asignado espacio de almacenamiento ni en disco ni en la memoria.</p>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Si un proceso accede a una pÃ¡gina legal, no ocurre nada y la instrucciÃ³n se ejecuta con normalidad.
Pero si accede a una pÃ¡gina marcada como invÃ¡lida:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Al intentar acceder a la pÃ¡gina, la MMU comprueba el bit de vÃ¡lido y genera una excepciÃ³n de <strong>fallo de pÃ¡gina</strong> al estar marcada como invÃ¡lida.
Dicha excepciÃ³n es capturada por el sistema operativo.</p>
</li>
<li>
<p>El sistema operativo comprueba en una tabla interna si la pÃ¡gina es legal o no.
Es decir, si la pÃ¡gina realmente no pertenece al espacio de direcciones virtual del proceso o si pertenece pero estÃ¡ almacenada en el disco.
Esta tabla interna suele almacenarse en el PCB del proceso como parte de la informaciÃ³n de gestiÃ³n de la memoria.</p>
</li>
<li>
<p>Si la pÃ¡gina es ilegal, el proceso ha cometido un error y debe ser terminado.
En sistemas POSIX, por ejemplo, el sistema envÃ­a al proceso una seÃ±al de <strong>violaciÃ³n de segmento</strong> que lo obliga a terminar.</p>
</li>
<li>
<p>Si la pÃ¡gina es legal, se carga desde el disco:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>El nÃºcleo busca un marco de memoria libre que, por ejemplo, se puede escoger de la lista de marcos libres del sistema.</p>
</li>
<li>
<p>Se solicita una operaciÃ³n de disco para leer la pÃ¡gina deseada en el marco asignado.</p>
<div class="paragraph">
<p>Puesto que no resulta eficiente mantener la CPU ocupada mientras la pÃ¡gina es recuperada desde el disco, el sistema debe solicitar la lectura de la pÃ¡gina y poner al proceso en estado <strong>esperando</strong>.</p>
</div>
</li>
<li>
<p>Cuando la lectura del disco haya terminado, se modifica la tabla interna, antes mencionada, y la tabla de pÃ¡ginas para indicar que la pÃ¡gina estÃ¡ en la memoria.</p>
</li>
<li>
<p>Reiniciar la instrucciÃ³n que fue interrumpida por la excepciÃ³n.
Generalmente esto se hace colocando el proceso nuevamente en la <strong>cola de preparados</strong> y dejando que el <strong>asignador</strong> lo reinicie cuando sea escogido por el <strong>planificador</strong> de la CPU.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Un caso extremo de la paginaciÃ³n bajo demanda es la <strong>paginaciÃ³n bajo demanda pura</strong>.
En ella la ejecuciÃ³n de un proceso se inicia sin cargar ninguna pÃ¡gina en la memoria.
Cuando el sistema operativo sitÃºa el contador de programa en la primera instrucciÃ³n del proceso âque es una pÃ¡gina no residente en memoriaâ se genera inmediatamente un <strong>fallo de pÃ¡gina</strong>.
La pÃ¡gina es cargada en la memoria âtal y como hemos descrito anteriormenteâ y el proceso continua ejecutÃ¡ndose, fallando cuando sea necesario con cada pÃ¡gina que necesite y no estÃ© cargada.
Las principales ventajas de la <strong>paginaciÃ³n bajo demanda pura</strong> son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Nunca se trae desde el disco una pÃ¡gina que no sea necesaria.</p>
</li>
<li>
<p>El inicio de la ejecuciÃ³n de un proceso es mucho mÃ¡s rÃ¡pido que si se cargara todo el proceso desde el principio.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_requerimientos_de_la_paginaciÃ³n_bajo_demanda">17.1.1. Requerimientos de la paginaciÃ³n bajo demanda</h4>
<div class="paragraph">
<p>Los requerimientos hardware para que un sistema operativo pueda soportar la <strong>paginaciÃ³n bajo demanda</strong> son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Tabla de pÃ¡ginas con habilidad para marcar entradas invÃ¡lidas, ya sea utilizando un bit especÃ­fico o con valores especiales en los bits de protecciÃ³n.</p>
</li>
<li>
<p>Disponibilidad de un dispositivo de almacenamiento secundario.</p>
<div class="paragraph">
<p>En este dispositivos se guardan las pÃ¡ginas que no estÃ¡n presentes en la memoria principal.
Normalmente se trata de un disco conocido como <strong>dispositivo de intercambio</strong>, mientras que la secciÃ³n de disco utilizada concretamente para dicho propÃ³sito se conoce como <strong>espacio de intercambio</strong> o <strong><em>swap</em></strong>.</p>
</div>
</li>
<li>
<p>Posibilidad de reiniciar cualquier instrucciÃ³n despuÃ©s de un fallo de pÃ¡gina.</p>
<div class="paragraph">
<p>En la mayor parte de los casos esta funcionalidad es sencilla de conseguir.
Sin embargo, la mayor dificultad proviene de las instrucciones que pueden modificar diferentes posiciones de la memoria, como aquellas pensadas para mover bloques de bytes o palabras.
En el caso de que el bloque de origen o de destino atraviese un borde de pÃ¡gina, la instrucciÃ³n serÃ­a interrumpida cuando la operaciÃ³n solo haya sido realizada parcialmente.
Si ademÃ¡s ambos bloques se superpusieran, no se podrÃ­a reiniciar la instrucciÃ³n completa.
Las posibles soluciones a este problema deben ser implementadas en la CPU.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_rendimiento_de_la_paginaciÃ³n_bajo_demanda">17.1.2. Rendimiento de la paginaciÃ³n bajo demanda</h4>
<div class="paragraph">
<p>Indudablemente, el rendimiento de un sistema con <strong>paginaciÃ³n bajo demanda</strong> se ve afectado por el <strong>nÃºmero de fallos de pÃ¡ginas</strong>.
En el peor de los casos, en cada instrucciÃ³n un proceso puede intentar acceder a una pÃ¡gina distinta, empeorando notablemente el rendimiento.
Sin embargo, esto no ocurre puesto que los programas tienden a tener localidad de referencia (vÃ©ase el <a href="#_hiperpaginaciÃ³n">Apartado 17.6</a>).</p>
</div>
<div class="sect4">
<h5 id="_tiempo_de_acceso_efectivo">Tiempo de acceso efectivo</h5>
<div class="paragraph">
<p>Como con la <strong>paginaciÃ³n</strong>, el rendimiento de un sistema con <strong>paginaciÃ³n bajo demanda</strong> tambiÃ©n estÃ¡ relacionado con el concepto de <strong>tiempo de acceso efectivo</strong> a la memoria, que intenta estimar el tiempo que realmente se tarda en acceder a la memoria teniendo en cuenta mecanismos del sistema operativo.</p>
</div>
<div class="paragraph">
<p>Supongamos que conocemos la probabilidad \$p_(fp)\$ de que ocurra un fallo de pÃ¡gina.
El <strong>tiempo de acceso efectivo</strong> se podrÃ­a calcular como la probabilidad de que no ocurra un fallo de pÃ¡gina \$(1-p_(fp))\$ por el <strong>tiempo de acceso</strong> a la memoria \$T_m\$, mas la probabilidad de que ocurra un fallo de pÃ¡gina \$p\$ por el tiempo necesario para gestionar cada fallo de pÃ¡gina âo <strong>tiempo de fallo de pÃ¡gina</strong>â \$T_(fp)\$:</p>
</div>
<div class="stemblock">
<div class="content">
\$T_(em)=(1-p_(fp)) T_m+p_(fp) T_(fp)\$
</div>
</div>
<div class="paragraph">
<p>Por tanto, para calcular el <strong>tiempo de acceso efectivo</strong> \$T_(em)\$ necesitamos estimar el <strong>tiempo de fallo de pÃ¡gina</strong> \$T_(fp)\$, que se consume fundamentalmente en:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Servir la excepciÃ³n de fallo de pÃ¡gina.</p>
<div class="paragraph">
<p>Esto incluye capturar la interrupciÃ³n, salvar los registros y el estado del proceso, determinar que la interrupciÃ³n es debida a una excepciÃ³n de <strong>fallo de pÃ¡gina</strong>, comprobar si la pÃ¡gina es legal y determinar la localizaciÃ³n de la misma en el disco.
Aproximadamente, en realizar esta tarea el sistema puede tardar de 1 a 100Î¼s.</p>
</div>
</li>
<li>
<p>Leer la pÃ¡gina en un marco libre.
En esta tarea se puede tardar alrededor de 8ms, pero este tiempo puede ser mucho mayor si el dispositivo estÃ¡ ocupado y se debe esperar a que se realicen otras operaciones.</p>
</li>
<li>
<p>Reiniciar el proceso.
Si incluimos el tiempo de espera en la cola de preparados, se puede tardar entre 1 y 100Î¼s.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Como se puede apreciar, la mayor parte del <strong>tiempo de fallo de pÃ¡gina</strong> es debido al tiempo requerido para acceder al <strong>dispositivo de intercambio</strong>.</p>
</div>
<div class="paragraph">
<p>Para ilustrar el cÃ¡lculo del <strong>tiempo de acceso efectivo</strong> a la memoria, solo vamos a considerar el tiempo requerido para acceder al <strong>dispositivo de intercambio</strong>, ignorando las otras tareas a realizar durante el <strong>fallo de pÃ¡gina</strong> ya que comparativamente consumen mucho menos tiempo.
Vamos suponer que el <strong>tiempo de acceso</strong> a la memoria \$T_m\$ es de 200 ns. y que la probabilidad \$p_(fp)\$ es muy pequeÃ±a âes decir, \$p âª 1\$â:</p>
</div>
<div class="stemblock">
<div class="content">
\${:
(T_(em),=,     (1-p_(fp))*200\ text{ns.}+p_(fp) * 8\ text{ms.}),
(      ,=,     (1-p_(fp))*200\ text{ns.}+p_(fp) * 8000000\ text{ns.}),
(     ,approx, 200\ text{ns.} + 7999800\ text{ns.} * p )
:}\$
</div>
</div>
<div class="paragraph">
<p>Como se puede apreciar el <strong>tiempo de acceso efectivo</strong> es proporcional a la <strong>tasa de fallos de pÃ¡gina</strong> \$tau_(fp)\$:</p>
</div>
<div class="stemblock">
<div class="content">
\$T_(em) approx T_(m) + tau_(fp)\$
</div>
</div>
<div class="paragraph">
<p>donde \$tau_(fp)=p_(fp) T_(fp)\$.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, si un proceso causa un fallo de pÃ¡gina en uno de cada 1000 accesos âes decir, \$p_(fp) = 0,001\$â el <strong>tiempo de acceso efectivo</strong> es de 8,2 ms., por lo que el rendimiento del sistema es 40 veces inferior debido a la <strong>paginaciÃ³n bajo demanda</strong>.
Por tanto, es necesario mantener la <strong>tasa de fallos de pÃ¡gina</strong> \$tau_(fp)\$ lo mÃ¡s baja posible para mantener un rendimiento adecuado.</p>
</div>
<div class="paragraph">
<p>Por simplicidad, por el momento hemos considerado \$T_m\$ como el tiempo de acceso a la memoria fÃ­sica.
Sin embargo, realmente estamos en un sistema que utiliza paginaciÃ³n âincluso con varios nivelesâ y que puede tener una TLB para mejorar su rendimiento.
Entonces, si queremos ser mÃ¡s precisos, podemos considerar \$T_m\$ como el <strong>tiempo de acceso efectivo</strong> que vimos en el <a href="#_tiempos_de_acceso_a_la_memoria">Apartado 16.2.3.3</a> para el mÃ©todo bÃ¡sico de paginaciÃ³n.
Por lo que sustituyendolo en la expresiÃ³n anterior:</p>
</div>
<div class="stemblock">
<div class="content">
\$T_(em) approx (2-p_(tlb)) T_m + tau_(fp)\$
</div>
</div>
<div class="paragraph">
<p>donde \$p_(tlb)\$ es la probabilidad de que una entrada estÃ© en la TLB y \$T_m\$ ahora sÃ­ es el <strong>tiempo de acceso</strong> a la memoria fÃ­sica.</p>
</div>
</div>
<div class="sect4">
<h5 id="_manejo_y_uso_del_espacio_de_intercambio">Manejo y uso del espacio de intercambio</h5>
<div class="paragraph">
<p>Otro aspecto fundamental que afecta al rendimiento de la <strong>paginaciÃ³n bajo demanda</strong> es el uso del espacio de intercambio.</p>
</div>
<div class="paragraph">
<p>Cuando un proceso genera un <strong>fallo de pÃ¡gina</strong>, el sistema operativo debe recuperar la pÃ¡gina de allÃ­ donde estÃ© almacenada.
Si esto ocurre al principio de la ejecuciÃ³n, ese lugar seguramente serÃ¡ el archivo que contiene la imagen binara del programa, pues es donde se encuentran las pÃ¡ginas en su estado inicial.
Sin embargo, el acceso al espacio de intercambio es mucho mÃ¡s eficiente que el acceso a un sistema de archivos, incluso aunque el primero estÃ© almacenado dentro de un archivo de gran tamaÃ±o.
Esto es debido a que los datos se organizan en bloques contiguos de gran tamaÃ±o, se evitan las bÃºsquedas de archivos y las indirecciones en la asignaciÃ³n de espacio.
Por ello debemos plantearnos quÃ© hacer con las imÃ¡genes de los programas que van a ser ejecutados.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se puede mejorar el rendimiento copiando en el espacio de intercambio la imagen completa de los programas durante el inicio del proceso, para despuÃ©s realizar la <strong>paginaciÃ³n bajo demanda</strong> sobre dicha copia.</p>
</li>
<li>
<p>Otra alternativa es cargar las pÃ¡ginas desde el archivo que contiene la imagen cuando son usadas por primera vez, pero siendo escritas en el espacio de intercambio cuando dichas pÃ¡ginas tiene que ser reemplazadas.
Esta aproximaciÃ³n garantiza que solo las pÃ¡ginas necesarias son leÃ­das desde el sistema de archivos, reduciendo el uso de espacio de intercambio, mientras que las siguientes operaciones de intercambio se hacen sobre dicho espacio.</p>
</li>
<li>
<p>TambiÃ©n se puede suponer que el cÃ³digo de los procesos no puede cambiar.
Esto permite utilizar el archivo de la imagen binaria para recargar las pÃ¡ginas de cÃ³digo, lo que tambiÃ©n evita escribirlas cuando son sustituidas.
Sin embargo, el espacio de intercambio se sigue utilizando para las pÃ¡ginas que no estÃ¡n directamente asociadas a un archivo, como la pila o el montÃ³n de los procesos.</p>
<div class="paragraph">
<p>Este Ãºltimo mÃ©todo parece conseguir un buen compromiso entre el tamaÃ±o del espacio de intercambio y el rendimiento.
Por eso se utiliza en la mayor parte de los sistemas operativos modernos.</p>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_copy_on_write">17.2. Copy-on-write</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El <strong><em>copy-on-write</em></strong> o <strong>copia durante la escritura</strong> permite la creaciÃ³n rÃ¡pida de nuevos procesos, minimizando la cantidad de pÃ¡ginas que deben ser asignadas a estos.</p>
</div>
<div class="paragraph">
<p>Para entenderlo, es importante recordar que la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> crear un proceso hijo cuyo espacio de direcciones es un duplicado del espacio de direcciones del padre.
Indudablemente, esto significa que durante la llamada es necesario asignar suficientes marcos de memoria fÃ­sica como para alojar las pÃ¡ginas del nuevo proceso hijo.
El <strong><em>copy-on-write</em></strong> minimiza de la siguiente manera el nÃºmero de marcos que deben ser asignadas al nuevo proceso:</p>
</div>
<div id="copy_on_write_1" class="imageblock">
<div class="content">
<img src="C17-memoria_virtual/media/copy-on-write1.svg" alt="copy on write1">
</div>
<div class="title">Figura 48. Copy-on-write antes de que el proceso 1 modifique la pÃ¡gina A.</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Cuando la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> crea el nuevo proceso lo hace de forma que Ã©ste comparta todas sus pÃ¡ginas con las del padre (vÃ©ase la <a href="#copy_on_write_1">Figura 48</a>).</p>
<div class="paragraph">
<p>Sin el <strong><em>copy-on-write</em></strong> el <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> tendrÃ­a que asignar marcos de memoria fÃ­sica al hijo, para a continuaciÃ³n copiar las pÃ¡ginas del padre en ellos.
Sin embargo, con el <strong><em>copy-on-write</em></strong> padre e hijo mapean sus pÃ¡ginas en los mismos marcos, evitando tener que asignar memoria libre.</p>
</div>
</li>
<li>
<p>Las pÃ¡ginas compartidas se marcan como <strong><em>copy-on-write</em></strong>.</p>
<div class="paragraph">
<p>Para ello se pueden marcar todas las pÃ¡ginas como de <strong>solo lectura</strong> en la tabla de pÃ¡ginas de ambos procesos y utilizar una tabla interna alojada en el PCB para indicar cuales son realmente de sÃ³lo lectura y cuales estÃ¡n en <strong><em>copy-on-write</em></strong>.
Es importante destacar que realmente sÃ³lo las pÃ¡ginas que pueden ser modificadas se marcan como <strong><em>copy-on-write</em></strong>. Las pÃ¡ginas que no puede ser modificadas âpor ejemplo, las que contienen el cÃ³digo ejecutable del programaâ simplemente pueden ser compartidas como de sÃ³lo lectura por los procesos, como hemos comentado anteriormente.</p>
</div>
</li>
<li>
<p>Si algÃºn proceso intenta escribir en una pÃ¡gina <strong><em>copy-on-write</em></strong>, la MMU genera una excepciÃ³n para notificar el suceso al sistema operativo.
Siguiendo lo indicado en el punto anterior, la excepciÃ³n se originarÃ­a porque la pÃ¡gina estÃ¡ marcada como de solo lectura, por lo que el sistema operativo comprobarÃ¡ si se trata de un acceso a una pÃ¡gina <strong><em>copy-on-write</em></strong> o a un intento real de escribir en una pÃ¡gina de sÃ³lo lectura.
Para ello, el sistema solo tiene que mirar la tabla interna almacenada en el PCB.
Si se ha intentado escribir en una pÃ¡gina de solo lectura, el proceso ha cometido un error y generalmente serÃ¡ terminado.</p>
</li>
</ol>
</div>
<div id="copy_on_write_2" class="imageblock">
<div class="content">
<img src="C17-memoria_virtual/media/copy-on-write2.svg" alt="copy on write2">
</div>
<div class="title">Figura 49. Copy-on-write despuÃ©s de que el proceso 1 modifique la pÃ¡gina A.</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Si el sistema detecta una escritura a una pÃ¡gina de <strong><em>copy-on-write</em></strong> solo tiene que copiarla en un marco libre y mapearlo en el espacio de direcciones del proceso (vÃ©ase la <a href="#copy_on_write_2">Figura 49</a>).</p>
<div class="paragraph">
<p>Para esto se sustituye la pÃ¡gina compartida por otra que contiene una copia pero que ya no estÃ¡ compartida.
Obviamente, la nueva pÃ¡gina debe ser marcada como de escritura para que en el futuro pueda ser modificada por el proceso.</p>
</div>
</li>
<li>
<p>La pÃ¡gina original marcada como <strong><em>copy-on-write</em></strong> puede ser marcada como de escritura y no como <strong><em>copy-on-write</em></strong>, pero solo si no va a seguir siendo compartida.
Esto es asÃ­ porque una pÃ¡gina marcada como <strong><em>copy-on-write</em></strong> puede estar siendo compartida con otros procesos.</p>
</li>
<li>
<p>El sistema operativo puede reiniciar el proceso.
A partir de ahora, Ã©ste puede escribir en la pÃ¡gina sin afectar al resto de los procesos.
Sin embargo, puede seguir compartiendo otras pÃ¡ginas en <strong><em>copy-on-write</em></strong>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>El <strong><em>copy-on-write</em></strong> permite ahorrar memoria y tiempo en la creaciÃ³n de los procesos, puesto que sÃ³lo se copian las pÃ¡ginas que son modificadas por Ã©stos.
Por eso se trata de una tÃ©cnica comÃºn en mÃºltiples sistemas operativos, como por ejemplo los sistemas POSIX modernos y Microsoft Windows.</p>
</div>
<div class="paragraph">
<p>El <strong><em>copy-on-write</em></strong> es especialmente interesante si a continuaciÃ³n se va a utilizar la llamada al sistema <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> puesto que si es asÃ­, copiar el espacio de direcciones completo es una pÃ©rdida de tiempo.</p>
</div>
</div>
<div class="sect2">
<h3 id="_archivos_mapeados_en_memoria">17.3. Archivos mapeados en memoria</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Los <strong>archivos mapeados en memoria</strong> permiten acceder a un archivo como parte del espacio de direcciones virtuales de un proceso.
Algunas de las caracterÃ­sticas de esta tÃ©cnica son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cuando una regiÃ³n del espacio de direcciones queda marcada para ser mapeada sobre una regiÃ³n de un archivo. se utiliza una estrategia similar a la comentada para el mÃ©todo bÃ¡sico de la paginaciÃ³n bajo demanda.
La diferencia es que las pÃ¡ginas son cargadas desde dicho archivo y no desde el espacio de intercambio.
Es decir, en un primer acceso a una pÃ¡gina mapeada se produce un <strong>fallo de pÃ¡gina</strong> que es resuelto por el sistema operativo leyendo una porciÃ³n del archivo en el marco asignado a la pÃ¡gina.</p>
</li>
<li>
<p>Esto significa que la lectura y escritura del archivo se realiza a travÃ©s de lecturas y escrituras en la memoria, lo que simplifica el acceso y elimina el costo adicional de las llamadas al sistema: <a href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a>, <a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a>, etc.</p>
</li>
<li>
<p>Las escrituras en disco se suelen realizar de forma asÃ­ncrona.
Es decir, los datos no se escriben inmediatamente en disco cuando se modifica la pÃ¡gina, sino que el sistema operativo comprueba periÃ³dicamente las pÃ¡ginas modificadas y las escribe en disco.</p>
</li>
<li>
<p>Los marcos utilizados en el mapeo pueden ser compartidos, lo que permite compartir los datos de los archivos.
AdemÃ¡s, se puede incluir soporte de <strong><em>copy-on-write</em></strong>, lo que permite a los procesos compartir buena parte de un archivo en modo de sÃ³lo lectura, pero disponiendo de sus propias copias de aquellas pÃ¡ginas que modifiquen.</p>
<div class="paragraph">
<p>Indudablemente, para que los procesos puedan compartir datos es necesario que exista algÃºn tipo de coordinaciÃ³n (vÃ©ase el <a href="#_sincronizaciÃ³n">CapÃ­tulo 13</a>).</p>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_mapeo_de_archivos">17.3.1. Ejemplo de mapeo de archivos</h4>
<div class="paragraph">
<p>Tanto en los sistemas POSIX como en Windows API el archivo a mapear hay que abrirlo con la llamada al sistema destinada a ello.
Por ejemplo, en sistemas POSIX:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span> <span class="s">"foo.txt"</span><span class="p">,</span> <span class="n">O_RDONLY</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>En el API POSIX con esto es suficiente para usar la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a> y mapear el archivo en memoria:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="n">lenght</span> <span class="o">=</span> <span class="n">lseek</span><span class="p">(</span> <span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_END</span> <span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="kt">void</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="n">length</span><span class="p">,</span>                 <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="n">PROT_READ</span><span class="p">,</span>              <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="n">MAP_SHARED</span><span class="p">,</span>
    <span class="n">fd</span><span class="p">,</span>                     <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="mi">0</span>                       <i class="conum" data-value="3"></i><b>(3)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Descriptor del archivo abierto con <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>La longitud de la regiÃ³n del archivo a mapear.
Si queremos mapear todo el archivo, podemos usar <a href="https://www.man7.org/linux/man-pages/man2/lseek.2.html">lseek()</a> para conocer su longitud.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Si no se mapea todo el archivo, se puede indicar la posiciÃ³n del archivo donde comenzar el mapeo.
Esta posiciÃ³n debe ser mÃºltiplo del tamaÃ±o de pÃ¡gina.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Permisos de la memoria mapeada.
Deben coincidir con el modo con el que se abriÃ³ el archivo.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Una vez mapeado el archivo, si no se van a crear mÃ¡s mapeos, se puede cerrar el descriptor de archivo con <a href="https://man7.org/linux/man-pages/man2/close.2.html">close()</a>.
Y la regiÃ³n de memoria mapeada se puede liberar, al terminar, con <a href="https://man7.org/linux/man-pages/man2/munmap.2.html">munmap()</a>.</p>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap17/mapped-files.cpp">mapped-files.cpp</a> se puede ver el ejemplo de un programa que cuenta el nÃºmero de lÃ­neas, palabra y caracteres de un archivo.
Para acceder a Ã©l, primero lo mapea en memoria, evitando tener que usar <a href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a> para leer su contenido.
El programa usa la clase definida en <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap17/memory_map.hpp">memory_map.hpp</a> para gestionar el mapeo del archivo.
Sus mÃ©todos muestran de forma prÃ¡ctica cÃ³mo utilizar las llamadas al sistema comentadas.</p>
</div>
<div class="paragraph">
<p>Con Windows API el proceso requiere un paso mÃ¡s. Primero hay que usar el manejador del archivo abierto para crear un <strong>objeto de mapeo de archivo</strong> con <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga">CreateFileMapping()</a>.
DespuÃ©s, el manejador devuelto por <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga">CreateFileMapping()</a> es usado con <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile">MapViewOfFile()</a> para mapear el archivo en la memoria del proceso.</p>
</div>
<div class="paragraph">
<p>Para liberar la memoria mapeada, se utiliza <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-unmapviewoffile">UnmapViewOfFile()</a>.
Mientras que para cerrar el manejador del <strong>objeto de mapeo de archivo</strong> se usa <a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle">CloseHandle()</a>, como es habitual.</p>
</div>
</div>
<div class="sect3">
<h4 id="_mapeo_de_archivos_en_el_nÃºcleo">17.3.2. Mapeo de archivos en el nÃºcleo</h4>
<div class="paragraph">
<p>Algunos sistemas operativos ofrecen el servicio de mapeo de archivos en la memoria solo a travÃ©s de una llamada al sistema concreta, permitiendo utilizar las llamadas estÃ¡ndar â<a href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a>, <a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a>, etc.â para hacer uso de la E/S tradicional.
Sin embargo, muchos sistemas modernos utilizan el mapeo en la memoria independientemente de que se pidan o no.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, en los sistemas POSIX, si un proceso utiliza llamada al sistema <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a> es porque explÃ­citamente pide que el archivo sea mapeado en memoria.
Por tanto, el nÃºcleo mapea el archivo en el espacio de direcciones del proceso.</p>
</div>
<div class="paragraph">
<p>Pero en Linux, Microsoft Windows y otros sistemas operativos modernos, adicionalmente, cuando un archivo es abierto con llamadas al sistemas estÃ¡ndar âcomo <strong>open</strong>â el archivo es mapeado en el espacio de direcciones del nÃºcleo y las llamadas <strong>read</strong> y <strong>write</strong> son traducidas en accesos a la memoria en dicha regiÃ³n.
No importa como sea abierto el archivo.
Estos sistemas tratan toda la E/S a archivos como mapeada en memoria, permitiendo que el acceso a los mismos, tenga lugar a travÃ©s del eficiente componente de gestiÃ³n de la memoria.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_reemplazo_de_pÃ¡gina">17.4. Reemplazo de pÃ¡gina</h3>
<div class="paragraph">
<p>Hasta el momento hemos considerado que disponemos de memoria fÃ­sica suficiente para atender cualquier fallo de pÃ¡gina pero Â¿quÃ© ocurre cuando no quedan marcos libres?.
En ese caso el cÃ³digo que da servicio a la excepciÃ³n de <strong>fallo de pÃ¡gina</strong> debe escoger alguna pÃ¡gina, intercambiarla con el disco y utilizar el marco de la misma para cargar la nueva pÃ¡gina.
Es decir, debemos modificar la funciÃ³n que ejecuta los pasos descritos en el <a href="#_paginaciÃ³n_bajo_demanda">Apartado 17.1</a> de la siguiente manera:</p>
</div>
<div class="olist arabic">
<ol class="arabic" start="4">
<li>
<p>Si la pÃ¡gina es legal, debe ser cargada desde el disco.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Buscar la localizaciÃ³n de la pÃ¡gina en disco.</p>
</li>
<li>
<p>El nÃºcleo debe buscar un marco de memoria libre que, por ejemplo, se puede escoger de la lista de marcos libres del sistema.</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>Si hay uno, usarlo.</p>
</li>
<li>
<p>Si no hay, usar un <strong>algoritmo de reemplazo de pÃ¡gina</strong> para seleccionar una vÃ­ctima.</p>
</li>
<li>
<p>Escribir la vÃ­ctima en el disco y cambiar las <strong>tablas de pÃ¡ginas y de marcos libres</strong> de acuerdo a la nueva situaciÃ³n.
Para evitar mantener la CPU ocupada, el sistema debe solicitar la escritura de la pÃ¡gina y poner al proceso en estado de <strong>esperando</strong>.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Se solicita una operaciÃ³n de disco para leer la pÃ¡gina deseada en el marco asignado.
Para evitar mantener la CPU ocupada, el sistema debe solicitar la escritura de la pÃ¡gina y poner al proceso en estado de <strong>esperando</strong>.</p>
</li>
<li>
<p>Cuando la lectura del disco haya terminado, se debe modificar la tabla interna de pÃ¡ginas vÃ¡lidas, y la tabla de pÃ¡ginas para indicar que la pÃ¡gina estÃ¡ en la memoria.</p>
</li>
<li>
<p>Reiniciar la instrucciÃ³n que fue interrumpida por la excepciÃ³n.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Es importante destacar que en caso de <strong>reemplazo</strong> se necesita realizar dos accesos al disco.
Esto se puede evitar utilizando un <strong>bit de modificado</strong> asociado a cada entrada en la <strong>tabla de pÃ¡ginas</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Este bit es puesto a 1 por el hardware cuando se escribe en la pÃ¡gina.</p>
</li>
<li>
<p>Se puede evitar escribir en disco aquellas pÃ¡ginas que tienen este bit a 0 cuando son seleccionada para reemplazo, siempre que el contenido de la pÃ¡gina no haya sido sobrescrito por otra en el espacio de intercambio.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>En general, para implementar la paginaciÃ³n bajo demanda necesitamos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Un <strong>algoritmo de asignaciÃ³n de marcos</strong>, que se encarga de asignar los marcos a los procesos.</p>
</li>
<li>
<p>Un <strong>algoritmo de reemplazo de pÃ¡gina</strong> para seleccionar que pÃ¡gina reemplazamos cuando no hay marcos suficientes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Obviamente, estos algoritmos deben ser escogidos de forma que mantengan la <strong>tasa de fallos de pÃ¡gina</strong> lo mÃ¡s baja posible para perjudicar en lo mÃ­nimo el rendimiento del sistema.</p>
</div>
<div class="sect3">
<h4 id="_algoritmos_de_reemplazo_de_pÃ¡ginas">17.4.1. Algoritmos de reemplazo de pÃ¡ginas</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Hay muchos <strong>algoritmos de reemplazo de pÃ¡gina</strong>.
La cuestiÃ³n es cÃ³mo seleccionar uno en particular, sabiendo que debe tener la menor tasa posible de <strong>fallos de pÃ¡gina</strong>.</p>
</div>
<div class="sect4">
<h5 id="_trazas_de_referencias">Trazas de referencias</h5>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Podemos evaluar el algoritmo utilizando una secuencia de referencias a memoria y calculando el nÃºmero de <strong>fallos de pÃ¡gina</strong>.
A dicha secuencia de referencias se la denomina <strong>trazas de referencias</strong>.</p>
</div>
<div class="paragraph">
<p>Las trazas pueden ser obtenidas aleatoriamente u obteniÃ©ndolas a partir de las que hace un proceso en un sistema real.
Indudablemente, esta Ãºltima alternativa puede proporcionar miles de millones de referencias.
Para reducir el nÃºmero de datos podemos hacer dos cosas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>De cada referencia sÃ³lo necesitamos considerar el nÃºmero de pÃ¡gina.</p>
</li>
<li>
<p>Si tenemos una referencia a la pÃ¡gina \$p\$, cualquier referencia inmediatamente posterior a dicha pÃ¡gina \$p\$ nunca provocarÃ¡ un fallo de pÃ¡gina, por lo que podemos ignorarlas.
Esto no tendrÃ­a porque ser cierto y si consideramos que hay varios procesos en el sistema y unos pueden expropiar a los otros.
Pero por simplicidad, ese no es nuestro caso.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Por ejemplo, si obtenemos la siguiente traza de un proceso particular:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>0100, 0432, 0101, 0612, 0102, 0103, 0104, 0101, 0611, 0102, 0103, 0104, 0101, 0610, 0102, 0103, 0104, 0101, 0609, 0102, 0105</pre>
</div>
</div>
<div class="paragraph">
<p>con pÃ¡ginas de 100 bytes, podemos reducirla a:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>1, 4, 1, 6, 1, 6, 1, 6, 1, 6, 1</pre>
</div>
</div>
<div class="paragraph">
<p>Indudablemente, para determinar el nÃºmero de <strong>fallos de pÃ¡gina</strong> tambiÃ©n debemos conocer el nÃºmero de marcos disponibles para el proceso.</p>
</div>
</div>
<div class="sect4">
<h5 id="_reemplazo_fifo">Reemplazo FIFO</h5>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>El <strong>algoritmo de reemplazo de pÃ¡ginas FIFO</strong> es el mÃ¡s sencillo.
Funciona de la siguiente manera:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se asocia a cada pÃ¡gina el instante de tiempo en que fue cargada por Ãºltima vez.</p>
</li>
<li>
<p>Cuando hay que hacer reemplazo se selecciona como vÃ­ctima a la pÃ¡gina mÃ¡s antigua.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Realmente no es estrictamente necesario almacenar el instante de tiempo en que una pÃ¡gina fue cargada.
En su lugar, las pÃ¡ginas en memoria pueden ser almacenadas en una cola FIFO, puesto que asÃ­ se conserva su orden de llegada en el tiempo, que es lo que nos interesa.
Esta misma cola FIFO es utilizada en algunos algoritmos que veremos posteriormente.</p>
</div>
<div class="paragraph">
<p>Vamos a ilustrar este algoritmo con un ejemplo, donde supondremos que tenemos 3 marcos de memoria fÃ­sica:</p>
</div>
<table class="tableblock frame-all grid-all stretch small">
<colgroup>
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top" colspan="20"><p class="tableblock">13 fallos de pÃ¡gina</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Como se puede observar, las primeras 3 referencias generan <strong>fallos de pÃ¡gina</strong> porque se supone que los marcos no estÃ¡n asignados a ninguna pÃ¡gina.
A partir de ahÃ­ se utiliza el <strong>algoritmo de reemplazo FIFO</strong> para seleccionar una pÃ¡gina cuyo marco es utilizado para cargar la pÃ¡gina requerida por el proceso.</p>
</div>
<div class="paragraph">
<p>El <strong>algoritmo FIFO</strong> no siempre tiene un buen rendimiento:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Puesto que utiliza el orden en el tiempo, puede reemplazar tanto pÃ¡ginas que no estÃ¡n siendo utilizadas como pÃ¡ginas usadas frecuentemente.
Sin embargo, aunque esto pase, todo seguirÃ¡ funcionado correctamente, aunque aumentarÃ¡ la tasa de <strong>fallos de pÃ¡gina</strong> enlenteciendo el sistema.</p>
</li>
<li>
<p>No siempre que aumenta la cantidad de memoria disponible mejora el rendimiento.</p>
</li>
</ul>
</div>
<div id="fallos_de_pÃ¡gina_frente_a_marcos" class="imageblock">
<div class="content">
<img src="C17-memoria_virtual/media/fallos_de_pÃ¡gina_frente_a_marcos.svg" alt="fallos de pÃ¡gina frente a marcos">
</div>
<div class="title">Figura 50. Fallos de pÃ¡gina frente a nÃºmero de marcos.</div>
</div>
<div class="paragraph">
<p>Es de esperar que si el nÃºmero de marcos disponibles aumenta, el nÃºmero de <strong>fallos de pÃ¡gina</strong> disminuya (vÃ©ase la <a href="#fallos_de_pÃ¡gina_frente_a_marcos">Figura 50</a>).
Sin embargo, con el <strong>algoritmo FIFO</strong> el nÃºmero de <strong>fallos de pÃ¡gina</strong> puede aumentar cuando el nÃºmero de marcos disponibles se incrementa.
Es lo que se conoce como la <strong>anormalidad de Belady</strong>.</p>
</div>
<div id="anormalidad_de_belady" class="imageblock">
<div class="content">
<img src="C17-memoria_virtual/media/anormalidad_de_belady.svg" alt="anormalidad de belady">
</div>
<div class="title">Figura 51. Fallos de pÃ¡gina con el algoritmo de reemplazo FIFO.</div>
</div>
<div class="paragraph">
<p>Para ilustrarlo consideraremos la siguiente traza de referencias:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5</pre>
</div>
</div>
<div class="paragraph">
<p>La <a href="#anormalidad_de_belady">Figura 51</a> muestra la curva de <strong>fallos de pÃ¡gina</strong> frente el nÃºmero de marcos.
Como se puede apreciar, el nÃºmero de <strong>fallos de pÃ¡gina</strong> con cuatro marcos es superior al nÃºmero de fallos con tres marcos, aunque era de esperar que el nÃºmero de fallos de pÃ¡ginas decrementara cuando aumenta el nÃºmero de marcos.</p>
</div>
</div>
<div class="sect4">
<h5 id="_reemplazo_Ã³ptimo">Reemplazo Ã³ptimo</h5>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>Como resultado del descubrimiento de la <strong>anormalidad de Belady</strong> se comenzÃ³ a buscar un algoritmo de reemplazo de pÃ¡gina Ã³ptimo.
Es decir:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Que tuviera la <strong>tasa de fallo de pÃ¡gina</strong> mÃ¡s baja posible.</p>
</li>
<li>
<p>Que nunca sufra de la <strong>anormalidad de Belady</strong>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ese algoritmo existe y consiste en reemplazar la pÃ¡gina que no va a ser utilizada en el mayor periodo de tiempo.</p>
</div>
<table class="tableblock frame-all grid-all stretch small">
<colgroup>
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top" colspan="20"><p class="tableblock">9 fallos de pÃ¡gina</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Desafortunadamente, el <strong>algoritmo de reemplazo Ã³ptimo</strong> es difÃ­cil de implementar puesto que necesita saber las pÃ¡ginas que serÃ¡n referenciadas en el futuro.
Por lo que sÃ³lo se usa en estudios comparativos, con el fin de saber cuÃ¡nto se aproxima al Ã³ptimo un algoritmo de reemplazo determinado.</p>
</div>
</div>
<div class="sect4">
<h5 id="_reemplazo_lru">Reemplazo LRU</h5>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>El <strong>algoritmo de reemplazo de pÃ¡gina LRU</strong> (<em>Least Recently Used</em>) es una aproximaciÃ³n del Ã³ptimo.
La hipÃ³tesis es que si una pÃ¡gina no ha sido usada durante un gran periodo de tiempo, entonces
probablemente tampoco serÃ¡ utilizada en el futuro; por lo que reemplazando la pÃ¡gina que hace mÃ¡s tiempo que no se usa, nos estarÃ­amos aproximando al algoritmo Ã³ptimo.
Vamos a ilustrarlo con un ejemplo:</p>
</div>
<table class="tableblock frame-all grid-all stretch small">
<colgroup>
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top" colspan="20"><p class="tableblock">11 fallos de pÃ¡gina</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Este algoritmo se considera bastante eficiente cuando se aplica al reemplazo de pÃ¡ginas, por lo que es utilizado con frecuencia.</p>
</div>
<div class="paragraph">
<p>Un detalle significativo es que necesita asociar cada pÃ¡gina con el momento en que fue utilizada por Ãºltima vez.
Aunque se pueden utilizar interrupciones para implementarlo por software âmonitorizando cada acceso a la memoriaâ esta soluciÃ³n es muy ineficiente, puesto que se necesitarÃ­a actualizar algunos datos en la memoria en cada referencia a una pÃ¡gina.
Por ello el reemplazo LRU es inconcebible sin apoyo del hardware.</p>
</div>
<div class="paragraph">
<p>Son posibles dos implementaciones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Utilizando contadores:</p>
<div class="openblock">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>La CPU debe tener un reloj lÃ³gico o contador que se incrementa con cada referencia
a la memoria.</p>
</li>
<li>
<p>A cada pÃ¡gina se aÃ±ade un campo de <strong>instante de uso</strong>, que se almacena en la entrada de la tabla de pÃ¡ginas correspondiente.</p>
</li>
<li>
<p>Cuando una pÃ¡gina es referenciada, el valor del contador de la CPU se almacena en
el campo de <strong>instante de uso</strong> de dicha pÃ¡gina.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>Esta implementaciÃ³n requiere que se haga una escritura en la memoria con cada referencia.
AdemÃ¡s de una bÃºsqueda por toda la tabla de pÃ¡ginas para localizar la pÃ¡gina LRU.</p>
</div>
</li>
<li>
<p>Utilizando una pila:</p>
<div class="openblock">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Se utiliza una pila de nÃºmeros de pÃ¡gina.</p>
</li>
<li>
<p>Si se referencia una pÃ¡gina, se quita el nÃºmero correspondiente de la mitad de la pila
y se inserta arriba.
Debido a esto, lo mejor es implementarla como una lista doblemente en lazada.</p>
</li>
</ol>
</div>
</div>
</div>
</li>
<li>
<p>La actualizaciÃ³n de la pila âque debe realizarse en cada referenciaâ tiene mayor coste que
en la implementaciÃ³n anterior, pues puede ser necesario cambiar hasta 6 punteros.
Sin embargo, no es necesario realizar ninguna bÃºsqueda para seleccionar la vÃ­ctima del
reemplazo, puesto que esta se puede extraer directamente del final de la pila.</p>
</li>
<li>
<p>Es una estrategia ideal para ser implementada en software o microcÃ³digo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El <strong>algoritmo reemplazo LRU</strong> pertenece a una clase denominada <strong>algoritmos de pila</strong>, que nunca se
ven afectados por la <strong>anormalidad de Belady</strong>.
En estos algoritmos, las pÃ¡ginas en memoria en un instante dado para \$N\$ marcos son un subconjunto de las que podrÃ­an haber con \$N+1\$ marcos.
Concretamente, en el <strong>algoritmo LRU</strong> las pÃ¡ginas en los marcos son las \$N\$ pÃ¡ginas mÃ¡s referenciadas recientemente.
Si el nÃºmero de marcos aumentase, estas \$N\$ pÃ¡ginas seguirÃ­an estando en memoria, pues siguen siendo las referenciadas mÃ¡s recientemente.</p>
</div>
</div>
<div class="sect4">
<h5 id="_reemplazo_lru_aproximado">Reemplazo LRU aproximado</h5>
<div class="paragraph">
<p>Pocos sistemas tienen soporte para utilizar el <strong>algoritmo de reemplazo de pÃ¡gina LRU</strong>.
Incluso en algunos casos no hay soporte de ningÃºn tipo, por lo que no queda mÃ¡s remedio que utilizar el remplazo FIFO.</p>
</div>
<div class="paragraph">
<p>Sin embargo, muchos proporcionan algo de ayuda en la forma de un <strong>bit de referencia</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cada entrada de la tabla de pÃ¡ginas tiene un <strong>bit de referencia</strong>.</p>
</li>
<li>
<p>El hardware pone a 1 el <strong>bit de referencia</strong> cada vez que se referencia a una pÃ¡gina.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Con el <strong>bit de referencia</strong> no podemos saber con exactitud el instante pero si que una pÃ¡gina ha sido
referenciada recientemente.
UtilizÃ¡ndolo, podemos implementar diversas aproximaciones al algoritmo LRU.</p>
</div>
<div class="sect5">
<h6 id="_reemplazo_nru">Reemplazo NRU</h6>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>En el <strong>algoritmo de reemplazo de pÃ¡gina NRU</strong> se utiliza el <strong>bit de referencia</strong> de la siguiente manera:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>En intervalos regulares de tiempo, todos los <strong>bits de referencia</strong> son puestos a cero por el sistema operativo.</p>
</li>
<li>
<p>SegÃºn los procesos se van ejecutando, el <strong>bit de referencia</strong> asociado a cada pÃ¡gina se pone a 1
por el hardware, al ser referenciadas.</p>
</li>
<li>
<p>Cuando haya que escoger una pÃ¡gina para ser reemplazada, se intenta seleccionar una que no haya sido referenciada âes decir, con el bit de referencia a 0â.</p>
</li>
<li>
<p>En caso de que hayan varias alternativas entre las que elegir se puede utilizar el <strong>algoritmo de reemplazo de pÃ¡gina FIFO</strong> o escoger un aleatoriamente.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Vamos a ilustrarlo con un ejemplo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Utilizaremos 3 marcos de pÃ¡gina.</p>
</li>
<li>
<p>Indicaremos el valor del bit de referencia con un superÃ­ndice junto al nÃºmero de pÃ¡gina.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>No debemos olvidar que en caso de que ocurra un fallo de pÃ¡gina, despuÃ©s de la carga de la pÃ¡gina se reinicia la instrucciÃ³n que generÃ³ dicho fallo.
Por lo tanto, habrÃ¡ un acceso que pondrÃ¡ el <strong>bit de referencia a 1</strong>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>Marcaremos con una flecha el instante de tiempo en el que todos los bits de referencia se
ponen a cero.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En un sistema operativo real los bits son desplazados en intervalos fijos de tiempo.
Pero esto no tiene que coincidir con una cantidad fija de referencias en la traza, puesto que hemos eliminado las referencias consecutivas a una misma pÃ¡gina.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>En caso de coincidencia, utilizaremos el <strong>reemplazo FIFO</strong> para seleccionar la vÃ­ctima.</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch small">
<colgroup>
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">â</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">â</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">â</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">â</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">â</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>0</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top" colspan="20"><p class="tableblock">11 fallos de pÃ¡gina</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Se puede mejorar el algoritmo anterior considerando tanto el <strong>bit de referencia</strong> como el <strong>bit de modificado</strong>, para clasificar las pÃ¡ginas en distintas categorÃ­as y escoger una pÃ¡gina en la mejor categorÃ­a.
Este es el tipo mÃ¡s comÃºn de <strong>algoritmo de reemplazo de pÃ¡gina NRU</strong>, pero lo veremos en el <a href="#_algoritmo_de_la_segunda_oportunidad_mejorado">Apartado 17.4.1.5.4</a> bajo el nombre de <strong>Algoritmo de la segunda oportunidad mejorado</strong>.</p>
</div>
</div>
<div class="sect5">
<h6 id="_con_bits_de_referencia_adicionales">Con bits de referencia adicionales</h6>
<div class="paragraph">
<p>Podemos obtener informaciÃ³n adicional sobre el orden en que se realizan las referencias, guardando los <strong>bits de referencia</strong> en intervalos periÃ³dicos de tiempo.
El <strong>reemplazo LRU aproximado con bits de referencia adicionales</strong>, o de <strong>envejecimiento</strong>, consiste en lo siguiente:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A parte del <strong>bit de referencia</strong>, cada pÃ¡gina tiene un conjunto de <strong>bits de referencia adicionales</strong> âpor ejemplo, 8 bitsâ que se guardan en alguna tabla interna que mantiene el sistema operativo.</p>
</li>
<li>
<p>A intervalos regulares âpor ejemplo, cada 100 ms.â el sistema operativo desplaza los <strong>bits de referencia adicionales</strong> de cada pÃ¡gina; insertando el <strong>bit de referencia</strong> de la pÃ¡gina en el bit de orden mÃ¡s alto y descartando el bit de orden mÃ¡s bajo.</p>
</li>
<li>
<p>Cuando haya que escoger una pÃ¡gina para ser reemplazada se escoge la que tenga el valor mÃ¡s pequeÃ±o en el conjunto de <strong>bits de referencia adicionales</strong>.
Esto es asÃ­, puesto que dicho conjunto contiene la historia de referencias de la pÃ¡gina.
Por ejemplo, \${1 1 0 0 0 1 0 0}\$ es mÃ¡s reciente que \${0 1 1 1 0 1 1 1}\$.</p>
</li>
<li>
<p>Se puede utilizar el <strong>algoritmo de reemplazo de pÃ¡gina FIFO</strong> o escoger un aleatoriamente, si dos pÃ¡ginas tienen el mismo valor.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Vamos a ilustrarlo con un ejemplo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Utilizaremos 3 marcos de pÃ¡gina.</p>
</li>
<li>
<p>Utilizaremos 2 bits adicionales.</p>
</li>
<li>
<p>Indicaremos el valor del <strong>bit de referencia</strong> y de los <strong>bits adicionales</strong> con un superÃ­ndice junto al nÃºmero de pÃ¡gina.</p>
</li>
<li>
<p>Marcaremos con una flecha el instante de tiempo en el que los bits son desplazados por el sistema operativo.</p>
</li>
<li>
<p>En caso de coincidencia, utilizaremos el <strong>reemplazo FIFO</strong> para seleccionar la vÃ­ctima.</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch small">
<colgroup>
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">â</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">â</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">â</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">â</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">â</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>0|10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1|10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1|10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>0|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>0|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>0|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>0|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>0|11</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1|10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1|10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1|10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>0|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>0|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>0|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>0|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1|11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1|11</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>0|10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>0|10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>0|10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>0|01</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>0|10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>0|10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>0|10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1|00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1|00</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top" colspan="20"><p class="tableblock">10 fallos de pÃ¡gina</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>El nÃºmero de <strong>bits adicionales</strong> puede variar de una implementaciÃ³n a otra, pero en cualquier caso debe ser seleccionado para realizar la actualizaciÃ³n lo mÃ¡s rÃ¡pidamente posible, teniendo en cuenta las caracterÃ­sticas del hardware.
En un caso extremo, el nÃºmero de <strong>bits de referencia adicionales</strong> podrÃ­a ser cero, dejando solo el <strong>bit de referencia</strong>.
A este algoritmo se lo conoce como el <strong>algoritmo de la segunda oportunidad</strong>.</p>
</div>
</div>
<div class="sect5">
<h6 id="_algoritmo_de_la_segunda_oportunidad">Algoritmo de la segunda oportunidad</h6>
<div class="paragraph">
<p>



</p>
</div>
<div class="paragraph">
<p>El <strong>algoritmo de reemplazo de la segunda oportunidad</strong> o del <strong>reloj</strong> es un <strong>algoritmo de reemplazo de pÃ¡gina FIFO</strong>, pero donde una pÃ¡gina es seleccionada considerando el <strong>bit de referencia</strong>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Cuando es necesario seleccionar una vÃ­ctima para reemplazo se extrae una pÃ¡gina de la cola FIFO.
Esta cola contiene todas las pÃ¡ginas con marcos asignados y en el orden en que fueron cargadas, como ocurre con el <strong>algoritmo FIFO de reemplazo</strong>.</p>
</li>
<li>
<p>Si el <strong>bit de referencia</strong> estÃ¡ a 0, se utiliza esta pÃ¡gina para reemplazo.</p>
</li>
<li>
<p>Si el <strong>bit de referencia</strong> estÃ¡ a 1:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Se pone el <strong>bit de referencia</strong> a 0 y se vuelve a insertar la pÃ¡gina en el final de la cola.</p>
</li>
<li>
<p>Se extrae la siguiente pagina del principio de la cola y se vuelve al punto 2.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>De este esquema podemos destacar algunos aspectos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Una pÃ¡gina a la que se le da la segunda oportunidad, no serÃ¡ reemplazada hasta que no se le de la segunda oportunidad a todas las demÃ¡s; siempre que no sea referenciada antes y el <strong>bit de referencia</strong> se vuelva a poner a 1.</p>
</li>
<li>
<p>En el peor de los casos, cuando todas las pÃ¡ginas tienen sus bits a uno, degenera en un reemplazo FIFO.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Vamos a ilustrarlo con un ejemplo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Utilizaremos 3 marcos de pÃ¡gina.</p>
</li>
<li>
<p>Indicaremos el valor del <strong>bit de referencia</strong> con un superÃ­ndice junto al nÃºmero de pÃ¡gina en el marco.</p>
</li>
<li>
<p>Indicaremos el principio de la cola con una flecha junto al nÃºmero de pÃ¡gina.</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch small">
<colgroup>
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â2<sup>0</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">â</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â0<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â0<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â3<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>0</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â4<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top" colspan="20"><p class="tableblock">11 fallos de pÃ¡gina</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect5">
<h6 id="_algoritmo_de_la_segunda_oportunidad_mejorado">Algoritmo de la segunda oportunidad mejorado</h6>
<div class="paragraph">
<p>Se puede mejorar el <strong>algoritmo de la segunda oportunidad</strong> considerando tanto el <strong>bit de referencia</strong> como el <strong>bit de modificado</strong>.
Algunos autores denominan a este algoritmo como <strong>algoritmo de la segunda oportunidad mejorado</strong>, mientras otro lo llaman <strong>NRU</strong>,
ya que es una versiÃ³n mejorada del algoritmo del <a href="#_reemplazo_nru">Apartado 17.4.1.5.1</a>.</p>
</div>
<div class="paragraph">
<p>Con esos dos bits, el sistema operativo clasifica las pÃ¡ginas en una de las siguientes cuatro clases:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>(0,0) ni recientemente usado ni modificado. Las pÃ¡ginas de esta clase son las mejores para ser
reemplazadas.</p>
</li>
<li>
<p>(0,1) no usado recientemente pero modificado. No es una buena elecciÃ³n puesto que hay que
escribir primero la pÃ¡gina al disco antes del reemplazo.</p>
</li>
<li>
<p>(1,0) recientemente usado pero no modificado.
Probablemente serÃ¡ usada de nuevo en un corto espacio de tiempo.</p>
</li>
<li>
<p>(1,1) usada y modificada.
SerÃ¡ utilizada pronto y la pÃ¡gina tendrÃ­a que ser escrita a disco para ser reemplazada.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Cuando el reemplazo de pÃ¡gina es invocado:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se examina la clase a la que pertenece cada pÃ¡gina y se reemplaza un pÃ¡gina en la clase de menor importancia que no estÃ© vacÃ­a.
Indudablemente, deberemos examinar la lista varias veces antes encontrar la pÃ¡gina que debe ser reemplazada.</p>
</li>
<li>
<p>A intervalos regulares los <strong>bits de referencia</strong> de todas las pÃ¡ginas son puestos a cero por el sistema operativo.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En un sistema real, el sistema operativo escribe las pÃ¡ginas modificadas en el almacenamiento secundario cuando estÃ¡ desocupado y luego pone el <strong>bit de modificado</strong> a 0.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Vamos a ilustrarlo con un ejemplo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Utilizaremos 3 marcos de pÃ¡gina.</p>
</li>
<li>
<p>El que la referencia a la memoria sea para lectura <strong>R</strong> o escritura <strong>W</strong> vendrÃ¡ indicado junto al nÃºmero de pÃ¡gina en la traza.</p>
</li>
<li>
<p>Marcaremos con una flecha el instante de tiempo en el que todos los bits de referencia se ponen a cero.</p>
</li>
<li>
<p>Indicaremos el valor del <strong>bit de referencia</strong> y del <strong>bit de modificado</strong> con un superÃ­ndice junto al nÃºmero de pÃ¡gina en el marco.</p>
</li>
<li>
<p>Indicaremos el principio de la cola con una flecha junto al nÃºmero de pÃ¡gina.
Sirve para mantener un orden en las pÃ¡ginas, de tal forma que si hay varios candidatos de la misma categorÃ­a, se escoja el primero encontrado.
Si la elecciÃ³n en caso de varios candidatos es aleatoria, por ejemplo, no hace falta ese puntero.</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch small">
<colgroup>
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">â</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">â</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">â</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">â</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">â</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7r</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0r</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1w</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2r</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0r</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2r</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0w</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2r</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4w</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0w</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2r</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0r</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1r</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3w</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0r</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1r</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2w</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7w</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0r</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1r</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â7<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â2<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â2<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â2<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>01</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>01</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>01</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>01</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>10</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">â</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â0<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â0<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â0<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â0<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â0<sup>01</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>01</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>01</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â1<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â1<sup>00</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â1<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â1<sup>10</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â7<sup>11</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>01</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>01</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>01</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>01</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â1<sup>01</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>01</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â0<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â0<sup>01</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â0<sup>11</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>11</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top" colspan="20"><p class="tableblock">11 fallos de pÃ¡gina</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_reemplazo_basado_en_contador">Reemplazo basado en contador</h5>
<div class="paragraph">
<p>Otros algoritmos utilizan un contador del nÃºmero de referencias que son realizadas a cada pÃ¡gina.
En esos casos, la elecciÃ³n de la vÃ­ctima se puede realizar utilizando dos esquemas: la que tiene el valor mayor o el menor.
Ninguno de los dos es muy comÃºn, ya que su implementaciÃ³n es costosa y no son una buena aproximaciÃ³n del Ã³ptimo.</p>
</div>
<div class="paragraph">
<p>Por lo general, la actualizaciÃ³n del contador no la realiza la CPU, ya que leer la entrada de la pÃ¡gina, incrementar el contador y volver a guardar la entrada, tiene un coste importante.
En su lugar:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>El contador de cada pÃ¡gina se guarda en una tabla interna.</p>
</li>
<li>
<p>PeriÃ³dicamente el sistema operativo examina el <strong>bit de referencia</strong> de cada pÃ¡gina y si estÃ¡ a 1, incrementa el contador de la pÃ¡gina correspondiente.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>El mayor problema es que permite hacer el seguimiento de la frecuencia con la que se usan las pÃ¡ginas pero no tiene en cuenta el periodo durante el que se usan.
Por ejemplo, los procesos durante su inicializaciÃ³n pueden usar intensamente ciertas pÃ¡ginas y despuÃ©s no necesitarlas mÃ¡s.
Debido a que esas pÃ¡ginas ha sido utilizadas intensamente, tiene un contador de referencias con un valor muy alto, por lo que son mantenidas en memoria aunque no vaya a ser utilizadas.</p>
</div>
<div class="paragraph">
<p>La soluciÃ³n es utilizar el <strong>algoritmo LRU aproximado con bits de referencia adicionales</strong> (vÃ©ase <a href="#_con_bits_de_referencia_adicionales">Apartado 17.4.1.5.2</a>) ya que tiene un coste muy similar a este y prioriza las usadas mÃ¡s recientemente sobre las que fueron usadas con mucha frecuencia en el pasado.</p>
</div>
<div class="sect5">
<h6 id="_reemplazo_lfu">Reemplazo LFU</h6>
<div class="paragraph">
<p>


</p>
</div>
<div class="paragraph">
<p>En el <strong>algoritmo de reemplazo de pÃ¡gina LFU</strong> (<em>Least Frequently Used</em>) o <strong>NFU</strong>  (<em>Not Frequently Used</em>) se escoge la pÃ¡gina con el contador mÃ¡s bajo.
Esto es asÃ­ puesto que suponemos que las pÃ¡ginas menos referenciadas son las que no se estÃ¡n utilizando de forma mÃ¡s activa.</p>
</div>
<div class="paragraph">
<p>Vamos a ilustrarlo con un ejemplo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Indicaremos el valor de los contadores con un superÃ­ndice junto al nÃºmero de pÃ¡gina.</p>
</li>
<li>
<p>En caso de coincidencia, utilizaremos el reemplazo <strong>FIFO</strong> para seleccionar la vÃ­ctima.</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch small">
<colgroup>
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>0</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>2</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>2</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>3</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>3</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>3</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>4</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>4</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>4</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>4</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>4</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>4</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>5</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>5</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>5</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>5</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>2</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>2</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>3</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>3</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>3</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>4</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>4</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>5</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>5</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>5</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>6</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>6</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>6</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>6</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>7</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>7</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top" colspan="20"><p class="tableblock">12 fallos de pÃ¡gina</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect5">
<h6 id="_reemplazo_mfu">Reemplazo MFU</h6>
<div class="paragraph">
<p>En el <strong>algoritmo de reemplazo de pÃ¡gina MFU</strong> (<em>Most Frequently Used</em>), se escoge la pÃ¡gina con el contador mÃ¡s alto.
Se basa en el argumento de que la pÃ¡gina con el contador mÃ¡s pequeÃ±o probablemente acaba de ser traÃ­da, por lo que aÃºn no ha sido utilizada.</p>
</div>
<div class="paragraph">
<p>Vamos a ilustrarlo con un ejemplo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Indicaremos el valor de los contadores con un superÃ­ndice junto al nÃºmero de pÃ¡gina.</p>
</li>
<li>
<p>En caso de coincidencia, utilizaremos el reemplazo <strong>FIFO</strong> para seleccionar la vÃ­ctima.</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch small">
<colgroup>
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>2</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>2</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>3</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>3</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>2</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>2</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>2</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>2</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>3</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>3</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7<sup>1</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>1</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<sup>2</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<sup>1</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top" colspan="20"><p class="tableblock">13 fallos de pÃ¡gina</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Por extraÃ±a que parezca esta polÃ­tica, suele ser mÃ¡s eficiente que el <strong>LRU</strong> cuando se utiliza en las aplicaciones de almacenamiento de datos, porque algunas las pÃ¡ginas se utilizan intensamente durante breves periodos de tiempo pero estÃ¡n un tiempo sin utilizarse.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_algoritmos_de_buffering_de_pÃ¡ginas">17.4.2. Algoritmos de buffering de pÃ¡ginas</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Existen otros procedimientos que pueden ser utilizados, junto con alguno de los <strong>algoritmos de reemplazo</strong> comentados, con el objetivo de mejorar su eficiencia.
Estos procedimientos se agrupan dentro de lo que se denomina <strong>algoritmos de <em>buffering</em> de pÃ¡ginas</strong>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se puede mantener una lista de marcos libres.
Cuando se produce un <strong>fallo de pagina</strong> se escoge un marco de la lista y se carga la pÃ¡gina, al tiempo que se selecciona una pÃ¡gina como vÃ­ctima y se copia al disco.</p>
<div class="paragraph">
<p>Esto permite que el proceso se reinicie lo antes posible, sin esperar a que la pÃ¡gina reemplazada sea escrita en el disco.
Posteriormente, cuando la escritura finalice, el marco es incluido en la lista de marcos libres.</p>
</div>
</li>
<li>
<p>Recordar quÃ© pÃ¡gina estuvo en cada marco antes de que Ã©ste pasara a la lista de marcos libres, serÃ­a una mejora de lo anterior.
De esta forma las pÃ¡ginas podrÃ­an ser recuperadas directamente desde la lista, si fallara alguna antes de que su marco sea utilizado por otra pÃ¡gina.</p>
<div class="paragraph">
<p>Esto permite reducir los efectos de que el <strong>algoritmo de reemplazo</strong> escoja una vÃ­ctima equivocada.</p>
</div>
</li>
<li>
<p>Se puede mantener una lista de pÃ¡ginas modificadas e ir escribiÃ©ndolas cuando el dispositivo del espacio de intercambio no estÃ© ocupado.</p>
<div class="paragraph">
<p>Este esquema aumenta la probabilidad de que una pÃ¡gina no estÃ© marcada como modificada âcon el <strong>bit de modificado</strong>â cuando sea seleccionada por el algoritmo de reemplazo, evitando tener que hacer en ese momento la escritura en disco.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_reemplazo_local_frente_a_global">17.4.3. Reemplazo local frente a global</h4>
<div class="paragraph">
<p>Cuando un proceso necesita un marco, el algoritmo de reemplazo puede, tanto extraerlo de cualquier proceso, como ser obligado a considerar sÃ³lo aquellas pÃ¡ginas que pertenecen al proceso que generÃ³ el fallo.
Eso permite clasificar los algoritmos de reemplazo en dos categorÃ­as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En el <strong>reemplazo local</strong> sÃ³lo se pueden escoger marcos de entre los asignados al proceso.
Por tanto:</p>
<div class="ulist">
<ul>
<li>
<p>El nÃºmero de marcos asignados a un proceso no cambia por que ocurran <strong>fallos de pÃ¡gina</strong>.</p>
</li>
<li>
<p>El mayor inconveniente es que un proceso no puede hacer disponible a otros procesos los marcos de memoria que menos utiliza.</p>
</li>
</ul>
</div>
</li>
<li>
<p>En el <strong>reemplazo global</strong> se pueden escoger marcos de entre todos los del sistema, independientemente de que estÃ©n asignados a otro proceso o no.
Por tanto:</p>
<div class="ulist">
<ul>
<li>
<p>El nÃºmero de marcos asignados a un proceso puede aumentar si durante los <strong>fallos de pÃ¡gina</strong> se seleccionan marcos de otros procesos.</p>
</li>
<li>
<p>El mayor inconveniente es que los procesos no pueden controlar su <strong>tasa de fallos de pÃ¡gina</strong>, puesto que esta depende del comportamiento de los otros procesos, pudiendo afectar a su tiempo de ejecuciÃ³n de forma significativa.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Generalmente, el <strong>reemplazo global</strong> proporciona mayor rendimiento, por lo que es el mÃ©todo mÃ¡s utilizado.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_asignaciÃ³n_de_marcos_de_pÃ¡gina">17.5. AsignaciÃ³n de marcos de pÃ¡gina</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>La cuestiÃ³n que queda por resolver es cÃ³mo repartir los marcos de memoria fÃ­sica libre entre los diferentes procesos, con el fin de cubrir las necesidades de reemplazo de cada uno de ellos.
Posibles soluciones a esto serÃ­an: repartir la memoria por igual entre todos los procesos o hacerlo en proporciÃ³n a la cantidad de memoria virtual que utilizan.</p>
</div>
<div class="paragraph">
<p>Sin embargo, intuitivamente parece interesante intentar estimar de alguna manera el <strong>mÃ­nimo nÃºmero de marcos</strong> que realmente necesita cada proceso.
AsÃ­, si a cada proceso se le proporciona el nÃºmero mÃ­nimo de marcos necesario, el sistema podrÃ­a disponer de memoria libre para aumentar el nÃºmero de procesos âaumentando el uso de la CPUâ o para dedicarla a otras funciones âcomo es el caso de los bÃºferes y las cachÃ©s de E/Sâ.</p>
</div>
<div class="paragraph">
<p>El <strong>mÃ­nimo nÃºmero de marcos</strong> viene establecido por diversos factores:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cuando ocurre un fallo de pÃ¡gina, la instrucciÃ³n que la ha provocado, debe ser reiniciada despuÃ©s de cargar la pÃ¡gina en un marco libre.
Por lo tanto, un proceso debe disponer de suficientes marcos como para guardar todas las pÃ¡ginas a las que una Ãºnica instrucciÃ³n pueda acceder pues, de lo contrario, el proceso nunca podrÃ­a ser reiniciado al fallar permanentemente en alguno de los acceso a memoria de la instrucciÃ³n.
Obviamente, este lÃ­mite viene establecido por la arquitectura de la mÃ¡quina.</p>
</li>
<li>
<p>Todo proceso tiene una cierta cantidad de pÃ¡ginas que en cada instante son utilizadas frecuentemente.
Si el proceso no dispone de suficientes marcos como para alojar dichas pÃ¡ginas, generarÃ¡ fallos de pÃ¡gina con demasiada frecuencia.
Esto afecta negativamente al rendimiento del sistema, por lo que es conveniente que el sistema asigne al nÃºmero de marcos necesario para que eso no ocurra.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>En general, si se va reduciendo el nÃºmero de marcos asignados a un proceso, mucho antes de haber alcanzado el mÃ­nimo establecido por la arquitectura, el proceso dejarÃ¡ de ser Ãºtil debido a la elevada <strong>tasa de fallos de pÃ¡gina</strong>, que serÃ¡ mayor cuantos menos marcos tenga asignados.
Cuando eso ocurre se dice que el proceso estÃ¡ <strong>hiperpaginando</strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_hiperpaginaciÃ³n">17.6. HiperpaginaciÃ³n</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Se dice que un proceso sufre de <strong>hiperpaginaciÃ³n</strong> cuando gasta mÃ¡s tiempo paginando que ejecutÃ¡ndose.</p>
</div>
<div class="sect3">
<h4 id="_causas_de_la_hiperpaginaciÃ³n">17.6.1. Causas de la hiperpaginaciÃ³n</h4>
<div class="paragraph">
<p>En los primeros sistemas multiprogramados que implementaron la paginaciÃ³n bajo demanda, era posible que se diera el siguiente caso:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>El sistema operativo monitorizaba el uso de la CPU.
Si el uso de la misma era bajo, se cargaban nuevos procesos desde la <strong>cola de entrada</strong> para aumentar el nÃºmero de procesos ejecutÃ¡ndose al mismo tiempo âtambiÃ©n llamado <strong>grado de multiprogramaciÃ³n</strong> en esos sistemasâ.</p>
</li>
<li>
<p>Si un proceso necesitaba demasiada memoria, le podÃ­a quitar los marcos a otro, puesto que se utilizaba un <strong>algoritmo de reemplazo global</strong>.
Esto podÃ­a ocasionar que aumentara la <strong>tasa de fallos de pÃ¡gina</strong> del proceso que perdÃ­a los marcos.</p>
</li>
<li>
<p>Al aumentar los <strong>fallos de pagina</strong> el uso de la CPU decrecÃ­a, por lo que el sistema operativo cargaba mÃ¡s procesos para aumentar el <strong>grado de multiprogramaciÃ³n</strong> y con ello el uso de la CPU.</p>
</li>
<li>
<p>Esto reducÃ­a la cantidad de memoria disponible para cada proceso, lo que aumentaba la <strong>tasa de fallos de pÃ¡ginas</strong>, que nuevamente reducÃ­a el uso de la CPU.</p>
</li>
<li>
<p>Este mecanismo iteraba hasta reducir considerablemente el rendimiento del sistema.</p>
</li>
</ol>
</div>
<div id="hiperpaginaciÃ³n" class="imageblock">
<div class="content">
<img src="C17-memoria_virtual/media/hiperpaginaciÃ³n.svg" alt="hiperpaginaciÃ³n">
</div>
<div class="title">Figura 52. HiperpaginaciÃ³n en sistemas multiprogramados.</div>
</div>
<div class="paragraph">
<p>El fenÃ³meno comentado, se ilustra en la <a href="#hiperpaginaciÃ³n">Figura 52</a>, donde se muestra el uso de la CPU frente al nÃºmero de procesos cargados en el sistema.
Cuando esto Ãºltimo aumenta, el uso de la CPU aumenta hasta alcanzar un mÃ¡ximo.
Si el <strong>grado de multiprogramaciÃ³n</strong> supera dicho punto, el sistema comienza a <strong>hiperpaginar</strong>, por lo que el uso de la CPU disminuye bruscamente.
Por lo tanto, si el sistema estÃ¡ <strong>hiperpaginando</strong>, es necesario reducir el <strong>grado de multiprogramaciÃ³n</strong> con el objetivo de liberar memoria.</p>
</div>
<div class="paragraph">
<p>En los sistemas operativos modernos ocurre algo parecido a lo descrito para los sistemas multiprogramados, aunque sin el efecto en cadena ocasionado por el intento del planificador de largo plazo de maximizar el uso de la CPU, ya que estos sistemas carecen de dicho planificador.
Sea como fuere, en ambos casos, los procesos <strong>hiperpaginan</strong> si no se les asigna un nÃºmero suficiente de marcos, haciendo que sea imposible utilizarlos.</p>
</div>
</div>
<div class="sect3">
<h4 id="_soluciones_a_la_hiperpaginaciÃ³n">17.6.2. Soluciones a la hiperpaginaciÃ³n</h4>
<div class="paragraph">
<p>Para el problema de la <strong>hiperpaginaciÃ³n</strong> existen diversas soluciones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Utilizar un algoritmo de reemplazo local, pues de esta manera un proceso que <strong>hiperpagina</strong> no puede afectar a otro.</p>
<div class="paragraph">
<p>Sin embargo, esto no es cierto del todo.
El uso intensivo del <strong>dispositivo de intercambio</strong> podrÃ­a afectar al rendimiento del sistema, al aumentar el <strong>tiempo de acceso efectivo</strong> al disco.</p>
</div>
</li>
<li>
<p>Proporcionar a un proceso tantos marcos como le hagan falta.
Como ya hemos comentados en diversas ocasiones, para evitar la <strong>hiperpaginaciÃ³n</strong> es necesario asignar al procesos al menos un nÃºmero mÃ­nimos de marcos, que a priori no es conocido.
Una de las estrategias que pretenden estimar dicho nÃºmero es el <strong>modelo de conjunto de trabajo</strong>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_modelo_del_conjunto_de_trabajo">17.6.3. Modelo del conjunto de trabajo</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Para entender el modelo de conjunto de trabajo es necesario comenzar definiendo el <strong>modelo de localidad</strong>.
El <strong>modelo de localidad</strong> establece que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Una <strong>localidad</strong> es un conjunto de pÃ¡ginas que se utilizan juntas.</p>
</li>
<li>
<p>Cuando un proceso se ejecuta, se va moviendo de una <strong>localidad</strong> a otra.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Por ejemplo, cuando se invoca una funciÃ³n se define una nueva <strong>localidad</strong>.
En esta <strong>localidad</strong> las referencias a la memoria se realizan: al cÃ³digo de la funciÃ³n, a las variables locales de la misma y a algunas variables globales del programa.</p>
</div>
<div class="paragraph">
<p>Supongamos que proporcionamos a un proceso suficientes marcos como para alojar toda su <strong>localidad</strong> en un momento dado.
Entonces, el proceso generarÃ¡ <strong>fallos de pÃ¡gina</strong> hasta que todas las pÃ¡ginas de su <strong>localidad</strong> estÃ©n cargadas.
DespuÃ©s de eso no volverÃ¡ a fallar hasta que no cambie a una nueva <strong>localidad</strong>.
Sin embargo, si damos al proceso menos marcos de los que necesita su <strong>localidad</strong>, Ã©ste <strong>hiperpaginarÃ¡</strong>.</p>
</div>
<div class="paragraph">
<p>El <strong>modelo de conjunto de trabajo</strong> es una estrategia que permite obtener una aproximaciÃ³n de la <strong>localidad</strong> del programa y consiste en lo siguiente:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Definir el parÃ¡metro \$Delta\$ como el tamaÃ±o de la <strong>ventana del conjunto de trabajo</strong>.</p>
</li>
<li>
<p>En un instante dado, el conjunto de pÃ¡ginas presente en las \$Delta\$ Ãºltimas referencias a la memoria se consideran el <strong>conjunto de trabajo</strong>.</p>
</li>
<li>
<p>Por lo tanto, el <strong>conjunto de trabajo</strong> es una aproximaciÃ³n de <strong>localidad</strong> del programa.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Por ejemplo, dada la siguiente lista de referencias a pÃ¡ginas en la memoria:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="C17-memoria_virtual/media/modelo_de_conjunto_de_trabajo.svg" alt="modelo de conjunto de trabajo">
</div>
</div>
<div class="paragraph">
<p>si \$Delta = 10\$ referencias a la memoria, entonces el conjunto de trabajo en \$t_1\$ es \${1, 2, 5, 6, 7}\$.
Mientras que en \$t_2\$ el conjunto de trabajo es \${3, 4}\$.</p>
</div>
<div class="paragraph">
<p>Obviamente, la precisiÃ³n del <strong>conjunto de trabajo</strong> como aproximaciÃ³n de la <strong>localidad</strong> del programa depende del parÃ¡metro \$Delta\$.
Por ejemplo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Si \$Delta\$ es muy pequeÃ±a, el <strong>conjunto de trabajo</strong> no cubrirÃ­a toda la <strong>localidad</strong>.</p>
</li>
<li>
<p>Si \$Delta\$ es muy grande, el <strong>conjunto de trabajo</strong> se superpondrÃ­a a varias <strong>localidades</strong>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_uso_del_conjunto_del_trabajo_para_evitar_la_hiperpaginaciÃ³n">17.6.4. Uso del conjunto del trabajo para evitar la hiperpaginaciÃ³n</h4>
<div class="paragraph">
<p>El uso del conjunto de trabajo es bastante sencillo:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Los diseÃ±adores del sistema seleccionan \$Delta\$.</p>
</li>
<li>
<p>El sistema operativo monitoriza el <strong>conjunto de trabajo</strong> de cada proceso y le asigna tantos marcos como pÃ¡ginas haya en el <strong>conjunto de trabajo</strong>.</p>
</li>
<li>
<p>Si sobran suficientes marcos otro proceso puede ser iniciado âen el caso de los sistemas multiprogramadosâ o se puede destinar la memoria libre a otros usos.</p>
</li>
<li>
<p>Si el <strong>tamaÃ±o del conjunto de trabajo</strong> total \$WSS\$ crece y excede el nÃºmero de marcos disponibles, el sistema podrÃ­a seleccionar un proceso para ser suspendido.
Ãste podrÃ¡ volver a ser reiniciado mÃ¡s tarde.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Donde el <strong>tamaÃ±o del conjunto de trabajo</strong> \$WSS\$ es la suma del <strong>tamaÃ±o de los conjuntos de trabajo</strong> \$WSS_i\$ para cada proceso \$i\$:</p>
</div>
<div class="stemblock">
<div class="content">
\$WSS=sum WSS_i\$
</div>
</div>
<div class="paragraph">
<p>y representa la demanda total de marcos.
Por eso, si \$WSS\$ es mayor que el nÃºmero de marcos disponibles, habrÃ¡ <strong>hiperpaginaciÃ³n</strong>.</p>
</div>
<div class="paragraph">
<p>El sencillo algoritmo anterior permite evitar la <strong>hiperpaginaciÃ³n</strong>.
Sin embargo, el problema estÃ¡ en como mover la <strong>ventana del conjunto de trabajo</strong> en cada referencia, con el fin de volver a calcular el <strong>conjunto de trabajo</strong>.
Una posible aproximaciÃ³n serÃ­a utilizar un temporizador que periÃ³dicamente invocase a una funciÃ³n encargada de examinar el <strong>bit de referencia</strong> de las pÃ¡ginas en la ventana \$Delta\$.
Es de suponer que las pÃ¡ginas con el <strong>bit de referencia</strong> a 1 forman parte de la <strong>localidad</strong> del programa y por tanto serÃ¡n el <strong>conjunto de trabajo</strong> a lo largo del siguiente periodo.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_otras_consideraciones">17.7. Otras consideraciones</h3>
<div class="paragraph">
<p>Ya hemos comentado que las principales decisiones que deben ser tomadas en el diseÃ±o de un sistema con <strong>paginaciÃ³n bajo demanda</strong> son la elecciÃ³n del <strong>algoritmo de reemplazo</strong> y la de la <strong>asignaciÃ³n de marcos de pÃ¡gina</strong>.
Sin embargo, hay otras consideraciones que deben ser tenidas en cuenta.</p>
</div>
<div class="sect3">
<h4 id="_prepaginado">17.7.1. Prepaginado</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El <strong>prepaginado</strong> es una tÃ©cnica que consiste en cargar mÃºltiples pÃ¡ginas junto con la pÃ¡gina demandada en cada <strong>fallo de pÃ¡gina</strong>.</p>
</div>
<div class="paragraph">
<p>Esas otras pÃ¡ginas se escogen especulativamente bajo la hipÃ³tesis de que van a ser necesitadas por el proceso en un corto espacio de tiempo.
De manera que si la predicciÃ³n es acertada, la <strong>tasa de fallos de pÃ¡gina</strong> se reduce significativamente.
Esta tÃ©cnica puede ser utiliza, por ejemplo, en las siguiente situaciones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En la <strong>paginaciÃ³n bajo demanda pura</strong>, el sistema sabe de antemano que cuando se inicia un proceso siempre fallan las primeras pÃ¡ginas de cÃ³digo, por lo que son buenas candidatas para el <strong>prepaginado</strong>.</p>
</li>
<li>
<p>En el acceso secuencial a <strong>archivos mapeados en memoria</strong>.</p>
<div class="paragraph">
<p>El sistema puede determinar que el acceso va ser de tipo secuencial, tanto mediante el uso de tÃ©cnicas heurÃ­sticas como mediante las opciones indicadas por el proceso en la llamada al sistema con la que se abriÃ³ el archivo.</p>
</div>
<div class="paragraph">
<p>En cualquier caso, si el sistema determina que el acceso al archivo es secuencial, en cada <strong>fallo de pÃ¡gina</strong> puede cargar tanto la pÃ¡gina demanda como las siguientes, en previsiÃ³n de que vayan a ser utilizas por el proceso.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>En general, el Ãºnico inconveniente del <strong>prepaginado</strong> es que debe ser ajustado para que el coste del mismo sea inferior al de servir los <strong>fallos de pÃ¡gina</strong>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_aplicaciones_en_modo_raw">17.7.2. Aplicaciones en modo RAW</h4>
<div class="paragraph">
<p>Algunas aplicaciones, cuando acceden sus datos a travÃ©s de los mecanismos de memoria virtual del sistema operativo, ofrecen peor rendimiento del que conseguirÃ­an si este mecanismo no existiera.</p>
</div>
<div class="paragraph">
<p>El ejemplo tÃ­pico, son los gestores de bases de datos, que conocen sus necesidades de memoria y disco mejor que cualquier sistema operativo de propÃ³sito general, por lo que salen beneficiadas si implementan sus propios algoritmos de gestiÃ³n de la memoria y de <em>buffering</em> de E/S.</p>
</div>
<div class="paragraph">
<p>Por eso muchos sistemas operativos modernos permiten que los programas que lo soliciten puedan acceder a los discos en <strong>modo RAW</strong>.
En el <strong>modo RAW</strong> no hay sistema de archivos, ni paginaciÃ³n bajo demanda, ni bloqueo de archivos, ni prepaginaciÃ³n, ni muchos otros servicios del sistema operativo; por lo que dichas aplicaciones deben implementar sus propios algoritmos de almacenamiento y gestiÃ³n de la memoria.</p>
</div>
<div class="paragraph">
<p>Sin embargo, hay que valorar muy bien las necesidades del programa antes de optar por este modo.
La mayor parte de las aplicaciones siempre funcionan mejor utilizando los servicios convencionales ofrecidos por el sistema operativo.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tamaÃ±o_de_las_pÃ¡ginas_2">17.7.3. TamaÃ±o de las pÃ¡ginas</h4>
<div class="paragraph">
<p>Como ya comentamos al estudiar el mÃ©todo bÃ¡sico de paginaciÃ³n (vÃ©ase el <a href="#_paginaciÃ³n">CapÃ­tulo 16</a>), una decisiÃ³n de diseÃ±o importante es escoger el tamaÃ±o adecuado para las pÃ¡ginas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Con pÃ¡ginas grandes</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Se consiguen menos <strong>fallos de pÃ¡ginas</strong>.
Por ejemplo, en un caso extremo, un proceso de 100 KiB solo podrÃ­a generar un <strong>fallo de pÃ¡gina</strong> si cada pÃ¡gina es de 100 KiB, pero puede generar 102400 fallos si cada pagina es de 1 byte.</p>
</li>
<li>
<p>Se consiguen tablas de pÃ¡ginas mÃ¡s pequeÃ±as.</p>
</li>
<li>
<p>La E/S para acceder al contenido de cada pÃ¡gina requiere menos tiempo.</p>
<div class="paragraph">
<p>En general el tiempo de transferencia es proporcional a la cantidad de informaciÃ³n transferida, lo que deberÃ­a beneficiar a los sistemas con pÃ¡ginas de pequeÃ±o tamaÃ±o.
Sin embargo, la latencia y el tiempo requerido para posicionar la cabeza lectora de los discos es muy superior al tiempo de transferencias de datos, por lo que es mÃ¡s eficiente tener menos transferencias de mayor tamaÃ±o âcomo cuando se usan pÃ¡ginas grandesâ que mÃ¡s transferencias de menor tamaÃ±o âcomo cuando se usan pÃ¡ginas pequeÃ±asâ.</p>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Con pÃ¡ginas pequeÃ±as</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Se consigue tener menos <strong>fragmentaciÃ³n interna</strong> y, por tanto, un mejor aprovechamiento de la memoria.</p>
</li>
<li>
<p>TeÃ³ricamente, se obtiene una mejor resoluciÃ³n para asignar y transferir al disco sÃ³lo la memoria que realmente necesitamos.
Esto a la larga deberÃ­a redundar en menos memoria asignada y menos operaciones de E/S.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>En la actualidad, el tamaÃ±o de pÃ¡gina mÃ¡s comÃºn es de 4 KiB en sistemas de 32 bits y 8 KiB en los de 64 bits, ya que son adecuados para la mayor parte de las aplicaciones.
Sin embargo, muchos sistemas modernos soportan el uso simultÃ¡neo de mÃºltiples tamaÃ±os de pÃ¡gina.
Esto permite que la mayor parte de las aplicaciones utilicen el tamaÃ±o estÃ¡ndar, mientras las que hacen un uso intensivo de la memoria âcomo es el caso de los gestores de bases de datosâ puedan utilizar pÃ¡ginas de mayor tamaÃ±o.</p>
</div>
</div>
<div class="sect3">
<h4 id="_efecto_de_la_estructura_de_los_programas">17.7.4. Efecto de la estructura de los programas</h4>
<div class="paragraph">
<p>Los programas creados considerando la <strong>localidad de referencia</strong> pueden mejorar su rendimiento en los sistemas con <strong>paginaciÃ³n bajo demanda</strong>.</p>
</div>
<div class="paragraph">
<p>Vamos a ilustrarlo con el siguiente ejemplo de un programa que inicializa a 0 un <em>array</em> de 128 por 128 elementos.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="kt">char</span> <span class="n">data</span><span class="p">[][]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">128</span><span class="p">][</span><span class="mi">128</span><span class="p">];</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Un <em>array</em> como el indicado es almacenado en filas:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="p">...,</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">127</span><span class="p">]</span>
<span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="p">...,</span> <span class="n">data</span><span class="p">[</span><span class="mi">127</span><span class="p">][</span><span class="mi">127</span><span class="p">]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>De manera que si suponemos que el tamaÃ±o de cada pÃ¡gina es de 128 bytes, en el mejor de los casos cada fila estarÃ¡ almacenada en una pÃ¡gina.
Por lo tanto:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Si el sistema le asigna 128 marcos o mÃ¡s, el proceso solo generarÃ¡ 128 fallos de pÃ¡gina.</p>
</li>
<li>
<p>Si el sistema operativo le asigna un solo marco, el proceso tendrÃ¡ 16,384 fallos, aproximadamente.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Sin embargo, el ejemplo serÃ­a diferente si el bucle interno del programa recorriera las columnas del <em>array</em> y no las filas:</p>
</div>
<div class="paragraph">
<p>Pues se podrÃ­an a 0 primero todos los bytes de una misma pÃ¡gina antes de empezar con la siguiente.
Esto reducirÃ­a el nÃºmero de <strong>fallos de pÃ¡gina</strong> a 128, aunque el sistema operativo sÃ³lo asigne un marco al proceso.</p>
</div>
<div class="paragraph">
<p>Por lo tanto se puede concluir que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La selecciÃ³n cuidadosa de las estructuras de datos y de programaciÃ³n pueden mejorar la <strong>localidad</strong>, reduciendo la <strong>tasa de fallos de pÃ¡ginas</strong> y el tamaÃ±o del <strong>conjunto de trabajo</strong>.
Por ejemplo, las estructuras de datos tipo pila tienen buena <strong>localidad</strong> puesto que el acceso siempre se realiza en lo alto de las mismas.
Sin embargo, las tablas de dispersiÃ³n, obviamente, estÃ¡n diseÃ±adas para dispersar las referencias, lo que produce una mala <strong>localidad</strong>.</p>
</li>
<li>
<p>La elecciÃ³n del lenguaje de programaciÃ³n tambiÃ©n puede tener efecto.
En los lenguajes como C y C&#43;&#43; se utilizan punteros con frecuencia, lo que aleatoriza el acceso a la memoria, empeorando la <strong>localidad de referencia</strong>.
AdemÃ¡s, algunos estudios indican que los lenguajes orientados a objetos tienden a tener peor <strong>localidad de referencia</strong> que los que no lo son.</p>
</li>
<li>
<p>El compilador y el cargador tambiÃ©n pueden tener un efecto importante:</p>
<div class="ulist">
<ul>
<li>
<p>Separando el cÃ³digo de los datos para permitir que las pÃ¡ginas de cÃ³digo puedan ser de sÃ³lo lectura.
Esto es interesante porque las pÃ¡ginas no modificadas no tienen que ser escritas antes de ser reemplazadas.</p>
</li>
<li>
<p>El compilador puede colocar las funciones que se llaman entre sÃ­ en la misma pÃ¡gina.</p>
</li>
<li>
<p>El cargador puede situar las funciones en la memoria de tal forma que en lo posible no crucen los bordes de las pÃ¡ginas.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_interbloqueo_de_es">17.7.5. Interbloqueo de E/S</h4>
<div class="paragraph">
<p>Supongamos que un proceso solicita una operaciÃ³n de E/S sobre el contenido de alguna de las pÃ¡ginas de su espacio de direcciones y que, antes de que la operaciÃ³n sea realizada, la pÃ¡gina es reemplazada mientras el proceso estÃ¡ esperando.
En ese caso, la operaciÃ³n de E/S se podrÃ­a acabar realizando sobre una pÃ¡gina que pertenece a un proceso diferente.
Para evitarlo existen diversas soluciones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se puede utilizar la memoria del nÃºcleo como bÃºfer en las operaciones de E/S.</p>
<div class="paragraph">
<p>En una escritura, Ã©sto obliga a la llamada al sistema a copiar los datos desde las pÃ¡ginas del proceso a la memoria del nÃºcleo, antes de solicitar la operaciÃ³n de E/S.
Mientras que en las operaciones de lectura serÃ­a justo al contrario.</p>
</div>
</li>
<li>
<p>Cada pÃ¡gina puede tener un <strong>bit de bloqueo</strong> que se utiliza para indicar quÃ© pÃ¡ginas no pueden ser seleccionadas para reemplazo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>AdemÃ¡s los <strong>bits de bloqueo</strong> se pueden utilizar en otras muchas situaciones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Bloquear las pÃ¡ginas del nÃºcleo para evitar que sean reemplazadas.</p>
</li>
<li>
<p>Bloquear las pÃ¡ginas que acaban de ser cargadas.</p>
<div class="paragraph">
<p>Ãsto evita que un <strong>fallo de pÃ¡gina</strong> en un proceso de mayor prioridad pueda reclamar el marco antes de que el proceso para el que se cargÃ³ la pÃ¡gina originalmente sea reiniciado, desperdiciando el trabajo de cargarla y provocando un nuevo <strong>fallo de pÃ¡gina</strong>.</p>
</div>
<div class="paragraph">
<p>Para implementarlo, se puede poner el <strong>bit de bloqueo</strong> a 1 cuando la pÃ¡gina se carga, volviÃ©ndolo despuÃ©s a poner a 0 cuando el proceso es planificado por primera vez, tras el <strong>fallo de pÃ¡gina</strong> que provocÃ³ la carga de la pÃ¡gina.</p>
</div>
</li>
<li>
<p>En los sistemas con <strong>tiempo real flexible</strong>, se suele permitir que las tareas de tiempo real informen de cuÃ¡les son las pÃ¡ginas mÃ¡s importantes, con el fin de que sean bloqueadas para evitar que puedan ser reemplazadas.</p>
<div class="paragraph">
<p>Para evitar riesgos, el sistema suele considerar estas solicitudes como Â«consejos de bloqueoÂ».
De esta manera el sistema es libre de descartar dichos consejos si el conjunto de marcos libres llega a ser demasiado pequeÃ±o o si un proceso pide bloquear demasiadas pÃ¡ginas.</p>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_interfaz_de_gestiÃ³n_de_la_memoria">17.8. Interfaz de gestiÃ³n de la memoria</h3>
<div class="paragraph">
<p>Gracias a la abstracciÃ³n de las tÃ©cnicas de memoria virtual âcomo la paginaciÃ³n bajo demandaâ, desde el punto de vista de los procesos, en cualquier sistema moderno prÃ¡cticamente sÃ³lo hace falta una llamada al sistema para gestionar su espacio de direcciones virtual.</p>
</div>
<div class="paragraph">
<p>En los sistemas POSIX esta llamada es <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a> y en Windows API es <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc()</a>, que se usan junto a sus opuestas <a href="https://man7.org/linux/man-pages/man2/munmap.2.html">munmap()</a> y <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualfree">VirtualFree()</a>, respectivamente.</p>
</div>
<div class="paragraph">
<p>Ambas funciones permiten:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Reservar una porciÃ³n del espacio de direcciones virtual del proceso.</p>
<div class="paragraph">
<p>La llamada solo hace la reserva de un rango de direcciones para pueda ser utilizado por el proceso âes decir, que las pÃ¡ginas en ese rango sean vÃ¡lidasâ siendo el componente de paginaciÃ³n bajo demanda, el responsable de asignar la memoria fÃ­sica que lo respalda, cuando el proceso acceda a esas direcciones.</p>
</div>
</li>
<li>
<p>Establecer permisos âlectura, escritura y ejecuciÃ³nâ, opciones de comparticiÃ³n entre procesos, bloqueo de pÃ¡ginas en la memoria fÃ­sica, pÃ¡ginas de gran tamaÃ±o y otras opciones, en la regiÃ³n de memoria virtual a reservar.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>AdemÃ¡s, en los sistemas POSIX, <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a> se utiliza tambiÃ©n para mapear archivos en regiones del espacio de direcciones virtual.
Mientras que en Windows API para esa funciÃ³n se utilizan llamadas diferentes, como hemos visto.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Ambas funciones ofrecen una buena cantidad de funcionalidades, pero operan a muy bajo nivel.
Por eso en ambas la pÃ¡gina es la unidad mÃ­nima en la gestiÃ³n de la memoria.
Es decir, las regiones reservadas del espacio de direcciones virtual, siempre deben comienzar en un borde de pÃ¡gina y su tamaÃ±o debe ser mÃºltiplo del tamaÃ±o de pÃ¡gina.</p>
</div>
<div class="paragraph">
<p>El problema es cÃ³mo compatibilizar eso, con las necesidades reales de los programas, que durante su ejecuciÃ³n necesitan reservar y liberar constantemente memoria para pequeÃ±os elementos, como: <em>arrays</em>, cadenas de texto, estructuras u  objetos.
Para esos casos, utilizar directamente <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a> o <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc()</a> no es una soluciÃ³n, puesto que la fragmentaciÃ³n interna conllevarÃ­a un importante derroche de recursos.</p>
</div>
<div class="sect3">
<h4 id="_anatomÃ­a_del_espacio_de_direcciones_virtual_del_proceso">17.8.1. AnatomÃ­a del espacio de direcciones virtual del proceso</h4>
<div class="paragraph">
<p>Los procesos pueden utilizar diversas ubicaciones dentro de su espacio de direcciones virtual para almacenar los datos que necesitan para su ejecuciÃ³n (vÃ©ase la <a href="#proceso_en_memoria_completo">Figura 53</a>):</p>
</div>
<div id="proceso_en_memoria_completo" class="imageblock">
<div class="content">
<img src="C17-memoria_virtual/media/proceso_en_memoria_completo.svg" alt="proceso en memoria completo">
</div>
<div class="title">Figura 53. AnatomÃ­a de un proceso en memoria.</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Las variables y constantes globales se almacenan en el <strong>segmento de datos</strong>, que tiene tamaÃ±o fijo, ya que las dimensiones de estas variables se conocen de antemano en tiempo de compilaciÃ³n, al igual que ocurre con el cÃ³digo del programa.</p>
</li>
<li>
<p>Las variables locales y los argumentos de las funciones se almacenan en la <strong>pila</strong>, junto con las direcciones de retorno para volver de las funciones.</p>
<div class="paragraph">
<p>Ãsta es la ubicaciÃ³n ideal para ellos, puesto que al retornar de una funciÃ³n, la pila se restablece al estado previo al que tenÃ­a cuando se invocÃ³ dicha funciÃ³n, haciendo que las variables locales y argumentos desaparezcan automÃ¡ticamente.</p>
</div>
</li>
<li>
<p>Las variables reservadas dinÃ¡micamente âpor ejemplo, usando <a href="https://en.cppreference.com/w/c/memory/malloc">malloc()</a>/<a href="https://en.cppreference.com/w/c/memory/free">free()</a> en C o <a href="https://en.cppreference.com/w/cpp/language/new">new</a>/<a href="https://en.cppreference.com/w/cpp/language/delete">delete</a> en C&#43;&#43; o Javaâ se almacenan en el <strong>montÃ³n</strong>, que no es mÃ¡s una regiÃ³n continua de memoria ubicada inmediatamente despuÃ©s del <strong>segmento de datos</strong> del proceso.</p>
</li>
<li>
<p>En la regiÃ³n entre el <strong>montÃ³n</strong> y la <strong>pila</strong> se ubican los <strong>archivos mapeados en memoria</strong>, las regiones de <strong>memoria compartida</strong>, las <strong>librerÃ­as de enlace dinÃ¡mico</strong>, las <strong>pilas</strong> de cada hilo âen procesos multihiloâ y, en general, la memoria reservada con funciones como <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a> y <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc()</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Cada lenguaje de programaciÃ³n, debe proporcionar âa travÃ©s de su <strong>librerÃ­a estÃ¡ndar</strong>â un mecanismo en espacio de usuario, adecuado para la gestiÃ³n en tiempo de ejecuciÃ³n de la memoria del <strong>montÃ³n</strong> del proceso.
Para eso, cada lenguaje puede utilizar su propia implementaciÃ³n de dicho mecanismo o bien recurrir a la proporcionada por la <strong>librerÃ­a del sistema</strong>.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, en los sistemas POSIX, la <strong>librerÃ­a del sistema</strong> proporciona su propia implementaciÃ³n, accesible a travÃ©s de las funciones <a href="https://en.cppreference.com/w/c/memory/malloc">malloc()</a> y <a href="https://en.cppreference.com/w/c/memory/free">free()</a>, que es utilizada directamente por los programas escritos en C.
Esta implementaciÃ³n hace uso de <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a>, pero ofrece mayor control sobre la cantidad de memoria que podemos reservar, como veremos en el <a href="#_gestiÃ³n_de_la_memoria_del_montÃ³n">Apartado 17.8.2</a>.</p>
</div>
<div class="paragraph">
<p>Otros lenguajes de programaciÃ³n tienen otras interfaces para gestionar la memoria, pero utilizan internamente las funciones <a href="https://en.cppreference.com/w/c/memory/malloc">malloc()</a> y <a href="https://en.cppreference.com/w/c/memory/free">free()</a> de la <strong>librerÃ­a del sistema</strong>.
Sin embargo, este no es el caso ni de C&#43;&#43; ni de Java ni de algunos otros lenguajes.
En C&#43;&#43;, los operadores <a href="https://en.cppreference.com/w/cpp/language/new">new</a> y <a href="https://en.cppreference.com/w/cpp/language/delete">delete</a> utilizan sus propios algoritmos de gestiÃ³n de la memoria del <strong>montÃ³n</strong>, mÃ¡s optimizados que <a href="https://en.cppreference.com/w/c/memory/malloc">malloc()</a> y <a href="https://en.cppreference.com/w/c/memory/free">free()</a> para la creaciÃ³n y destrucciÃ³n de objetos de cualquier tamaÃ±o de manera eficiente.</p>
</div>
<div class="paragraph">
<p>En Windows API ocurre algo similar.
La <strong>librerÃ­a del sistema</strong> proporciona su propia gestiÃ³n de la memoria del <strong>montÃ³n</strong>, que es accesible para cualquier programa a travÃ©s de las funciones <a href="https://docs.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heapalloc">HeapAlloc()</a> y <a href="https://docs.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heapfree">HeapFree()</a>, y que se implementa sobre <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc()</a>.
La <strong>librerÃ­a estÃ¡ndar</strong> de C utiliza, a su vez, esas funciones para implementar <a href="https://en.cppreference.com/w/c/memory/malloc">malloc()</a> y <a href="https://en.cppreference.com/w/c/memory/free">free()</a>.
Lo mismo ocurre en otros lenguajes, aunque no en todos, ya que algunos optan por implementar algoritmos mÃ¡s eficientes para sus casos de uso directamente sobre <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc()</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_gestiÃ³n_de_la_memoria_del_montÃ³n">17.8.2. GestiÃ³n de la memoria del montÃ³n</h4>
<div class="paragraph">
<p>Para ilustrar cÃ³mo se puede gestionar la memoria del <strong>montÃ³n</strong> utilizaremos como ejemplo el mecanismo empleado por la <strong>librerÃ­a del sistema</strong> de los sistemas POSIX âaccesible a travÃ©s de las funciones <a href="https://en.cppreference.com/w/c/memory/malloc">malloc()</a> y <a href="https://en.cppreference.com/w/c/memory/free">free()</a>.
Sin embargo, es importante tener en cuenta que esta tarea se realiza de manera muy similar en las implementaciones de otros sistemas operativos y lenguajes de programaciÃ³n.</p>
</div>
<div class="paragraph">
<p>El funcionamiento bÃ¡sico de <a href="https://en.cppreference.com/w/c/memory/malloc">malloc()</a> sigue las siguiente reglas:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Cuando la memoria solicitada supera cierto umbral â128KB en sistemas GNU/Linuxâ es reservada directamente mediante la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a>.
Eso significa que las peticiones de gran tamaÃ±o realmente no consumen espacio del <strong>montÃ³n</strong>, si no que se reservan del hueco entre el <strong>montÃ³n</strong> y la <strong>pila</strong>.</p>
</li>
<li>
<p>Cuando un proceso hace una peticiÃ³n de memoria dinÃ¡mica espera que el espacio ofrecido sea continuo en el espacio de direcciones virtual, por lo que la memoria del <strong>montÃ³n</strong> se gestiona usando un algoritmo de <strong>asignaciÃ³n contigua de memoria</strong> (vÃ©ase <a href="#_asignaciÃ³n_contigua_de_memoria">Apartado 15.5</a>) y, puesto que las peticiones pueden ser de tamaÃ±o variable, se utiliza con un esquema de <strong>particionado dinÃ¡mico</strong>.</p>
<div class="paragraph">
<p>Es decir, que para las peticiones que no entran en el caso anterior, se busca en la tabla de huecos libres y ocupados del <strong>montÃ³n</strong> uno lo suficientemente como grande para atender la peticiÃ³n.
Se asigna el espacio solicitado y el resto sigue marcado como hueco libre.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>La estrategia mÃ¡s comÃºn de bÃºsqueda es el <strong>mejor ajuste</strong>, utilizando algÃºn tipo de estructura de datos que mantenga los huecos libres ordenados por tamaÃ±o, para encontrar el de tamaÃ±o adecuado rÃ¡pidamente.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Si no hay suficiente memoria libre contigua como para atender la peticiÃ³n, se utiliza la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a>, para extender el tamaÃ±o del <strong>montÃ³n</strong> reservando una nueva regiÃ³n separada âa veces llamada <strong>arena</strong>â y comenzar a repartirla.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En aplicaciones pequeÃ±as, algunas implementaciones intentan ampliar primero el espacio libre utilizando la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/brk.2.html">brk()</a>, que sirve para extender el <strong>montÃ³n</strong> sobre la regiÃ³n adyacente no asignada del espacio de direcciones virtual del proceso.
Este es el caso de la implementaciÃ³n estÃ¡ndar de <a href="https://en.cppreference.com/w/c/memory/malloc">malloc()</a> en GNU/Linux.</p>
</div>
<div class="paragraph">
<p>La llamada al sistema <a href="https://man7.org/linux/man-pages/man2/brk.2.html">brk()</a> ha sido eliminada del estÃ¡ndar POSIX, pero algunos sistemas la mantienen por compatibilidad hacia atrÃ¡s, dado que era la forma en la que tradicionalmente se ampliaba la memoria del <strong>montÃ³n</strong> en los primeros UNIX.
En macOS esta llamada se emula con una regiÃ³n de 4 MiB reservada con <strong>mmap</strong> la primer vez que se utiliza.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_fragmentaciÃ³n_2">17.8.3. FragmentaciÃ³n</h4>
<div class="paragraph">
<p>Las estrategia comentada sufre de <strong>fragmentaciÃ³n interna</strong>.
En las peticiones grandes, <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a> reserva en mÃºltiplos de tamaÃ±o de pÃ¡gina, por lo que siempre se puede perder cierta cantidad, aunque pequeÃ±a en comparaciÃ³n al tamaÃ±o de la regiÃ³n reservada.
En las peticiones pequeÃ±as, la memoria se asigna en mÃºltiplos de una unidad mÃ­nima âpor ejemplo, 16 o 32 bytesâ por lo que tambiÃ©n se puede perder cierta cantidad de memoria.</p>
</div>
<div class="paragraph">
<p>AdemÃ¡s sufre de <strong>fragmentaciÃ³n externa</strong>, porque despuÃ©s de que el proceso lleva un tiempo en ejecuciÃ³n, liberando y reservando memoria, el espacio puede comenzar a quedar fraccionado en un gran nÃºmero de pequeÃ±os huecos, obligando a la librerÃ­a a buscar mÃ¡s espacio para el <strong>montÃ³n</strong>, aunque en suma haya suficiente espacio en los huecos libres.</p>
</div>
<div class="paragraph">
<p>Ãsto, representa un reto para los desarrolladores de aplicaciones, que previsiblemente vayan a ejecutarse durante periodos muy largos de tiempo.
En esos casos, es comÃºn optar por librerÃ­as externas, que implementen gestores de memoria que fragmenten menos la memoria, o soluciones basadas en alguna forma de referencias indirectas y recolecciÃ³n de basura, para ocasionalmente poder compactar la memoria del <strong>montÃ³n</strong>.
Esto Ãºltimo, es lo que hace la mÃ¡quina virtual de Java.</p>
</div>
</div>
</div>
</div>
</div>
<h1 id="_gestiÃ³n_del_almacenamiento" class="sect0">Parte V: GestiÃ³n del almacenamiento</h1>
<div class="sect1">
<h2 id="_almacenamiento_secundario">18. Almacenamiento secundario</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>10 minutos</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_dispositivos_de_almacenamiento">18.1. Dispositivos de almacenamiento</h3>
<div class="paragraph">
<p>Los ordenadores pueden almacenar informaciÃ³n en diferentes soportes de almacenamiento âpor ejemplo, en discos magnÃ©ticos, DVD o memorias de estado sÃ³lidoâ.
Cada uno tiene propiedades fÃ­sicas diferentes que pasamos a comentar brevemente a continuaciÃ³n.</p>
</div>
<div class="sect3">
<h4 id="_discos_magnÃ©ticos">18.1.1. Discos magnÃ©ticos</h4>
<div class="paragraph">
<p>Los discos magnÃ©ticos son el tipo principal de almacenamiento secundario, generalmente en la forma de lo que se denominan discos duros.</p>
</div>
<div id="disco_duro_fÃ­sico" class="imageblock">
<div class="content">
<img src="C18-almacenamiento/media/disco_duro_fÃ­sico.jpg" alt="disco duro fÃ­sico">
</div>
<div class="title">Figura 54. Disco duro&#8201;&#8212;&#8201;Fuente: <a href="https://commons.wikimedia.org/wiki/File:Hard_Drive_(11644168395).jpg">Wikipedia</a></div>
</div>
<div class="paragraph">
<p>Tal y como se puede apreciar en la <a href="#disco_duro_fÃ­sico">Figura 54</a> cada unidad estÃ¡ compuesta por una serie de platos de forma circular recubiertos de material magnÃ©tico.
La informaciÃ³n se almacena grabÃ¡ndola magnÃ©ticamente sobre los platos, para lo cual se utilizan unas cabezas de lectura que Â«flotanÂ» tanto por encima como por debajo de cada plato.</p>
</div>
<div id="disco_duro_lÃ³gico" class="imageblock">
<div class="content">
<img src="C18-almacenamiento/media/disco_duro_lÃ³gico.svg" alt="disco duro lÃ³gico">
</div>
<div class="title">Figura 55. Estructura lÃ³gica de un disco magnÃ©tico.</div>
</div>
<div class="paragraph">
<p>Desde el punto de vista lÃ³gico (vÃ©ase la <a href="#disco_duro_lÃ³gico">Figura 55</a>) la superficie de cada plato estÃ¡ dividida en <strong>pista</strong> circulares, cada una de las cuales se subdivide en <strong>sectores</strong>.
El conjunto de pistas formado por todas aquellas que estÃ¡n situadas en la misma posiciÃ³n en los distintos platos se denomina <strong>cilindro</strong>.</p>
</div>
<div class="paragraph">
<p>En estos dispositivos consume mucho mÃ¡s tiempo mover la cabeza de lectura hasta el sector de interÃ©s, que la lectura y transferencia de los datos almacenados a la memoria RAM.
Por lo tanto, el tiempo de acceso aleatorio al disco es mucho mayor que el de acceso secuencial.</p>
</div>
</div>
<div class="sect3">
<h4 id="_discos_Ã³pticos">18.1.2. Discos Ã³pticos</h4>
<div class="paragraph">
<p>Los discos Ã³pticos âCD, DVD, BluRay, o cualquier otro medio similarâ consisten en un disco circular en el cual la informaciÃ³n se almacena haciendo uso de surcos microscÃ³picos, que se leen haciendo incidir un lÃ¡ser sobre una de las caras planas que lo componen.</p>
</div>
<div class="paragraph">
<p>En este tipo de discos la informaciÃ³n se almacena siguiendo un recorrido continuo en espiral que cubre la superficie entera del disco, extendiÃ©ndose desde el interior hacia el exterior.
Dado que el lÃ¡ser siempre debe desplazarse sobre la espiral, el acceso aleatorio a los datos es mÃ¡s lento que con otras tecnologÃ­as de disco.</p>
</div>
</div>
<div class="sect3">
<h4 id="_memorias_de_estado_sÃ³lido">18.1.3. Memorias de estado sÃ³lido</h4>
<div class="paragraph">
<p>Una memoria de estado sÃ³lido âmemoria USB o un SSDâ es un dispositivo de almacenamiento que usa una memoria no volÃ¡til âcomo las <a href="https://es.wikipedia.org/wiki/Memoria_flash">memorias <em>flash</em></a>â para almacenar datos, en lugar de utilizar discos Ã³pticos o magnÃ©ticos.</p>
</div>
<div class="paragraph">
<p>En este tipo de memorias la informaciÃ³n se almacena como en un vector lineal de bytes, que se puede indexar aleatoriamente con la misma eficiencia con la que se accede secuencialmente âcomo ocurre con la memoria RAMâ.
Sin embargo algunos dispositivos, de cara al resto del sistema informÃ¡tico, emulan una interfaz y un modo de direccionamiento similar al utilizado por los discos magnÃ©ticos âes decir, usando pistas, sectores y cilindrosâ por temas de compatibilidad.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_archivos_y_sistemas_de_archivos">18.2. Archivos y sistemas de archivos</h3>
<div class="paragraph">
<p>Teniendo en cuenta la gran diversidad de dispositivos de almacenamiento que existen, para que el sistema informÃ¡tico sea cÃ³modo de utilizar, el sistema operativo proporciona una visiÃ³n lÃ³gica uniforme de todos los sistemas de almacenamiento.
Es decir, abstrae las propiedades fÃ­sicas de los dispositivos de almacenamiento para definir una unidad de almacenamiento lÃ³gico que sea Ãºtil para los usuarios.
Esta unidad es el <strong>archivo</strong>.</p>
</div>
<div class="paragraph">
<p>Un <strong>archivo</strong> o <strong>fichero</strong> es una colecciÃ³n de datos relacionados, identificados por un nombre, que es tratada por el sistema operativo como una unidad de informaciÃ³n en el almacenamiento secundario.
Desde la perspectiva de los usuarios, un archivo es la unidad mÃ¡s pequeÃ±a de almacenamiento.
Es decir, los usuarios no pueden escribir datos en el almacenamiento secundario a menos que Ã©stos se encuentren dentro de un archivo.</p>
</div>
<div class="paragraph">
<p>El sistema operativo puede ofrecer esta abstracciÃ³n gracias al <strong>sistema de archivos</strong>.
Ãste proporciona los mecanismos para el almacenamiento de los datos y programas en archivos, tanto del propio sistema operativo como los de todos los usuarios del sistema informÃ¡tico.</p>
</div>
<div class="paragraph">
<p>Los sistemas de archivos estÃ¡n compuestos de dos partes claramente diferenciadas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Una colecciÃ³n de archivos</strong>, cada una de las cuales almacena una serie de datos relacionados.</p>
</li>
<li>
<p><strong>Una colecciÃ³n de estructuras de metadatos</strong>, que contienen informaciÃ³n relativa a los archivos almacenados ânombre, ubicaciÃ³n en el disco, permisos, entre otrosâ y que se encarga de organizarlos; generalmente haciendo uso de una estructura de directorios.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_volÃºmenes_de_datos">18.3. VolÃºmenes de datos</h3>
<div class="paragraph">
<p>Los dispositivos de almacenamiento comentados anteriormente pueden ser utilizados al 100% con un Ãºnico sistema de archivos.
Sin embargo, en ocasiones es interesante hacer divisiones con el objeto de disponer de mÃºltiples sistemas de archivos en el mismo dispositivo.
Cada una de esas divisiones es un <strong>volumen</strong>.</p>
</div>
<div class="paragraph">
<p>En otros casos interesa combinar divisiones o dispositivos de almacenamiento completos para crear espacios de mayor tamaÃ±o âtambiÃ©n denominadas <strong>volÃºmenes</strong>â cada una de las cuales puede albergar un Ãºnico sistema de archivos.
AsÃ­ que en general, utilizaremos el tÃ©rmino <strong>volumen</strong> para referirnos a un espacio de almacenamiento que alberga un sistema de archivos, tanto si ese espacio es una pequeÃ±a parte del espacio completo del dispositivo, como si se trata de una estructura de mayor tamaÃ±o compuesta a partir de varios dispositivos.</p>
</div>
<div class="paragraph">
<p>A continuaciÃ³n comentaremos brevemente las tecnologÃ­as utilizadas con mayor frecuencia para construir estos volÃºmenes.</p>
</div>
<div class="sect3">
<h4 id="_raid">18.3.1. RAID</h4>
<div class="paragraph">
<p>La tecnologÃ­a <strong>RAID</strong> (<em>Redundant Array of Inexpensive Disks</em>) permite combinar varios discos duros para mejorar las prestaciones a travÃ©s del paralelismo en el acceso o para mejorar la fiabilidad a travÃ©s del almacenamiento de informaciÃ³n redundante.
En concreto se definen diversos <strong>niveles RAID</strong>, de entre los cuales los mÃ¡s comunes son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En un <strong>conjunto RAID 0</strong> se distribuyen los datos equitativamente en bloques de tamaÃ±o fijo entrelazados entre dos o mÃ¡s discos, sin incluir ningÃºn tipo de informaciÃ³n redundante.
Esto permite leer y escribir mÃ¡s datos en el mismo tiempo, ya que se pueden enviar en paralelo peticiones a los distintos discos.
Sin embargo, la fiabilidad es inversamente proporcional al nÃºmero de discos, ya que para que el conjunto falle basta con que lo haga cualquiera de ellos.</p>
</li>
<li>
<p>En un <strong>conjunto RAID 1</strong> se crea una copia exacta âen espejoâ de los datos en dos o mÃ¡s discos.
El resultado es que, incluso con dos discos, se incrementa exponencialmente la fiabilidad respecto a tener uno solo, ya que para que el conjunto falle es necesario que lo hagan todos los discos.
Adicionalmente, el rendimiento en las operaciones de lectura se incrementa linealmente con el nÃºmero de copias, ya que los datos estÃ¡n disponibles en todos los discos al mismo tiempo, por lo que se pueden balancear las operaciones de lectura entre todos ellos.</p>
</li>
<li>
<p>En un <strong>conjunto RAID 5</strong> se distribuyen los datos equitativamente en bloques de tamaÃ±o fijo entrelazados entre dos o mÃ¡s discos y se utiliza uno adicional para almacenar la informaciÃ³n de paridad de los bloques de una misma divisiÃ³n.
En RAID se denomina divisiÃ³n o <em>stripe</em> a la serie de bloques consecutivos escogido cada uno de uno de los discos del conjunto.</p>
<div class="paragraph">
<p>El disco utilizado para almacenar el bloque de paridad cambia de forma escalonada de una divisiÃ³n a la siguiente, de ahÃ­ que se diga que el bloque de paridad estÃ¡ distribuido.
Algunos aspectos adicionales a tener en cuenta son que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cada vez que se escribe un bloque de datos se debe actualizar el bloque de paridad.
Por lo tanto las escrituras en un conjunto RAID 5 son costosas en tÃ©rminos de operaciones de disco y trÃ¡fico.</p>
</li>
<li>
<p>Los bloques de paridad no se leen durante las lecturas de datos, ya que eso reducirÃ­a el rendimiento.
SÃ³lo se hace en caso de que la lectura de un sector falle, puesto que el sector en la misma posiciÃ³n relativa dentro de cada uno de los otros bloques de datos de la divisiÃ³n y en el bloque de paridad se pueden utilizar para reconstruir el sector errÃ³neo.</p>
</li>
<li>
<p>En un conjunto RAID 5 el fallo de 2 discos provoca la pÃ©rdida completa de los datos.
Esto significa que aunque se pueden aÃ±adir discos de manera ilimitada, eso no suele ocurrir puesto que a mÃ¡s discos en el conjunto mÃ¡s probabilidad de que fallen dos de ellos.</p>
</li>
</ul>
</div>
</li>
<li>
<p>En un <strong>conjunto RAID 6</strong> se utiliza la misma estrategia que en RAID 5 pero en cada divisiÃ³n hay dos bloques de paridad âen lugar de unoâ en dos discos diferentes.
Esto permite que fallen hasta dos discos sin perder los datos.</p>
</li>
<li>
<p>En un conjunto con niveles anidados se combinan varios niveles RAID bÃ¡sicos como si fueran capas superpuestas.
Ejemplos tÃ­picos son:</p>
<div class="ulist">
<ul>
<li>
<p><strong>RAID 0+1</strong>, donde se hace un espejo de un conjunto RAID 0.</p>
</li>
<li>
<p><strong>RAID 1+0</strong> o <strong>RAID 10</strong>, donde diversos conjuntos en espejo se combina en un RAID 0, aumentando la capacidad total.</p>
</li>
<li>
<p><strong>RAID 50</strong>, donde diversos conjuntos RAID 5 se combinan en un RAID 0, aumentando tambiÃ©n la capacidad total.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>La implementaciÃ³n de RAID es otra de las Ã¡reas donde existen diversas variantes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>RAID puede implementarse en el hardware de la controladora de disco, de tal forma que sÃ³lo los discos conectados a Ã©sta pueden formar parte de un conjunto RAID determinado.
Esta soluciÃ³n es muy eficiente, especialmente cuando se utilizan niveles que requieren cÃ¡lculo de la paridad, ya que se evita utilizar tiempo de CPU para ese trabajo.
Sin embargo, estas controladoras son notablemente mÃ¡s caras que las que carecen de soporte para RAID.</p>
</li>
<li>
<p>RAID puede implementarse dentro del sistema operativo en lo que se denomina el <strong>software de gestiÃ³n de volÃºmenes</strong>.
En este caso las soluciones RAID con paridad son bastante lentas, por lo que normalmente sÃ³lo se soportan los niveles RAID 0, 1, 10 o 0+1.
Algunas controladoras de disco modernas que dicen venir con soporte RAID realmente implementan esta tecnologÃ­a en software, a nivel del controlador de dispositivo, mientras que en el hardware sÃ³lo se implementan unas caracterÃ­sticas de apoyo mÃ­nimas.
En algunos entornos se denomina a este tipo de implementaciones <em>fakeRAID</em> o <em>hostRAID</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Cada conjunto RAID se comporta como una unidad de almacenamiento independiente desde el punto de vista del resto del sistema, por lo que se puede utilizar entero para albergar un Ãºnico sistema de archivos.
Sin embargo, lo mÃ¡s comÃºn es dividirlo en regiones con el objeto de utilizar mÃºltiples sistemas de archivos o combinarlo en estructuras de mayor tamaÃ±o, para lo cuÃ¡l se pueden utilizar alguna de las tÃ©cnicas que veremos a continuaciÃ³n.</p>
</div>
</div>
<div class="sect3">
<h4 id="_particiones">18.3.2. Particiones</h4>
<div class="paragraph">
<p>Un disco, un conjunto RAID o cualquier otro dispositivo de almacenamiento se puede dividir en regiones para utilizar en cada una de ellas un sistema de archivos diferente.
A esas regiones se las conoce comÃºnmente como <strong>particiones</strong>, <strong>franjas</strong> o <strong>minidiscos</strong>.</p>
</div>
<div class="paragraph">
<p>SegÃºn la plataforma, existen diversas maneras de implementar el soporte de particiones.
Entre los sistemas de escritorio las tecnologÃ­as mÃ¡s difundidas y utilizadas son la <strong>MBR</strong> (<em>Master Boot Record</em>) y la <strong>GPT</strong> (<em>GUID Partition Table</em>).
En ambas se almacena, en los primeros sectores del dispositivo de almacenamiento, una tabla con una entrada por particiÃ³n donde se guardan las direcciones del primer y Ãºltimo sector de cada una de ellas en el dispositivo, asÃ­ como otra informaciÃ³n.
Eso es todo lo que necesita el sistema operativo para determinar los lÃ­mites de la regiÃ³n ocupada por cada sistema de archivos.</p>
</div>
</div>
<div class="sect3">
<h4 id="_volÃºmenes_dinÃ¡micos">18.3.3. VolÃºmenes dinÃ¡micos</h4>
<div class="paragraph">
<p>SegÃºn la tecnologÃ­a que se utilice para particionar es posible encontrarse con una serie de restricciones comunes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Limitado nÃºmero de particiones que puede contener un mismo dispositivo.</p>
</li>
<li>
<p>Limitaciones o imposibilidad de redimensionar las particiones.
Especialmente si el sistema operativo estÃ¡ en ejecuciÃ³n.</p>
</li>
<li>
<p>La imposibilidad de crear particiones que hagan uso de regiones libres en diferentes dispositivos de almacenamiento.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Para resolverlo, algunos sistemas operativos incluyen un <strong>software de gestiÃ³n de volÃºmenes</strong> que hace uso de tecnologÃ­a propia para superar estas limitaciones.
Estas herramientas generalmente permiten agrupar dispositivos completos, conjuntos RAID, particiones, etc. y sobre ellos construir los volÃºmenes que sean necesarios.
Estos volÃºmenes pueden ser redimensionados âen ocasiones sin tener que detener la ejecuciÃ³n del sistema operativoâ y en caso de que haga falta se pueden incluir dinÃ¡micamente nuevos dispositivos para incrementar el espacio disponible.
AdemÃ¡s, como ya hemos comentado, el software de gestiÃ³n de volÃºmenes puede incluir alguna funcionalidad propia de conjuntos RAID, con el objeto de mejorar las prestaciones, a travÃ©s del paralelismo en el acceso, o mejorar la fiabilidad, a travÃ©s del almacenamiento de informaciÃ³n redundante.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sistemas_de_archivos">19. Sistemas de archivos</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>54 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Como hemos comentado, cada volumen puede albergar un sistema de archivos.
A continuaciÃ³n estudiaremos los elementos mÃ¡s comunes a la mayor parte de los sistemas de archivos actuales.</p>
</div>
<div class="sect2">
<h3 id="_estructura_de_un_sistema_de_archivos">19.1. Estructura de un sistema de archivos</h3>
<div id="estructura_sistema_de_archivos" class="imageblock">
<div class="content">
<img src="C19-sistema_de_archivos/media/estructura_sistema_de_archivos.svg" alt="estructura sistema de archivos">
</div>
<div class="title">Figura 56. Estructura de un sistema de archivos.</div>
</div>
<div class="paragraph">
<p>Los sistema de archivos son un componente complejo, por lo que suelen estar compuesto de varios niveles diferentes.
En la <a href="#estructura_sistema_de_archivos">Figura 56</a> se muestra un ejemplo tÃ­pico de la estructura de un sistema de archivos diseÃ±ado en niveles.
Cada nivel utiliza las funciones de los niveles inferiores y proporciona nuevas funciones a los niveles superiores.</p>
</div>
<div class="sect3">
<h4 id="_control_de_es">19.1.1. Control de E/S</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>En el nivel mÃ¡s bajo, accediendo directamente a los dispositivos de almacenamiento, se encuentra el <strong>control de E/S</strong>.</p>
</div>
<div class="paragraph">
<p>Contiene los controladores de dispositivo encargados de transferir la informaciÃ³n entre la memoria principal y el disco.
Estos controladores, que generalmente son compartidos entre los distintos sistemas de archivos, transfieren los datos en unidades de <strong>bloques</strong> âen lugar de transferir un byte cada vezâ para mejorar la eficiencia.
Cada _*bloque* estÃ¡ formado por uno o mÃ¡s sectores.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Dependiendo de la unidad de disco, los sectores pueden tener tamaÃ±os de entre 32 bytes y 4096 bytes.
Lo mÃ¡s comÃºn es que su tamaÃ±o sea de 512 bytes.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_sistema_bÃ¡sico_de_archivos">19.1.2. Sistema bÃ¡sico de archivos</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El <strong>sistema bÃ¡sico de archivos</strong> se encarga de enviar comandos genÃ©ricos al controlador de dispositivo apropiado, con el fin de leer y escribir bloques fÃ­sicos en el disco.
Cada bloque fÃ­sico se identifica mediante su direcciÃ³n de disco numÃ©rica.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, en dispositivos que usan direccionamiento de tipo cabeza-cilindro-sector (CHS), la direcciÃ³n de un sector podrÃ­a ser: unidad 1, cilindro 73, cabeza 2, sector 10.
Mientras que en dispositivos que admiten direccionamiento LBA (<em>Logical Block Addressing</em>), la direcciÃ³n de un sector podrÃ­a ser: unidad 1, sector 4691123.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>El <strong>LBA</strong> es un mÃ©todo comÃºn para especificar la localizaciÃ³n de los sectores de un disco.
Usa un esquema de direccionamiento lineal, donde cada sector es identificado con un nÃºmero entero Ãºnico.
Antes de este mÃ©todo, se usaba el de cabeza-cilindro-sector (CHS), pero tenÃ­a la desventaja de hacer pÃºblicos los detalles fÃ­sicos del dispositivo de almacenamiento.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_mÃ³dulo_de_organizaciÃ³n_de_archivos">19.1.3. MÃ³dulo de organizaciÃ³n de archivos</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El <strong>mÃ³dulo de organizaciÃ³n de archivos</strong> tiene conocimiento de los archivos y se encarga de traducir las direcciones lÃ³gicas de los bloques en los archivos âes decir, posiciÃ³n del bloque dentro del archivo, siendo 0 la direcciÃ³n del primer bloqueâ en las direcciones fÃ­sicas de bloque âpor ejemplo, cilindro, cabeza y sector del bloque correspondiente en el dispositivo de almacenamientoâ que serÃ¡n enviadas al <strong>sistema bÃ¡sico de archivos</strong> para que realice las transferencias solicitadas.</p>
</div>
<div class="paragraph">
<p>Los bloques lÃ³gicos de cada archivo son numerados de 0 a <em>N</em>, pero los bloques fÃ­sicos asignados a estos bloques lÃ³gicos no tienen porquÃ© coincidir en los nÃºmeros de bloque.
Por eso, el <strong>mÃ³dulo de organizaciÃ³n de archivos</strong> debe utilizar la ubicaciÃ³n del contenido del archivo en el disco y la informaciÃ³n sobre los bloques fÃ­sicos asignados, para traducir las direcciones lÃ³gicas en direcciones fÃ­sicas.</p>
</div>
<div class="paragraph">
<p>AdemÃ¡s, el mÃ³dulo de organizaciÃ³n, incluye el gestor de espacio libre, que controla los bloques no asignados y proporciona dichos bloques cuando el <strong>mÃ³dulo de organizaciÃ³n de archivos</strong> lo necesita, ya sea para crear un archivo nuevo o para extender uno existente.</p>
</div>
</div>
<div class="sect3">
<h4 id="_sistema_lÃ³gico_de_archivos">19.1.4. Sistema lÃ³gico de archivos</h4>
<div class="paragraph">
<p>El <strong>sistema lÃ³gico de archivos</strong> gestiona los <strong>metadatos</strong>.
En los <strong>metadatos</strong> se incluye toda la estructura del sistema de archivos, excepto los propios datos de los archivos.</p>
</div>
<div class="paragraph">
<p>Entre dichos <strong>metadatos</strong> estÃ¡ la <strong>estructura de directorios</strong> y los <strong>bloques de control de archivo</strong>.
Un <strong>bloque de control de archivo</strong> o <strong>FCB</strong> (<em>File Control Block</em>) contiene informaciÃ³n acerca del archivo, incluyendo su propietario, los permisos y la ubicaciÃ³n del contenido del mismo.</p>
</div>
<div class="paragraph">
<p>AdemÃ¡s, el <strong>sistema lÃ³gico de archivos</strong> tambiÃ©n es responsable de las tareas de protecciÃ³n y seguridad.</p>
</div>
<div class="paragraph">
<p>Cada sistema operativo puede soportar uno o mÃ¡s sistemas de archivos para dispositivos de disco.
Por ejemplo, en los sistemas UNIX se utiliza el  Â«sistema de archivos UNIXÂ» o <a href="https://es.wikipedia.org/wiki/Unix_File_System">UFS</a> (<em>UNIX File System</em>), que estÃ¡ basado en el sistema <a href="https://es.wikipedia.org/wiki/Berkeley_Fast_File_System">FFS</a> (<em>Fast File System</em>) de la Universidad de Berkeley.
Microsoft Windows soporta los sistemas de archivo <a href="https://es.wikipedia.org/wiki/Tabla_de_asignaci%C3%B3n_de_archivos">FAT</a> (<em>File Allocation Table</em>), <a href="https://es.wikipedia.org/w/index.php?title=FAT32">FAT32</a> y <a href="https://es.wikipedia.org/wiki/NTFS">NTFS</a> (<em>NT File System</em>).
En Linux se soportan mÃ¡s de cuarenta sistemas de archivo, entre los que cabe destacar: la familia <em>extended filesystem</em> â
<a href="https://es.wikipedia.org/wiki/Ext2">ext2</a>, <a href="https://es.wikipedia.org/wiki/Ext3">ext3</a> y <a href="https://es.wikipedia.org/wiki/Ext4">ext4</a>â <a href="https://es.wikipedia.org/wiki/XFS">XFS</a> y <a href="https://es.wikipedia.org/wiki/Btrfs">Btrfs</a>.</p>
</div>
<div class="paragraph">
<p>AdemÃ¡s, la mayorÃ­a de los sistemas operativos modernos soportan otros sistemas de archivo, como los utilizados en los soportes removibles.
Por ejemplo el <a href="https://es.wikipedia.org/wiki/ISO_9660">ISO 9660</a>, utilizado por la mayor parte de los CD-ROM, o el <a href="https://es.wikipedia.org/wiki/Universal_Disk_Format">UDF</a> (<em>Universal Disk Format</em>), utilizado por los DVD-ROM y Blu-ray.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_estructuras_de_metadatos_en_disco">19.2. Estructuras de metadatos en disco</h3>
<div class="paragraph">
<p>Para implementar un sistema de archivos se utilizan diversas estructuras de <strong>metadatos</strong> alojadas tanto en el disco como en la memoria.
Estas estructuras varÃ­an dependiendo del sistema operativo y del sistema de archivos.
Sin embargo, a continuaciÃ³n intentaremos describir brevemente las estructuras en disco mÃ¡s comunes.</p>
</div>
<div class="sect3">
<h4 id="_bloque_de_control_de_arranque">19.2.1. Bloque de control de arranque</h4>
<div class="paragraph">
<p>

</p>
</div>
<div class="paragraph">
<p>En todo sistema de archivos suele haber un <strong>bloque de control de arranque</strong> âtambiÃ©n llamado <strong>bloque de inicio</strong> o <strong>sector de arranque</strong>â que suele ocupar el primer bloque de cada volumen y que contiene la informaciÃ³n necesaria para iniciar un sistema operativo a partir de dicho volumen.</p>
</div>
<div class="paragraph">
<p>Este bloque puede estar vacÃ­o, si el volumen no contiene un sistema operativo.</p>
</div>
</div>
<div class="sect3">
<h4 id="_bloque_de_control_de_volumen">19.2.2. Bloque de control de volumen</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El <strong>bloque de control de volumen</strong> contiene todos los detalles acerca del volumen.
Por ejemplo, el nÃºmero mÃ¡ximo de bloques, el tamaÃ±o de los bloques, el nÃºmero de bloques libres y punteros a los mismos; asÃ­ como un contador de bloques de informaciÃ³n <strong>FCB</strong> ocupados y punteros a estos.</p>
</div>
<div class="paragraph">
<p>A esta estructura se la denomina <strong>superbloque</strong>, en los sistemas de archivos de sistemas UNIX y Linux.
Mientras que en <a href="https://es.wikipedia.org/wiki/NTFS">NTFS</a> esta informaciÃ³n se almacena en la <strong>tabla maestra de archivos</strong> o <strong>MFT</strong> (<em>Master File Table</em>).</p>
</div>
</div>
<div class="sect3">
<h4 id="_bloque_de_control_de_archivo">19.2.3. Bloque de control de archivo</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Todo sistema de archivos tiene un <strong>bloque de control de archivo</strong> o <strong>FCB</strong> (<em>File Control Block</em>) por archivo, en que se almacenan numerosos detalles sobre cada uno de los archivos
Por ejemplo, los permisos, el propietario, el tamaÃ±o y la ubicaciÃ³n de los bloques de datos, entre otros.</p>
</div>
<div class="paragraph">
<p>En tÃ©rminos generales, todos los <strong>FCB</strong> del sistema de archivos se almacenan en una tabla denominada <strong>directorio de dispositivo</strong> o <strong>tabla de contenidos del volumen</strong>.</p>
</div>
<div class="paragraph">
<p>En los sistemas de archivos de sistemas UNIX y Linux cada FCB se denomina <strong>inodo</strong> y se almacenan a continuaciÃ³n del <strong>superbloque</strong>.
En <a href="https://es.wikipedia.org/wiki/NTFS">NTFS</a> esta informaciÃ³n se almacena en la <strong>MFT</strong>, ya que cada entrada de dicha tabla es un <strong>FCB</strong>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_estructura_de_directorios">19.2.4. Estructura de directorios</h4>
<div class="paragraph">
<p>Finalmente, por lo general los sistemas de archivos tienen una estructura de directorios, para organizar los archivos.</p>
</div>
<div class="paragraph">
<p>En los sistemas de archivos de sistemas UNIX y Linux, cada directorio es como un archivo especial que almacena los nombres de los archivos que contiene y los Ã­ndices de los <strong>inodos</strong> de cada uno de ellos.
En <a href="https://es.wikipedia.org/wiki/NTFS">NTFS</a> es similar, aunque la estructura de directorios completa se almacena en la propia <strong>MFT</strong>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_estructuras_de_metadatos_en_memoria">19.3. Estructuras de metadatos en memoria</h3>
<div class="paragraph">
<p>La informaciÃ³n almacenada en memoria se utiliza tanto para la gestiÃ³n del sistema de archivos como para mejorar el rendimiento del mismo mediante mecanismos de cachÃ©.</p>
</div>
<div class="paragraph">
<p>Los datos se cargan en el momento de comenzar a utilizar el sistema de archivos âproceso denominado montajeâ y se descartan cuando se va a dejar de hacer uso del mismo âes decir, en el desmontajeâ.</p>
</div>
<div class="paragraph">
<p>Las estructuras existentes en la memoria pueden incluir las que a continuaciÃ³n se describen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Una <strong>tabla de montaje</strong> en memoria que contiene informaciÃ³n acerca de cada volumen montado en el sistema.</p>
</li>
<li>
<p>Una cachÃ© en memoria de la <strong>estructura de directorios</strong> que almacena la informaciÃ³n relativa a los directorios a los que se ha accedido recientemente.
Los directorios que actÃºan como puntos de montaje pueden contener un puntero a la entrada, en la tabla de montaje, del volumen montado en el directorio.</p>
</li>
<li>
<p>La <strong>tabla global de archivos abiertos</strong> que contiene una copia del <strong>FCB</strong> de cada archivo abierto en el sistema, ademÃ¡s de otras informaciones.</p>
</li>
<li>
<p>La <strong>tabla de archivos abiertos</strong> de cada proceso.
El <strong>PCB</strong> de cada proceso contiene una tabla donde se listan los archivos abiertos por el proceso.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>La <strong>tabla de archivos abiertos</strong> contiene, para cada archivo, un puntero a la entrada correspondiente del mismo archivo en la tabla global de archivos abiertos, pero tambiÃ©n guarda otras informaciones adicionales que son particulares de cada proceso.
Por ejemplo, si el proceso lo ha abierto para lectura o escritura o la posiciÃ³n del puntero que indica la siguiente posiciÃ³n a leer o escribir.</p>
</div>
</div>
<div class="sect2">
<h3 id="_montaje_de_sistemas_de_archivos">19.4. Montaje de sistemas de archivos</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Un sistema de archivos debe <strong>montarse</strong> para que sus archivos sean accesibles a los procesos del sistema.
El proceso de montaje incluye los siguientes pasos:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Al sistema operativo se le debe proporcionar el nombre o identificador del dispositivo y el punto de montaje.
El <strong></strong> es la ubicaciÃ³n dentro de la estructura de directorios âla ruta al directorio concretoâ a la que queremos conectar el sistema de archivos.
DespuÃ©s de que el proceso de montaje se haya completado, los archivos y directorios del sistema de archivos montado serÃ¡n accesibles como descendientes del directorio del <strong>punto de montaje</strong>.</p>
</li>
<li>
<p>A continuaciÃ³n el sistema operativo verifica que el dispositivo contiene un sistema de archivos vÃ¡lido.
Para ello lee el <strong>bloque de control de volumen</strong> y comprueba que tiene un formato vÃ¡lido.</p>
</li>
<li>
<p>Finalmente el sistema operativo registra en la <strong>tabla de montaje</strong> el tipo de sistema de archivos y el identificador del dispositivo montado.
DespuÃ©s, almacena el Ã­ndice de la entrada correspondiente en la <strong>tabla de montaje</strong> en la copia en memoria del <strong>FCB</strong> del directorio que hace de <strong>punto de montaje</strong>.</p>
<div class="paragraph">
<p>Esto permite que pueda ser recorrida la estructura de directorios de distintos sistemas de archivos, pasando de uno a otro de forma transparente, segÃºn sea necesario.</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>En muchos sistemas operativos modernos, el montaje se ejecuta automÃ¡ticamente cuando los dispositivos son detectados durante el arranque del sistema o cuando se conectan durante el funcionamiento del mismo âpor ejemplo, cuando se inserta un medio en la unidad CD-ROM o se pincha una memoria flash en un puerto USBâ.
En algunos se permite, ademÃ¡s, que el administrador del equipo ejecute operaciones de montaje manuales.</p>
</div>
</div>
<div class="sect2">
<h3 id="_archivos">19.5. Archivos</h3>
<div class="paragraph">
<p>Cada sistema de archivos almacena en disco una tabla donde cada entrada guarda un <strong>bloque de control de archivo</strong> o <strong>FCB</strong> (<em>File Control Block</em>) por archivo.
Concretamente, en cada <strong>FCB</strong> se almacena diversa informaciÃ³n acerca del archivo al que representa.</p>
</div>
<div class="sect3">
<h4 id="_atributos_de_archivos">19.5.1. Atributos de archivos</h4>
<div class="paragraph">
<p>La colecciÃ³n de atributos asociada a un archivo varÃ­a de un sistema operativo a otro, pero tÃ­picamente son los siguientes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Nombre</strong>.
Nombre simbÃ³lico del archivo, que se mantiene en un formato legible por la conveniencia de los usuarios.</p>
</li>
<li>
<p><strong>Identificador</strong>.
Identifica de forma unÃ­voca el archivo dentro del sistema de archivos.
Generalmente es el Ã­ndice del <strong>FCB</strong> en la <strong>tabla de contenidos del volumen</strong>, donde se almacenan los <strong>FCB</strong>.</p>
</li>
<li>
<p><strong>Tipo</strong>.
Es un atributo necesario en los sistemas que soportan diferentes tipos de archivos.</p>
</li>
<li>
<p><strong>UbicaciÃ³n</strong>.
Es un puntero a un dispositivo y a la ubicaciÃ³n de los bloques con los datos del archivo dentro del mismo.</p>
</li>
<li>
<p><strong>TamaÃ±o</strong>.
Indica el tamaÃ±o actual de archivo âen bytes, palabras o bloquesâ y, posiblemente, el tamaÃ±o mÃ¡ximo permitido.</p>
</li>
<li>
<p><strong>ProtecciÃ³n</strong>.
InformaciÃ³n de control de acceso que determina quiÃ©n puede leerlo, escribirlo, ejecutarlo, etc.</p>
</li>
<li>
<p><strong>Fecha, hora e identificaciÃ³n del usuario</strong>.
Esta informaciÃ³n puede mantenerse para los sucesos de creaciÃ³n, de Ãºltima modificaciÃ³n y Ãºltimo uso del archivo.
Puede resultar Ãºtil para la protecciÃ³n, seguridad y monitorizaciÃ³n del uso del archivo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Los atributos de los archivos se almacenan en las estructuras de <strong>metadatos</strong>.</p>
</div>
<div class="paragraph">
<p>Normalmente el nombre se almacena en la estructura de directorios, de tal manera que una entrada de directorio estÃ¡ compuesta del nombre de un archivo y del identificador de su <strong>FCB</strong>.
Dicho identificador permite localizar el <strong>FCB</strong> en la <strong>tabla de contenidos del volumen</strong>, que contiene el resto de los atributos del archivo.</p>
</div>
</div>
<div class="sect3">
<h4 id="_operaciones_con_los_archivos">19.5.2. Operaciones con los archivos</h4>
<div class="paragraph">
<p>Un archivo es un tipo abstracto de datos sobre el que pueden realizarse diversas operaciones.
Concretamente el sistema operativo proporciona llamadas al sistema para: crear, abrir, escribir, leer, reposicionar el puntero de lectura/escritura, borrar y truncar o redimensionar archivos.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Generalmente el sistema mantiene un puntero de lectura/escritura que hace referencia a la ubicaciÃ³n dentro del archivo en la que debe tener lugar la siguiente operaciÃ³n.
Este puntero se actualiza, avanzando cada vez que se realiza un nueva lectura/escritura.</p>
</div>
<div class="paragraph">
<p>Para desplazarse aleatoriamente por el archivo, el sistema operativo debe ofrecer una llamada al sistema que permita reposicionar el puntero allÃ­ donde interese.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Muchos sistemas tambiÃ©n disponen de operaciones para consultar y modificar diversos atributos de un archivo, como la longitud o el propietario del mismo.
AdemÃ¡s, se suelen incluir llamadas para otras operaciones comunes, como aÃ±adir datos al final de un archivo o el renombrado de un archivo existente.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 14. Funciones de la API para manipular archivos.</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">POSIX API</th>
<th class="tableblock halign-left valign-top">Windows API</th>
</tr>
</thead>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Crear archivos</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a> / <a href="https://man7.org/linux/man-pages/man2/openat.2.html">openat()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Abrir archivos</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a> / <a href="https://man7.org/linux/man-pages/man2/openat.2.html">openat()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-openfile">OpenFile()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Cerrar archivos</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/close.2.html">close()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle">CloseHandle()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Borrar archivos</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/unlink.2.html">unlink()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-deletefilea">DeleteFile()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Leer contenidos</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile">ReadFile()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Escribir contenido</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile">WriteFile()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Reposicionar puntero de lectura/escritura</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.man7.org/linux/man-pages/man2/lseek.2.html">lseek()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfilepointer">SetFilePointer()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Redimensionar archivos</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://linux.die.net/man/2/ftruncate">ftruncate()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setendoffile">SetEndOfFile()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Consultar atributos</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/stat.2.html">stat()</a> / <a href="https://man7.org/linux/man-pages/man2/fstat.2.html">fstat()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfileattributesa">GetFileAttributes()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Renombrar archivos</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/rename.2.html">rename()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-movefile">MoveFile()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Copiar archivos</p></th>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-movefile">MoveFile()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Mover archivos</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/rename.2.html">rename()</a> <span class="lightcell">solo en el mismo sistema de archivos</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-copyfile">CopyFile()</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Estas operaciones primitivas puede combinarse, a su vez, para realizar otras operaciones mÃ¡s complejas âpor ejemplo, crear una copia de un archivo o moverlo a otro lugar de la estructura de directoriosâ.</p>
</div>
</div>
<div class="sect3">
<h4 id="_abrir_archivos">19.5.3. Abrir archivos</h4>
<div class="paragraph">
<p>La mayor parte de las operaciones comentadas implican realizar una bÃºsqueda en el directorio para encontrar la entrada asociada con el archivo cuyo nombre se ha indicado.
Para evitar realizar estÃ¡ bÃºsqueda una yo otra vez, muchos sistemas requieren que el proceso haga una llamada al sistema <strong>open</strong>, antes de realizar cualquiera de estas operaciones por primera vez sobre un archivo.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En unos pocos sistemas, los archivos se abren automÃ¡ticamente cuando un proceso solicita su primera operaciÃ³n sobre los mismos y se cierran cuando el proceso termina.
Sin embargo lo mÃ¡s comÃºn es que los procesos tengan que abrir los archivos explÃ­citamente.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>En concreto la operaciÃ³n <strong>open</strong>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Busca en el directorio el nombre del archivo, hasta encontrar la entrada asociada y recupera el identificador del mismo.</p>
</li>
<li>
<p>Utiliza el identificador del archivo para recuperar el <strong>FCB</strong> correspondiente.</p>
</li>
<li>
<p>Crea una entrada para el archivo en la <strong>tabla de archivos abiertos</strong> donde se almacena la informaciÃ³n del FCB.</p>
</li>
<li>
<p>Retorna al proceso devolviendo un identificador âen forma de puntero o de Ã­ndiceâ a la nueva entrada en la tabla de archivos abiertos.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>El nombre con el que se designa a esas entradas en la tabla de archivos abiertos varÃ­a de unos sistemas operativos a otros.
En los sistemas POSIX se utiliza el tÃ©rmino <strong>descriptor de archivo</strong> âo <em>file descriptor</em>â mientras que en los sistemas Microsoft Windows se prefiere el tÃ©rmino <strong>manejador de archivo</strong> âo <em>file handler</em>â.</p>
</div>
<div class="paragraph">
<p>DespuÃ©s de utilizar la llamada al sistema <strong>open</strong>, cuando se desea solicitar una operaciÃ³n sobre un archivo, sÃ³lo es necesario proporcionar el identificador devuelto, evitando asÃ­ que haga falta realizar nuevamente la exploraciÃ³n del directorio para buscar el archivo.</p>
</div>
<div class="paragraph">
<p>En los sistemas operativos donde varios procesos pueden abrir un mismo archivo, se suelen utilizar dos niveles de tablas de archivos abiertos:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Una <strong>tabla para cada proceso</strong> âalmacenada en el <strong>PCB</strong>â donde se indican todos los archivos que el proceso tiene abiertos.</p>
<div class="paragraph">
<p>En dicha tabla se almacena toda la informaciÃ³n referente al uso de cada archivo por parte de un proceso.
Por ejemplo, se puede almacenar la posiciÃ³n actual utilizada por las operaciones de lectura y escritura o los derechos de acceso.</p>
</div>
</li>
<li>
<p>Una <strong>tabla global para todo el sistema</strong> donde se almacena toda la informaciÃ³n independiente de los procesos, como la ubicaciÃ³n del archivo en el disco, las fechas de acceso y el tamaÃ±o del archivo.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Cuando un proceso invoca la llamada <strong>open</strong>, se aÃ±ade una entrada en la <strong>tabla de archivos abiertos del proceso</strong>, que a su vez apunta a la entrada correspondiente dentro de la <strong>tabla global del sistema</strong>.
Si el archivo no existe en esta Ãºltima, tambiÃ©n hay que crear una entrada en la tabla global del sistema haciendo uso de la informaciÃ³n contenida en disco en el <strong>FCB</strong> correspondiente.</p>
</div>
<div class="paragraph">
<p>Es muy comÃºn, que la <strong>tabla global</strong> almacene un <strong>contador de aperturas</strong> para cada archivo, con el objetivo de indicar cuantos procesos lo mantienen abierto.</p>
</div>
<div class="paragraph">
<p>Cuando el archivo deja de ser utilizado activamente por el proceso, puede ser cerrado utilizado la llamada al sistema <strong>close</strong>.
Entonces el <strong>contador de aperturas</strong> se decrementa, de forma que cuando alcance cero querrÃ¡ decir que la entrada puede ser eliminada de la <strong>tabla global de archivos abiertos</strong>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tipos_de_archivo">19.5.4. Tipos de archivo</h4>
<div class="paragraph">
<p>Cuando se diseÃ±a un sistema operativo es necesario considerar si debe reconocer y soportar el concepto de <strong>tipo de archivo</strong>.
Si el sistema operativo reconoce el <strong>tipo de un archivo</strong> puede operar con el mismo de formas razonables.
Por ejemplo, el sistema puede impedir que un usuario intente imprimir los archivos que contienen programas en formato binario, pues el documento impreso serÃ­a ininteligible.</p>
</div>
<div class="paragraph">
<p>En los sistemas operativos mÃ¡s comunes las tÃ©cnicas utilizadas para implementar los tipos de archivo son las siguientes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En MS-DOS y Microsoft Windows el tipo de archivo se incluye como parte del nombre del archivo.
Es decir, el nombre se divide en dos partes: un nombre y una extensiÃ³n, separadas por un punto.</p>
<div class="paragraph">
<p>El sistema puede utilizar la extensiÃ³n para conocer el tipo de archivo y el tipo de operaciones que se pueden realizar con el mismo.</p>
</div>
</li>
<li>
<p>En macOS cada archivo tiene un atributo que almacena el tipo âpor ejemplo, TEXT para los archivos de texto o APPL para las aplicacionesâ y otro que contiene el nombre del programa que lo creÃ³.
Cuando el usuario hace clic con el ratÃ³n sobre el icono de un archivo, el programa que lo creÃ³ se ejecuta automÃ¡ticamente y Ã©ste abre el archivo.</p>
</li>
<li>
<p>En los sistemas estilo UNIX se utiliza un <strong>nÃºmero mÃ¡gico</strong>, almacenado al principio de algunos archivos, para indicar el tipo del mismo.
No todos los archivos tienen nÃºmeros mÃ¡gicos, por lo que se permite hacer sugerencias en forma de extensiones del nombre del archivo.</p>
<div class="paragraph">
<p>Sin embargo, en estos sistemas estas extensiones ni son obligatorias ni el sistema depende de ellas.
Su objetivo, fundamentalmente, es ayudar a los usuarios a determinar el tipo de contenido de un archivo, por lo que pueden ser utilizadas o ignoradas por cada aplicaciÃ³n concreta, en funciÃ³n de las preferencias de sus desarrolladores.</p>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_estructura_de_directorios_2">19.6. Estructura de directorios</h3>
<div class="paragraph">
<p>Algunos sistemas de archivos pueden almacenar millones de archivos en terabytes de disco.
Para gestionar todos esos datos necesitamos organizarlos de alguna manera, lo que generalmente implica el uso de directorios.</p>
</div>
<div class="paragraph">
<p>Un <strong>directorio</strong> puede considerarse una tabla de sÃ­mbolos que traduce los nombre de los archivos en los identificadores que permiten recuperar sus correspondientes entradas en la <strong>tabla de contenidos del volumen</strong>, donde se almacenan los <strong>FCB</strong>.</p>
</div>
<div class="paragraph">
<p>A continuaciÃ³n vamos a estudiar los diversos esquemas para definir la estructura lÃ³gica del sistema de directorios.</p>
</div>
<div class="sect3">
<h4 id="_directorios_de_un_nivel">19.6.1. Directorios de un nivel</h4>
<div class="paragraph">
<p>En la estructura de directorios de un nivel todos los archivos estÃ¡n contenidos en un Ãºnico directorio.</p>
</div>
<div class="paragraph">
<p>Esto presenta algunas limitaciones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cuando el nÃºmero de usuarios del sistema aumenta se hace mÃ¡s difÃ­cil que cada uno escoja nombres diferentes para sus archivos.
Esto es necesario, puesto que todos los archivos se encuentran en el mismo directorio.</p>
</li>
<li>
<p>Incluso en los sistemas operativos monousuario, puede ser difÃ­cil para un usuario mantener organizados sus datos a medida que se incrementa el nÃºmero de archivos.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Este esquema fue utilizado por la primera versiÃ³n del sistema operativo MS-DOS.</p>
</div>
</div>
<div class="sect3">
<h4 id="_directorio_de_dos_niveles">19.6.2. Directorio de dos niveles</h4>
<div class="paragraph">
<p>En la estructura de directorios de dos niveles cada usuario tiene su propio <strong>directorio de archivos de usuario</strong> o <strong>UFD</strong> (<em>User File Directory</em>) que cuelga del <strong>directorio maestro de archivos</strong> o <strong>MFD</strong> (<em>Master File Directory</em>).</p>
</div>
<div class="paragraph">
<p>Cuando un usuario se conecta al sistema o inicia un trabajo, se explora el <strong>MFD</strong>.
Ãsta es una tabla indexada por el nombre de los usuarios o por los nÃºmeros de cuenta, donde cada una de sus entradas apunta al <strong>UFD</strong> de dicho usuario.
Puesto que cada <strong>UFD</strong> incluye sÃ³lo los archivos del usuario al que pertenece, el sistema operativo puede confinar todas las operaciones que puede realizar un usuario sobre los archivos a su <strong>UFD</strong>.</p>
</div>
<div class="paragraph">
<p>Aunque esto resuelve el problema de la colisiÃ³n de nombres entre diferentes usuarios, tambiÃ©n presenta algunas desventajas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La estructura descrita aÃ­sla a los usuarios, lo cual puede ser un problema cuando Ã©stos quieren compartir datos para cooperar en alguna tarea.</p>
<div class="paragraph">
<p>La soluciÃ³n pasa por utilizar <strong>nombres de ruta</strong> para designar a un archivo de forma unÃ­voca.
Por ejemplo, si el usuario <code>usera</code> quiere acceder a su archivo <code>test</code>, simplemente debe referirse a Ã©l como <code>test</code>.
Mientras que si quiere acceder al archivo <code>test</code> del usuario <code>userb</code>, debe utilizar un <strong>nombre de ruta</strong> como <code>/userb/test</code>, donde se indica el nombre del usuario y el nombre del archivo.</p>
</div>
<div class="paragraph">
<p>En general, cada sistema operativo utiliza su propia sintaxis par nombrar los archivos contenidos en los directorios de otros usuarios.</p>
</div>
</li>
<li>
<p>Puede ser difÃ­cil para un usuario mantener organizados sus datos a medida que se incrementa el nÃºmero de archivos personales, incluso aunque tenga un directorio para Ã©l solo.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_directorios_con_estructura_de_Ã¡rbol">19.6.3. Directorios con estructura de Ã¡rbol</h4>
<div class="paragraph">
<p>La estructura de directorio de dos niveles puede generalizarse en la <strong>estructura de directorios en Ã¡rbol</strong> de altura arbitraria.
Esto permite que los usuarios puedan crear sus propios subdirectorios para organizar sus archivos de la forma mÃ¡s conveniente.</p>
</div>
<div class="paragraph">
<p>Cada sistema de archivos tiene un <strong>directorio raÃ­z</strong> que puede contener tanto archivos como otros directorios.
A su vez, cada directorio puede contener un conjunto de archivos y subdirectorios.</p>
</div>
<div class="paragraph">
<p>Normalmente, cada entrada de directorio incluye un bit donde se indica si dicha entrada apunta a un archivo o a un subdirectorio.
Esto se hace asÃ­ porque, generalmente, los directorios no son mÃ¡s que archivos con un formato interno especial; por lo que el sistema debe saber si la entrada apunta a un directorio para interpretar correctamente los datos del directorio.</p>
</div>
<div class="sect4">
<h5 id="_directorio_de_trabajo_actual">Directorio de trabajo actual</h5>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>ComÃºnmente, en el <strong>PCB</strong> de cada proceso se guarda cual es su <strong>directorio de trabajo</strong> actual.
De esta forma, cuando se hace referencia a un archivo en una llamada al sistema usando solo su nombre, se le busca en el <strong>directorio de trabajo</strong> del proceso.</p>
</div>
<div class="paragraph">
<p>Si se necesita un archivo que no se encuentra en el <strong>directorio de trabajo</strong> actual, entonces el usuario debe especificar un <strong>nombre de ruta</strong> desde el <strong>directorio de trabajo</strong>, o primero cambiar con una llamada al sistema el directorio de trabajo del proceso al directorio donde estÃ¡ almacenado el archivo.</p>
</div>
<div class="paragraph">
<p>Windows API permite indicar el <strong>directorio de trabajo</strong> de un nuevo proceso al crearlo, a travÃ©s del argumento <code>lpCurrentDirectory</code> de <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a>.
Si este argumento vale NULL, el proceso hereda el <strong>directorio de trabajo</strong> del padre.
En todo caso, cualquier proceso puede cambiar su <strong>directorio de trabajo</strong> actual llamando a <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setcurrentdirectory">SetCurrentDirectory()</a>.</p>
</div>
<div class="paragraph">
<p>En los sistemas POSIX, el proceso hijo creado con <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> hereda automÃ¡ticamente el <strong>directorio de trabajo</strong> actual del proceso padre.
Por lo que si necesitamos cambiar su <strong>directorio de trabajo</strong> âpor ejemplo, antes de llamar a <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> para cambiar el <strong>directorio de trabajo</strong> para el nuevo programaâ el proceso puede usar <a href="https://man7.org/linux/man-pages/man2/chdir.2.html">chdir()</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Gracias a la herencia del <strong>directorio de trabajo</strong> es como los <strong>interpretes de comandos</strong> indican a los comandos que ejecutan en quÃ© directorio deben ejecutarse.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, en los sistemas POSIX el intÃ©rprete de comandos <strong>Bash</strong> se inicia usando el directorio personal del usuario como <strong>directorio de trabajo</strong>.
El usuario puede cambiar el <strong>directorio de trabajo</strong> del proceso de la <strong>Bash</strong> usando el comando interno <code>cd</code>.
Cuando se pide a la <strong>Bash</strong> que ejecute cualquier otro comando, Ã©sta crea un nuevo proceso hijo donde ejecutar el programa de dicho comando.
Ese proceso hereda el <strong>directorio de trabajo</strong> actual de <strong>Bash</strong>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_nombre_de_ruta">Nombre de ruta</h5>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Los <strong>nombres de ruta</strong> es la forma en la que se indica la ubicaciÃ³n de un archivo o directorio en el Ã¡rbol de directorios.</p>
</div>
<div class="paragraph">
<p>Los <strong>nombres de ruta</strong> pueden ser de dos tipos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Un <strong>nombre de ruta absoluto</strong> comienza en la raÃ­z y va indicando los directorios que componen la ruta de forma descendente hasta llegar al archivo especificado.</p>
<div class="paragraph">
<p>Por ejemplo, <code>/usr/share/doc</code>, <code>C:\Programa Files\WindowsApps</code> o <code>\Windows\System32</code></p>
</div>
</li>
<li>
<p>Un <strong>nombre de ruta relativo</strong> define una ruta a partir del <strong>directorio de trabajo actual</strong>.</p>
<div class="paragraph">
<p>Por ejemplo, <code>ImÃ¡genes/Enero/000001.jpg</code>, <code>Downloads\horario.zip</code> o <code>C:Desktop\Proyectos</code>.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Con una <strong>estructura de directorios en Ã¡rbol</strong>, unos usuarios pueden acceder a los archivos de otros.
Para eso, solo es necesario que se utilicen <strong>nombres de ruta</strong> para designar los archivos del otro usuario, o que se cambie el <strong>directorio de trabajo actual</strong>.</p>
</div>
<div class="paragraph">
<p>Este tipo de estructura de directorios es la utilizada por MS-DOS y por las distintas versiones de Microsoft Windows.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_directorios_en_grafo_acÃ­clico">19.6.4. Directorios en grafo acÃ­clico</h4>
<div class="paragraph">
<p>La <strong>estructura de directorio en grafo acÃ­clico</strong> es una generalizaciÃ³n natural del esquema con <strong>estructura en Ã¡rbol</strong>.</p>
</div>
<div class="paragraph">
<p>A diferencia de este Ãºltimo, la <strong>estructura en grafo acÃ­clico</strong> permite que los mismos archivos y subdirectorios existan simultÃ¡neamente en distintos lugares de la estructura de directorios.
Eso significa que para acceder a un archivo o directorio pueden existir diversos <strong>nombres de ruta</strong>.</p>
</div>
<div class="paragraph">
<p>Esto, por ejemplo, permite que los usuarios puedan compartir archivos de tal forma que los mismos archivos y directorios estÃ©n disponibles directamente desde el directorio personal de los diferentes usuarios.</p>
</div>
<div class="sect4">
<h5 id="_enlaces">Enlaces</h5>
<div class="paragraph">
<p>Los archivos y subdirectorios compartidos pueden implementarse de diversas formas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se pueden crear una entrada de directorio especial denominada <strong>enlace</strong>.
Un <strong>enlace</strong> es, generalmente, un archivo que contiene la ruta relativa o absoluta de otro archivo o subdirectorio.
En los sistemas POSIX a Ã©stos se los conoce como <strong>enlaces simbÃ³licos</strong>.</p>
</li>
<li>
<p>TambiÃ©n se puede duplicar toda la informaciÃ³n de la entrada de directorio del archivo compartido en todos los directorios que tambiÃ©n contienen dicho archivo.</p>
<div class="paragraph">
<p>AsÃ­, mientras que los <strong>enlaces simbÃ³licos</strong> son claramente diferentes de la entrada original de directorio, las entradas de directorio duplicadas hacen que la entrada original y la copia sean indistinguibles.
En los sistemas POSIX, a este tipo de entradas duplicadas se las conoce como <strong>enlaces duros</strong>.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Como <strong>enlaces simbÃ³licos</strong> almacenan una ruta, pueden apuntar a archivos o directorios en otros sistemas de archivos.
Mientras que los <strong>enlaces duros</strong> solo pueden apuntar a archivos en el mismo sistema de archivos.</p>
</div>
<div class="paragraph">
<p>En en los sistemas POSIX los <strong>enlaces duros</strong> se crean llamando a <a href="https://man7.org/linux/man-pages/man2/link.2.html">link()</a> y los <strong>enlaces simbÃ³licos</strong> con <a href="https://man7.org/linux/man-pages/man2/symlink.2.html">symlink()</a>.</p>
</div>
<div class="paragraph">
<p>En Microsoft Windows se soportan ambos tipos de enlaces desde la primera versiÃ³n âMicrosoft Windows NT 3.1â pero Ãºnicamente en el sistema de archivos <a href="https://es.wikipedia.org/wiki/NTFS">NTFS</a> y solo por compatibilidad con las aplicaciones POSIX.
Windows API no tuvo funciones para crear <strong>enlaces</strong> hasta mucho despuÃ©s.
Por eso su uso en Microsoft Windows no es tan comÃºn.</p>
</div>
<div class="paragraph">
<p>En Windows API los <strong>enlaces duros</strong> se crean con <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka">CreateHardLink()</a> desde Windows 2000.
Mientras que los <strong>enlaces simbÃ³licos</strong> se crean con <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka">CreateSymbolicLink()</a> desde Windows Vista.</p>
</div>
</div>
<div class="sect4">
<h5 id="_inconvenientes">Inconvenientes</h5>
<div class="paragraph">
<p>Una estructura en grafo acÃ­clico es mÃ¡s flexible que una estructura en Ã¡rbol, pero no por eso estÃ¡ exenta de inconvenientes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Si estamos intentando recorrer el sistema de archivos completo âpor ejemplo, para buscar un archivo o para copiarlos en un dispositivo para hacer copias de seguridadâ debemos evitar acceder mÃ¡s de una vez a los archivos y subdirectorios enlazados.
No olvidemos que en los sistemas con estructura en grafo acÃ­clico, cada archivo puede tener mÃºltiples nombres de ruta absoluta.</p>
<div class="paragraph">
<p>Esto es mÃ¡s sencillo de resolver en el caso de los <strong>enlaces simbÃ³licos</strong>, puesto que podemos evitar recorrerlos al ser claramente distinguibles de los archivos normales.</p>
</div>
</li>
<li>
<p>Los diseÃ±adores deben enfrentarse a la cuestiÃ³n de cuÃ¡ndo liberar el espacio asignado a un archivo enlazado.
Si lo hacemos cuando un usuario lo borra podrÃ­amos dejar <strong>enlaces</strong> que referencian a archivos que no existen.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Sobre esta Ãºltima cuestiÃ³n:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>El caso mÃ¡s sencillo de resolver es el de los <strong>enlaces simbÃ³licos</strong>, ya que pueden ser borrados sin que el archivo original se vea afectado, puesto que lo que se elimina es el <strong>enlace</strong> y no el archivo original.</p>
</li>
<li>
<p>Si lo que se pretende borrar es la entrada de un archivo original que es apuntado desde un <strong>enlace simbÃ³lico</strong>, tampoco hay problema en hacerlo y liberar el espacio asignado al mismo, dejando que el enlace apunte a un archivo que no existe.
Cuando se produzca un intento de acceder al archivos a travÃ©s del <strong>enlace</strong>, el sistema determinarÃ¡ que el archivo referenciado fue borrado y tratarÃ¡ el acceso al enlace de forma similar a cualquier otro acceso ilegal a un archivo que no existe.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Ciertamente, podrÃ­amos plantearnos la posibilidad de buscar todos los <strong>enlaces</strong> al archivo borrado y eliminarlos pero, a menos que el FCB de cada archivo guarde las rutas a los <strong>enlaces</strong> que le seÃ±alan, esta bÃºsqueda podrÃ­a ser muy costosa.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>Otra opciÃ³n es almacenar en la entrada del archivo original un contador con el nÃºmero de referencias al archivo.
Cada vez que se elimina una referencia se decrementa el contador.
Cuando el contador sea 0, sabremos que ha llegado el momento de liberar el espacio asignado.</p>
<div class="paragraph">
<p>En los sistemas UNIX se utiliza esta tÃ©cnica para saber cuÃ¡ndo liberar el contenido de archivos con <strong>enlaces duros</strong>.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Por Ãºltimo, no debemos olvidar que la estructura de directorios en grafo se conserva acÃ­clica si se prohÃ­be que hayan mÃºltiples referencias a un mismo directorio.
Ese es el motivo por el que en muchos sistemas POSIX no se permite, por defecto, que los <strong>enlaces duros</strong> hagan referencia a directorios.
Sin embargo si se pueden utilizar <strong>enlaces simbÃ³licos</strong> para este fin, puesto que al ser distinguibles del directorio original podemos evitar los ciclos, si mientras se explora se ignoran dichos enlaces.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_directorios_en_forma_de_grafo_general">19.6.5. Directorios en forma de grafo general</h4>
<div class="paragraph">
<p>Uno de los principales problemas de la <strong>estructura de directorios en grafo acÃ­clico</strong> es garantizar que no exista ningÃºn ciclo.
Esto es interesante puesto que mientras sea asÃ­ los algoritmos diseÃ±ados para recorrer el grafo y para determinar cuÃ¡ndo no existen mÃ¡s referencias a un archivo, son relativamente simples.</p>
</div>
<div class="paragraph">
<p>No olvidemos que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Es importante evitar encontrar cualquier archivo dos o mÃ¡s veces, tanto por razones de correcciÃ³n como de rendimiento.</p>
</li>
<li>
<p>En una <strong>estructura de directorios en forma de grafo general</strong> que use contadores de referencia para borrar archivos cuÃ¡ndo no hay mÃ¡s referencias, puede que dicho contador no sea 0, aunque no hayan mÃ¡s referencias al archivo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Esto significa que generalmente se necesita algÃºn mecanismo de recolecciÃ³n de basura para determinar con seguridad cuÃ¡ndo se ha borrado la Ãºltima referencia.
La recolecciÃ³n de basura implica recorrer todo el sistema de archivos y marcar todos aquellos elementos que sean accesibles.
DespuÃ©s, en una segunda pasada, se elimina todo lo que no estÃ© marcado.
Por tanto, es evidente que la recolecciÃ³n de basura para un sistema de archivos basado en disco consume mucho tiempo, por lo que se utiliza en muy pocas ocasiones.</p>
</div>
<div class="paragraph">
<p>Es mucho mÃ¡s sencillo trabajar con <strong>estructuras de directorio en grafo acÃ­clico</strong>.
Para evitar que en un grafo aparezca un ciclo al aÃ±adir un nuevo <strong>enlace</strong>, se pueden utilizar diversos algoritmos.
Sin embargo, puesto que tambiÃ©n suelen ser muy costosos, lo mÃ¡s simple es ignorar todos los <strong>enlaces simbÃ³licos</strong> en los casos en los que se recorre el Ã¡rbol de directorios para realizar una tarea en la que es importante no entrar en un bucle âpor ejemplo, al hacer una bÃºsquedaâ.</p>
</div>
<div class="paragraph">
<p>En el caso de los <strong>enlaces duros</strong> âdonde se duplica entradas de directorio que no se pueden distinguir de la del archivo original y, por tanto, no se pueden ignorarâ lo mÃ¡s sencillo es que el sistema operativo no permita crear mÃºltiples referencias a un mismo directorio.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_comparticiÃ³n_de_archivos">19.7. ComparticiÃ³n de archivos</h3>
<div class="paragraph">
<p>Como ya hemos comentado, el que los usuarios puedan compartir archivos es algo muy deseable, pues permite que Ã©stos puedan colaborar en la realizaciÃ³n de una tarea determinada.
Sin embargo, al aÃ±adir esta caracterÃ­stica, hay que tener en cuenta algunos aspectos que deben ser resueltos en el diseÃ±o del sistema operativo.</p>
</div>
<div class="sect3">
<h4 id="_mÃºltiples_usuarios_y_protecciÃ³n">19.7.1. MÃºltiples usuarios y protecciÃ³n</h4>
<div class="paragraph">
<p>Cuando un sistema operativo admite mÃºltiples usuarios y utiliza una estructura de directorio que permite que Ã©stos compartan archivos, cobra gran importancia la protecciÃ³n de los datos.
En este sentido, el sistema operativo debe adoptar un papel de mediador en lo que respecta a la comparticiÃ³n de los archivos.</p>
</div>
<div class="paragraph">
<p>Para implementar la comparticiÃ³n y los mecanismos de protecciÃ³n, el sistema debe soportar mÃ¡s atributos para cada archivo y directorio que los que necesita en un sistema monousuario.
Aunque a lo largo de la historia se han adoptado diversos enfoques, la mayorÃ­a han evolucionado hasta utilizar los conceptos de <strong>propietario</strong> âo <strong>usuario</strong>â y <strong>grupo</strong> de un archivo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>El propietario de un archivo es el usuario que puede cambiar los atributos y conceder el acceso.
Se trata del usuario que dispone del mayor grado de control sobre el archivo.</p>
</li>
<li>
<p>El grupo es un conjunto de usuarios que pueden compartir el acceso al archivo.
El propietario del archivo es quien define que operaciones pueden ser ejecutadas por los miembros del grupo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Los identificadores del propietario y el grupo de un archivo se almacenan junto con los otros atributos en el FCB.</p>
</div>
<div class="paragraph">
<p>Cuando un usuario solicita realiza una operaciÃ³n sobre un archivo, se compara el identificador del usuario con el atributo del propietario para determinar si el solicitante es el propietario.
Exactamente de la misma manera se puede proceder con los identificadores de grupo.
El resultado de la comparaciÃ³n indica que permisos son aplicables.
A continuaciÃ³n, el sistema aplica dichos permisos a la operaciÃ³n solicitada y la autoriza o deniega segÃºn sea el caso.</p>
</div>
<div class="paragraph">
<p>Existen diversas implementaciones del esquema utilizado para determinar los permisos aplicables a un usuario que pretende operar sobre un archivo concreto.</p>
</div>
<div class="sect4">
<h5 id="_lista_de_control_de_acceso">Lista de control de acceso</h5>
<div class="paragraph">
<p>El esquema mÃ¡s general consiste en asociar a cada archivo o directorio una <strong>lista de control de acceso</strong> o <strong>ACL</strong> (<em>Access-control list</em>) que especifique los nombres de usuario o grupos y los tipos de acceso para cada uno.</p>
</div>
<div class="paragraph">
<p>Cuando un usuario solicita acceder a un archivo concreto, el sistema operativo comprueba la <strong>ACL</strong> asociada a dicho archivo.
Si el usuario, o alguno de sus grupos, estÃ¡ incluido en la lista para el tipo de acceso solicitado, se permite el acceso.</p>
</div>
<div class="paragraph">
<p>Esta tÃ©cnica presenta diversas ventajas e inconvenientes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se trata de la tÃ©cnica mÃ¡s general, permitiendo la implementaciÃ³n de polÃ­ticas de acceso muy complejas.</p>
</li>
<li>
<p>Construir la lista puede ser una tarea tediosa.
Por ejemplo, si queremos que varios usuarios puedan leer unos archivos determinados, es necesario enumerar todos los usuarios que disponen de ese acceso en las <strong>ACL</strong> de dichos archivos.</p>
</li>
<li>
<p>El <strong>FCB</strong>, que hasta el momento tenÃ­a un tamaÃ±o fijo, ahora tendrÃ¡ que ser de tamaÃ±o variable para almacenar la <strong>ACL</strong>, lo que requiere mecanismos mÃ¡s complejos de gestiÃ³n del espacio.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>La familia de sistemas operativos Microsoft Windows utiliza este tipo de <strong>ACL</strong>.
Al crear un archivo nuevo, se puede indicar la <strong>ACL</strong> deseada a travÃ©s del argumento <code>lpSecurityAttributes</code> de <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile()</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>TambiÃ©n se puede consultar la <strong>ACL</strong> de cualquier objeto con permisos âincluidos los archivosâ usando <a href="https://docs.microsoft.com/en-us/windows/win32/api/aclapi/nf-aclapi-getsecurityinfo">GetSecurityInfo()</a> o <a href="https://docs.microsoft.com/en-us/windows/win32/api/aclapi/nf-aclapi-getnamedsecurityinfoa">GetNamedSecurityInfo()</a> y modificarla usando <a href="https://docs.microsoft.com/en-us/windows/win32/api/aclapi/nf-aclapi-setsecurityinfo">SetSecurityInfo()</a> o <a href="https://docs.microsoft.com/en-us/windows/win32/api/aclapi/nf-aclapi-setnamedsecurityinfoa">SetNamedSecurityInfo()</a>.</p>
</div>
<div class="paragraph">
<p>Las <strong>ACL</strong> y los <strong>descriptores de seguridad</strong> de Windows API son un tema complejo.
Antes de manipularlos, es conveniente consultar <a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/security-descriptors">Â«Security DescriptorsÂ»</a> en Microsoft Docs.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_lista_de_control_de_acceso_condensada">Lista de control de acceso condensada</h5>
<div class="paragraph">
<p>Para solucionar algunos de los problemas de las <strong>ACL</strong> muchos sistemas utilizan <strong>listas de control de acceso condensadas</strong>.</p>
</div>
<div class="paragraph">
<p>Para condensar la longitud de la lista de control de acceso, generalmente los sistemas clasifican a los usuarios en tres grupos: <strong>propietario</strong>, <strong>grupo</strong> y <strong>otros</strong>.
AsÃ­ sÃ³lo es necesario un campo para cada clase de usuario, siendo cada campo una colecciÃ³n de bits, donde cada uno permite o deniega el tipo de acceso asociado al mismo.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, en los sistemas POSIX se definen 3 campos â<strong>propietario</strong>, <strong>grupo</strong> y <strong>otros</strong>) de 3 bits cada uno: <code>rwx</code>, donde <code>r</code> controla el acceso de lectura, <code>w</code> controla el acceso de escritura y <code>x</code> controla la ejecuciÃ³n.</p>
</div>
<div class="paragraph">
<p>Las ACL condensadas son mÃ¡s sencillas de construir.
Al mismo tiempo, por tener una longitud fija, es mucho mÃ¡s simple gestionar el espacio para el <strong>FCB</strong> donde se almacenan.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Permisos de archivo en sistemas POSIX</div>
<div class="paragraph">
<p>Los sistemas POSIX usan, por defecto, <strong>listas de control de acceso condensadas</strong>.</p>
</div>
<div class="paragraph">
<p>Al crear un archivo nuevo, se pueden indicar los permisos de forma numÃ©rica a travÃ©s del argumento <code>mode</code> de <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span>
    <span class="s">"foo.txt"</span><span class="p">,</span>
    <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_RDWR</span><span class="p">,</span>
    <span class="mo">0666</span>  <i class="conum" data-value="1"></i><b>(1)</b> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Indica los permisos del archivo en caso de crearlo.
Se ignora si el archivo ya existe.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Los bits a 1 del nÃºmero especificado indican los permisos autorizados.
Es muy comÃºn hacerlo en base octal, como en el ejemplo.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Otra llamada al sistema que permite indicar permisos es <a href="https://man7.org/linux/man-pages/man2/mkdir.2.html">mkdir()</a>, que se utiliza para crear directorios</p>
</div>
<div class="paragraph">
<p>En ambos casos, los permisos finalmente usados vienen determinados por la <strong><em>umask</em></strong> del proceso.
Esta es una propiedad numÃ©rica de los procesos âheredada de padres a hijosâ que indica quÃ© permisos del argumento <code>mode</code> de <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a> y <a href="https://man7.org/linux/man-pages/man2/mkdir.2.html">mkdir()</a> se desactivan al crear un archivo o directorio.
Por ejemplo, si el argumento <code>mode</code> es 0666 y <strong><em>umask</em></strong> es 0022, los permisos efectivos al crear el archivo serÃ¡n 0644.</p>
</div>
<div class="paragraph">
<p>Un proceso puede cambiar su <strong><em>umask</em></strong> mediante la funciÃ³n <a href="https://man7.org/linux/man-pages/man2/umask.2.html">umask()</a> y los usuarios de <strong>Bash</strong>, las de su <em>shell</em> usando el comando del mismo nombre.</p>
</div>
<div class="paragraph">
<p>Los procesos pueden consultar fÃ¡cilmente los permisos que tienen sobre un archivo usando <a href="https://man7.org/linux/man-pages/man2/access.2.html">access()</a>.
Y pueden cambiar su propietario y el grupo llamando a la funciÃ³n <a href="https://man7.org/linux/man-pages/man2/chown.2.html">chown()</a>.
Si necesitan leer los permisos, el propietario y el resto de <strong>metadatos</strong> del archivo, pueden usar <a href="https://man7.org/linux/man-pages/man2/stat.2.html">stat()</a> o <a href="https://man7.org/linux/man-pages/man2/fstat.2.html">fstat()</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_combinar_ambos_tipos_de_listas_de_control_de_acceso">Combinar ambos tipos de listas de control de acceso</h5>
<div class="paragraph">
<p>Muchos sistemas POSIX tambiÃ©n soportan un borrador de especificaciÃ³n llamado POSIX ACL, que describe una interfaz para usar las <strong>ACL</strong> mÃ¡s genÃ©ricas.
Sistemas operativos como Linux, macOS o FreeBSD implementan ambos tipos de ACL.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Para mÃ¡s informaciÃ³n sobre las listas de control de acceso POSIX, vÃ©ase <a href="https://www.man7.org/linux/man-pages/man5/acl.5.html">Â«acl(5)&#8201;&#8212;&#8201;Linux ManualÂ»</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Combinar ambos tipos de <strong>ACL</strong> ofrece lo mejor de ambos mundos, pero no es una soluciÃ³n que estÃ© exenta de dificultades:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Uno de los problemas es que los usuarios deben poder determinar cuando estÃ¡n activados los permisos <strong>ACL</strong> mÃ¡s generales.
En Linux, por ejemplo, se utiliza el sÃ­mbolo <code>+</code> al listar los permisos de la ACL condensada para indicar dicha circunstancia.
Esos permisos pueden ser gestionados utilizando los comandos <a href="https://man7.org/linux/man-pages/man1/setfacl.1.html">setfacl</a> y <a href="https://man7.org/linux/man-pages/man1/getfacl.1.html">getfacl</a>.</p>
</li>
<li>
<p>Otra dificultad es la relativa a la asignaciÃ³n de precedencias cuando ambas <strong>ACL</strong> entran en conflicto.
En general, se suele asignar a la <strong>ACL</strong> mÃ¡s prioridad que a la <strong>ACL condensada</strong>, pues la primera tiene una granularidad mÃ¡s fina y no se crea de forma predeterminada.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_semÃ¡ntica_de_coherencia">19.7.2. SemÃ¡ntica de coherencia</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>La <strong>semÃ¡ntica de coherencia</strong> especifica cuÃ¡ndo las modificaciones que un proceso realiza en los archivos serÃ¡n observables por los otros procesos.
Por tanto, es importante tenerla en cuenta cuando esperamos que varios procesos utilicen los mismos archivos al mismo tiempo.</p>
</div>
<div class="paragraph">
<p>A continuaciÃ³n vamos comentar algunos ejemplos de tipos <strong>semÃ¡ntica de coherencia</strong>.</p>
</div>
<div class="sect4">
<h5 id="_semÃ¡ntica_posix">SemÃ¡ntica POSIX</h5>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Los sistemas de archivos de los sistemas operativos POSIX utilizan la siguiente <strong>semÃ¡ntica de coherencia</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Las escrituras en un archivo abierto por parte de un proceso son visibles inmediatamente para los procesos que tengan abierto el mismo archivo.</p>
</li>
<li>
<p>Existe un modo de comparticiÃ³n que permite a los procesos compartir el puntero de ubicaciÃ³n actual dentro del archivo.
AsÃ­, el incremento de ese puntero por parte de un proceso afecta a todos los procesos que estÃ©n compartiendo el archivo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>En la semÃ¡ntica POSIX, cada archivo estÃ¡ asociado con una Ãºnica imagen fÃ­sica con el contenido del archivo, a la que se accede en forma de recurso en <strong>exclusiÃ³n mutua</strong>.
Por ejemplo, un proceso que haga <strong>read</strong> sobre un archivo podrÃ­a quedar en espera si al mismo tiempo otro proceso estÃ¡ ejecutando un <strong>write</strong>, hasta que este Ãºltimo termine.</p>
</div>
<div class="paragraph">
<p>La competiciÃ³n por acceder a esta imagen Ãºnica provoca retardos en los procesos debido a estos bloqueos.</p>
</div>
</div>
<div class="sect4">
<h5 id="_semÃ¡ntica_de_sesiÃ³n">SemÃ¡ntica de sesiÃ³n</h5>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El <a href="https://es.wikipedia.org/wiki/Andrew_File_System">sistema de archivos Andrew</a> (AFS) es un sistema de archivos en red âo sistema de archivos distribuidoâ es decir, sirve para compartir archivos en una red de ordenadores y usarlos como si estuvieran almacenados localmente.</p>
</div>
<div class="paragraph">
<p>AFS es altamente escalable, existiendo despliegues con mÃ¡s de 25000 clientes.
Para conseguirlo, cada equipo mantiene una copia local de los archivos abiertos.
Las operaciones de lectura y escritura se realizan en esa copia.
Cuando se cierra el archivo modificado, los cambios son enviados al servidor de archivos, para actualizar el archivo original.</p>
</div>
<div class="paragraph">
<p>Aunque es posible implementar la <strong>semÃ¡ntica POSIX</strong> âcomo hacen otros sistemas de archivos en redâ Ã©sta no escala adecuadamente, porque implica mantener sincronizadas las copias locales de cada archivo.
Es decir, asegurar que los nodos no pueden modificar sus copias locales simultÃ¡neamente y que los cambios se propaguen adecuadamente entre las
copias, antes de responder a cualquier operaciÃ³n de lectura solicitada por un proceso.
Por eso el sistema de archivo AFS usa una semÃ¡ntica de coherencia diferente, denominada <strong>semÃ¡ntica de sesiÃ³n</strong>.</p>
</div>
<div class="paragraph">
<p>Suponiendo que una <strong>sesiÃ³n de archivo</strong> es el conjunto de operaciones entre las llamadas <strong>open</strong> y <strong>close</strong>, la <strong>semÃ¡ntica de sesiÃ³n</strong> consisten en que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Las escrituras en un archivo abierto por parte de un proceso no son visibles inmediatamente para los otros usuarios que hayan abierto ese mismo archivo.</p>
</li>
<li>
<p>Una vez que se cierra un archivo, los cambios realizados en Ã©l son visibles Ãºnicamente en las sesiones que comiencen posteriormente.
Las sesiones ya abiertas sobre el archivo no reflejarÃ¡n dichos cambios.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Esto significa que un archivo puede permanecer temporalmente asociado a distintas imÃ¡genes fÃ­sicas de su contenido al mismo tiempo.
Esto ocurre en el sistema de archivos AFS porque un mismo archivo tiene distintas copias locales temporales  en los nodos que lo tienen abierto.
AsÃ­ se permite que mÃºltiples nodos realicen accesos concurrentes, tanto de lectura como de escritura, en sus propias imÃ¡genes del archivo, evitando los retardos.</p>
</div>
<div class="paragraph">
<p>A cambio hay que tener cuidado con el hecho de que un proceso puede estar leyendo datos obsoletos, sin saberlo.
Si un proceso necesita acceder a los datos que escribe otro proceso, ambos deben sincronizarse explÃ­citamente abriendo y cerrando el archivo.</p>
</div>
</div>
<div class="sect4">
<h5 id="_semÃ¡ntica_de_archivos_compartidos_inmutables">SemÃ¡ntica de archivos compartidos inmutables</h5>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>En esta semÃ¡ntica, cuando un archivo es declarado como compartido por su creador, ya no puede ser ser modificado.</p>
</div>
<div class="paragraph">
<p>Estos archivos inmutables cumplen dos propiedades clave: su nombre no puede reutilizarse y su contenido no puede ser modificado.
AsÃ­ podemos estar seguros de que el contenido de un archivo inmutable es fijo.
Para escribir algo en uno de estos archivos, es necesario crear una copia con un nuevo nombre y hacer en ella los cambios.</p>
</div>
<div class="paragraph">
<p>Para optimizar la implementaciÃ³n de esta semÃ¡ntica se suele usar una tÃ©cnica similar al <strong>copy-on-write</strong>.
Con esta tÃ©cnica, cuando se va a modificar un archivo inmutable, se genera una copia que tiene la misma asignaciÃ³n de bloques que el archivo original.
Cada vez que se va modificar la informaciÃ³n de un bloque, se crear una copia de ese bloque, se aplican los cambios y se sustituye el identificador del bloque anterior por el del nuevo bloque en la asignaciÃ³n de bloques del archivo en el <strong>FCB</strong>.
AsÃ­, las copias de archivos inmutables se hacen mÃ¡s rÃ¡pido y se ahorra espacio, dado que de cada archivo solo se guardan los bloques modificados.</p>
</div>
<div class="paragraph">
<p>AdemÃ¡s, cuando los sistemas operativos usan esta semÃ¡ntica, suelen tener una forma de crear automÃ¡ticamente los nombres de las nuevas versiones de un archivo âpor ejemplo, aÃ±adiendo un entero al nombre e incrementÃ¡ndolo en cada versiÃ³nâ.</p>
</div>
<div class="paragraph">
<p>La implementaciÃ³n de esta semÃ¡ntica en un sistema de archivos distribuido es muy simple, puesto que es muy sencillo hacer copias locales de los archivos.
Al ser inmutables, no hace falta disponer de un mecanismo para sincronizar los cambios entre los nodos.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_bloqueos_de_archivo">19.7.3. Bloqueos de archivo</h4>
<div class="paragraph">
<p>Algunos sistemas operativos proporcionan funciones para bloquear un archivo abierto âo partes del mismoâ.
Esto permite que un proceso impida que otros procesos puedan acceder al archivo bloqueado.</p>
</div>
<div class="paragraph">
<p>Los bloqueos de archivo resultan Ãºtiles para encadenar varias operaciones de E/S sobre un archivo, teniendo la seguridad de que otros procesos no podrÃ¡n hacer modificaciones en el mismo mientras tanto.</p>
</div>
<div class="paragraph">
<p>Los sistemas operativos pueden proporcionar diferentes tipos de bloqueos de archivo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Un <strong>bloqueo compartido</strong> es un tipo de bloqueo que puede ser adquirido âes decir, bloquear el archivoâ al mismo tiempo por varios procesos.</p>
</li>
<li>
<p>Un <strong>bloqueo exclusivo</strong> solo puede ser adquirido por un proceso cada vez.
Si otro proceso intenta adquirir un <strong>bloqueo exclusivo</strong> sobre un archivo ya bloqueado, por cualquiera de los dos tipos de bloqueos, se suspende a la espera de que el bloqueo anterior sea liberado.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Algunos sistemas operativos sÃ³lo proporcionan el <strong>bloqueo exclusivo</strong>.
Sin embargo, en los que implementan ambos tipos de bloqueo, lo normal es que los procesos que pretenden acceder a un archivo compartido para sÃ³lo lectura utilicen el <strong>bloqueo compartido</strong>, mientras que los que acceden para modificar el contenido utilicen el <strong>bloqueo exclusivo</strong>.
AsÃ­, varios procesos puedan leer el archivo al mismo tiempo, pero si un proceso accede para escribir, ningÃºn otro podrÃ¡ acceder ni para leer ni para escribir.</p>
</div>
<div class="sect4">
<h5 id="_bloqueo_obligatorio_o_sugerido">Bloqueo obligatorio o sugerido</h5>
<div class="paragraph">
<p>AdemÃ¡s, los sistemas operativos pueden proporcionar dos tipos de mecanismos de bloqueo de archivos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Si el <strong>bloqueo es obligatorio</strong>, despuÃ©s de que un proceso adquiera un bloqueo exclusivo, el sistema operativo impedirÃ¡ a todos los demÃ¡s procesos que hagan cualquier operaciÃ³n sobre el archivo bloqueado.</p>
<div class="paragraph">
<p>Esto ocurrirÃ¡ incluso si los otros procesos no han sido programados para intentar adquirir el bloqueo.
Por tanto, el sistema operativo es el encargado de garantizar que los bloqueos se cumplen, haciendo las comprobaciones pertinentes en las llamadas al sistema.</p>
</div>
</li>
<li>
<p>Si el <strong>bloqueo es sugerido</strong>, el sistema operativo sÃ³lo impedirÃ¡ que accedan al archivo bloqueado aquellos procesos programados para adquirir el bloqueo explÃ­citamente.</p>
<div class="paragraph">
<p>Para eso los programas deben invocar ciertas llamadas al sistema para adquirir el bloqueo y liberarlo,
Pero el sistema operativo no impedirÃ¡ el acceso al archivo a un proceso que lo abre y lo lee o escribe sin mÃ¡s.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Los sistemas operativos Microsoft Windows implementan un mecanismo de <strong>bloqueo obligatorio</strong>.
En Windows API se puede indicar el modo de bloqueo al abrir el archivo con <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile()</a> o se puede usar <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-lockfile">LockFile()</a> para adquirir un bloqueo sobre una parte del contenido</p>
</div>
<div class="paragraph">
<p>En los sistemas UNIX y estilo UNIX, como regla general, no se bloquea un archivo al abrirlo.
Existen diferentes mecanismos de bloqueo, algunos de los cuales pueden ser <strong>bloqueos obligatorio</strong>, pero por defecto son <strong>bloqueos sugeridos</strong>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Bloqueo de archivos en sistemas POSIX</div>
<div class="paragraph">
<p>En los sistemas POSIX el mecanismo mÃ¡s usado es <a href="https://man7.org/linux/man-pages/man2/fcntl.2.html">fcntl()</a>, que permite bloquear porciones del contenido de un archivo, tanto con <strong>bloqueo exclusivo</strong> como con <strong>bloqueo compartido</strong>.
El bloqueo se asocia al <strong>inodo</strong> y al <strong>PID</strong> del proceso, por lo que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Si el archivo tiene varios nombres âpor el uso de <strong>enlaces duros</strong>â el bloqueo sobre el archivo tiene efecto sin importar el nombre usado para abrirlo.</p>
</li>
<li>
<p>Diferentes descriptores sobre el mismo archivo obtenidos llamando a <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a> varias veces en el mismo proceso, comparten los bloqueos adquiridos.
AsÃ­ que, usando este tipo de bloqueos es posible sincronizar distintos procesos pero no distintos hilos, ya que todos los hilos de un mismo proceso comparten la adquisiciÃ³n del bloqueo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El estÃ¡ndar POSIX tambiÃ©n soporta <a href="https://man7.org/linux/man-pages/man3/lockf.3.html">lockf()</a>, que es como una versiÃ³n simplificada de <a href="https://man7.org/linux/man-pages/man2/fcntl.2.html">fcntl()</a>.
Aunque el estÃ¡ndar deja sin especificar como deben interactuar ambas llamadas, lo cierto es que es comÃºn que <a href="https://man7.org/linux/man-pages/man3/lockf.3.html">lockf()</a> se implemente usando <a href="https://man7.org/linux/man-pages/man2/fcntl.2.html">fcntl()</a>.
Esta funciÃ³n tambiÃ©n crea bloqueos de porciones del contenido, asociados al <strong>inodo</strong> del archivo y el <strong>PID</strong>, pero solo soporta crear y liberar <strong>bloqueos exclusivos</strong>.</p>
</div>
<div class="paragraph">
<p>Finalmente, muchos sistemas UNIX y estilo UNIX soportan <a href="https://man7.org/linux/man-pages/man2/flock.2.html">flock()</a>.
Esta funciÃ³n fue introducida en 4.2BSD pero nunca fue incorporada al estÃ¡ndar POSIX.
Admite tanto <strong>bloqueos exclusivos</strong> como <strong>bloqueos compartidos</strong> pero, a diferencia de las llamadas anteriores, el bloqueo afecta siempre al archivo completo y se asocia al descriptor de archivo.</p>
</div>
<div class="paragraph">
<p>Esto Ãºltimo significa que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Diferentes descriptores sobre el mismo archivo obtenidos llamando a <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a> varias veces, no comparten los bloqueos adquiridos.
AsÃ­ que pueden usarse para sincronizar incluso hilos de un mismo proceso.</p>
</li>
<li>
<p>Diferentes descriptores de archivo obtenidos llamando a <a href="https://man7.org/linux/man-pages/man2/dup.2.html">dup2()</a> o a <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>, comparten los bloqueos adquiridos.
Por lo que no pueden usarse para sincronizar hilos de un mismo proceso, pero permite que un proceso padre transfiera la adquisiciÃ³n del bloqueo a sus hijos.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Aparte de estos mecanismos, cada sistema operativo puede implementar algunas funcionalidades adicionales, no incluidas en el estÃ¡ndar POSIX.
Por ejemplo, la llamada <a href="https://man7.org/linux/man-pages/man2/fcntl.2.html">fcntl()</a> de Linux permite un tipo de bloqueo con las ventajas de los bloqueos originales de <a href="https://man7.org/linux/man-pages/man2/fcntl.2.html">fcntl()</a> pero asociados a descriptores de archivo.
Esto permite usarlos para sincronizar hilos de un mismo proceso y para que un proceso pueda transferir la adquisiciÃ³n del bloqueo a sus hijos, como ocurre con los bloqueos BSD de <a href="https://man7.org/linux/man-pages/man2/flock.2.html">flock()</a>.</p>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap19/filelock-server.c">filelock-server.c</a> y <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap19/filelock-client.cpp">filelock-client.cpp</a> se puede ver un ejemplo similar al de capÃ­tulos anteriores, pero usando en esta ocasiÃ³n bloqueo de archivos.
El servidor <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap19/filelock-server.c">filelock-server.c</a> es un programa que muestra periÃ³dicamente la hora del sistema.
Mientras que el cliente <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap19/filelock-client.cpp">filelock-client.cpp</a>, simplemente envÃ­a una seÃ±al <code>SIGTERM</code> al servidor cuando queremos que termine.
Para que el cliente conozca el PID del servidor âde entre todos los procesos en ejecuciÃ³n en el sistemaâ el servidor escribe su PID en un archivo en un ubicaciÃ³n conocida por ambos.</p>
</div>
<div class="paragraph">
<p>Como el cliente lee el archivo con una Ãºnica operaciÃ³n <a href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a> y el servidor lo escribe con una Ãºnica operaciÃ³n <a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a>, no hace falta el uso de bloqueo de archivos para sincronizarlos.
Gracias a la semÃ¡ntica de coherencia POSIX, el cliente no puede leer el archivo en medio de la escritura.
Es decir, o ve el PID completo escrito por el servidor o no ve ninguno.</p>
</div>
<div class="paragraph">
<p>Pero si puede darse el caso de que se ejecuten varios servidores al mismo tiempo.
Cada uno debe comprobar si archivo existe y, si es asÃ­, leer el PID que contiene y comprobar si hay un proceso con ese mismo PID.
Si el archivo no existe o no encuentra un proceso con ese PID, debe entender que es el nuevo servidor y escribir su PID en el archivo, para que lo encuentre el cliente.
En caso contrario, debe terminar.</p>
</div>
<div class="paragraph">
<p>Para evitar que varios servidores den todos esos pasos al mismo tiempo, acaben creyendo que son los Ãºnicos y sobrescriban el archivo varias veces, el acceso al archivo debe hacerse en <strong>exclusiÃ³n mutua</strong>.
AsÃ­ lo van bloqueando de uno en uno y mientras no hace sus comprobaciones los demÃ¡s esperan.
Por eso <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2021/src/cap19/filelock-server.c">filelock-server.c</a> utiliza <a href="https://man7.org/linux/man-pages/man3/lockf.3.html">lockf()</a> para bloquear el archivo, sincronizando el acceso de los servidores.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_coherencia">19.8. Coherencia</h3>
<div class="paragraph">
<p>Como hemos comentado anteriormente, parte de los <strong>metadatos</strong> se almacena en la memoria principal para acelerar el acceso.
Dicha informaciÃ³n generalmente estÃ¡ mÃ¡s actualizada que la correspondiente en el disco, puesto que la informaciÃ³n almacenada en la memoria no tiene porque ser escrita inmediatamente despuÃ©s de una actualizaciÃ³n.</p>
</div>
<div class="paragraph">
<p>Entonces Â¿quÃ© ocurrirÃ­a si fallase el sistema? Pues que el contenido de la cachÃ© y de los bÃºferes se perderÃ­a, y con ellos los cambios realizados en los directorios y archivos abiertos.
Esto puede dejar el sistema de archivos en un estado incoherente, pues el estado real de algunos archivos no serÃ­a el que se describe en la estructura de <strong>metadatos</strong>.</p>
</div>
<div class="sect3">
<h4 id="_comprobaciÃ³n_de_coherencia">19.8.1. ComprobaciÃ³n de coherencia</h4>
<div class="paragraph">
<p>El <strong>comprobador de coherencia</strong> comprueba la estructura de <strong>metadatos</strong> y tratar de corregir todas las incoherencias que detecte.</p>
</div>
<div class="paragraph">
<p>Los algoritmos de asignaciÃ³n y de gestiÃ³n del espacio de almacenamiento dictan los tipos de problemas que el comprobador puede tratar de detectar y tambiÃ©n el grado de Ã©xito que puede tener en esa tarea.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, la pÃ©rdida de un <strong>FCB</strong>, cuando es Ã©ste el que almacena la lista de bloques que contienen los datos del archivo, es desastrosa porque no hay forma de saber quÃ© datos le pertenecen de entre todos los que hay en el disco.
Por esta razÃ³n, UNIX almacena en cachÃ© las entradas de directorio para acelerar las lecturas, pero todas las escrituras de datos que provoquen algÃºn cambio en la asignaciÃ³n de espacio o en algÃºn otro tipo de metadato, se realizan sÃ­ncronamente âantes de continuar ejecutando el proceso desde la llamada al sistemaâ.</p>
</div>
<div class="paragraph">
<p>Es decir, si se hace una escritura de datos que extiende el tamaÃ±o de un archivo; el cambio del <strong>FCB</strong> correspondiente, con el nuevo tamaÃ±o de archivo y la lista actualizada de las direcciones de los bloques que contienen âo van a contenerâ los datos del archivo, se escribe en disco antes de terminar la llamada al sistema y devolver el control al proceso que la invocÃ³.</p>
</div>
<div class="paragraph">
<p>Sin embargo, no ocurre lo mismo con los datos que el proceso querÃ­a escribir en el archivo.
El sistema operativo suele copiarlos a bÃºferes internos en la memoria para escribirlos en disco mÃ¡s adelante, evitando interrumpir el proceso durante demasiado tiempo.
Esto significa que en caso de fallo del sistema, el sistema de archivos puede estar en estado consistente pero haberse perdido los nuevos datos del archivo, porque no dio tiempo de escribirlos en el disco.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En Microsoft Windows el programa <strong>comprobador de coherencia</strong> se llama <a href="https://es.wikipedia.org/wiki/CHKDSK">CHKDSK</a>.
Mientras que en sistemas POSIX se llama <a href="https://es.wikipedia.org/wiki/Fsck">fsck</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_soft_updates">19.8.2. Soft Updates</h4>
<div class="paragraph">
<p>Para mejorar la eficiencia del sistema de archivos, sin comprometer la coherencia en caso de fallo, los distintos sabores de los sistemas UNIX BSD utilizan una tÃ©cnica denominada <strong>soft updates</strong> en su implementaciÃ³n del sistema de archivos <a href="https://es.wikipedia.org/wiki/Unix_File_System">UFS</a>.</p>
</div>
<div class="paragraph">
<p>Cuando se monta un sistema de archivos con la opciÃ³n <strong>soft updates</strong>, el sistema operativo desactiva la escritura sÃ­ncrona de los <strong>metadatos</strong>, que comentamos anteriormente, permitiendo que Ã©stos sean escritos cuando los algoritmos de gestiÃ³n de la cachÃ© lo consideren necesario, pero se impone cierto orden en el que dichas operaciones de escritura deben ser realizadas.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, cuando se van a escribir en el disco las modificaciones debidas a la creaciÃ³n de un nuevo archivo, el sistema se asegura de que primero se escribe el nuevo <strong>FCB</strong> âun <em>inodo</em>, en los sistemas UNIX BSDâ y posteriormente se escribe el directorio con la nueva entrada de archivo con el identificador a dicho <strong>FCB</strong>.</p>
</div>
<div class="paragraph">
<p>Es sencillo darse cuenta de que haciÃ©ndolo al revÃ©s, si el sistema fallase antes de crear el <strong>FCB</strong>, acabarÃ­amos con una entrada de directorio que apuntarÃ­a a un <strong>FCB</strong> invÃ¡lido.
Mientras que de esta manera el sistema de archivos permanecerÃ¡ consistente aunque el sistema falle entre ambas operaciones.</p>
</div>
</div>
<div class="sect3">
<h4 id="_sistemas_de_archivos_basados_en_registro">19.8.3. Sistemas de archivos basados en registro</h4>
<div class="paragraph">
<p>Otra soluciÃ³n al problema de la coherencia del sistema de archivos, consiste en aplicar tÃ©cnicas de recuperaciÃ³n basadas en <strong>registro</strong>  âo <strong>journaling</strong>â durante las actualizaciones de los <strong>metadatos</strong> del sistema de archivos.</p>
</div>
<div class="paragraph">
<p>Fundamentalmente, en los <strong>sistemas de archivos basados en registro</strong> cada conjunto de operaciones sobre los <strong>metadatos</strong>, necesario para realizar una tarea especÃ­fica sobre el sistema de archivos, es una <strong>transacciÃ³n</strong>.
Por ejemplo, crear un archivo nuevo es una <strong>transacciÃ³n</strong>, formada por el conjunto de operaciones sobre los <strong>metadatos</strong> necesarias para crearlo.
TambiÃ©n lo es aÃ±adir datos al final de un archivo existente, aunque en este caso la <strong>transacciÃ³n</strong> estÃ¡ formada por las operaciones sobre los <strong>metadatos</strong> necesarias para extender el tamaÃ±o del archivo.</p>
</div>
<div class="paragraph">
<p>Las operaciones sobre los <strong>metadatos</strong> de una <strong>transacciÃ³n</strong> se escriben secuencialmente en un <strong>registro</strong> de operaciones que se usa de la siguiente manera:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Durante la llamada al sistema, la lista de operaciones sobre los <strong>metadatos</strong> necesarias para completar una <strong>transacciÃ³n</strong> se escribe secuencial y sÃ­ncronamente en el <strong>registro</strong>, antes de terminar la llamada al sistema.
Cuando la lista de operaciones pendientes termina de ser escrita en el registro, se considera que las operaciones han sido <strong>confirmadas</strong> y la llamada al sistema puede volver al proceso, permitiendo que continÃºe con su ejecuciÃ³n.</p>
</li>
<li>
<p>Mientras tanto, el sistema operativo va ejecutando las operaciones indicadas en el <strong>registro</strong> sobre las estructuras reales del sistema de archivos.
A medida que se realizan los cambios, se actualiza el <strong>registro</strong> para indicar las operaciones completadas.</p>
</li>
<li>
<p>Cuando todas las operaciones de una <strong>transacciÃ³n</strong> se han ejecutado con Ã©xito, dicha <strong>transacciÃ³n</strong> se considera completada y se elimina del <strong>registro</strong>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>En el supuesto de que el sistema falle:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se comprueba el <strong>registro</strong> durante el montaje del sistema de archivos, antes de que pueda ser utilizado de nuevo.</p>
</li>
<li>
<p>Todas las <strong>transacciones confirmadas</strong> que contenga el <strong>registro</strong> estarÃ¡n a medias, por lo que se terminan de aplicar las <strong>operaciones pendientes</strong> antes de finalizar el proceso de montaje.</p>
</li>
<li>
<p>Todos los cambios correspondientes a las <strong>transacciones no confirmadas</strong> que hubieran sido aplicados al sistema de archivos, son deshechos para preservar la coherencia.
Las <strong>transacciones no confirmadas</strong> son aquellas no terminaron de ser escritas en el <strong>registro</strong> antes del fallo y, por tanto, cuya lista de operaciones no estÃ¡ completa.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Esta tÃ©cnica es muy comÃºn en muchos sistemas operativos modernos.
Por ejemplo, es utilizada en sistemas de archivos tales como: <a href="https://es.wikipedia.org/wiki/Ext3">ext3</a>, <a href="https://es.wikipedia.org/wiki/Ext4">ext4</a>, <a href="https://es.wikipedia.org/wiki/NTFS">NTFS</a>, <a href="https://es.wikipedia.org/wiki/XFS">XFS</a>, <a href="https://es.wikipedia.org/wiki/HFS%2B">HFS+</a>, etc.</p>
</div>
<div class="sect4">
<h5 id="_operaciones_sobre_datos">Operaciones sobre datos</h5>
<div class="paragraph">
<p>Es importante recordar que lo se guarda en el <strong>registro</strong> son las operaciones sobre los <strong>metadatos</strong>, porque se trata de preservar la coherencia del sistema de archivos en caso de fallo del sistema.
Sin embargo, Ã©sto quiere decir que se pueden perder lo que no son operaciones sobre los <strong>metadatos</strong>, como por ejemplo, las operaciones que modifican los datos de los archivos, con lo que lo Ã©stos pueden acabar almacenando datos corruptos o antiguos.</p>
</div>
<div class="paragraph">
<p>Para evitar en parte este problema, algunos sistemas de archivos fuerzan la escritura de los datos en el disco antes de <strong>confirmar</strong> la transacciÃ³n en el <strong>registro</strong>.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, al aÃ±adir datos al final de un archivo existente, se guardan en el registro las operaciones sobre los <strong>metadatos</strong> necesarias para extender el archivo sobre bloques nuevos.
Pero esta <strong>transacciÃ³n</strong> no se marca <strong>confirmada</strong>, hasta que los nuevos datos no se escriban en los nuevos bloques del archivo.
AsÃ­, sÃ­ el sistema falla antes de que se escriban los datos, como la operaciÃ³n no estÃ¡ <strong>confirmada</strong>, la extensiÃ³n del archivo se deshace, quedando en su estado anterior, en lugar de extenderse sobre bloques que no se han terminado de escribir.
Si el sistema falla despuÃ©s, como la operaciÃ³n estÃ¡ <strong>confirmada</strong>, el archivo termina de extenderse sobre los bloques actualizados con los datos.</p>
</div>
<div class="paragraph">
<p>El sistema de archivos <a href="https://es.wikipedia.org/wiki/Ext4">ext4</a> tiene por defecto ese comportamiento.
Sin embargo, si la fiabilidad de los datos es muy importante, se le puede indicar que considere las operaciones sobre los datos dentro de la <strong>transacciÃ³n</strong>.
De esta forma, las incluye en la lista de operaciones guardadas en el <strong>registro</strong>, las aplica posteriormente junto al resto de operaciones sobre los <strong>metadatos</strong> de la <strong>transacciÃ³n</strong> y, en caso de fallo del sistema, puede decidir si deshacerlas o terminar de aplicarlas, para asegurar la consistencia de los datos en los archivos.</p>
</div>
</div>
<div class="sect4">
<h5 id="_rendimiento_en_el_acceso_a_disco">Rendimiento en el acceso a disco</h5>
<div class="paragraph">
<p>Un efecto colateral de la utilizaciÃ³n de un <strong>registro</strong> es la mejora del rendimiento en el acceso al sistema de archivo.</p>
</div>
<div class="paragraph">
<p>La razÃ³n de esta mejora, es que las costosas escrituras sÃ­ncronas âes decir, antes de devolver el control al procesoâ de los <strong>metadatos</strong> en lugares aleatorios del volumen se transforman en escrituras sÃ­ncronas secuenciales âque son mucho mÃ¡s eficientesâ en el <strong>registro</strong>.
Mientras que todas las operaciones indicadas en el <strong>registro</strong> se aplican asÃ­ncronamente mediante escrituras aleatorias en las estructuras apropiadas, por lo que pueden ser reordenadas a conveniencia para maximizar el rendimiento.</p>
</div>
<div class="paragraph">
<p>Recordemos que en el registro pueden haber operaciones de distintos procesos que afecten a regiones prÃ³ximas del disco.
Por lo que el resultado global es una significativa ganancia en la velocidad de las operaciones relativas a los <strong>metadatos</strong>, como por ejemplo la creaciÃ³n y borrado de archivos.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Journaling en XFS</div>
<div class="paragraph">
<p>El sistema de archivos <a href="https://es.wikipedia.org/wiki/XFS">XFS</a> modifica ligeramente esta tÃ©cnica, sustituyendo las escrituras sÃ­ncronas necesarias para actualizar el <strong>registro</strong> por escrituras asÃ­ncronas.
Es decir, el control se devuelve al proceso antes de terminar de escribir las operaciones en el <strong>registro</strong> y confirmar la transacciÃ³n, por lo que el proceso puede seguir ejecutÃ¡ndose antes que en otros sistemas de archivos.</p>
</div>
<div class="paragraph">
<p>El uso de escrituras asÃ­ncronas en el <strong>registro</strong> es peligroso.
Cualquier caÃ­da del sistema podrÃ­a provocar la corrupciÃ³n del <strong>registro</strong>, porque las escrituras asÃ­ncronas pueden ocurrir en cualquier orden.
Esto, aparentemente, elimina cualquier ventaja de utilizar un <strong>registro</strong> de operaciones.
Sin embargo, XFS impone cierto orden en las operaciones de escritura sobre el registro âde forma similar a como se hace con los <strong>soft updates</strong>â de tal manera que la coherencia del registro estÃ¡ asegurada.</p>
</div>
<div class="paragraph">
<p>El utilizar escrituras asÃ­ncronas en el <strong>registro</strong> âaunque sea preservando cierto ordenâ ofrece alguna mejora en el rendimiento, porque el <strong>registro</strong> deja de ser un cuello de botella para las operaciones que modifica los <strong>metadatos</strong> del sistema de archivos.</p>
</div>
<div class="paragraph">
<p>Como hemos comentado, en otros <strong>sistemas de archivos basados en registro</strong>, el registro es un recurso al que se accede en <strong>exclusiÃ³n mutua</strong>.
Es decir, las operaciones de una <strong>transacciÃ³n</strong> se deben escribir antes de devolver el control al proceso y de permitir que otro proceso a la espera escriba las operaciones de su <strong>transacciÃ³n</strong>.
Estas esperas en el acceso al <strong>registro</strong> son las que <a href="https://es.wikipedia.org/wiki/XFS">XFS</a> evita, permitiendo su modificaciÃ³n de manera asÃ­ncrona.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_sistemas_de_archivos_basados_en_copia_durante_la_escritura">19.8.4. Sistemas de archivos basados en copia durante la escritura</h4>
<div class="paragraph">
<p><em>Las tÃ©cnicas anteriores son necesarias para preservar la coherencia porque la modificaciÃ³n de los metadatos se hace sobrescribiendo los datos que ya existen</em>.
Es decir, cuando se crea un nuevo archivo, el sistema busca un FCB libre, sobrescribe el bloque del dispositivo donde lo encuentra para almacenar el nuevo FCB, busca una entrada libre en el directorio y, nuevamente, sobrescribe el bloque del disco donde se almacena el directorio para incorporar la nueva entrada.
Si algunos de estos cambios tienen lugar pero otros no, el disco puede quedar en estado inconsistente.</p>
</div>
<div class="paragraph">
<p><em>Los <strong>sistemas de archivos basados en copia durante la escritura</strong></em> âo <em>copy-on-write</em>â <em>evitan cambiar los metadatos sobrescribiendo en el sitio</em>.
En su lugar buscan un hueco libre, hacen en Ã©l una copia del bloque completo con los cambios y despuÃ©s modifican los metadatos del sistema de archivos que sirven para localizar el bloque modificado en su nueva ubicaciÃ³n.
Estos cambios, a su vez, tampoco se hacen sobrescribiendo, sino que disparan la creaciÃ³n de copias modificadas de los bloques afectados, lo que nuevamente va seguido de cambios en los metadatos que ayudan a localizarlos.
El proceso se repite hasta que se alcanza el <em>bloque de control de volumen</em> y se cambia, momento en el que toda la secuencia de cambios se consolida.</p>
</div>
<div class="paragraph">
<p>Los sistemas de archivos basados en copy-on-write suele hacer hacer uso intensivo de estructuras de datos basadas en Ã¡rbol porque es muy sencillo mover un nodo de bloque, con un efecto mÃ­nimo en el resto de la estructura.
Por ejemplo, al crear un archivo:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>Se busca un FCB libre, se lee el bloque que lo contiene en la memoria principal, se modifica y se escribe en un bloque libre</em>.
El sistema de archivos debe tener alguna estructura de datos que permita encontrar el bloque que contiene un FCB a partir de su identificador.
Por lo general, esta estructura es algÃºn tipo de Ã¡rbol.
AsÃ­ que se modifica el nodo del Ã¡rbol que seÃ±ala al bloque con el nuevo FCB para que conozca la nueva ubicaciÃ³n.
Este cambio, implica crear un copia del bloque de dicho nodo con el cambio, lo que a su vez significa modificar el nodo que seÃ±ala a este.
Y asÃ­ sucesivamente hasta llegar a la raÃ­z del Ã¡rbol de FCB.</p>
</li>
<li>
<p><em>Se busca una entrada libre en el directorio que va a contener al archivo y se modifica para aÃ±adir el nombre del archivo, el identificador de su FCB y otras propiedades</em>.
Nuevamente, este cambio significa crear una copia, con los cambios descritos, del bloque que contiene la entrada y modificar el FCB del directorio para que contenga la nueva ubicaciÃ³n del bloque con el contenido del directorio.
Como antes, este cambio en el FCB dispara copias y modificaciones por todo el Ã¡rbol de FCB, hasta la raÃ­z</p>
</li>
<li>
<p>Una vez la raÃ­z del Ã¡rbol ha sido copiada a una nueva ubicaciÃ³n con los cambios, se actualiza su nueva posiciÃ³n en el <em>bloque de control de volumen.</em></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Si el sistema falla antes de la modificaciÃ³n del <em>bloque de control de volumen</em>, durante el montaje del sistema de archivos no quedarÃ¡ ni rastro de ninguno de los cambios porque dicho bloque aun hace referencia a la antigua raÃ­z del Ã¡rbol de FCB y, a partir de ellas, a todos los nodos, bloques y FCB originales.
Obviamente los sistemas que implementan este tipo de sistemas de archivo usan la memoria principal como cachÃ© con el objeto de combinar varias modificaciones sobre un mismo bloque antes de proceder a su escritura en disco, evitando desencadenar mÃºltiples veces los cambios posteriores.</p>
</div>
<div class="paragraph">
<p>Los sistemas de archivos ZFS y Btrfs son los principales ejemplos de sistemas de archivos basados en <em>copy-on-write</em>.
Esta soluciÃ³n no sÃ³lo les permite tener las mismas propiedades que el uso de registro en cuanto a la preservaciÃ³n de la coherencia âcon la ventaja de evitar dos escrituras en disco, una en el registro y otra para el cambio propiamente dichoâ sino que ademÃ¡s facilita que puedan ofrecer caracterÃ­sticas adicionales, como la creaciÃ³n de copias instantÃ¡neas del volumen.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementaciÃ³n_de_sistemas_de_archivos">20. ImplementaciÃ³n de sistemas de archivos</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>31 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Como ya hemos comentado, un sistema de archivos suele estar compuesto de varios niveles diferentes.
En la <a href="#estructura_sistema_de_archivos">Figura 56</a> se muestra un ejemplo de la estructura de un sistema de archivos diseÃ±ado en niveles.
Cada nivel utiliza las funciones de los niveles inferiores y proporciona nuevas funciones a los niveles superiores.
El papel de cada uno de estos niveles fue descrito en el <a href="#_estructura_de_un_sistema_de_archivos">Apartado 19.1</a>.
Mientras que las estructuras de metadatos utilizadas, tanto en la memoria como en disco, fueron tratadas brevemente en el <a href="#_estructuras_de_metadatos_en_disco">Apartado 19.2</a> y en el <a href="#_estructuras_de_metadatos_en_memoria">Apartado 19.3</a>.</p>
</div>
<div class="paragraph">
<p>A continuaciÃ³n, vamos a profundizar aun mÃ¡s en las estructuras y operaciones utilizadas para implementar los sistemas de archivos</p>
</div>
<div class="sect2">
<h3 id="_implementaciÃ³n_de_directorios">20.1. ImplementaciÃ³n de directorios</h3>
<div class="paragraph">
<p>Cada directorio suele contener una estructura de datos que relaciona el nombre de cada archivo que contiene con el identificador de su <strong>FCB</strong>.
Dicho identificador permite localizar el FCB en la <strong>tabla de contenidos del volumen</strong>, que contiene el resto de los atributos del archivo.</p>
</div>
<div class="paragraph">
<p>En esta secciÃ³n vamos a estudiar las formas mÃ¡s comunes de implementar la estructura de datos de un directorio.</p>
</div>
<div class="sect3">
<h4 id="_lista_lineal">20.1.1. Lista lineal</h4>
<div class="paragraph">
<p>El mÃ©todo mas simple para implementar un directorio consiste en utilizar una lista lineal o vector de nombres de archivos e identificadores del <strong>FCB</strong>.</p>
</div>
<div class="paragraph">
<p>Las acciones a realizar, para implementar cada una de las posibles operaciones sobre el directorio, serÃ­an:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Crear un archivo</strong>.
Primero se explora el directorio para estar seguros de que no haya ningÃºn archivo con el mismo nombre.
DespuÃ©s se aÃ±ade una nueva entrada al final del directorio.</p>
</li>
<li>
<p><strong>Borrar un archivo</strong>.
Primero se explora la lista en busca del archivo especificado y, una vez localizada, se libera la entrada correspondiente.
Para reutilizar la entrada del directorio tenemos diversas alternativas:</p>
<div class="ulist">
<ul>
<li>
<p>Se puede marcar la entrada como no utilizada.
Para eso se puede emplear un nombre especial o utilizar algÃºn campo adicional âa parte de nombre de archivo e identificador del <strong>FCB</strong>â que se haya aÃ±adido a la entrada con ese propÃ³sito.</p>
</li>
<li>
<p>Insertar un puntero a la entrada en una lista de entradas libres, que se guarda dentro del mismo directorio.</p>
</li>
<li>
<p>Copiar la Ãºltima entrada del directorio en la ubicaciÃ³n que ha quedado libre y reducir la longitud del directorio.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>La principal desventaja de un directorio implementado como una lista lineal de entradas es que para localizar un archivo es necesario realizar una bÃºsqueda lineal, lo cual puede resultar muy costoso en directorios con un nÃºmero muy grande de archivos.
Utilizando una lista ordenada se puede reducir el tiempo medio de bÃºsqueda, pero complica los procesos de creaciÃ³n y borrado, pues puede que sea necesario mover cantidades importantes de informaciÃ³n para mantener la lista ordenada.</p>
</div>
<div class="paragraph">
<p>TambiÃ©n se puede utilizar una lista enlazada, tanto para reducir el tiempo necesario para borrar un archivo como para facilitar la tarea de mantener ordenada la lista.</p>
</div>
<div class="paragraph">
<p>Los sistemas de archivos <a href="https://es.wikipedia.org/wiki/Tabla_de_asignaci%C3%B3n_de_archivos">FAT</a> y <a href="https://es.wikipedia.org/w/index.php?title=FAT32">FAT32</a> implementan los directorios utilizando una lista lineal, donde en cada entrada se almacena el nombre del archivo y el <strong>FCB</strong> del mismo.
Al borrar un archivo, la entrada correspondiente se marca poniendo 0xE5 en el primer caracter del nombre del archivo.</p>
</div>
<div class="paragraph">
<p>Los sistemas de archivos <a href="https://es.wikipedia.org/wiki/Ext2">ext2</a> y <a href="https://es.wikipedia.org/wiki/Unix_File_System">UFS</a> tambiÃ©n utilizan una lista lineal no ordenada, donde sÃ³lo se almacena el nombre del archivo o subdirectorio y el identificador del <strong>inodo</strong> âel FCB, esos sistemas de archivoâ correspondiente.
En caso de borrar un archivo, el identificador del <strong>inodo</strong> se pone a 0.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tabla_de_dispersiÃ³n">20.1.2. Tabla de dispersiÃ³n</h4>
<div class="paragraph">
<p>En los directorios implementados con una <a href="https://es.wikipedia.org/wiki/Tabla_hash">tabla de dispersiÃ³n</a> tambiÃ©n se almacenan las entradas de directorio en una lista lineal, pero al mismo tiempo se utiliza una tabla de dispersiÃ³n para reducir enormemente el tiempo de bÃºsqueda en el directorio.
Para obtener la ubicaciÃ³n de dicho archivo dentro de la lista lineal, se usa un Ã­ndice calculado con cierta funciÃ³n de dispersiÃ³n a partir del nombre del archivo.</p>
</div>
<div class="paragraph">
<p>El Ãºnico inconveniente es que debemos tratar la posible apariciÃ³n de colisiones, que son aquellas situaciones en las que dos nombres de archivo dan lugar, al aplicarles la funciÃ³n de dispersiÃ³n, la misma ubicaciÃ³n en la tabla.
Esto se puede resolver utilizando una lista enlazada en cada entrada de la lista âcada entrada en la lista seÃ±alarÃ­a la ubicaciÃ³n de la siguiente entrada de la lista que tiene el mismo valor para la funciÃ³n de dispersiÃ³nâ a cambio de que las bÃºsquedas sean un poco mÃ¡s lentas.
En cualquier caso, este mÃ©todo serÃ¡ normalmente mÃ¡s rÃ¡pido que una bÃºsqueda lineal por todo el directorio.</p>
</div>
</div>
<div class="sect3">
<h4 id="_Ã¡rbol_b">20.1.3. Ãrbol B</h4>
<div class="paragraph">
<p>Para mantener el directorio ordenado, algunos sistemas de archivos modernos utilizan estructuras de datos en Ã¡rbol mÃ¡s sofisticadas, como por ejemplo Ã¡rboles B.</p>
</div>
<div class="paragraph">
<p>Un caso concreto es el sistema de archivos <a href="https://es.wikipedia.org/wiki/NTFS">NTFS</a>, utilizado por Microsoft Windows.
<a href="https://es.wikipedia.org/wiki/NTFS">NTFS</a> utiliza una estructura de datos denominada <a href="https://es.wikipedia.org/wiki/%C3%81rbol_B%2B">Ã¡rbol B+</a> para almacenar el Ã­ndice de los nombres de archivo contenidos en un directorio.</p>
</div>
<div class="paragraph">
<p>En la entrada en la <strong>MFT</strong> (<em>Master File Table</em>) de cada directorio se almacena un atributo denominado <strong>raÃ­z del Ã­ndice</strong>.
Si el directorio es de pequeÃ±o tamaÃ±o, la <strong>raÃ­z del Ã­ndice</strong> contiene todas las entradas de archivos del directorio, pero para un directorio de gran tamaÃ±o, la <strong>raÃ­z del Ã­ndice</strong> sÃ³lo puede almacenar unas pocas entradas de archivos del directorio.
En ese caso la <strong>raÃ­z del Ã­ndice</strong> contiene el nivel superior del Ã¡rbol B+.
Es decir, cada una de esas entradas de archivos en la <strong>raÃ­z del Ã­ndice</strong> incluye tambiÃ©n un puntero al bloque del disco que contiene un nodo del Ã¡rbol con las entradas con nombres alfabÃ©ticamente anteriores a ese.
Si en dicho nodo tampoco caben todas las entradas, sÃ³lo podrÃ¡ contener algunas de ellas, por lo que cada una tendrÃ¡, a su vez, un puntero a un nuevo nodo del Ã¡rbol; y asÃ­ sucesivamente.</p>
</div>
<div class="paragraph">
<p>Las ventajas de los Ã¡rboles B+ son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Eliminan el coste de reordenar las entradas del directorio.</p>
</li>
<li>
<p>La longitud desde la raÃ­z del Ã¡rbol hasta un nodo hoja es la misma para todas los caminos por el Ã¡rbol, por lo que el tiempo de bÃºsqueda tiene una cota superior.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">ImplementaciÃ³n de directorios en XFS</div>
<div class="paragraph">
<p>El sistema de archivos <a href="https://es.wikipedia.org/wiki/XFS">XFS</a> tambiÃ©n utiliza un <a href="https://es.wikipedia.org/wiki/%C3%81rbol_B%2B">Ã¡rbol B+</a>, pero en Ã©ste caso la implementaciÃ³n es un poco mÃ¡s compleja:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Un directorio de pequeÃ±o tamaÃ±o almacena sus entradas como una lista lineal no ordenada dentro de su mismo <strong>inodo</strong> o FCB.</p>
</li>
<li>
<p>Cuando el directorio no cabe en el <strong>inodo</strong> se le asigna un bloque propio, donde el directorio es implementado con una tabla de dispersiÃ³n, tal y como hemos visto anteriormente.</p>
</li>
<li>
<p>Cuando el tamaÃ±o del directorio excede el tamaÃ±o del bloque, la tabla de dispersiÃ³n se extrae y se almacena en un bloque diferente.
La lista lineal tambiÃ©n se extrae, pero no tiene que ser almacenada en un Ãºnico bloque, sino que puede estar repartida por distintos bloques a lo largo del disco.</p>
</li>
<li>
<p>Finalmente, cuando la tabla de dispersiÃ³n excede el tamaÃ±o de un bloque, dicha tabla se convierte en un Ã¡rbol B+.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mÃ©todos_de_asignaciÃ³n">20.2. MÃ©todos de asignaciÃ³n</h3>
<div class="paragraph">
<p>El siguiente problema es cÃ³mo asignar el espacio disponible en el disco a los archivos almacenados, de forma que el espacio sea utilizado de forma eficiente y que se pueda acceder a los archivos de la forma mÃ¡s rÃ¡pida posible.</p>
</div>
<div class="paragraph">
<p>Como la unidad mÃ­nima de asignaciÃ³n de espacio a un archivo es el bloque, la fragmentaciÃ³n interna suele ser un problema comÃºn a todos los mÃ©todos que veremos a continuaciÃ³n.</p>
</div>
<div class="sect3">
<h4 id="_asignaciÃ³n_contigua">20.2.1. AsignaciÃ³n contigua</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>La <strong>asignaciÃ³n contigua</strong> requiere que cada archivo ocupe un conjunto contiguo de bloques en el disco.
Esto es muy eficiente, puesto que el acceso a todos los datos de un archivo requiere un movimiento mÃ­nimo del cabezal del disco.</p>
</div>
<div class="paragraph">
<p>El problema de la <strong>asignaciÃ³n contigua</strong> puede verse como un caso concreto del problema de la asignaciÃ³n dinÃ¡mica del almacenamiento (vÃ©ase el <a href="#_asignaciÃ³n_contigua_de_memoria">Apartado 15.5</a>).
Es decir, que en un momento dado tendremos una peticiÃ³n de tamaÃ±o <em>N</em> que deberemos satisfacer con una lista de huecos libres de tamaÃ±o variable.
Como estudiamos anteriormente, las estrategias mÃ¡s comunes son las de el <strong>primer ajuste</strong> y el <strong>mejor ajuste</strong>.</p>
</div>
<div class="sect4">
<h5 id="_fragmentaciÃ³n_externa_2">FragmentaciÃ³n externa</h5>
<div class="paragraph">
<p>La asignaciÃ³n contigua sufre el problema de la <strong>fragmentaciÃ³n externa</strong>.
La soluciÃ³n serÃ­a utilizar alguna forma de <strong>compactaciÃ³n</strong> para unir los huecos libres, pero esto puede llevar mucho tiempo en discos duros de gran tamaÃ±o y en algunos sistemas esta tarea tiene que realizarse con el dispositivo desmontado.
Por eso es conveniente evitar utilizar tÃ©cnicas de compactaciÃ³n en los sistemas en producciÃ³n.</p>
</div>
<div class="paragraph">
<p>Afortunadamente, la mayor parte de los sistemas operativos modernos que necesitan mecanismos de <strong>desfragmentaciÃ³n</strong> pueden realizar esta tarea sin detener el sistema, aunque la perdida de rendimiento puede ser significativa.</p>
</div>
</div>
<div class="sect4">
<h5 id="_estimaciÃ³n_del_tamaÃ±o_del_archivo">EstimaciÃ³n del tamaÃ±o del archivo</h5>
<div class="paragraph">
<p>En la asignaciÃ³n contigua es necesario determinar cuÃ¡nto espacio necesita un archivo antes de asignÃ¡rselo.
El problema es que eso no siempre es posible.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, si vamos a copiar un archivo, es indudable que conocemos de antemano cuanto espacio necesita la copia.
Pero Â¿quÃ© ocurre cuando vamos a crear uno nuevo? Entonces al crear un archivo es necesario que el usuario haga una estimaciÃ³n del espacio que va necesitar y se la indique al sistema.</p>
</div>
<div class="paragraph">
<p>Â¿Y si la estimaciÃ³n no es correcta o posteriormente queremos aÃ±adir nuevos datos al archivo?
Entonces, Lo mÃ¡s probable es que el espacio situado a ambos lados del archivo ya estÃ© ocupado, si hemos utilizado la estrategia del <strong>mejor ajuste</strong>.
Para resolver este problema existen dos estrategias:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La primera, es terminar el programa de usuario, emitiendo un error.
Entonces, el usuario deberÃ¡ volver a crear el archivo indicando mÃ¡s espacio y volver a ejecutar el programa.
Puesto que las ejecuciones repetidas pueden ser muy costosas, lo mÃ¡s comÃºn es que el usuario acabe sobrestimando el espacio, lo que darÃ¡ como resultado un desperdicio considerable de espacio.</p>
</li>
<li>
<p>La segunda, es buscar un hueco libre de mayor tamaÃ±o y copiar el contenido del archivo al nuevo espacio.
Esto puede hacerse siempre que exista suficiente espacio, aunque puede consumir bastante tiempo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Para minimizar estos problemas, se puede implementar un esquema de asignaciÃ³n contigua modificado, donde se asigna inicialmente un bloque contiguo de espacio al archivo y, posteriormente, si dicho espacio resulta no ser lo suficientemente grande, se aÃ±ade otra Ã¡rea de espacio contiguo, denominado <strong>extensiÃ³n</strong>.</p>
</div>
<div class="paragraph">
<p>La ubicaciÃ³n de las <strong>extensiones</strong> de un archivo se registran en el FCB, guardando la direcciÃ³n del primer bloque de cada extensiÃ³n que compone el archivo y el nÃºmero de bloques que ocupa cada una.</p>
</div>
<div class="paragraph">
<p>Los sistemas de archivo <a href="https://es.wikipedia.org/wiki/XFS">XFS</a> y <a href="https://es.wikipedia.org/wiki/Ext4">ext4</a> utilizan <strong>extensiones</strong> para optimizar su funcionamiento.
El motivo es que cuantos mÃ¡s bloques contiguos sean asignados a un archivo, menos reposicionamientos del cabezal del disco son necesarios para leerlos.
En <a href="https://es.wikipedia.org/wiki/Ext4">ext4</a> el espacio se asigna a los archivos en <strong>extensiones</strong> de hasta 128 MiB, compuestas por bloques, generalmente, de 4KiB.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_asignaciÃ³n_enlazada">20.2.2. AsignaciÃ³n enlazada</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>En la <strong>asignaciÃ³n enlazada</strong> cada archivo es una lista enlazada de bloques de disco, pudiendo estos bloques estar dispersos por todo el disco:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Cada entrada de directorio contiene un puntero al primer bloque.
En ocasiones, la entrada tambiÃ©n incluye un puntero al Ãºltimo, para facilitar aÃ±adir nuevos datos al final del archivo.</p>
</li>
<li>
<p>Cada bloque contiene un puntero al bloque siguiente.
Por ejemplo, si cada bloque tiene 512 bytes de tamaÃ±o y un puntero requiere 4 bytes, los bloques de disco tendrÃ¡n un tamaÃ±o efectivo de 508 bytes.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Este mecanismo resuelve todos los problemas de la asignaciÃ³n contigua y ademÃ¡s:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>No hay fragmentaciÃ³n externa</strong>, puesto que pueden utilizarse cualquier bloque libre para satisfacer una solicitud de espacio.</p>
</li>
<li>
<p><strong>No es necesario declarar el espacio del archivo</strong> en el momento de crearlo, pues el archivo podrÃ¡ siempre podrÃ¡ crecer mientras hayan bloques libres.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Sin embargo, la asignaciÃ³n enlazada tambiÃ©n tiene sus desventajas.</p>
</div>
<div class="sect4">
<h5 id="_eficiencia_en_accesos_aleatorios">Eficiencia en accesos aleatorios</h5>
<div class="paragraph">
<p>La <strong>asignaciÃ³n enlazada</strong> sÃ³lo resulta eficaz para acceder a los archivos de acceso secuencial.</p>
</div>
<div class="paragraph">
<p>Si necesitamos ir directamente al bloque i-Ã©simo de un archivo, tendremos que comenzar desde el principio e ir leyendo cada bloque para obtener el puntero que nos indica el siguiente bloque.
Es muy posible que esas lecturas deban ir precedidas de un reposicionamiento de los cabezales del disco.</p>
</div>
<div class="paragraph">
<p>Una soluciÃ³n parcial a esto puede ser guardar en la memoria una cachÃ© de las direcciones de los bloques de los archivos accedidos recientemente.</p>
</div>
</div>
<div class="sect4">
<h5 id="_eficiencia_en_el_uso_del_espacio_de_almacenamiento">Eficiencia en el uso del espacio de almacenamiento</h5>
<div class="paragraph">
<p>En la <strong>asignaciÃ³n enlazada</strong> se pierde cierta cantidad de espacio con los punteros.</p>
</div>
<div class="paragraph">
<p>Si, por ejemplo, un puntero ocupa 4 bytes y un bloque tienen un tamaÃ±o de 512 bytes, el 0,758% del espacio en disco serÃ¡ utilizado para los punteros, en lugar de para almacenar informaciÃ³n Ãºtil.</p>
</div>
<div class="paragraph">
<p>La soluciÃ³n para este problema consiste en asignar los bloques en grupos âdenominados <strong>clÃºsteres</strong>â.
AsÃ­, el primer bloque de cada <strong>clÃºster</strong> sÃ³lo tendrÃ­a que almacenar un puntero al siguiente <strong>clÃºster</strong>, lo que reducirÃ­a la cantidad de espacio desperdiciada en los punteros y mejorarÃ­a la eficiencia al reducir el nÃºmero de reposicionamientos del cabezal del disco.
Sin embargo, esto tambiÃ©n incrementarÃ­a el grado de <strong>fragmentaciÃ³n interna</strong> pues se pierde mÃ¡s espacio cuando un <strong>clÃºster</strong> estÃ¡ parcialmente lleno.</p>
</div>
</div>
<div class="sect4">
<h5 id="_fiabilidad">Fiabilidad</h5>
<div class="paragraph">
<p>Teniendo en cuenta que los archivos estÃ¡n enlazados mediante punteros, parte de un archivo se puede corromper fÃ¡cilmente con que solo uno de esos punteros se pierda o resulte daÃ±ado.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">AsignaciÃ³n enlazada en FAT y FAT32</div>
<div class="paragraph">
<p>Los sistemas de archivos <a href="https://es.wikipedia.org/wiki/Tabla_de_asignaci%C3%B3n_de_archivos">FAT</a> y <a href="https://es.wikipedia.org/w/index.php?title=FAT32">FAT32</a> utilizan una variante del mecanismo de asignaciÃ³n enlazada en la que se emplea una <strong>tabla de asignaciÃ³n de archivo</strong> o <strong>FAT</strong> (<em>File-Allocation Table</em>).</p>
</div>
<div class="paragraph">
<p>La FAT se almacena en una secciÃ³n al principio del volumen.
Contiene una entrada por cada <strong>clÃºster</strong> del disco y en cada una guarda el nÃºmero del siguiente <strong>clÃºster</strong> del archivo.
Es decir, lo que hace la FAT es agrupa en un solo lugar los punteros de la <strong>asignaciÃ³n enlazada</strong>.</p>
</div>
<div id="estructura_fat" class="imageblock">
<div class="content">
<img src="C20-implementaciÃ³n_del_sistemas_de_archivos/media/estructura_fat.svg" alt="estructura fat">
</div>
<div class="title">Figura 57. AsignaciÃ³n enlazada en el sistema de archivos FAT.</div>
</div>
<div class="paragraph">
<p>Eso significa que la FAT es una estructura crÃ­tica.
Si se corrompe, puede provocar la pÃ©rdida de todo el sistema de archivos.
Por eso, realmente se almacenan dos copias de la FAT al principio del volumen.</p>
</div>
<div class="paragraph">
<p>El indexar con clÃºsteres âo grupos de bloquesâ sirve para ubicar cerca bloques contiguos, pero sobre todo es una decisiÃ³n de diseÃ±o para permitir que los sistemas de archivos <a href="https://es.wikipedia.org/wiki/Tabla_de_asignaci%C3%B3n_de_archivos">FAT</a> puedan gestionar volÃºmenes mÃ¡s grandes.
Por ejemplo, la FAT de MS-DOS 3.0 y posteriores usaba 16 bits para numerar los clÃºsteres âpor eso se llamaba FAT16â.
Si FAT16 trabaja directamente con bloques y cada bloque tuviera 512 bytes, no podrÃ­a gestionar volÃºmenes de mÃ¡s de \$512* 2^16\$ bytes, es decir, 32 MiB.
Sin embargo, trabajando con 64 bloques por clÃºster, se puede usar para gestionar volÃºmenes de hasta 2 GiB.</p>
</div>
<div class="paragraph">
<p>Aunque algunas versiones de Microsoft Windows NT llegaron a admitir 128 e, incluso, 512 bloques por clÃºster, con clÃºsteres tan grandes la <strong>fragmentaciÃ³n interna</strong> es un problema.</p>
</div>
<div class="paragraph">
<p>Por eso âentre otras cosasâ Microsoft introdujo <a href="https://es.wikipedia.org/w/index.php?title=FAT32">FAT32</a>, que utiliza 32 bits para numerar los clÃºsteres.
Eso implicar poder gestionar mÃ¡s cantidad de clÃºsteres, lo que permite gestionar volÃºmenes mÃ¡s grandes con clÃºsteres mÃ¡s pequeÃ±os y, por tanto, con menor <strong>fragmentaciÃ³n interna</strong>.
Por ejemplo, <a href="https://es.wikipedia.org/w/index.php?title=FAT32">FAT32</a> podÃ­a gestionar volÃºmenes de hasta 2 TiB con 64 bloques por clÃºster.</p>
</div>
<div class="paragraph">
<p>Como se puede ver en la <a href="#estructura_fat">Figura 57</a>, en los sistemas de archivos <a href="https://es.wikipedia.org/wiki/Tabla_de_asignaci%C3%B3n_de_archivos">FAT</a> cada entrada de directorio contiene, a parte del nombre del archivo y otros atributos, el nÃºmero del primer clÃºster con datos del archivo.
La entrada de la FAT indexada segÃºn ese nÃºmero contiene el nÃºmero del siguiente clÃºster del archivo.
Iterando de esa manera, se puede conocer los nÃºmeros de todos los clÃºsteres de un archivo.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>El Ãºltimo bloque del archivo se indica con un valor especial en su entrada en la FAT.
Mientras que los bloques no utilizados se indican con un valor igual a 0 en su entrada en la FAT.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>El uso de la FAT puede provocar un nÃºmero importante de reposicionamientos del cabezal de disco, debido a que siempre es necesario volver al principio del volumen para leer dicha tabla.
Por eso, es muy habitual que el sistema operativo intente mantener una copia de la FAT en la memoria, a modo de cachÃ©.</p>
</div>
<div class="paragraph">
<p>Una de las ventajas de este esquema es que mejora el tiempo de los accesos aleatorios a los archivos ârespecto a la asignaciÃ³n enlazada convencionalâ porque se puede conocer la ubicaciÃ³n de cualquier bloque a partir de la informaciÃ³n en la FAT, sin tener que leer todos los bloques del archivo uno a uno.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_asignaciÃ³n_indexada">20.2.3. AsignaciÃ³n indexada</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El mecanismo de <strong>asignaciÃ³n indexada</strong> agrupa todos los punteros de la asignaciÃ³n enlazada en una Ãºnica ubicaciÃ³n: el <strong>bloque de Ã­ndices</strong>.
AsÃ­ se resuelve la falta de eficiencia de la asignaciÃ³n enlazada convencional âen ausencia de FATâ cuando se realizan accesos aleatorios.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>En la <strong>asignaciÃ³n indexada</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cada archivo tiene su propio <strong>bloque de Ã­ndices</strong>, que es un bloque del disco con una tabla con los nÃºmeros de los bloques del disco que contienen los datos del archivo.</p>
</li>
<li>
<p>La entrada i-Ã©sima del bloque de Ã­ndice contiene la direcciÃ³n del bloque i-Ã©simo del archivo.</p>
</li>
<li>
<p>Cada entrada de directorio contiene la direcciÃ³n del bloque de Ã­ndices del archivo correspondiente.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Este mecanismo soporta el acceso aleatorio eficiente, ademÃ¡s de no sufrir el problema de la fragmentaciÃ³n externa.
Sin embargo, tambiÃ©n tiene sus desventajas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se pierde mÃ¡s espacio en los punteros que con el mecanismo de asignaciÃ³n enlazada, pues siempre hay que reservar un <strong>bloque de Ã­ndices</strong> completo para cada archivo.
Mientras que con la asignaciÃ³n enlazada, sÃ³lo se pierde el espacio de los punteros que realmente es necesario utilizar.</p>
</li>
<li>
<p>Al diseÃ±ar el sistema de archivos debemos determinar el tamaÃ±o del <strong>bloque de Ã­ndices</strong>.</p>
<div class="paragraph">
<p>Por el inconveniente anterior y puesto que cada archivo debe tener un bloque de Ã­ndices, ese bloque debe ser lo mÃ¡s pequeÃ±o posible para no perder espacio.
Pero si es demasiado pequeÃ±o, no podrÃ¡ almacenar suficientes punteros para un archivo de gran tamaÃ±o.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Entre los mecanismos que pueden utilizarse para resolver este Ãºltimo problema estÃ¡n los siguientes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En el <strong>esquema enlazado</strong>, se enlazan los bloques de Ã­ndices.</p>
<div class="paragraph">
<p>Por ejemplo, se puede utilizar el Ãºltimo puntero del bloque de Ã­ndices para apuntar al siguiente bloque de Ã­ndices.
Si dicho puntero tiene valor 0, entonces estamos en el Ãºltimo bloque de Ã­ndices del archivo.</p>
</div>
</li>
<li>
<p>En el <strong>Ã­ndice multinivel</strong>, los punteros del bloque de Ã­ndices no seÃ±alan a los bloques del archivo, sino a un conjunto de bloques de Ã­ndices de segundo nivel y estos, a su vez seÃ±alan, a los bloques del archivo.
Esta tÃ©cnica puede puede ampliarse utilizando un tercer o cuarto nivel, dependiendo del tamaÃ±o mÃ¡ximo de archivo que se desee.</p>
</li>
<li>
<p>En el <strong>esquema combinado</strong> las primeras entradas del bloque de Ã­ndices apuntan directamente a los primeros bloques del archivo.
Mientras que las siguientes entradas contiene punteros indirectos, que apunta a un conjunto de bloques de Ã­ndices de segundo nivel.
DespuÃ©s podrÃ­an haber entradas que contienen punteros doblemente indirectos y luego entradas con punteros triplemente indirectos.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Para mejorar el rendimiento de los mecanismos de asignaciÃ³n indexados, es muy comÃºn que el sistema operativo intente mantener los bloques de Ã­ndices en la memoria.</p>
</div>
<div id="asignaciÃ³n_ext2" class="imageblock">
<div class="content">
<img src="C20-implementaciÃ³n_del_sistemas_de_archivos/media/asignaciÃ³n_ext2.svg" alt="asignaciÃ³n ext2">
</div>
<div class="title">Figura 58. AsignaciÃ³n indexada combinada en el sistema de archivos ext2.</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Los sistemas de archivos <a href="https://es.wikipedia.org/wiki/Ext2">ext2</a> y <a href="https://es.wikipedia.org/wiki/Ext3">ext3</a> utilizan el mecanismo de <strong>asignaciÃ³n indexada</strong> con <strong>esquema combinado</strong>.
Concretamente el mecanismo en <a href="https://es.wikipedia.org/wiki/Ext2">ext2</a> se implementa de la siguiente manera:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>El disco se divide en mÃºltiples grupos de bloques de disco.</p>
</li>
<li>
<p>En cada grupo, se utilizan los primeros bloques para almacenar una tabla de <strong>inodos</strong>.
Estos <strong>inodos</strong> son los <strong>FCB</strong> de los archivos almacenados en el grupo.</p>
<div class="paragraph">
<p>El resto de los bloques se utilizan para almacenar los datos de los archivos representados por los <strong>inodos</strong> del grupo.</p>
</div>
</li>
<li>
<p>Dentro de cada <strong>inodo</strong> âentre otra informaciÃ³n tÃ­pica en un <strong>FCB</strong>â se almacenan los punteros a los bloques del archivo, en lugar de utilizar un bloque de Ã­ndices aparte.</p>
</li>
<li>
<p>Como se puede ver en la <a href="#asignaciÃ³n_ext2">Figura 58</a>, los primeros 12 punteros en el <strong>inodo</strong> son directos, seguidos de un puntero indirecto, un puntero doblemente indirecto y uno triplemente indirecto.
Esto permite almacenar hasta \$2^64\$ bytes de informaciÃ³n en cada archivo.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gestiÃ³n_del_espacio_libre">20.3. GestiÃ³n del espacio libre</h3>
<div class="paragraph">
<p>Puesto que el espacio en disco es limitado, necesitamos poder reutilizar el espacio de los archivos borrados.
Para controlar el espacio libre en el disco, el sistema de archivos mantiene una <strong>lista de espacio libre</strong> que contiene todos los bloques de disco disponibles.
Para crear un archivo, se explora la <strong>lista de espacio libre</strong> hasta obtener la cantidad de espacio requerida y se asigna ese espacio al nuevo archivo.</p>
</div>
<div class="paragraph">
<p>A continuaciÃ³n estudiaremos las diferentes maneras de implementar esa lista.</p>
</div>
<div class="sect3">
<h4 id="_vector_de_bits">20.3.1. Vector de bits</h4>
<div class="paragraph">
<p>La lista de espacio libre puede ser implementada como un <strong>vector de bits</strong> o <strong>mapa de bits</strong>, donde cada bloque es representado por un bit.
Si el bloque estÃ¡ libre, el bit estÃ¡ a 1, mientras que si el bloque estÃ¡ asignado, el bit estÃ¡ a 0.</p>
</div>
<div class="paragraph">
<p>Este enfoque es relativamente sencillo y eficiente, puesto que muchos procesadores disponen de instrucciones para manipular bits, que pueden utilizarse para obtener rÃ¡pidamente el primer bloque libre.
Por ejemplo, la familia de procesadores <a href="https://es.wikipedia.org/wiki/IA-32">x86</a>, a partir del <a href="https://es.wikipedia.org/wiki/Intel_80386">Intel 80386</a>, tiene instrucciones que devuelven la posiciÃ³n del primer bit a 1 en el valor de un registro.</p>
</div>
<div class="paragraph">
<p>Sin embargo, leer el vector de bits, modificarlo y actualizarlo en disco en cada ocasiÃ³n, es tremendamente ineficiente.
Por tanto, usar vectores de bits es ineficiente, a menos que se mantenga el vector completo en la memoria principal, escribiÃ©ndose ocasionalmente en el disco.</p>
</div>
<div class="paragraph">
<p>Esto Ãºltimo puede ser imposible para los discos de gran tamaÃ±o, en funciÃ³n de la cantidad de memoria principal.
Por ejemplo, un disco de 40 GiB con bloques de 512 bytes necesitarÃ¡ un mapa de bits de mÃ¡s de 10 MiB, lo que no es un gran requisito para un sistema moderno pero si lo era hace dos dÃ©cadas.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>El sistema de archivo NTFS y la familia <em>extended filesystem</em> âes decir, <a href="https://es.wikipedia.org/wiki/Extended_file_system">ext</a>, <a href="https://es.wikipedia.org/wiki/Ext2">ext2</a>, <a href="https://es.wikipedia.org/wiki/Ext3">ext3</a> y {ext4â utilizan mapas de bits, tanto para gestionar los bloques de datos libres como las entradas disponibles en la tabla de <strong>inodos</strong>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_lista_enlazada">20.3.2. Lista enlazada</h4>
<div class="paragraph">
<p>Otra tÃ©cnica consiste en enlazar todos los bloques de disco libres.
Para eso se puede guardar un puntero al primer bloque libre en una ubicaciÃ³n especial del disco y que ese bloque contenga un puntero al siguiente bloque libre del disco.
El segundo bloque contendrÃ­a un puntero al tercer bloque libre, y asÃ­ sucesivamente.</p>
</div>
<div class="paragraph">
<p>El inconveniente es que recorrer la lista no resulta eficiente, pues tenemos que leer cada bloque para conocer la direcciÃ³n del siguiente bloque libre en disco.
Sin embargo, debemos tener en cuenta que no es frecuente tener que recorrer la lista de espacio libre completa porque, por lo general, basta con encontrar el primer bloque libre para asignar el espacio.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Los sistemas de archivos <a href="https://es.wikipedia.org/wiki/Tabla_de_asignaci%C3%B3n_de_archivos">FAT</a> incorporan el control de bloques libres dentro de la <strong>tabla de asignaciÃ³n de archivos</strong> guardando un 0 en las entradas de los <strong>clÃºsteres</strong> libres, por lo que no se necesita ningÃºn mÃ©todo adicional.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_agrupamiento">20.3.3. Agrupamiento</h4>
<div class="paragraph">
<p>Una modificaciÃ³n de la tÃ©cnica basada en la lista enlazada consiste en almacenar las direcciones de <em>N</em> bloques libres en el primer bloque libre.
Los primeros <em>N â 1</em> de esos bloques estarÃ­an realmente libres, pero el Ãºltimo de ellos apuntarÃ­a a otro bloque con <em>N</em> bloques libres.
AsÃ­ podrÃ­an localizarse rÃ¡pidamente las direcciones de un gran nÃºmero de bloques libres, lo cual mejora la eficiencia respecto a la tÃ©cnica de lista enlazada.</p>
</div>
</div>
<div class="sect3">
<h4 id="_recuento">20.3.4. Recuento</h4>
<div class="paragraph">
<p>Generalmente los bloques son asignados o liberados en bloques contiguos, especialmente si el espacio es asignado mediante asignaciÃ³n contigua o en <strong>extensiones</strong> o <strong>clÃºsteres</strong>.
Esto puede ser aprovechado para mantener una lista donde cada entrada almacena la direcciÃ³n del primer bloque de un conjunto de bloques libres contiguo, asÃ­ como el nÃºmero de bloques del conjunto.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, el sistema de archivos <a href="https://es.wikipedia.org/wiki/XFS">XFS</a> utiliza un Ã¡rbol B+ para almacenar las direcciones de las extensiones de bloques libres y mantenerlas ordenadas por el tamaÃ±o de la extensiÃ³n a la que apuntan.
AsÃ­ el sistema operativo puede localizar rÃ¡pidamente el espacio libre necesario para satisfacer una necesidad de espacio concreta.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_de_archivos_virtuales">20.4. Sistemas de archivos virtuales</h3>
<div class="paragraph">
<p>En el <a href="#_montaje_de_sistemas_de_archivos">Apartado 19.4</a> vimos cÃ³mo el sistema operativo <strong>monta</strong> sistemas de archivos de tal forma que aparenten estar integrados en una Ãºnica estructura de directorios, permitiendo a los usuarios moverse de forma transparente entre distintos dispositivos y tipos de sistemas de archivos.
Para hacerlo, un sistema operativo moderno debe ser capaz de soportar de manera eficiente distintos tipos de sistemas de archivos, ocultando sus diferencias de cara a los usuarios.</p>
</div>
<div class="paragraph">
<p>Un mÃ©todo para implementar mÃºltiples tipos de sistemas de archivos consiste en escribir diferentes rutinas de acceso, manipulaciÃ³n y gestiÃ³n âde los directorios y archivosâ para cada uno de los tipos de sistema de archivo existentes.
Sin embargo, en lugar de esta soluciÃ³n, la mayorÃ­a de los sistemas operativos utilizan tÃ©cnicas de programaciÃ³n orientada a objetos para implementar diferentes tipos de sistemas de archivos detrÃ¡s de una misma interfaz de programaciÃ³n.
Es decir, se utilizan estructuras de datos y procedimientos comunes para separar las llamadas al sistema de los detalles de su implementaciÃ³n real, para cada uno de los sistemas de archivos.</p>
</div>
<div class="paragraph">
<p>La implementaciÃ³n de un sistema de archivos estÃ¡ compuesta de tres niveles fundamentales: la <strong>interfaz del sistema de archivos</strong>, el <strong>sistema de archivos virtual</strong> y, finalmente, la implementaciÃ³n real del sistema de archivos.</p>
</div>
<div class="sect3">
<h4 id="_interfaz_del_sistema_de_archivos">20.4.1. Interfaz del sistema de archivos</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El primer nivel es la <strong>interfaz del sistema de archivos</strong>, a la que acceden los desarrolladores a travÃ©s de las llamadas al sistema.
En sistemas POSIX, estamos hablando de las llamadas <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a>, <a href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a>, <a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a> y <a href="https://man7.org/linux/man-pages/man2/close.2.html">close()</a>, entre otras.
Y de los descriptores de archivos con los que se identifican los archivos abiertos.</p>
</div>
<div class="paragraph">
<p>Esta interfaz es la misma sea cual sea el sistema de archivos al que se estÃ© intentando acceder.</p>
</div>
</div>
<div class="sect3">
<h4 id="_sistema_de_archivos_virtual">20.4.2. Sistema de archivos virtual</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El segundo nivel es la interfaz del <strong>sistema de archivos virtual</strong> o <strong>VFS</strong> (<em>Virtual File System</em>).
Este nivel es utilizado por el anterior para atender las peticiones realizadas.</p>
</div>
<div class="paragraph">
<p>Describe operaciones genÃ©ricas sobre cualquier sistema de archivos y estructuras genÃ©ricas.
Por ejemplo, el <strong>FCB virtual</strong>, que identifica de forma unÃ­voca a cada archivo o directorio en uso en todo el sistema, dando acceso a sus metadatos.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En Linux el <strong>FCB virtual</strong> se denomina <strong>vnodo</strong>.
El <strong>vnodo</strong> de un archivo lo identifica de forma unÃ­voca en todo el sistema, incluso diferenciando archivos en sistemas de archivos diferentes.
Mientras que el <strong>inodo</strong> es un detalle de la implementaciÃ³n real del sistema de archivos, por lo que solo es Ãºnico dentro del mismo sistema de archivos.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Este nivel cumple con dos importantes funciones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Separa las operaciones genÃ©ricas sobre el sistema de archivos con respecto a su implementaciÃ³n.</p>
<div class="paragraph">
<p><strong>VFS</strong> define una interfaz muy clara y comÃºn para todos los sistemas de archivos.
De esta interfaz existirÃ¡n diversas implementaciones en el mismo sistema, una para cada sistema de archivos diferente.</p>
</div>
</li>
<li>
<p>Proporcionar un mecanismo para acceder de forma coherente a los archivos a travÃ©s de la red.</p>
<div class="paragraph">
<p>Una implementaciÃ³n de <strong>VFS</strong> no tiene que estar limitada exclusivamente a ofrecer acceso a archivos en dispositivos conectados fÃ­sicamente al sistema.
Las operaciones de la interfaz <strong>VFS</strong> pueden implementarse de tal forma que usen un protocolo de acceso a algÃºn servidor de archivos conectado a la red.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_implementaciÃ³n_del_sistema_de_archivos">20.4.3. ImplementaciÃ³n del sistema de archivos</h4>
<div class="paragraph">
<p>El tercer nivel es donde se implementa cada tipo de sistema de archivos o los distintos protocolos de los servidores de archivos en la red.
La interfaz <strong>VFS</strong> recurre a la implementaciÃ³n correspondiente para cada tipo de sistema de archivos, para satisfacer las solicitudes de los niveles superiores.</p>
</div>
<div class="paragraph">
<p>AsÃ­, por ejemplo, un <a href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a> puede implicar que se tenga que recuperar el <strong>vnodo</strong> del archivo involucrado desde la tabla de archivos abiertos, usando el descriptor de archivo indicado en la llamada al sistema.
DespuÃ©s, se invocarÃ­a la operaciÃ³n <strong>VFS</strong> <code>read()</code> sobre el <strong>vnodo</strong>, en la implementaciÃ³n concreta de <strong>VFS</strong> segÃºn el tipo de sistema de archivos involucrado.
SerÃ¡ esa implementaciÃ³n quien extraiga del <strong>vnodo</strong> la informaciÃ³n necesaria âpor ejemplo, el <strong>inodo</strong> real del archivo en el sistema de archivosâ para llevar acabo la operaciÃ³n indicada, segÃºn las especificidades del sistema de archivos.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_planificaciÃ³n_de_disco">20.5. PlanificaciÃ³n de disco</h3>
<div class="paragraph">
<p>Como ya hemos comentado, es responsabilidad del sistema operativo usar los recursos del hardware de forma eficiente.
Eso incluye planificar los procesos en la CPU para conseguir el mÃ­nimo tiempo de espera que sea posible o aprovechar de la mejor forma la memoria principal disponible para atender la demanda de los distintos procesos al mismo tiempo; pero tambiÃ©n, intentar obtener el menor tiempo de acceso y el mayor ancho de banda posible en el acceso a los discos.</p>
</div>
<div class="sect3">
<h4 id="_rendimiento_del_acceso_a_disco">20.5.1. Rendimiento del acceso a disco</h4>
<div class="paragraph">
<p>En un disco duro magnÃ©tico el <strong>tiempo de acceso al disco</strong> \$T^d\$ viene determinado por el <strong>tiempo de bÃºsqueda</strong> \$T^b\$ y la <strong>latencia rotacional</strong> \$T^r\$:</p>
</div>
<div class="stemblock">
<div class="content">
\$T_d=T_b+T_r\$
</div>
</div>
<div class="paragraph">
<p>El <strong>tiempo de bÃºsqueda</strong> \$T^b\$ es el tiempo que se tarda en mover el brazo del disco hasta el cilindro deseado.
Mientras que la <strong>latencia rotacional</strong> \$T^r\$ es el tiempo que hay que esperar para que el disco gira hasta que la cabeza llegue al sector deseado del cilindro.
Por lo tanto, el <strong>tiempo de acceso al disco</strong> es menor cuando se realizan accesos consecutivos a sectores fÃ­sicamente prÃ³ximos que cuando estÃ¡n dispersos por todo el disco.</p>
</div>
<div class="paragraph">
<p>El <strong>ancho de banda</strong> o <strong>tasa de transferencia</strong> del disco es el total de bytes transferidos en una peticiÃ³n dividido por el tiempo total que transcurre desde la primera solicitud de servicio hasta el final de la Ãºltima transferencia, con la que se termina de atender la peticiÃ³n.
Al considerar todo el tiempo necesario para atender la peticiÃ³n, a mÃ¡s <strong>tiempo de acceso al disco</strong> menor es el <strong>ancho de banda</strong>.</p>
</div>
<div class="paragraph">
<p>En los dispositivos de almacenamiento basados en memorias de estado sÃ³lido (vÃ©ase el <a href="#_memorias_de_estado_sÃ³lido">Apartado 18.1.3</a>) el tiempo de acceso viene determinado por las caracterÃ­sticas de la memoria âentre otros factoresâ lo que hace que las diferencias entre accesos secuenciales y accesos aleatorios sean mucho menos significativas.</p>
</div>
</div>
<div class="sect3">
<h4 id="_cola_de_es_al_disco">20.5.2. Cola de E/S al disco</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Cuando se solicita una operaciÃ³n de E/S sobre el almacenamiento, si la controladora y la unidad de disco estÃ¡n desocupadas, el sistema operativo puede atender la peticiÃ³n sobre la marcha.
Pero si estÃ¡n ocupadas, el sistema operativo almacena la solicitud en una cola de peticiones pendientes.
Cuando se resuelve una solicitud, el sistema operativo escoge otra de la cola y se comunica con el hardware para programar la siguiente peticiÃ³n.
La cuestiÃ³n es Â¿cuÃ¡l es el orden adecuado para escoger la peticiones de E/S de la cola, si se quiere acceder al disco de la forma mÃ¡s eficaz posible?</p>
</div>
</div>
<div class="sect3">
<h4 id="_planificaciÃ³n_fcfs_2">20.5.3. PlanificaciÃ³n FCFS</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>En la planificaciÃ³n <strong>FCFS</strong> (<em>First Come, First Served</em>) o <strong>primero que llega, primero servido</strong> la cola de E/S al disco es FIFO.
Es decir, que las las solicitudes se atienden en orden de llegada.</p>
</div>
<div class="paragraph">
<p>Es el algoritmo de planificaciÃ³n mÃ¡s simple y es equitativo, en sentido de que atiende a todos los procesos por igual.
Pero, lamentablemente, no proporciona el servicio mÃ¡s rÃ¡pido en disco duros magnÃ©ticos, donde interesa mover el brazo del disco lo menos posible.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En Linux el <strong>FCFS</strong> es actualmente denominado <strong>NOOP</strong>.
Se suele utilizar en los discos basados en memorias de estado sÃ³lido, donde reordenar las solicitudes no proporciona una mejora significativa del rendimiento, o cuando se utilizan controladoras de disco inteligentes que pueden reordenar las solicitudes segÃºn su propio criterio.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_planificaciÃ³n_sstf">20.5.4. PlanificaciÃ³n SSTF</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>En la planificaciÃ³n <strong>SSTF</strong> (<em>Sortest</em> <em>Seek Time First</em>) o algoritmo de <strong>tiempo de bÃºsqueda mÃ¡s corto</strong>, de toda cola se selecciona la solicitud con el menor <strong>tiempo de bÃºsqueda</strong> desde la posiciÃ³n actual de la cabeza.
Este algoritmo de planificaciÃ³n primero da servicio a las solicitudes cercanas a la posiciÃ³n actual de la cabeza, antes de alejarse para dar servicio a otras solicitudes, dado que el <strong>tiempo de bÃºsqueda</strong> se incrementa a medida que lo hace el nÃºmero de cilindros que es necesario recorrer para llegar a una posiciÃ³n dada.</p>
</div>
<div class="paragraph">
<p>Aun asÃ­, la soluciÃ³n no es Ã³ptima, dado que puede provocar inaniciÃ³n de algunas solicitudes, si van llegando constantemente nuevas solicitudes sobre regiones cercanas a donde estÃ¡ actualmente la cabeza del disco.</p>
</div>
</div>
<div class="sect3">
<h4 id="_planificaciÃ³n_scan_y_c_scan">20.5.5. PlanificaciÃ³n SCAN y C-SCAN</h4>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>En la planificaciÃ³n <strong>SCAN</strong>, algoritmo de <strong>exploraciÃ³n</strong> o del <strong>ascensor</strong>, el brazo del disco comienza en un extremo del disco y se mueve hacia el otro, atendiendo solicitudes a medida que pasa por cada cilindro, hasta llegar al otro extremo del disco.
En el otro extremo, la direcciÃ³n de movimiento de la cabeza se invierte para recorrer el disco en sentido inverso, repitiendo el proceso.</p>
</div>
<div class="paragraph">
<p>Suponiendo que las solicitudes se distribuyen de forma uniforme a lo largo del disco, es de suponer que cuando se llega a un extremo âjusto antes de volverâ la cantidad de solicitudes en dicho extremo serÃ¡ notablemente menor que dÃ³nde comenzÃ³ el barrido que acaba de terminar.
Entonces Â¿por quÃ© no volver a empezar desde ese extremo?</p>
</div>
<div class="paragraph">
<p>A la variante del <strong>SCAN</strong> que cuando llega a un extremo vuelve al inicio, para volver a barrer desde allÃ­, sin atender ninguna solicitud por el camino, se la denomina <strong>C-SCAN</strong> âde <em>Circula SCAN</em>â.
Con esta variante el tiempo que tiene que esperar una solicitud para ser atendida es mÃ¡s uniforme que con el algoritmo <strong>SCAN</strong> original.</p>
</div>
</div>
<div class="sect3">
<h4 id="_planificaciÃ³n_look_y_c_look">20.5.6. PlanificaciÃ³n LOOK y C-LOOK</h4>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>En teorÃ­a los algoritmos <strong>SCAN</strong> y <strong>C-SCAN</strong> hacen que el brazo recorra los cilindros del primero al Ãºltimo, pero normalmente no se suelen implementar asÃ­.</p>
</div>
<div class="paragraph">
<p>Por lo general, cuando en el recorrido del brazo, tras atender una solicitud, se descubre que ya no hay mÃ¡s solicitudes siguiendo la misma direcciÃ³n, el brazo invierte la direcciÃ³n sin llegar hasta el extremo del disco.</p>
</div>
<div class="paragraph">
<p>A estas variantes de <strong>SCAN</strong> y <strong>C-SCAN</strong> se las denomina <strong>(LOOK)</strong> y <strong>(C-LOOK)</strong>, respectivamente.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Linux utilizÃ³ <strong>C-LOOK</strong>, bajo el nombre de <strong><em>elevator</em></strong>, como planificador de E/S de disco hasta Linux 2.6.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_planificaciÃ³n_n_step_scan_n_step_look_y_f_scan">20.5.7. PlanificaciÃ³n N-Step-SCAN, N-Step-LOOK y F-SCAN</h4>
<div class="paragraph">
<p>

</p>
</div>
<div class="paragraph">
<p>Los algoritmos <strong>N-Step-SCAN</strong> y <strong>N-Step-LOOK</strong> son variantes de los algoritmos <strong>SCAN</strong> y <strong>LOOK</strong>, respectivamente; donde se limita a <em>N</em> el nÃºmero de solicitudes que se atenderÃ¡n en cada barrido del brazo del disco.
Estos algoritmos funcionan de la siguiente manera:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Se utiliza una cola con espacio para <em>N</em> solicitudes pendientes, que se van atendiendo mientras el brazo barre el disco.</p>
</li>
<li>
<p>Mientras tanto, todas las nuevas solicitudes se incorporan a una cola diferente.</p>
</li>
<li>
<p>Cuando el brazo termina el barrido y las <em>N</em> primeras solicitudes han sido atendidas, el planificador toma otras <em>N</em> solicitudes de la segunda cola y las introduce en la primera para repetir el proceso.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Si en lugar de copiar <em>N</em> peticiones de la segunda a la primera cola, se copian todas las solicitudes pendientes, el algoritmo se denomina <strong>F-SCAN</strong>.</p>
</div>
<div class="paragraph">
<p>Estos algoritmos previenen un problema denominado <strong>rigidez del brazo</strong> âo <em>arm stickiness</em>, en inglÃ©sâ a diferencia de los algoritmos SSTF, SCAN, C-SCAN, LOOK y C-LOOK, que no lo hacen.
El termino <strong>rigidez del brazo</strong> hace referencia a cuando hay un flujo continuo de solicitudes para el mismo cilindro, esto hace que con los algoritmos vistos hasta ahora, el brazo no avance por los cilindros hasta llegar al otro extremo.
Como <strong>F-SCAN</strong>, <strong>N-Step-SCAN</strong> y <strong>N-Step-LOOK</strong> separan las solicitudes en dos colas âhaciendo que las nuevas tengan que esperarâ el brazo siempre continua su barrido hacia el extremo del disco.</p>
</div>
</div>
<div class="sect3">
<h4 id="_planificaciÃ³n_cfq">20.5.8. PlanificaciÃ³n CFQ</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El planificador <strong>CFQ</strong> (<em>Completely Fair Queuing</em>) se diseÃ±Ã³ para compartir de forma equitativa el <strong>ancho de banda</strong> entre todos los procesos que solicitan acceso al disco.
Fue utilizado por defecto en muchas distribuciones de Linux hasta la versiÃ³n 5.0 del nÃºcleo y funciona de la siguiente manera:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>CFQ</strong> mantiene una cola de solicitudes para cada proceso y en ella inserta las solicitudes sÃ­ncronas de E/S.
Cada cola tiene una ventana de tiempo âo <strong>cuanto</strong>â para acceder al disco.
La longitud del <strong>cuanto</strong> y el tamaÃ±o mÃ¡ximo de cada cola dependen de la prioridad de E/S que tenga el proceso.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Las solicitudes sÃ­ncronas de E/S son aquellas que hacen que el proceso permanezca en estado <strong>esperando</strong> hasta que se resuelve la peticiÃ³n.
Por ejemplo, las operaciones de lectura bloqueantes, como ocurre por defecto con <a href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a>.
Mientras que las solicitudes asÃ­ncronas son las que permiten que el proceso continÃºe su ejecuciÃ³n en la CPU mientras se atiende la peticiÃ³n.
Como las escrituras con <a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>CFQ</strong> mantiene una cola de solicitudes por cada prioridad de E/S, donde se insertan las solicitudes asÃ­ncronas de todos los procesos.
Una solicitud asÃ­ncrona se inserta en una cola u otra segÃºn la prioridad del proceso que la generÃ³.</p>
</li>
<li>
<p>Usando el algoritmo <strong><em>round-robin</em></strong>, el planificador <strong>CFQ</strong> recorre las colas y extrae de ellas las solicitudes durante el tiempo marcado por el cuanto de cada cola.
Las solicitudes extraÃ­das se insertan en la cola de E/S al disco, donde se ordenan para minimizar el <strong>tiempo de bÃºsqueda</strong>, antes de ser enviadas al dispositivo.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Actualmente, los planificadores <strong>CFS</strong> y <strong>NOOP</strong> se consideran obsoletos.
En su lugar el planificador por defecto en Linux para SSD y discos duros es <strong>mq-deadline</strong> âun adaptaciÃ³n del planificador <a href="https://en.wikipedia.org/wiki/Deadline_scheduler">deadline</a>, tambiÃ©n obsoletoâ.
Mientras que para dispositivos NVM Express se utiliza <strong>NONE</strong>, que bÃ¡sicamente desactiva la planificaciÃ³n de la E/S de disco.</p>
</div>
<div class="paragraph">
<p>Otros planificadores disponibles actualmente son <a href="http://algo.ing.unimo.it/people/paolo/disk_sched/">BFQ</a> âdiseÃ±ado para minimizar la latenciaâ y Kyber.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_bibliografÃ­a">BibliografÃ­a</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Parte de los contenidos de este documento estÃ¡n basados en las siguientes fuentes:</p>
</div>
<div class="ulist bibliography">
<ul class="bibliography">
<li>
<p><a id="Bavier2000"></a>[Bavier2000]
Bavier, A. Â«Creating New CPU Schedulers with Virtual TimeÂ». En 21st IEEE Real-Time Systems Symposium (RTSS 2000) WIP Proceedings, 2000.</p>
</li>
<li>
<p><a id="Chase2009"></a>[Chase2009]
Chase, K. y Russinovich, M. Â«Processes, Threads, and Jobs in the Windows Operating SystemÂ». [en lÃ­nea]. Pearson, 2009 [2009]. URL <a href="https://www.microsoftpressstore.com/articles/article.aspx?p=2233328&amp;seqNum=7" class="bare">https://www.microsoftpressstore.com/articles/article.aspx?p=2233328&amp;seqNum=7</a></p>
</li>
<li>
<p><a id="Friedman1999"></a>[Friedman1999]
Friedman, M. B. Â«Windows NT Page Replacement PoliciesÂ». En 25th International Computer Measurement Group Conference, December 5-10, 1999, Pag. 234-244.</p>
</li>
<li>
<p><a id="Ganger2000"></a>[Ganger2000]
Ganger, G. R., McKusick, M. K., Soules, C. A. N. y Patt, Y. N. Â«Soft Updates: A Solution to the Metadata Update Problem in File SystemsÂ». En ACM Transactions on Computer Systems, Vol. 18, No. 2, May 2000, Pag. 127â153.</p>
</li>
<li>
<p><a id="Gaydov2016"></a>[Gaydov2016]
Gaydov, V. Â«File locking in LinuxÂ» [en lÃ­nea]. 2016 [2020]. URL <a href="https://gavv.github.io/articles/file-locks/" class="bare">https://gavv.github.io/articles/file-locks/</a></p>
</li>
<li>
<p><a id="Gorman2004"></a>[Gorman2004]
Gorman, M. Â«Understanding the Linux Virtual Memory ManagerÂ». Prentice Hall, 2004.</p>
</li>
<li>
<p><a id="Hailperin2006"></a>[Hailperin2006]
Hailperin, M. Â«Operating Systems and Middleware: Supporting Controlled InteractionÂ». Course Technology, 2006.</p>
</li>
<li>
<p><a id="Jacob1998"></a>[Jacob1998]
Jacob, B y Mudge, T. Â«Virtual Memory: Issues of ImplementationÂ». Computer, 31:33-43, 1998. ISSN 0018-9162. DOI: 10.1109/2.683005. URL <a href="http://dx.doi.org/10.1109/2.683005" class="bare">http://dx.doi.org/10.1109/2.683005</a>.</p>
</li>
<li>
<p><a id="Microsoft2005"></a>[Microsoft2005]
Â«Kernel Enhancements for Microsoft Windows Vista and Windows Server LonghornÂ» [en lÃ­nea]. Microsoft Corporation, 2005. URL <a href="https://www.slideserve.com/iolani/kernel-enhancements-for-windows-server-longhorn" class="bare">https://www.slideserve.com/iolani/kernel-enhancements-for-windows-server-longhorn</a>.</p>
</li>
<li>
<p><a id="Microsoft2003"></a>[Microsoft2003]
Â«Kernel Enhancements for Windows XPÂ» [en lÃ­nea]. Microsoft Corporation, 2003 [2006]. ARCHIVADO <a href="https://web.archive.org/web/20080307105611/http://www.microsoft.com/whdc/driver/kernel/xp_kernel.mspx" class="bare">https://web.archive.org/web/20080307105611/http://www.microsoft.com/whdc/driver/kernel/xp_kernel.mspx</a>.</p>
</li>
<li>
<p><a id="Microsoft2018"></a>[Microsoft2018]
Â«Scheduling PrioritiesÂ» [en lÃ­nea]. Microsoft Corporation, 2018 [2020]. URL <a href="https://docs.microsoft.com/en-us/windows/win32/procthread/scheduling-priorities" class="bare">https://docs.microsoft.com/en-us/windows/win32/procthread/scheduling-priorities</a></p>
</li>
<li>
<p><a id="SGI2006"></a>[SGI2006]
Â«XFS Filesystem StructureÂ» [en lÃ­nea]. Silicon Graphics Inc, 2006 [2007]. URL <a href="https://goo.gl/YF82JB" class="bare">https://goo.gl/YF82JB</a></p>
</li>
<li>
<p><a id="Silberschatz2004"></a>[Silberschatz2004]
Silberschatz, A., Galvin, P. y Gagne, G. <a href="http://absysnetweb.bbtk.ull.es/cgi-bin/abnetopac?ACC=DOSEARCH&amp;xsqf99=184173.titn./">Â«Operating System Concepts with JavaÂ»</a>. 6Âº ed. John Wiley &amp; Sons Inc., 2004.</p>
</li>
<li>
<p><a id="Silberschatz2005"></a>[Silberschatz2005]
Silberschatz, A., Galvin, P. y Gagne, G. <a href="http://absysnetweb.bbtk.ull.es/cgi-bin/abnetopac?ACC=DOSEARCH&amp;xsqf99=345629.titn./">Â«Fundamentos de Sistemas OperativosÂ»</a>. 7Âª ed. McGraw Hill, 2005.</p>
</li>
<li>
<p><a id="Solomon2005"></a>[Solomon2005]
Solomon, D. A. y Russinovich, M. Â«Windows OS Internals&#8201;&#8212;&#8201;Unit OS4: Scheduling and Dispatch 4.4. Windows ThreadÂ» [en lÃ­nea]. 2005 [2009]. URL <a href="https://slideplayer.com/slide/6972581/" class="bare">https://slideplayer.com/slide/6972581/</a></p>
</li>
<li>
<p><a id="Stallings2005"></a>[Stallings2005]
Stallings, W. <a href="http://absysnetweb.bbtk.ull.es/cgi-bin/abnetopac?TITN=314530">Â«Sistemas operativos: Aspectos internos y principios de diseÃ±oÂ»</a>. 5Âª ed. Pearson, 2005</p>
</li>
<li>
<p><a id="Sun2006"></a>[Sun2006]
Â«ZFS On-Disk Specification [en lÃ­nea]Â». Sun Microsystems, Inc. 2006 [2009]. URL <a href="http://www.giis.co.in/Zfs_ondiskformat.pdf" class="bare">http://www.giis.co.in/Zfs_ondiskformat.pdf</a></p>
</li>
<li>
<p><a id="Tanenbaum2014"></a>[Tanenbaum2014]
Tanenbaum, A. y Bos, H. Â«Modern Operating SystemsÂ». 4Âª ed. Prentice Hall Press 2014.</p>
</li>
<li>
<p><a id="Wikipedia-cmalloc"></a>[Wikipedia-cmalloc]
Â«C dynamic memory allocationÂ» [en lÃ­nea]. Wikipedia (en), [2011]. URL <a href="http://goo.gl/OkFJ3" class="bare">http://goo.gl/OkFJ3</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Ãltima actualizaciÃ³n 2020-12-10 18:09:28 UTC
</div>
</div>
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge .cm {
  color: #999988;
  font-style: italic;
}
pre.rouge .cp {
  color: #999999;
  font-weight: bold;
}
pre.rouge .c1 {
  color: #999988;
  font-style: italic;
}
pre.rouge .cs {
  color: #999999;
  font-weight: bold;
  font-style: italic;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cpf {
  color: #999988;
  font-style: italic;
}
pre.rouge .err {
  color: #a61717;
  background-color: #e3d2d2;
}
pre.rouge .gd {
  color: #000000;
  background-color: #ffdddd;
}
pre.rouge .ge {
  color: #000000;
  font-style: italic;
}
pre.rouge .gr {
  color: #aa0000;
}
pre.rouge .gh {
  color: #999999;
}
pre.rouge .gi {
  color: #000000;
  background-color: #ddffdd;
}
pre.rouge .go {
  color: #888888;
}
pre.rouge .gp {
  color: #555555;
}
pre.rouge .gs {
  font-weight: bold;
}
pre.rouge .gu {
  color: #aaaaaa;
}
pre.rouge .gt {
  color: #aa0000;
}
pre.rouge .kc {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kd {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kn {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kp {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kr {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kt {
  color: #445588;
  font-weight: bold;
}
pre.rouge .k, pre.rouge .kv {
  color: #000000;
  font-weight: bold;
}
pre.rouge .mf {
  color: #009999;
}
pre.rouge .mh {
  color: #009999;
}
pre.rouge .il {
  color: #009999;
}
pre.rouge .mi {
  color: #009999;
}
pre.rouge .mo {
  color: #009999;
}
pre.rouge .m, pre.rouge .mb, pre.rouge .mx {
  color: #009999;
}
pre.rouge .sb {
  color: #d14;
}
pre.rouge .sc {
  color: #d14;
}
pre.rouge .sd {
  color: #d14;
}
pre.rouge .s2 {
  color: #d14;
}
pre.rouge .se {
  color: #d14;
}
pre.rouge .sh {
  color: #d14;
}
pre.rouge .si {
  color: #d14;
}
pre.rouge .sx {
  color: #d14;
}
pre.rouge .sr {
  color: #009926;
}
pre.rouge .s1 {
  color: #d14;
}
pre.rouge .ss {
  color: #990073;
}
pre.rouge .s, pre.rouge .sa, pre.rouge .dl {
  color: #d14;
}
pre.rouge .na {
  color: #008080;
}
pre.rouge .bp {
  color: #999999;
}
pre.rouge .nb {
  color: #0086B3;
}
pre.rouge .nc {
  color: #445588;
  font-weight: bold;
}
pre.rouge .no {
  color: #008080;
}
pre.rouge .nd {
  color: #3c5d5d;
  font-weight: bold;
}
pre.rouge .ni {
  color: #800080;
}
pre.rouge .ne {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nf, pre.rouge .fm {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nl {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nn {
  color: #555555;
}
pre.rouge .nt {
  color: #000080;
}
pre.rouge .vc {
  color: #008080;
}
pre.rouge .vg {
  color: #008080;
}
pre.rouge .vi {
  color: #008080;
}
pre.rouge .nv, pre.rouge .vm {
  color: #008080;
}
pre.rouge .ow {
  color: #000000;
  font-weight: bold;
}
pre.rouge .o {
  color: #000000;
  font-weight: bold;
}
pre.rouge .w {
  color: #bbbbbb;
}
pre.rouge {
  background-color: #f8f8f8;
}
</style>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains('stemblock')) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>