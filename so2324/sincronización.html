<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.20">
<meta name="author" content="Jesús Torres">
<title>Sistemas Operativos</title>
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */

@import url("//fonts.googleapis.com/css?family=Noto+Sans:300,600italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700");
@import url(https://cdn.jsdelivr.net/gh/asciidoctor/asciidoctor@2.0/data/stylesheets/asciidoctor-default.css); /* Default asciidoc style framework - important */

/* CUSTOMISATIONS */
/* Change the values in root for quick customisation. If you want even more fine grain... venture further. */

:root{
--maincolor:#FFFFFF;
--primarycolor:#2c3e50;
--secondarycolor:#ba3925;
--tertiarycolor: #186d7a;
--sidebarbackground:#CCC;
--linkcolor:#b71c1c;
--linkcoloralternate:#f44336;
--white:#FFFFFF;
--black:#000000;
}

/* Text styles */
h1{color:var(--primarycolor) !important;}
h2,h3,h4,h5,h6{color:var(--secondarycolor) !important;}
.title{color:var(--tertiarycolor) !important; font-family:"Noto Sans",sans-serif !important;font-style: normal !important; font-weight: normal !important;}
p{font-family: "Noto Sans",sans-serif !important}

/* Table styles */
th{font-family: "Noto Sans",sans-serif !important}

/* Responsiveness fixes */
video {
  max-width: 100%;
}

@media all and (max-width: 600px) {
table {
  width: 55vw!important;
  font-size: 3vw;
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge, pre.rouge .w {
  color: #24292f;
  background-color: #f6f8fa;
}
pre.rouge .k, pre.rouge .kd, pre.rouge .kn, pre.rouge .kp, pre.rouge .kr, pre.rouge .kt, pre.rouge .kv {
  color: #cf222e;
}
pre.rouge .gr {
  color: #f6f8fa;
}
pre.rouge .gd {
  color: #82071e;
  background-color: #ffebe9;
}
pre.rouge .nb {
  color: #953800;
}
pre.rouge .nc {
  color: #953800;
}
pre.rouge .no {
  color: #953800;
}
pre.rouge .nn {
  color: #953800;
}
pre.rouge .sr {
  color: #116329;
}
pre.rouge .na {
  color: #116329;
}
pre.rouge .nt {
  color: #116329;
}
pre.rouge .gi {
  color: #116329;
  background-color: #dafbe1;
}
pre.rouge .kc {
  color: #0550ae;
}
pre.rouge .l, pre.rouge .ld, pre.rouge .m, pre.rouge .mb, pre.rouge .mf, pre.rouge .mh, pre.rouge .mi, pre.rouge .il, pre.rouge .mo, pre.rouge .mx {
  color: #0550ae;
}
pre.rouge .sb {
  color: #0550ae;
}
pre.rouge .bp {
  color: #0550ae;
}
pre.rouge .ne {
  color: #0550ae;
}
pre.rouge .nl {
  color: #0550ae;
}
pre.rouge .py {
  color: #0550ae;
}
pre.rouge .nv, pre.rouge .vc, pre.rouge .vg, pre.rouge .vi, pre.rouge .vm {
  color: #0550ae;
}
pre.rouge .o, pre.rouge .ow {
  color: #0550ae;
}
pre.rouge .gh {
  color: #0550ae;
  font-weight: bold;
}
pre.rouge .gu {
  color: #0550ae;
  font-weight: bold;
}
pre.rouge .s, pre.rouge .sa, pre.rouge .sc, pre.rouge .dl, pre.rouge .sd, pre.rouge .s2, pre.rouge .se, pre.rouge .sh, pre.rouge .sx, pre.rouge .s1, pre.rouge .ss {
  color: #0a3069;
}
pre.rouge .nd {
  color: #8250df;
}
pre.rouge .nf, pre.rouge .fm {
  color: #8250df;
}
pre.rouge .err {
  color: #f6f8fa;
  background-color: #82071e;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cm, pre.rouge .cp, pre.rouge .cpf, pre.rouge .c1, pre.rouge .cs {
  color: #6e7781;
}
pre.rouge .gl {
  color: #6e7781;
}
pre.rouge .gt {
  color: #6e7781;
}
pre.rouge .ni {
  color: #24292f;
}
pre.rouge .si {
  color: #24292f;
}
pre.rouge .ge {
  color: #24292f;
  font-style: italic;
}
pre.rouge .gs {
  color: #24292f;
  font-weight: bold;
}
</style>
<link rel="icon" href="media/extras/favicon.ico" sizes="any">
<link rel="icon" href="media/extras/ssoo-icon.svg" type="image/svg+xml">
<link rel="icon" type="image/png" sizes="192x192" href="media/extras/ssoo-icon-192.png">
<link rel="icon" type="image/png" sizes="512x512" href="media/extras/ssoo-icon-512.png">
<link rel="apple-touch-icon" href="media/extras/ssoo-apple-touch-icon.png"><!-- 180×180 -->
<link rel="stylesheet" href="media/extras/inlineDisqussions.css">
<style>
    body {
        display: flex;
        flex-direction: column;
        min-height: 100vh;
    }
    content {
        flex: 1;
    }
    #preamble {
        margin-top: 0.5em;
    }
    #header, #content, #footnotes {
        margin: 0 auto 0 5em
    }
    #content h1>a.anchor, h2>a.anchor, h3>a.anchor,
    #toctitle>a.anchor, .sidebarblock>.content>.title>a.anchor,
    h4>a.anchor, h5>a.anchor, h6>a.anchor {
        color: #ba3925;
    }
    .imageblock {
        text-align: center;
    }
    .imageblock > .content {
        margin-bottom: 1rem;
    }
    .imageblock > .title {
        text-align: inherit;
    }
    .tableblock > .lightcell {
        color: gray;
    }
    table tfoot td p {
        font-weight: bold;
    }
    #footer-text {
        margin: 0 auto;
        max-width: 62.5em;
        padding-left: .9375em;
        padding-right: .9375em;
    }
    #footer-text a {
        color: hsla(0,0%,100%,.8);
        text-decoration: none;
        font-weight: bold;
    }
    #footer-text a:hover {
        color: hsla(0,0%,100%,.8);
    }
</style>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script src="media/extras/inlineDisqussions.js"></script>
<script type="text/javascript">
    window.onload = function(){
        if ('{comments_enabled}' === 'true') {
            setTimeout(function() {
                disqus_shortname = 'ull-esit-sistemas-operativos';
                jQuery("img, p, .colist td, .stemblock").not('#toc p').inlineDisqussions();
                query_params = (new URL(document.location)).searchParams;
                if (query_params.has('disqussion')) {
                    let identifier = window.location.pathname + 'disqussion-' + query_params.get('disqussion');
                    let selection = jQuery('[data-disqus-identifier="' +  identifier + '"]').not('.disqussion-link');
                    if (selection.length) {
                        selection[0].scrollIntoView(true);
                    }
                }
            }, 500);
        }
    }
</script>
<style>.toc-current{font-weight: bold;} .toc-root{font-family: "Open Sans","DejaVu Sans",sans-serif;
                       font-size: 0.9em;} #content{display: flex; flex-direction: column; flex: 1 1 auto;}
             .nav-footer{text-align: center; margin-top: auto;}
             .nav-footer > p > a {white-space: nowrap;}</style>
<style>
.admonitionblock td.icon .icon-time:before {content:"\f017";color:#f28500;}
</style>
</head>
<body id="sincronización" class="book toc2 toc-left">
<div id="header">
<h1>Sistemas Operativos</h1>
<div class="details">
<span id="author" class="author">Jesús Torres</span><br>
<span id="email" class="email"><a href="mailto:jmtorres@ull.es">jmtorres@ull.es</a></span><br>
<span id="revdate">Curso 2023-2024</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Tabla de Contenido</div>
<p><span class="toc-root"><a href="main.html">Sistemas Operativos</a></span></p><ul class="sectlevel1">
<li><a href="ediciones_y_licencia.html">Ediciones y licencia</a>
</li>
<li><a href="código_de_los_ejemplos.html">Código de los ejemplos</a>
</li>
<li><a href="introducción.html">Parte I: Introducción</a>
</li>
<li><a href="organización_de_los_sistemas_operativos.html">Parte II: Organización de los sistemas operativos</a>
</li>
<li><a href="gestión_de_procesos.html">Parte III: Gestión de procesos</a>
<ul class="sectlevel1">
<li><a href="procesos.html">9. Procesos</a>
</li>
<li><a href="comunicación_mediante_paso_de_mensajes.html">10. Comunicación mediante paso de mensajes</a>
</li>
<li><a href="memoria_compartida.html">11. Memoria compartida</a>
</li>
<li><a href="hilos.html">12. Hilos</a>
</li>
<li><a href="sincronización.html"><span class="toc-current">13. Sincronización</span></a>
<ul class="sectlevel2">
<li><a href="sincronización.html#_el_problema_de_las_secciones_críticas">13.1. El problema de las secciones críticas</a>
</li>
<li><a href="sincronización.html#_sincronización_por_hardware">13.2. Sincronización por hardware</a>
</li>
<li><a href="sincronización.html#_semáforos">13.3. Semáforos</a>
</li>
<li><a href="sincronización.html#_mutex">13.4. Mutex</a>
</li>
<li><a href="sincronización.html#_variables_de_condición">13.5. Variables de condición</a>
</li>
<li><a href="sincronización.html#_implementación_de_semáforos">13.6. Implementación de semáforos</a>
</li>
<li><a href="sincronización.html#_esperas">13.7. Esperas</a>
</li>
<li><a href="sincronización.html#_funciones_reentrantes_y_seguras_en_hilos">13.8. Funciones reentrantes y seguras en hilos</a>
</li>
</ul>
</li>
<li><a href="planificación_de_la_cpu.html">14. Planificación de la CPU</a>
</li>
</ul>
</li>
<li><a href="gestión_de_la_memoria.html">Parte IV: Gestión de la memoria</a>
</li>
<li><a href="gestión_del_almacenamiento.html">Parte V: Gestión del almacenamiento</a>
</li>
<li><a href="bibliografía.html">Bibliografía</a>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="sincronización"><a class="anchor" href="#sincronización"></a>13. Sincronización</h2>
<div class="sectionbody">
<div class="admonitionblock time">
<table>
<tr>
<td class="icon">
<i class="fa icon-time" title=""></i>
</td>
<td class="content">
<div class="paragraph">
<p><strong>Tiempo de lectura:</strong> 34 minutos</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>En el <a href="memoria_compartida.html">Capítulo 11</a> vimos que varios procesos pueden compartir regiones de la memoria con el objeto de cooperar en las tareas que deben desempeñar.
Además, en el <a href="hilos.html">Capítulo 12</a> vimos que en los procesos multihilo todos los hilos comparten el espacio de direcciones del proceso al que pertenecen, lo que significa que pueden acceder al mismo tiempo a las variables globales y a la memoria reservada dinámicamente.</p>
</div>
<div class="paragraph">
<p>Ambas posibilidades introducen algunos riesgos, puesto que el acceso simultáneo a los datos compartidos puede ocasionar inconsistencias.
Así que ha llegado el momento de discutir cómo se puede asegurar la ejecución ordenada de hilos o procesos cooperativos que comparten regiones de la memoria, con el fin de mantener la consistencia de los datos.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En este capítulo hablaremos de hilos y de procesos que comparten memoria indistintamente.
En ambos casos el problema es el mismo y las soluciones similares.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_el_problema_de_las_secciones_críticas"><a class="anchor" href="#_el_problema_de_las_secciones_críticas"></a>13.1. El problema de las secciones críticas</h3>
<div class="paragraph">
<p>Llamamos <strong>condición de carrera</strong> a la situación en la que varios procesos o hilos pueden acceder y manipular los mismos datos al mismo tiempo —es decir, de forma <strong>concurrente</strong>— y donde el resultado de la ejecución depende del orden particular en el que tienen lugar dichos accesos.
Estas situaciones ocurren frecuentemente en los sistemas operativos, puesto que diferentes componentes del mismo manipulan los mismos recursos interfiriendo unos con otros.</p>
</div>
<div class="sect3">
<h4 id="_problema_del_productor_consumidor"><a class="anchor" href="#_problema_del_productor_consumidor"></a>13.1.1. Problema del productor-consumidor</h4>
<div class="paragraph">
<p>Para ilustrarlo, veamos un problema clásico de concurrencia: el <strong>problema del productor-consumidor</strong>.</p>
</div>
<div class="paragraph">
<p>Supongamos que dos hilos o procesos comparten una región de la memoria que contiene un vector de elementos y un contador con el número de elementos del vector.</p>
</div>
<div class="paragraph">
<p>El primer hilo realiza varias tareas, que no entraremos a describir.
Lo importante es que, como resultado de esas tareas, en ocasiones añade un elemento al vector e incrementa el contador que indica el número de elementos en el vector.
Es decir, el primer hilo actúa como un <strong>productor</strong> de elementos del vector.</p>
</div>
<div class="paragraph">
<p>A continuación mostramos una porción de la función del productor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">while</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">item</span> <span class="o">=</span> <span class="n">produce_item</span><span class="p">();</span>

    <span class="c1">// Si el vector está lleno, esperar</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">VECTOR_SIZE</span><span class="p">);</span>

    <span class="c1">// Añadir el elemento al vector</span>
    <span class="n">vector</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
    <span class="o">++</span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>El segundo hilo también realiza varias tareas que no describiremos.
Pero para realizar esas tareas en ocasiones debe tomar un elemento del vector compartido, decrementando el contador para indicar que ahora hay un elemento menos en el vector.
Es decir, el segundo hilo actúa como un <strong>consumidor</strong> de elementos del vector.</p>
</div>
<div class="paragraph">
<p>A continuación mostramos una porción de la función del consumidor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">while</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Si el vector está vacio, esperar</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// Extraer un elemento del vector</span>
    <span class="o">--</span><span class="n">count</span><span class="p">;</span>
    <span class="n">item</span> <span class="o">=</span> <span class="n">vector</span><span class="p">[</span><span class="n">count</span><span class="p">];</span>

    <span class="n">consume_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Aunque el <strong>problema del productor-consumidor</strong> parezca artificial, lo cierto es que es muy común.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, en una herramienta de grabación de audio, el <strong>productor</strong> es un hilo dedicado a obtener bloques de muestras grabadas a través de la API multimedia del sistema operativo.
Mientras tanto, otro hilo puede dedicarse a tomar las muestras y realizar diversas transformaciones, como: reducir el ruido, mezclar con otras fuentes de sonido o aplicar algún tipo de efecto digital.
Este segundo hilo es el <strong>consumidor</strong>.
La manera de conectar ambos es tener un vector compartido, donde se depositan los bloques de muestras cuando llegan y de dónde se extraen para su tratamiento.
Así, ambos hilos pueden trabajar a su propio ritmo, de forma casi independiente.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Aunque el código anterior del productor y del consumidor es correcto cuando no coinciden en el tiempo al ejecutarse, no funciona adecuadamente cuando sí lo hacen.
El motivo es que los dos hilos comparten y modifican la variable <code>count</code>.</p>
</div>
<div class="paragraph">
<p>Obviamente, las sentencias <code>++count</code> y <code>--count</code> pueden modificar <code>count</code> al mismo tiempo si los hilos se ejecutan en núcleos diferentes en máquinas multiprocesador o multinúcleo.
Eso también puede ocurrir en máquinas monoprocesador con sistemas operativos con planificación expropiativa (véase el <a href="planificación_de_la_cpu.html#_planificación_expropiativa">Apartado 14.1</a>) dado que en esos sistemas un hilo puede ser interrumpido en cualquier momento para dar paso a la ejecución de otro.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, <code>++count</code> podría dividirse por el compilador en las siguientes operaciones, al generar las instrucciones del procesador:</p>
</div>
<div class="listingblock">
<div class="title">++count</div>
<div class="content">
<pre>registro1 = [count];
registro1 = registro1 + 1;
[count] = registro1;</pre>
</div>
</div>
<div class="paragraph">
<p>Donde <code>registro1</code> representa un registro de la CPU.
De forma parecida la sentencia <code>--count</code> podría ser implementada de la siguiente manera:</p>
</div>
<div class="listingblock">
<div class="title">--count</div>
<div class="content">
<pre>registro2 = [count];
registro2 = registro2 - 1;
[count] = registro2;</pre>
</div>
</div>
<div class="paragraph">
<p>Donde nuevamente <code>registro2</code> representa un registro de la CPU.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
Aunque <code>registro1</code> y <code>registro2</code> pueden ser el mismo registro físico, el contenido de los registros se guarda y se recupera durante los cambios de contexto de un hilo al otro, por lo que es indiferente si son el mismo o registros diferentes.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>En sistemas monoprocesador, el que las sentencias <code>++count</code> y <code>--count</code> se ejecute de forma concurrente, es similar a que las instrucciones de lenguaje máquina de ambas sentencias en ambos hilos o procesos se entrelacen en algún orden aleatorio.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, un posible entrelazado de las instrucciones en lenguaje máquina entre hilos, suponiendo que inicialmente <code>count = 5</code>, podría ser el siguiente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="c1">// Entra ++count</span>
<span class="n">registro1</span> <span class="o">=</span> <span class="p">[</span><span class="n">count</span><span class="p">];</span>        <span class="c1">// registro1 = 5</span>
<span class="n">registro1</span> <span class="o">=</span> <span class="n">registro1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// registro1 = 6</span>
<span class="c1">// Sale ++count y entra --count</span>
<span class="n">registro2</span> <span class="o">=</span> <span class="p">[</span><span class="n">count</span><span class="p">];</span>        <span class="c1">// registro2 = 5</span>
<span class="n">registro2</span> <span class="o">=</span> <span class="n">registro2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// registro2 = 4</span>
<span class="c1">// Sale --count y entra ++count</span>
<span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">registro1</span><span class="p">;</span>        <span class="c1">// count = 6 </span><i class="conum" data-value="2"></i><b>(2)</b>
<span class="c1">// Entra --count</span>
<span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">registro2</span><span class="p">;</span>        <span class="c1">// count = 4 </span><i class="conum" data-value="1"></i><b>(1)</b> <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Así llegamos al resultado incorrecto <code>count = 4</code>, indicando que hay 4 elementos en el vector cuando realmente hay 5.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Si invertimos el orden de las sentencias obtendremos el resultado, también incorrecto, <code>count = 6</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Como se puede apreciar, hemos llegado a estos valores incorrectos porque hemos permitido la manipulación concurrente de la variable <code>count</code>.
Según como se entrelacen las instrucciones de <code>++count</code> y <code>--count</code> en la CPU, el resultado final podría ser: 4, 5 o 6.
Sin embargo, el único resultado correcto es 5, que es el que obtendremos si ejecutamos las sentencias secuencialmente, sin mezclar las operaciones en las que se dividen.</p>
</div>
</div>
<div class="sect3">
<h4 id="_manipular_estructuras_de_datos"><a class="anchor" href="#_manipular_estructuras_de_datos"></a>13.1.2. Manipular estructuras de datos</h4>
<div class="paragraph">
<p>Obviamente, el problema comentado no aparece solo en sentencias simples, sino también en bloques de código destinados a hacer tareas complejas, como manipular estructuras de datos.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, supongamos que <code>vector</code> no es un simple <em>array</em> de elementos, sino una lista enlazada, de tal forma que ahora extraer un elemento sería así:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="o">--</span><span class="n">count</span><span class="p">;</span>
<span class="n">item</span> <span class="o">=</span> <span class="n">vector</span><span class="p">.</span><span class="n">extract</span><span class="p">(</span><span class="n">count</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>y el método <code>extract()</code> tendría que dar los siguientes pasos:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Iterar sobre la lista para buscar el nodo en la posición <code>count</code>.</p>
</li>
<li>
<p>Al encontrarlo, preservar en variables locales el puntero a ese nodo y al previo.</p>
</li>
<li>
<p>Cambiar en el nodo previo el puntero al siguiente nodo, para que apunte al nodo tras el que queremos extraer.
En este momento el nodo a extraer ya no pertenece a la lista enlazada.</p>
</li>
<li>
<p>Extrae el <code>item</code> del campo que lo contiene en el nodo.</p>
</li>
<li>
<p>Destruir el nodo.</p>
</li>
<li>
<p>Salir del método retornando el elemento.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Esto genera varios momentos cruciales en torno al paso 3, que puedan dar lugar a <strong>condiciones de carrera</strong>.
Por ejemplo, si el hilo es interrumpido tras guardar el puntero al nodo en una variable local y llega otro hilo que extrae —y destruye— antes ese mismo nodo, el puntero ya no es válido —es un <em>dangling pointer</em> o referencia colgante— al continuar la ejecución del primer hilo.
Y lo mismo ocurre con el puntero al nodo previo o al siguiente, si el hilo es interrumpido y otro hilo destruye antes alguno de ellos.</p>
</div>
<div class="paragraph">
<p>Los problemas que esto puede causar son diversos, según el momento exacto en el que ocurra.
Puede haberlos al intentar leer el elemento guardado en el nodo en el paso 4, porque este último ya no exista.
También, al intentar actualizar, en el paso 3, el puntero al siguiente nodo en el nodo previo, porque el nodo previo no exista.
Incluso puede que la función termine con aparente normalidad, pero dejando que el nodo previo apunte a un nodo siguiente que no existe.
En este último supuesto, la lista quedaría en estado inconsistente y así el problema se lo encontraría el próximo hilo que intente usarla.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exclusión_mutua"><a class="anchor" href="#_exclusión_mutua"></a>13.1.3. Exclusión mutua</h4>
<div class="paragraph">
<p>Para evitar que estas situaciones lleven a la corrupción de datos y a caídas de servicios y sistemas, debemos asegurarnos que solo un hilo en cada momento puede manipular recursos y variables compartidas.
Por tanto, necesitamos algún tipo de mecanismo de sincronización para que mientras se ejecuta <code>++count</code> no se pueda ejecutar <code>--count</code> en otro hilo, ni viceversa.
O para que mientras un hilo haga un <code>insert()</code> o un <code>extract()</code> en una lista, otro no pueda utilizar ni estas ni otras funciones de la misma clase.</p>
</div>
<div class="paragraph">
<p>Para resolver esto, debemos empezar buscando las <strong>secciones críticas</strong> de nuestro código.
Una <strong>sección crítica</strong> es una porción del código donde se accede a variables, tablas, listas, archivos y otros recursos compartidos.</p>
</div>
<div class="paragraph">
<p>Para evitar <strong>condiciones de carrera</strong>, el acceso a las <strong>secciones críticas</strong> debe ser controlado, de manera que cuando un hilo se esté ejecutando en una sección de este tipo ningún otro pueda hacerlo en la suya correspondiente para manipular los mismos recursos.
En estos casos se dice que existe <strong>exclusión mutua</strong> entre las <strong>secciones críticas</strong>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_eventos"><a class="anchor" href="#_eventos"></a>13.1.4. Eventos</h4>
<div class="paragraph">
<p>Las <strong>condiciones de carrera</strong> son el principal problema del código anterior del productor y el consumidor, pero no el único.
En ambos ejemplos se usan bucles para que el hilo espere si el vector está lleno o vacío, antes de continuar.
A esta técnica se la denomina <strong>espera ocupada</strong> o <strong>espera activa</strong> y está completamente desaconsejada usarla en código del espacio de usuario, porque contribuye a gastar tiempo de CPU inútilmente.</p>
</div>
<div class="paragraph">
<p>En su lugar, se recomienda usar mecanismos de sincronización ofrecidos por el sistema operativo; diseñados para que un hilo o proceso notifique eventos a otro, de tal forma que hasta que eso ocurre, el que espera permanezca en estado <strong>esperando</strong>, dejando la CPU para los hilos que la necesitan.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sincronización_por_hardware"><a class="anchor" href="#_sincronización_por_hardware"></a>13.2. Sincronización por hardware</h3>
<div class="paragraph">
<p>Las soluciones ofrecidas por el sistema operativo, para resolver los problemas anteriores, suelen tener que apoyarse en características del hardware.
A continuación veremos algunas de esas características, antes de profundizar en los mecanismos ofrecidos por el sistema operativo.</p>
</div>
<div class="sect3">
<h4 id="_bloque_de_las_interrupciones"><a class="anchor" href="#_bloque_de_las_interrupciones"></a>13.2.1. Bloque de las interrupciones</h4>
<div class="paragraph">
<p>El problema de la sección crítica puede ser resuelto de forma sencilla en un sistema monoprocesador.</p>
</div>
<div class="paragraph">
<p>Como el núcleo del sistema operativo es un software controlado mediante interrupciones, basta con que los hilos bloqueen las interrupciones mientras se está dentro de la sección crítica.
Así, el sistema operativo no puede tomar el control y asignar otro hilo a la CPU, lo que impide que se ejecute otra secuencia de instrucciones que podría modificar los datos compartidos.</p>
</div>
<div class="paragraph">
<p>Indudablemente esta solución no es práctica en sistema multiprocesador, donde hay varios procesadores ejecutándose a la vez.</p>
</div>
</div>
<div class="sect3">
<h4 id="_instrucciones_atómicas"><a class="anchor" href="#_instrucciones_atómicas"></a>13.2.2. Instrucciones atómicas</h4>
<div class="paragraph">
<p>
Las CPU modernas disponen de instrucciones para comparar y modificar el contenido de una variable o intercambiar el contenido de dos variables, de forma <strong>atómica</strong>.
El término <strong>atómico</strong> hace referencia a que las operaciones se ejecutan como una unidad ininterrumpible.
No importa que varias CPU ejecuten estas instrucciones simultáneamente, puesto el hardware se encargará de que sean ejecutadas secuencialmente en algún orden arbitrario.</p>
</div>
<div id="instrucciones-atómicas-en-mips" class="exampleblock">
<div class="title">Ejemplo 13.1. Instrucciones atómicas en procesadores MIPS.</div>
<div class="content">
<div class="paragraph">
<p>En los procesadores MIPS el acceso atómico a la memoria se realiza mediante las instrucciones <strong><em>load-linked</em></strong> <code>ll</code> y <strong><em>store-conditional</em></strong> <code>sc</code>.</p>
</div>
<div class="paragraph">
<p>La instrucción <code>ll</code> caga un valor de la memoria en un registro y monitorizar la dirección de memoria correspondiente para detectar si otro procesador la modifica.
Mientras que la instrucción <code>sc</code> intenta almacenar un valor en la dirección de memoria, siempre que dicha dirección no haya sido modificada desde la anterior instrucción <code>ll</code>.</p>
</div>
<div class="paragraph">
<p>Ambas instrucciones se utilizan de la siguiente manera para implementar una operación atómica de incremento:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>main:
  la      r2, count

retry_increment:
  ll      r1, 0(r2)                 <i class="conum" data-value="1"></i><b>(1)</b>
  addiu   r1, r1, 1                 <i class="conum" data-value="2"></i><b>(2)</b>
  sc      r1, 0(r2)                 <i class="conum" data-value="3"></i><b>(3)</b>
  beqz    r1, retry_increment       <i class="conum" data-value="4"></i><b>(4)</b>
  nop                               <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Suponiendo que <code>r2</code> contiene la dirección de la variable <code>count</code>, carga el valor de dicha variable en <code>r1</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Incrementa el valor en el registro <code>r1</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Intenta almacenar el valor incrementado en <code>count</code>.
Si tiene éxito, porque el valor de <code>count</code> no ha sido modificado por otro proceso, <code>r1</code> se pone a 1.
En caso contrario, se pone a 0.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Si <code>r1</code> vale 0, es que la instrucción <code>sc</code> falló porque la variable <code>count</code> fue modificada por otro proceso.
En ese caso, se salta a <code>retry_increment</code> para volver a intentar el incremento de la variable.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Se pone una instrucción para evitar que después de <code>beqz</code> se ponga un instrucción que el procesador ejecute antes del salto.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Antes y después del bloque de instrucciones <code>ll</code> y <code>sc</code>, generalmente se usa la instrucción <code>sync</code>.
Esta instrucción crear una barrera de operaciones en memoria, de forma que el procesador se ve obligado a completar todas las operaciones en memoria anteriores a <code>sync</code> antes de realizar las operaciones en memoria siguientes, como <code>ll</code> y <code>sc</code>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Estas instrucciones están disponibles para los programadores de C y C&#43;&#43; a través de tipos especiales.
Por ejemplo, en C11 <a href="https://en.cppreference.com/w/c/atomic">&lt;stdatomic.h&gt;</a> define tipos como: <code>atomic_bool</code>, <code>atomic_uint</code> o <code>atomic_char</code> para declarar variables atómicas de los tipos <code>bool</code>, <code>unsigned int</code> y <code>char</code>, respectivamente.
También declara funciones para inicializar, leer, guardar, intercambiar, sumar, restar y realizar operaciones lógicas, de forma atómica sobre estas variables:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">atomic_int</span> <span class="n">count</span><span class="p">;</span>
<span class="n">atomic_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="kt">int</span> <span class="n">old_count</span> <span class="o">=</span> <span class="n">atomic_fetch_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Inicializar el valor de la variable atómica.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Como un <code>count++</code> atómico: incrementa la variable devolviendo el valor previo.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>En C&#43;&#43;11, <a href="https://en.cppreference.com/w/cpp/header/atomic">&lt;atomic&gt;</a> declara la plantilla <a href="https://en.cppreference.com/w/cpp/atomic/atomic">std::atomic</a> que ofrece una funcionada similar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">count</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>  <i class="conum" data-value="1"></i><b>(1)</b> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="kt">int</span> <span class="n">old_count</span> <span class="o">=</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>     <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>También hay un tipo <code>std::atomic_int</code> que es equivalente.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Se usa el constructor para inicializar la variable atómica.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Además de soportar los operadores '++' y '--', soporta los métodos <a href="https://en.cppreference.com/w/cpp/atomic/atomic/fetch_add">std::atomic::fetch_add()</a> y <a href="https://en.cppreference.com/w/cpp/atomic/atomic/fetch_sub">std::atomic::fetch_sub()</a> para sumar y restar devolviendo el valor previo.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>La importancia de estas instrucciones está en que pueden ser utilizadas por el sistema operativo para ofrecer soluciones sencillas al problema de la sección crítica.
Por ejemplo, <strong>semáforos</strong> o <strong><em>mutex</em></strong>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_semáforos"><a class="anchor" href="#_semáforos"></a>13.3. Semáforos</h3>
<div class="paragraph">
<p>
La exclusión mutua en las secciones críticas se asegura utilizando adecuadamente una serie de recursos que para ese fin proporciona el sistema operativo.
Estos recursos utilizan internamente instrucciones y otras características de la CPU, incluidas por los diseñadores para resolver este tipo de problemas, que hemos comentado anteriormente.
Ese es el caso de los <strong>semáforos</strong>.</p>
</div>
<div class="paragraph">
<p>Los <strong>semáforos</strong> son un tipo de objetos del sistema operativo que nos permiten controlar el acceso a una sección crítica, por medio de dos primitivas: <strong>acquire</strong> y <strong>release</strong> —o <strong>wait</strong> y <strong>signal</strong>, según el libro de texto que consultemos—.</p>
</div>
<div class="paragraph">
<p>Los <strong>semáforos</strong> tienen un contador interno que se inicializa, de tal forma que <strong>un semáforo inicializado a <em>N</em> solo permite que <em>N</em> hilos ejecuten la sección crítica al mismo tiempo</strong>.</p>
</div>
<div class="paragraph">
<p>A continuación describimos el mecanismo de funcionamiento:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">semaphore</span> <span class="nf">S</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>    <i class="conum" data-value="1"></i><b>(1)</b>

<span class="n">S</span><span class="p">.</span><span class="n">acquire</span><span class="p">()</span>         <i class="conum" data-value="2"></i><b>(2)</b>

<span class="c1">// Código de la sección crítica... </span><i class="conum" data-value="3"></i><b>(3)</b>

<span class="n">S</span><span class="p">.</span><span class="n">signal</span><span class="p">();</span>         <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Crear el <strong>semáforo</strong> <code>S</code> inicializado a 10.
Un <strong>semáforo</strong> contiene fundamentalmente un contador con el número máximo de hilos que pueden estar ejecutando el código de la sección crítica al mismo tiempo.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Intentar entrar en la sección crítica:
<div class="ulist">
<ul>
<li>
<p>Si el contador interno del <strong>semáforo</strong> es mayor que 0, <code>acquire()</code> lo decrementa y retorna para que la ejecución continúe.</p>
</li>
<li>
<p>Si el contador interno del <strong>semáforo</strong> es igual a 0, <code>acquire()</code> saca al hilo de la CPU y lo pone en una cola de espera, suspendiendo así su ejecución.
Básicamente, es que hay demasiados hilos dentro de la sección crítica.</p>
</li>
</ul>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Aquí iría el código protegido con el <strong>semáforo</strong>.
Es decir, el código de la sección crítica en sí.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Salir de la sección crítica:
<div class="ulist">
<ul>
<li>
<p>Si el contador interno del <strong>semáforo</strong> es mayor que 0, <code>release()</code> lo incrementa y retorna para que la ejecución continúe.</p>
</li>
<li>
<p>Si el contador interno del <strong>semáforo</strong> es igual a 0, <code>release()</code> lo incrementa y saca a uno de los hilos en la cola de espera —donde los puso su <code>acquire()</code>— para meterlo en la cola de preparados, dejándolo listo para entrar en la CPU.
Cuando eso ocurra, ese hilo decrementará el contador interno del <strong>semáforo</strong> y saldrá de su <code>acquire()</code>, donde hasta ahora estaba atrapado.
Mientras tanto <code>release()</code> retorna y la ejecución del hilo que sale del sección crítica continúa.</p>
</li>
</ul>
</div></td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Para que funcione correctamente, el <strong>semáforo</strong> <code>S</code> debe ser el mismo para todos los hilos que tengan secciones críticas en cuya ejecución debe haber <strong>exclusión mutua</strong>.
Es decir, el <strong>semáforo</strong> <code>S</code> debe estar compartido entre los hilos de la misma manera que las estructuras de datos, variables y otros recursos que protege.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_tipos_de_semáforos"><a class="anchor" href="#_tipos_de_semáforos"></a>13.3.1. Tipos de semáforos</h4>
<div class="paragraph">
<p>Tanto el estándar POSIX como Windows API soportan semáforos y ambos admiten dos tipos de semáforos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Los <strong>semáforos anónimos</strong> que solo existen en el espacio de direcciones del proceso que los crea, de tal forma que están disponibles para sincronizar hilos del mismo proceso.</p>
<div class="paragraph">
<p>La forma de usarlos para sincronizar procesos diferentes o hilos en procesos diferentes depende del sistema operativo.
Con Windows API se pueden heredar de padres a hijos.
Mientras que en sistemas POSIX es necesario crear el <strong>semáforo</strong> en una región de <strong>memoria compartida</strong>, que hayamos creado previamente, e indicar un valor distinto de 0 en el argumento <code>pshared</code> de <a href="https://man7.org/linux/man-pages/man3/sem_init.3.html">sem_init()</a>.</p>
</div>
</li>
<li>
<p>Las <strong>semáforos con nombre</strong> son públicos al resto del sistema, por lo que teóricamente cualquier proceso con permisos puede abrirlos para utilizarlos.</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 13.1. Funciones de la API para manipular semáforos.</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">POSIX API</th>
<th class="tableblock halign-left valign-top">Windows API</th>
</tr>
</thead>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Crear semáforo anónimo</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/sem_init.3.html">sem_init()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsemaphorea">CreateSemaphore()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Crear semáforo con nombre</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/sem_open.3.html">sem_open()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsemaphorea">CreateSemaphore()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Abrir semáforo con nombre</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/sem_open.3.html">sem_open()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-opensemaphorew">OpenSemaphore()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Operación acquire</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/sem_wait.3.html">sem_wait()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject">WaitForSingleObject()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Operación release</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/sem_post.3.html">sem_post()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-releasesemaphore">ReleaseSemaphore()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Cerrar semáforo con nombre</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/sem_close.3.html">sem_close()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle">CloseHandle()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Destruir semáforo anónimo</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/sem_destroy.3.html">sem_destroy()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="lightcell">[Automático]</span></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Destruir semáforo con nombre</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/sem_unlink.3.html">sem_unlink()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="lightcell">[Automático]</span></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_ejemplos_del_uso_de_semáforos"><a class="anchor" href="#_ejemplos_del_uso_de_semáforos"></a>13.3.2. Ejemplos del uso de semáforos</h4>
<div class="paragraph">
<p>En el ejemplo <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2324/src/cap11/anom-shared-memory.cpp">anom-shared-memory.cpp</a> de comunicación mediante memoria compartida, se usa un <strong>semáforo</strong> para que el proceso hijo indique al proceso padre que ha terminado de calcular el factorial y el resultado ya está en la memoria.</p>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2324/src/cap11/shared-memory-server.c">shared-memory-server.c</a> está el ejemplo completo de un programa que muestra periódicamente la hora del sistema y que puede ser controlado remotamente, mediante memoria compartida, con un cliente como el de <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2324/src/cap11/shared-memory-client.cpp">shared-memory-client.cpp</a>.</p>
</div>
<div class="paragraph">
<p>Para enviar los mensajes entre el cliente y el servidor, en la memoria compartida se reserva hueco para un búfer en el que el cliente copia el comando que quiere enviar y para dos <strong>semáforos</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="k">struct</span> <span class="n">memory_content</span>
<span class="p">{</span>
    <span class="n">sem_t</span> <span class="n">empty</span><span class="p">;</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">sem_t</span> <span class="n">ready</span><span class="p">;</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="kt">char</span> <span class="n">command_buffer</span><span class="p">[</span><span class="n">MAX_COMMAND_SIZE</span><span class="p">];</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Indica cuándo <code>command_buffer</code> está vacío, así que se inicializa a 1.
El cliente usa <a href="https://man7.org/linux/man-pages/man3/sem_wait.3.html">sem_wait()</a> en este <strong>semáforo</strong> antes de escribir un nuevo comando en <code>command_buffer</code>:
<div class="ulist">
<ul>
<li>
<p>Si el <strong>semáforo</strong> está a 0, el cliente pasa y escribe el comando.
Después llama a <a href="https://man7.org/linux/man-pages/man3/sem_post.3.html">sem_post()</a> en <code>ready</code>.</p>
</li>
<li>
<p>Si el <strong>semáforo</strong> está a 1, el cliente queda bloqueado y tiene que esperar a que el servidor use <a href="https://man7.org/linux/man-pages/man3/sem_post.3.html">sem_post()</a> sobre el mismo <strong>semáforo</strong>.
El servidor lo hace después de leer el comando para interpretarlo.</p>
</li>
</ul>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Indica cuándo <code>command_buffer</code> tiene un comando, así que se inicializa a 0.
El servidor usa <a href="https://man7.org/linux/man-pages/man3/sem_wait.3.html">sem_wait()</a> en este <strong>semaforo</strong> antes de leer el comando en <code>command_buffer</code> para interpretarlo:
<div class="ulist">
<ul>
<li>
<p>Si el <strong>semáforo</strong> está a 0, el cliente pasa y lee el comando.
Después llama a <a href="https://man7.org/linux/man-pages/man3/sem_post.3.html">sem_post()</a> en <code>empty</code>.</p>
</li>
<li>
<p>Si el <strong>semáforo</strong> está a 1, el servidor queda bloqueado y tiene que esperar a que el cliente use <a href="https://man7.org/linux/man-pages/man3/sem_post.3.html">sem_post()</a> sobre el mismo <strong>semáforo</strong>.
El cliente lo hace después de escribir un nuevo comando en <code>command_buffer</code>.</p>
</li>
</ul>
</div></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>El detalle de cómo cliente y servidor usan ambos semáforos, se puede ver en el código de <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2324/src/cap11/shared-memory-client.cpp">shared-memory-client.cpp</a> y <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2324/src/cap11/shared-memory-server.c">shared-memory-server.c</a>, respectivamente.</p>
</div>
<div class="paragraph">
<p>Finalmente, para resolver el <strong>problema del productor-consumidor</strong> tenemos que considerar que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Necesitamos un semáforo para que haya <strong>exclusión mutua</strong> entre ambos al insertar y extraer elementos del vector.</p>
</li>
<li>
<p>Necesitamos una forma de que el productor espere cuando el vector esté lleno y que el consumidor haga lo mismo cuando el vector esté vacío.
Una solución es usar dos semáforos, uno para que cuente el número de elementos en el vector y otro para contar el número de huecos libres:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">sem_t</span> <span class="n">mutex</span><span class="p">;</span>       <i class="conum" data-value="1"></i><b>(1)</b>
<span class="n">sem_t</span> <span class="n">fill_count</span><span class="p">;</span>  <i class="conum" data-value="2"></i><b>(2)</b>
<span class="n">sem_t</span> <span class="n">empty_count</span><span class="p">;</span> <i class="conum" data-value="3"></i><b>(3)</b>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">item_t</span><span class="o">&gt;</span> <span class="n">buffer</span><span class="p">(</span> <span class="n">VECTOR_SIZE</span> <span class="p">);</span>

<span class="kt">void</span> <span class="nf">initialize</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">sem_init</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>  <i class="conum" data-value="1"></i><b>(1)</b> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="n">sem_init</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>  <i class="conum" data-value="2"></i><b>(2)</b> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="n">sem_init</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">VECTOR_SIZE</span> <span class="p">);</span>  <i class="conum" data-value="3"></i><b>(3)</b> <i class="conum" data-value="4"></i><b>(4)</b>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">productor</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="k">while</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">item_t</span> <span class="n">item</span> <span class="o">=</span> <span class="n">produce_item</span><span class="p">();</span>

        <span class="n">sem_wait</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">empty_count</span> <span class="p">);</span> <i class="conum" data-value="5"></i><b>(5)</b>
        <span class="n">sem_wait</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">mutex</span> <span class="p">);</span>       <i class="conum" data-value="7"></i><b>(7)</b>

        <span class="n">vector</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>

        <span class="n">sem_post</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">mutex</span> <span class="p">);</span>       <i class="conum" data-value="7"></i><b>(7)</b>
        <span class="n">sem_post</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">fill_count</span> <span class="p">);</span>  <i class="conum" data-value="6"></i><b>(6)</b>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">consumer</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="k">while</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">sem_wait</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">fill_count</span> <span class="p">);</span>  <i class="conum" data-value="6"></i><b>(6)</b>
        <span class="n">sem_wait</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">mutex</span> <span class="p">);</span>       <i class="conum" data-value="7"></i><b>(7)</b>

        <span class="n">item_t</span> <span class="n">item</span> <span class="o">=</span> <span class="n">vector</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
        <span class="n">vector</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>

        <span class="n">sem_post</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">mutex</span> <span class="p">);</span>       <i class="conum" data-value="7"></i><b>(7)</b>
        <span class="n">sem_post</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">empty_count</span> <span class="p">);</span> <i class="conum" data-value="5"></i><b>(5)</b>

        <span class="n">consume_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><strong>Semáforo</strong> que se encarga de la exclusión mutua.
Se inicializa a 1, para que el primer hilo que use <a href="https://man7.org/linux/man-pages/man3/sem_wait.3.html">sem_wait()</a> pueda entrar.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><strong>Semáforo</strong> que se encarga de contar huecos ocupados en el vector.
Se inicializa a 0, porque al principio no hay ningún elemento.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><strong>Semáforo</strong> que se encarga de contar los huecos libres en el vector.
Se inicializa a VECTOR_SIZE, porque están todos vacíos.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>El segundo argumento de <a href="https://man7.org/linux/man-pages/man3/sem_init.3.html">sem_init()</a> es <code>pshared</code>.
Se pone a 0 para indicar que este <strong>semaforo</strong> no se va a compartir entre procesos diferentes.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Antes de insertar un elemento se decrementa <code>empty_count</code>.
Así, si vale 0, es que el vector está lleno y el productor se bloquea.
El consumidor incrementa <code>empty_count</code> tras extraer un elemento y dejar hueco, despertando al productor.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Antes de extraer un elemento se decrementa <code>fill_count</code>.
Así, si vale 0, es que el vector está vacío y el consumidor se bloquea.
El productor incrementa <code>fill_count</code> tras insertar un elemento nuevo, despertando al consumidor.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>El acceso al vector con los elementos es en <strong>exclusión mutua</strong>, así que tanto productor como consumidor deben usar <a href="https://man7.org/linux/man-pages/man3/sem_wait.3.html">sem_wait()</a> sobre <code>mutex</code> antes de acceder a él.
Esto decrementa el semáforo, así que solo uno de los dos pasa y ejecuta las líneas siguientes, mientras el otro queda bloqueado.
Cuando el que haya pasado termine, debe usar <a href="https://man7.org/linux/man-pages/man3/sem_post.3.html">sem_post()</a> sobre <code>mutex</code> para incrementar el semáforo y permitir que el otro hilo entre en su <strong>sección crítica</strong>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mutex"><a class="anchor" href="#_mutex"></a>13.4. Mutex</h3>
<div class="paragraph">
<p>Los <strong><em>mutex</em></strong> —término que tiene su origen en <em>mutual exclusion</em>— son un tipo de objeto del sistema operativo que permite controlar el acceso a una sección crítica, de forma que <strong>solo un hilo pueda ejecutarla al mismo tiempo</strong>.</p>
</div>
<div class="paragraph">
<p>En este sentido, los <strong><em>mutex</em></strong> se comportan como semáforos inicializados a 1, motivo por el que también se denominan <strong>semáforos binarios</strong>.
Por tanto, aunque un sistema o lenguaje solo soporte <strong>semáforos</strong>, es directo usarlos para implementar <strong><em>mutex</em></strong>.</p>
</div>
<div class="paragraph">
<p>El estándar POSIX soporta <strong><em>mutex</em></strong> a través de <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a>.
Por defecto solo se pueden utilizar para sincronizar hilos del mismo proceso; pero tienen un atributo para permitir la sincronización entre procesos diferentes, aunque para eso deben ser creados en una región de memoria compartida por dichos procesos.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>La API de <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a> no soporta <strong>semáforos</strong> porque, como vimos antes, ya eran parte del estándar POSIX.</p>
</div>
</td>
</tr>
</table>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 13.2. Funciones de la API para manipular <em>mutex</em>.</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">C&#43;&#43;</th>
<th class="tableblock halign-left valign-top">POSIX API</th>
<th class="tableblock halign-left valign-top" colspan="2">Windows API</th>
</tr>
</thead>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Crear</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.cppreference.com/w/cpp/thread/mutex">std::mutex</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/pthread_mutex_init.3p.html">pthread_mutex_init()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-initializecriticalsection">InitializeCriticalSection()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createmutexa">CreateMutex()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Abrir</p></th>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-openmutexw">OpenMutex()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Operación acquire</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.cppreference.com/w/cpp/thread/mutex/lock">std::mutex:::lock()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/pthread_mutex_lock.3p.html">pthread_mutex_lock()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-entercriticalsection">EnterCriticalSection()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject">WaitForSingleObject()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Operación release</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.cppreference.com/w/cpp/thread/mutex/unlock">std::mutex::unlock()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/pthread_mutex_unlock.3p.html">pthread_mutex_unlock()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-leavecriticalsection">LeaveCriticalSection()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-releasemutex">ReleaseMutex()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Destruir</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="lightcell">[Destructor]</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/pthread_mutex_destroy.3p.html">pthread_mutex_destroy()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-deletecriticalsection">DeleteCriticalSection()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle">CloseHandle()</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>En Windows API hay dos tipo de objetos equiparables a los <strong><em>mutex</em></strong>: los <strong><em>mutex</em></strong> y las <strong>secciones críticas</strong>.
Las <strong>secciones críticas</strong> son más ligeras, pero solo se pueden utilizar para sincronizar hilos del mismo proceso.
Mientras que los <strong><em>mutex</em></strong> de Windows API son objetos más costosos, pero se pueden compartir entre procesos sin utilizar memoria compartida; ya sea mediante herencia al crear un proceso hijo o asignando un nombre al <strong><em>mutex</em></strong>, como ocurre con los <strong>semáforos</strong>.</p>
</div>
<div class="sect3">
<h4 id="_ejemplos_del_uso_de_mutex"><a class="anchor" href="#_ejemplos_del_uso_de_mutex"></a>13.4.1. Ejemplos del uso de mutex</h4>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2324/src/cap13/pthreads-sync-factorial.cpp">pthreads-sync-factorial.cpp</a> se puede estudiar el código completo de un ejemplo similar a <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2324/src/cap12/pthreads.cpp">pthreads.cpp</a>, donde se calculaba el factorial de un número, repartiendo la tarea entre dos hilos, usando la API de <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a>.
La diferencia es que ahora los hilos no retornan el resultado, sino que cada uno lo mete en un vector compartido.
Al terminar, el hilo principal recorre el vector multiplicando los resultados parciales.</p>
</div>
<div class="paragraph">
<p>Como ahora ambos hilos acceden a una estructura de datos compartida, esta debe ir protegida por un <strong><em>mutex</em></strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">pthread_mutex_t</span> <span class="n">mutex</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BigInt</span><span class="o">&gt;</span> <span class="n">partials</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Antes de meter un nuevo valor, cada hilo debe adquirir el <code>mutex</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// Bloquear el mutex y guardar el resultado</span>
<span class="n">pthread_mutex_lock</span><span class="p">(</span> <span class="n">mutex</span> <span class="p">);</span>   <i class="conum" data-value="1"></i><b>(1)</b>
<span class="n">partials</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">result</span> <span class="p">);</span>
<span class="n">pthread_mutex_unlock</span><span class="p">(</span> <span class="n">mutex</span> <span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Adquirir <code>mutex</code> antes de entrar en la <strong>sección crítica</strong>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Liberar <code>mutex</code> para salir de la <strong>sección crítica</strong>.
Es importante no olvidarnos de liberar el <strong><em>mutex</em></strong> al terminar o de lo contrario uno de los hilos quedará dormido indefinidamente, al no poder entrar en la <strong>sección crítica</strong>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2324/src/cap13/pthreads-sync-counter.cpp">pthreads-sync-counter.cpp</a> se puede observar un ejemplo más simple donde dos hilos intentan incrementar un contador.
El resultado es correcto siempre que cada hilo adquiera el mismo <strong><em>mutex</em></strong> antes del incremento:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// Bloquear el mutex antes de incrementar el contador.</span>
<span class="n">pthread_mutex_lock</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">mutex</span> <span class="p">);</span>
<span class="n">args</span><span class="o">-&gt;</span><span class="n">counter</span><span class="o">++</span><span class="p">;</span>
<span class="c1">// Desbloquear el mutex tras incrementar el contador.</span>
<span class="n">pthread_mutex_unlock</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">mutex</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2324/src/cap13/threads-sync-counter.cpp">threads-sync-counter.cpp</a> y <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2324/src/cap13/threads-sync-factorial.cpp">threads-sync-factorial.cpp</a> se puede ver ejemplos equivalentes pero usando <a href="https://en.cppreference.com/w/cpp/thread/thread">std::thread</a> y <a href="https://en.cppreference.com/w/cpp/thread/mutex">std::mutex</a>, de la librería estándar de C&#43;&#43;.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_variables_de_condición"><a class="anchor" href="#_variables_de_condición"></a>13.5. Variables de condición</h3>
<div class="paragraph">
<p>
En la solución que dimos al <strong>problema del productor-consumidor</strong> usando <strong>semáforos</strong> (véase el <a href="sincronización.html#_ejemplos_del_uso_de_semáforos">Apartado 13.3.2</a>) empleamos <strong>semáforos</strong> para implementar las esperas del productor y el consumidor cuando el vector está lleno o vacío, respectivamente.
Lamentablemente, los <em>mutex</em> no se pueden usar de la misma manera para señalar eventos.
En su lugar necesitamos otro tipo de objeto llamado <strong>variable de condición</strong>.</p>
</div>
<div class="paragraph">
<p>Las <strong>variables de condición</strong> soportan tres primitivas principales:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">wait( mutex )</dt>
<dd>
<p>Es llamada por un hilo que desea esperar a que ocurra el evento que representa la variable de condición.
El hilo debe haber adquirido antes el <strong><em>mutex</em></strong>, es liberado en el momento de poner al hilo en estado <strong>esperando</strong>.
Varios hilos pueden llamar a <strong>wait</strong> sobre la misma variable de condición, a la espera de que alguno use <strong>notify</strong>.</p>
</dd>
<dt class="hdlist1">notify</dt>
<dd>
<p>Es llamada por un hilo que quiere notificar el suceso de un evento a los hilos que esperan en la variable de condición.
Uno de esos hilos es despertado, adquiere el <strong><em>mutex</em></strong> que liberó al llamar a <strong>wait</strong> y, finalmente, retorna de <strong>wait</strong> para seguir ejecutándose.</p>
</dd>
<dt class="hdlist1">notifyAll</dt>
<dd>
<p>Es llamada por un hilo que quiere notificar el suceso de un evento a los hilos que esperan en la variable de condición.
Todos los hilos son despertados e intentan adquirir el <strong><em>mutex</em></strong> que liberaron al llamar a <strong>wait</strong>.
Cuando lo consiguen, retornan de <strong>wait</strong> para seguir ejecutándose.
Obviamente, si todos hicieron <strong>wait</strong> sobre el mismo <strong><em>mutex</em></strong>, irán retornando de <strong>wait</strong> de uno en uno, porque solo un hilo puede tener el <strong><em>mutex</em></strong> al mismo tiempo.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Tanto Windows API como el estándar POSIX, a través de <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a>, soportan <strong>variables de condición</strong>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 13.3. Funciones de la API para manipular variables de condición.</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">C&#43;&#43;</th>
<th class="tableblock halign-left valign-top">POSIX API</th>
<th class="tableblock halign-left valign-top">Windows API</th>
</tr>
</thead>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Crear</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.cppreference.com/w/cpp/thread/condition_variable">std::condition_variable</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/pthread_cond_init.3p.html">pthread_cond_init()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-initializeconditionvariable">InitializeConditionVariable()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Operación wait</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.cppreference.com/w/cpp/thread/condition_variable/wait">std::condition_variable::wait()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/pthread_cond_wait.3p.html">pthread_cond_wait()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleepconditionvariablecs">SleepConditionVariableCS()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Operación notify</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.cppreference.com/w/cpp/thread/condition_variable/notify_one">std::condition_variable::notify_one()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/pthread_cond_signal.3p.html">pthread_cond_signal()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-wakeconditionvariable">WakeConditionVariable()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Operación notifyAll</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.cppreference.com/w/cpp/thread/condition_variable/notify_all">std::condition_variable::notify_all()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/pthread_cond_broadcast.3p.html">pthread_cond_broadcast()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-wakeallconditionvariable">WakeAllConditionVariable()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Destruir</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="lightcell">[Destructor]</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/pthread_cond_destroy.3p.html">pthread_cond_destroy()</a></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Por defecto, las <strong>variables de condición</strong> de <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">POSIX Threads</a> solo se pueden utilizar para sincronizar hilos del mismo proceso; pero tienen un atributo para permitir la sincronización entre procesos diferentes.
Obviamente, para eso deben ser creadas en una región de memoria compartida por dichos procesos.</p>
</div>
<div class="paragraph">
<p>Las <strong>variables de condición</strong> de Windows API solo se pueden utilizar en hilos del mismo procesos.
Como alternativa, Windows API soporta <strong>eventos</strong>, que son un tipo de objeto similar a las <strong>variables de condición</strong>, pero que sí se puede utilizar entre hilos de procesos diferentes (véase <a href="https://docs.microsoft.com/en-us/windows/win32/sync/using-event-objects">«Using Event Objects&#8201;&#8212;&#8201;Microsoft Docs»</a>).</p>
</div>
<div class="paragraph">
<p>A los <strong>eventos</strong> se les puede asignar un nombre, para que sean accesibles por otros procesos, o heredarse de padres a hijos.
Además son más pesados que las <strong>variables de condición</strong> de Windows API, no exigen un <strong><em>mutex</em></strong> para liberar al invocar su operación <strong>wait</strong>, ni admiten la operación <strong>notifyAll</strong>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 13.4. Funciones de la API para manipular eventos de Windows API.</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">Windows API</th>
</tr>
</thead>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Crear</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createeventa">CreateEvent()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Abrir</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-openeventa">OpenEvent()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Operación wait</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject">WaitForSingleObject()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Operación notify</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-setevent">SetEvent()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Resetear evento</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-resetevent">ResetEvent()</a></p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Destruir</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle">CloseHandle()</a></p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="_ejemplos_del_uso_de_variables_de_condición"><a class="anchor" href="#_ejemplos_del_uso_de_variables_de_condición"></a>13.5.1. Ejemplos del uso de variables de condición</h4>
<div class="paragraph">
<p>Vamos a intentar resolver el <strong>problema del productor-consumidor</strong> sin usar <strong>semáforos</strong>.
Para lo que, nuevamente, tenemos que considerar que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Necesitamos <strong>exclusión mutua</strong> entre ambos hilos al insertar y extraer elementos del vector para evitar <strong>condiciones de carrera</strong>, por tanto usamos un <strong><em>mutex</em></strong> para proteger la <strong>sección crítica</strong>.</p>
</li>
<li>
<p>Necesitamos una forma de que el productor espere cuando el vector está lleno y que el consumidor haga lo mismo cuando el vector está vacío.
Para señalar estos eventos necesitamos dos <strong>variables de condición</strong>:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">mutext</span> <span class="n">mutex</span><span class="p">;</span>                <i class="conum" data-value="1"></i><b>(1)</b>
<span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">no_full</span><span class="p">;</span>  <i class="conum" data-value="2"></i><b>(2)</b>
<span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">no_empty</span><span class="p">;</span> <i class="conum" data-value="3"></i><b>(3)</b>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">item_t</span><span class="o">&gt;</span> <span class="n">buffer</span><span class="p">(</span> <span class="n">VECTOR_SIZE</span> <span class="p">);</span>

<span class="kt">void</span> <span class="nf">productor</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="k">while</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">item_t</span> <span class="n">item</span> <span class="o">=</span> <span class="n">produce_item</span><span class="p">();</span>

        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span> <span class="n">lock</span><span class="p">{</span> <span class="n">mutex</span> <span class="p">};</span>        <i class="conum" data-value="4"></i><b>(4)</b> <i class="conum" data-value="5"></i><b>(5)</b>

        <span class="k">while</span><span class="p">(</span> <span class="n">buffer</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">VECTOR_SIZE</span> <span class="p">)</span>  <i class="conum" data-value="6"></i><b>(6)</b> <i class="conum" data-value="10"></i><b>(10)</b>
        <span class="p">{</span>
            <span class="n">no_full</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span> <span class="n">mutex</span> <span class="p">);</span>            <i class="conum" data-value="11"></i><b>(11)</b>
        <span class="p">}</span>

        <span class="n">vector</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">item</span> <span class="p">);</span>             <i class="conum" data-value="11"></i><b>(11)</b>

        <span class="n">no_empty</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>                <i class="conum" data-value="7"></i><b>(7)</b>
    <span class="p">}</span>                                         <i class="conum" data-value="6"></i><b>(6)</b>

    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">consumer</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="k">while</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span> <span class="n">lock</span><span class="p">{</span> <span class="n">mutex</span> <span class="p">};</span>  <i class="conum" data-value="4"></i><b>(4)</b> <i class="conum" data-value="5"></i><b>(5)</b>

        <span class="k">while</span><span class="p">(</span> <span class="n">buffer</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>      <i class="conum" data-value="8"></i><b>(8)</b> <i class="conum" data-value="10"></i><b>(10)</b>
        <span class="p">{</span>
            <span class="n">no_empty</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span> <span class="n">mutex</span> <span class="p">);</span>     <i class="conum" data-value="11"></i><b>(11)</b>
        <span class="p">}</span>

        <span class="n">item_t</span> <span class="n">item</span> <span class="o">=</span> <span class="n">vector</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>    <i class="conum" data-value="11"></i><b>(11)</b>
        <span class="n">vector</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>

        <span class="n">no_full</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>           <i class="conum" data-value="9"></i><b>(9)</b>

        <span class="n">consume_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
    <span class="p">}</span>                                   <i class="conum" data-value="6"></i><b>(6)</b>

    <span class="c1">// ...</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><strong><em>Mutex</em></strong> que se encarga de la exclusión mutua.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><strong>Variable de condición</strong> que se encarga de indicar cuando el vector no está lleno.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><strong>Variable de condición</strong> que se encarga de indicar cuando el vector no está vacío.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Antes de acceder al vector es necesario bloquear <code>mutex</code>.
Ni siquiera es seguro preguntar por el número de elementos guardados en <code>vector</code> sin antes adquirir el <strong><em>mutex</em></strong>, puesto que el otro hilo puede estar modificando <code>vector</code> al mismo tiempo.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Los <strong><em>mutex</em></strong> se pueden adquirir y liberar con <a href="https://en.cppreference.com/w/cpp/thread/mutex/lock">std::mutex:::lock()</a> y  cpp_mutex_unlock}, pero esa no es la forma recomendada.
Lo recomendado es crear alguno de los objetos <em>lock</em> incluidos en la librería estándar.
Estos objetos bloquean el <strong><em>mutex</em></strong> al crearse y lo desbloquean automáticamente al destruirse.
Así es complicado que nos olvidemos de desbloquearlo al salir de la función.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Antes de insertar un elemento se comprueba si hay algún hueco disponible.
Si no lo hay, se pone el hilo a la espera en la <strong>variable de condición</strong> <code>no_full</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>El consumidor despierta al productor de esa espera tras extraer un elemento, porque es seguro que al hacerlo habrá dejado un hueco.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Antes de extraer un elemento se comprueba si hay alguno en el vector.
Si no lo hay, se pone el hilo a la espera en la <strong>variable de condición</strong> <code>no_empty</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>El productor despierta al consumidor de esta espera tras insertar un nuevo elemento.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>El estándar de C&#43;&#43; indica que las esperas en las <strong>variables de condición</strong> son susceptibles de despertar de forma espuria.
Es decir, que el hilo puede salir de <a href="https://en.cppreference.com/w/cpp/thread/condition_variable/wait">std::condition_variable::wait()</a> sin que haya habido notificación.
Por eso hay que volver a comprobar la condición antes de continuar ejecutando sentencias en la <strong>sección crítica</strong>.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>Cuando los hilos se bloquean en <a href="https://en.cppreference.com/w/cpp/thread/condition_variable/wait">std::condition_variable::wait()</a>, <code>mutex</code> es liberado para que el otro hilo pueda entrar y extraer o insertar un elemento.
De lo contrario, no podría hacerlo y ambos se quedarían bloqueados indefinidamente —en una situación que se denomina <strong>interbloqueo</strong> o <strong><em>deadlock</em></strong>—.
Pero antes de salir de <a href="https://en.cppreference.com/w/cpp/thread/condition_variable/wait">std::condition_variable::wait()</a>, el hilo adquiere de nuevo el <code>mutex</code>.
Así que el código que inserta y extrae elementos se ejecuta en <strong>exclusión mutua</strong>, tal y como nos interesa.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_implementación_de_semáforos"><a class="anchor" href="#_implementación_de_semáforos"></a>13.6. Implementación de semáforos</h3>
<div class="paragraph">
<p>Como hemos visto, tanto los <strong><em>mutex</em></strong> como las <strong>variables de condición</strong> son casos particulares de los <strong>semáforos</strong>.
De igual forma, si un sistema o lenguaje soporta <strong><em>mutex</em></strong> y <strong>variables de condición</strong>, es muy sencillo implementar <strong>semáforos</strong>, así como otras primitivas de sincronización.</p>
</div>
<div class="paragraph">
<p>Un <strong>semáforo</strong> se implementa de forma muy parecida a la solución anterior al <strong>problema del productor-consumidor</strong> (véase el <a href="sincronización.html#_ejemplos_del_uso_de_variables_de_condición">Apartado 13.5.1</a>), solo que eliminando lo relacionado con el vector de elementos.</p>
</div>
<div id="ejemplo-implementación-semáforo" class="exampleblock">
<div class="title">Ejemplo 13.2. Implementación de un semáforo en C&#43;&#43;.</div>
<div class="content">
<div class="paragraph">
<p>El código fuente completo de la clase <code>semaphore</code> está disponible en <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2324/src/cap13/semaphore.hpp">semaphore.hpp</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">class</span> <span class="nc">semaphore</span> <span class="p">{</span>
<span class="nl">public:</span>

    <span class="n">semaphore</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">count_</span><span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="nf">release</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span> <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="n">count_</span><span class="o">++</span><span class="p">;</span>
        <span class="n">cv_</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>                          <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">acquire</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span> <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="k">while</span><span class="p">(</span><span class="n">count_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cv_</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>                        <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="p">}</span>
        <span class="n">count_</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mutex_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cv_</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">count_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>El acceso al contador <code>count_</code> esta protegido por el <strong><em>mutex</em></strong> <code>mutex_</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>En <code>semaphore::acquire()</code>, si el contador está a 0 no pueden entrar más hilos, por lo que el hilo debe esperar en la <strong>variable de condición</strong> <code>cv_</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Cada vez que un hilo llama a <code>semaphore::release()</code> se incrementa el contador y se despierta uno de los hilos a la espera en <code>cv_</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/so2324/src/cap13/threads-sync-semaphore.cpp">threads-sync-semaphore.cpp</a> se puede ver un ejemplo de cómo utilizarla para limitar el número de hilos que pueden ejecutarse en una <strong>sección crítica</strong> al mismo tiempo.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="kt">void</span> <span class="nf">thread_function</span><span class="p">(</span><span class="n">semaphore</span><span class="o">&amp;</span> <span class="n">sem</span><span class="p">,</span> <span class="kt">int</span> <span class="n">thread_id</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">sem</span><span class="p">.</span><span class="n">acquire</span><span class="p">();</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span> <span class="s">"Hilo {} creado</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">thread_id</span> <span class="p">);</span>

    <span class="c1">// Dormir el hilo para simular trabajo</span>
    <span class="c1">// ...</span>

    <span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span> <span class="s">"Hilo {} terminado</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">thread_id</span> <span class="p">);</span>
    <span class="n">sem</span><span class="p">.</span><span class="n">release</span><span class="p">();</span> <i class="conum" data-value="4"></i><b>(4)</b>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">num_threads</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">semaphore</span> <span class="n">sem</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_threads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="p">{</span>
        <span class="n">threads</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span> <span class="n">thread_function</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">sem</span><span class="p">),</span> <span class="n">i</span> <span class="p">));</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">t</span> <span class="o">:</span> <span class="n">threads</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Solo se van a permitir 3 hilos simultáneos.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Se crean 10 hilos y se guardan en un vector los objetos <a href="https://en.cppreference.com/w/cpp/thread/thread">std::thread</a> para luego poder esperar por ellos usando <a href="https://en.cppreference.com/w/cpp/thread/thread/join">std::thread::join()</a>, antes de terminar el programa.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Se llama a <code>semaphore::acquire()</code> antes de entrar en la <strong>sección crítica</strong>.
Si hay más de 3 hilos en ella, el hilo es suspendido en la <strong>variable de condición</strong> <code>cv_</code> de <code>semaphore</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Se llama a <code>semaphore::release()</code> al salir de la <strong>sección critica</strong>.
Esto hace que la <strong>variable de condición</strong> <code>cv_</code> de <code>semaphore</code> despierte a uno de los hilos que está esperando en <code>semaphore::acquire()</code> para que entre en la <strong>sección crítica</strong>.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_esperas"><a class="anchor" href="#_esperas"></a>13.7. Esperas</h3>
<div class="paragraph">
<p>Muchos de los objetos de sincronización que hemos visto necesitan algún mecanismo para poner en espera a los hilos que los usan.
Existen dos alternativas desde el punto de vista de cómo implementar esta espera:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>El sistema operativo puede cambiar el estado del hilo o proceso a <strong>esperado</strong> y moverlo a una cola de espera asociada al objeto de sincronización, tal y como hemos comentado en varias ocasiones.
Entonces el planificador de la CPU escogerá a otro proceso para ser ejecutado.</p>
</li>
<li>
<p>El hilo puede iterar comprobando constantemente la condición hasta que se cumple.
A esa técnica se la denomina <strong>espera ocupada</strong>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Este tipo de <strong>espera ocupada</strong> desperdicia tiempo de CPU que otro hilo podría utilizar de forma más productiva, por lo que solo se utiliza en el caso de esperas previsiblemente cortas.
Para evitar que las esperas ocupadas sean demasiado largas, los sistemas operativos nunca expulsan de la CPU a hilos que se estén ejecutando dentro de secciones críticas controladas por objetos de sincronización con este tipo de espera, con la idea de que salgan de la sección crítica lo antes posible.</p>
</div>
<div class="paragraph">
<p>En Windows API, por ejemplo, se puede utilizar <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-initializecriticalsectionandspincount">InitializeCriticalSectionAndSpinCount()</a> para inicializar un objeto de <strong>sección crítica</strong> donde el hilo que la intenta adquirir itera el número especificado de veces en una <strong>espera ocupada</strong>, comprobando si la sección es liberada, antes de bloquearse en el estado <strong>esperando</strong> si eso no ocurre.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>La <strong>espera ocupada</strong> de estos objetos <strong>sección crítica</strong> de Windows API solo ocurre en sistemas multiprocesador, donde el hilo que tiene adquirida la sección puede estar ejecutándose en otro hilo y terminar rápidamente.
En sistemas monoprocesador nunca hay <strong>espera ocupada</strong>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A los <strong><em>mutex</em></strong> con <strong>espera ocupada</strong> también se los denomina <strong><em>(spinlock)</em></strong>.
Los <strong><em>spinlocks</em></strong> son utilizados frecuentemente para proteger las estructuras del núcleo en los sistemas multiprocesador, cuando la tarea a realizar dentro de la sección crítica en el núcleo requiere poco tiempo y los diseñadores calculan que se desperdicia más tiempo sacando de la CPU al hilo en espera para ejecutar otro en su lugar.</p>
</div>
</div>
<div class="sect2">
<h3 id="_funciones_reentrantes_y_seguras_en_hilos"><a class="anchor" href="#_funciones_reentrantes_y_seguras_en_hilos"></a>13.8. Funciones reentrantes y seguras en hilos</h3>
<div class="paragraph">
<p>Todas estas cuestiones sobre la sincronización no solo afectan al código que escribimos sino también a las librerías que podemos utilizar.
A la hora de decidir utilizar una librería en un programa multihilo es necesario que tengamos en cuenta los conceptos de <strong>reentrante</strong> y <strong>seguridad de hilos</strong>.</p>
</div>
<div class="sect3">
<h4 id="_funciones_reentrantes"><a class="anchor" href="#_funciones_reentrantes"></a>13.8.1. Funciones reentrantes</h4>
<div class="paragraph">
<p>
Una función es <strong>reentrante</strong> puede ser interrumpida en medio de su ejecución y, mientras espera, volver a ser llamada con total seguridad.
Obviamente las funciones recursivas deben ser reentrantes para poder llamarse a sí mismas una y otra vez con seguridad.</p>
</div>
<div class="paragraph">
<p>En el contexto de la programación multihilo, ocurre una reentrada cuando durante la ejecución de una función por parte de un hilo, este es interrumpido por el sistema operativo para planificar posteriormente a otro del mismo proceso que invoca la misma función.</p>
</div>
<div class="paragraph">
<p>En general una función es reentrante, si:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>No modifica variables estáticas o globales.
Si lo hiciera solo puede hacerlo mediante operaciones <strong>leer-modificar-escribir</strong> que sean ininterrumpibles —es decir, atómicas—.</p>
</li>
<li>
<p>No modifica su propio código y no llama a otras funciones que no sean reentrantes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Como hemos mencionado anteriormente, los <strong>manejadores de señal</strong> deben ser funciones <strong>reentrantes</strong>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_seguridad_en_hilos"><a class="anchor" href="#_seguridad_en_hilos"></a>13.8.2. Seguridad en hilos</h4>
<div class="paragraph">
<p>
Una función es <strong>segura en hilos</strong> o <strong>thread-safe</strong> si al manipular estructuras compartidas de datos lo hace de tal manera que se garantiza la ejecución segura de la misma por múltiples hilos al mismo tiempo.
Obviamente estamos hablando de un problema de secciones críticas, por lo que las funciones lo  resuelven sincronizando el acceso a estos datos mediante el uso de <strong>semáforos</strong>, <strong><em>mutex</em></strong> u otros recursos similares ofrecidos por el sistema operativo.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En ocasiones, ambos conceptos se confunden porque es bastante común que el código reentrante también sea seguro en hilos.
Sin embargo es posible crear código reentrante que no sea seguro en hilos y viceversa.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A la hora de usar una función o librería que va a ser llamada desde múltiples hilos, primero debemos consultar la documentación para averiguar si es <strong>segura en hilos</strong>.
Si no lo fuera, tendríamos que buscar funciones alternativas o recordar proteger las llamadas a las funciones no seguras con mecanismos de sincronización, para asegurar que solo son invocadas desde un hilo al mismo tiempo.</p>
</div>
<div class="paragraph">
<p>Esto se aplica tanto a librerías de otros desarrolladores como a la librería estándar del lenguaje que estemos usando y a la librería del sistema.</p>
</div>
<div class="sect4">
<h5 id="_seguridad_en_hilos_en_c"><a class="anchor" href="#_seguridad_en_hilos_en_c"></a>Seguridad en hilos en C++</h5>
<div class="paragraph">
<p>La norma general es que las clases de la librería estándar de C&#43;&#43; son seguras frente a múltiples accesos de lectura desde diferentes hilos.
Pero si un hilo modifica un objeto, todas las lecturas y escrituras en el mismo objeto por ese y otros hilos deben estar protegidas.</p>
</div>
<div class="paragraph">
<p>Obviamente, las clases de mecanismos de sincronización y gestión de hilos generalmente ofrecen mayores garantías, para lo que hay que consultar la documentación.</p>
</div>
</div>
<div class="sect4">
<h5 id="_seguridad_en_hilos_en_c_2"><a class="anchor" href="#_seguridad_en_hilos_en_c_2"></a>Seguridad en hilos en C</h5>
<div class="paragraph">
<p>El estándar de C no menciona nada sobre <strong>seguridad en hilos</strong>, por lo que se debe suponer que las funciones de la librería estándar no lo son o consultar la documentación ofrecida por el proveedor de la librería.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, todas las versiones de la librería estándar de C en Windows actualmente son <strong>seguras en hilos</strong> (véase <a href="https://docs.microsoft.com/en-us/cpp/parallel/multithreading-with-c-and-win32?view=vs-2019">«Multithreading with C and Win32&#8201;&#8212;&#8201;Microsoft Docs»</a>).
Pero hasta hace unos años Microsoft ofrecía varias versiones de la librería, algunas <strong>seguras en hilos</strong>, para usar en aplicaciones multihilo, y otras no seguras para usar en aplicaciones monohilo.</p>
</div>
</div>
<div class="sect4">
<h5 id="_seguridad_en_hilos_en_posix"><a class="anchor" href="#_seguridad_en_hilos_en_posix"></a>Seguridad en hilos en POSIX</h5>
<div class="paragraph">
<p>La API POSIX es un superconjunto de la API de la librería estándar de C.
Por lo que en esos sistemas el estándar POSIX es el que marca qué funciones de la librería estándar de C y del resto de la API POSIX son <strong>seguras en hilos</strong>.</p>
</div>
<div class="paragraph">
<p>En los sistemas POSIX, el estándar establece que todas las funciones son seguras excepto algunas muy concretas, que se pueden consultar en el apartado <a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_09_01">«2.9.1 Thread-Safety»</a> de la especificación.
Muchas de esas funciones no se especifican como <strong>seguras en hilos</strong> porque existe alguna alternativa que sí lo es.
Por ejemplo, <a href="https://man7.org/linux/man-pages/man3/strerror.3.html">strerror()</a> no es <strong>segura en hilos</strong>, pero <a href="https://man7.org/linux/man-pages/man3/strerror.3.html">strerror_r()</a> tiene una funcionalidad equivalente y sí lo es.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph nav-footer">
<p>← Anterior: <a href="hilos.html">Hilos</a> | ↑ Subir: <a href="gestión_de_procesos.html">Gestión de procesos</a> | ⌂ Inicio: <a href="main.html">Sistemas Operativos</a> | Siguiente: <a href="planificación_de_la_cpu.html">Planificación de la CPU</a> →</p>
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "AMS" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
<div id="footer">
    <div id="footer-text">
        Esta obra está sujeta a la licencia
        <a href="http://creativecommons.org/licenses/by/4.0/deed.es">Creative Commons Atribución 4.0 Internacional</a>,
        excepto donde se indique lo contrario.
    </div>
</div>
</body>
</html>